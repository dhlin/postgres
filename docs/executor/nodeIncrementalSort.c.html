<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>executor/nodeIncrementalSort.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>executor/nodeIncrementalSort.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1077">ExecEndIncrementalSort</a></li>
<li><a href="#L495">ExecIncrementalSort</a></li>
<li><a href="#L1173">ExecIncrementalSortEstimate</a></li>
<li><a href="#L1194">ExecIncrementalSortInitializeDSM</a></li>
<li><a href="#L1219">ExecIncrementalSortInitializeWorker</a></li>
<li><a href="#L1233">ExecIncrementalSortRetrieveInstrumentation</a></li>
<li><a href="#L976">ExecInitIncrementalSort</a></li>
<li><a href="#L1107">ExecReScanIncrementalSort</a></li>
<li><a href="#L127">instrumentSortedGroup</a></li>
<li><a href="#L212">isCurrentGroup</a></li>
<li><a href="#L164">preparePresortedCols</a></li>
<li><a href="#L286">switchToPresortedPrefixMode</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L479">DEFAULT_MAX_FULL_SORT_GROUP_SIZE</a></li>
<li><a href="#L467">DEFAULT_MIN_GROUP_SIZE</a></li>
<li><a href="#L98">INSTRUMENT_SORT_GROUP</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * nodeIncrementalSort.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines to handle incremental sorting of relations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/executor/nodeIncrementalSort.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * DESCRIPTION<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Incremental sort is an optimized variant of multikey sort for cases<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; when the input is already sorted by a prefix of the sort keys.&nbsp; For<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; example when a sort by (key1, key2 ... keyN) is requested, and the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; input is already sorted by (key1, key2 ... keyM), M &lt; N, we can<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; divide the input into groups where keys (key1, ... keyM) are <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; and only sort on the remaining columns.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Consider the following example.&nbsp; We have input tuples consisting of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; two integers (X, Y) already presorted by X, while it's required to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; sort them by both X and Y.&nbsp; Let input tuples be following.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (1, 5)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (1, 2)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (2, 9)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (2, 1)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (2, 5)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (3, 3)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (3, 7)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; An incremental sort algorithm would split the input into the following<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; groups, which have <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> X, and then sort them by Y individually:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (1, 5) (1, 2)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (2, 9) (2, 1) (2, 5)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (3, 3) (3, 7)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; After sorting these groups and putting them altogether, we would get<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the following result which is sorted by X and Y, as requested:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (1, 2)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (1, 5)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (2, 1)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (2, 5)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (2, 9)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (3, 3)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (3, 7)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Incremental sort may be more efficient than plain sort, particularly<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; on large datasets, as it reduces the amount of data to sort at once,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; making it more likely it fits into <a href="../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> (eliminating the need to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; spill to disk).&nbsp; But the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> advantage of incremental sort is that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; it can start producing rows early, <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> sorting the whole dataset,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; which is a significant benefit especially for queries with LIMIT.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The algorithm we've implemented here is modified from the theoretical<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; base described above by operating in two different modes:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; - Fetching a minimum number of tuples without checking prefix key<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; group membership and sorting on all columns when safe.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; - Fetching all tuples for a single prefix key group and sorting on<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; solely the unsorted columns.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; We always begin in the first mode, and employ a heuristic to switch<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; into the second mode if we believe it's beneficial.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Sorting incrementally can potentially use less memory, avoid fetching<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; and sorting all tuples in the dataset, and begin returning tuples <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the entire result set is available.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The hybrid mode approach allows us to <a href="../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> for both very small<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; groups (where the overhead of a new tuplesort is high) and very large<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; groups (where we can <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> cost by not having to sort on already sorted<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; columns), albeit at some extra cost while switching between modes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;executor/execdebug.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeIncrementalSort.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/tuplesort.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We need to store the instrumentation information in either local node's sort<br/></li>
<li></span><span class="Comment"> * info or, for a parallel worker process, in the shared info (this avoids<br/></li>
<li></span><span class="Comment"> * having to additionally memcpy the info from local memory to shared memory<br/></li>
<li></span><span class="Comment"> * at each instrumentation call). This macro expands to choose the proper sort<br/></li>
<li></span><span class="Comment"> * state and group info.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Arguments:<br/></li>
<li></span><span class="Comment"> * - node: type IncrementalSortState *<br/></li>
<li></span><span class="Comment"> * - groupName: the token fullsort or prefixsort<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L98">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">INSTRUMENT_SORT_GROUP</span>(node, groupName) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> ((node)-&gt;ss.ps.instrument != </span><span class="Constant">NULL</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> ((node)-&gt;shared_info &amp;&amp; (node)-&gt;am_worker) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(IsParallelWorker()); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../access/transam/parallel.c.html#L112" title="access/transam/parallel.c:112">ParallelWorkerNumber</a> &lt;= (node)-&gt;shared_info-&gt;num_workers); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L127" title="executor/nodeIncrementalSort.c:127">instrumentSortedGroup</a>(&amp;(node)-&gt;shared_info-&gt;sinfo[<a href="../access/transam/parallel.c.html#L112" title="access/transam/parallel.c:112">ParallelWorkerNumber</a>].groupName##GroupInfo, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (node)-&gt;groupName##_state); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">else</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L127" title="executor/nodeIncrementalSort.c:127">instrumentSortedGroup</a>(&amp;(node)-&gt;incsort_info.groupName##GroupInfo, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (node)-&gt;groupName##_state); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; } \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * <a href="#L127" title="executor/nodeIncrementalSort.c:127">instrumentSortedGroup</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Because incremental sort processes (potentially many) sort batches, we need<br/></li>
<li></span><span class="Comment"> * to capture tuplesort stats each time we finalize a sort state. This summary<br/></li>
<li></span><span class="Comment"> * data is later used for EXPLAIN ANALYZE output.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L127">&#x200c;</a></span><span class="linkable">instrumentSortedGroup</span>(IncrementalSortGroupInfo *groupInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *sortState)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortInstrumentation sort_instr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; groupInfo-&gt;groupCount++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L2537" title="utils/sort/tuplesort.c:2537">tuplesort_get_stats</a>(sortState, &amp;sort_instr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Calculate total and maximum memory and disk space used. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (sort_instr.spaceType)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SORT_SPACE_TYPE_DISK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; groupInfo-&gt;totalDiskSpaceUsed += sort_instr.spaceUsed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sort_instr.spaceUsed &gt; groupInfo-&gt;maxDiskSpaceUsed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; groupInfo-&gt;maxDiskSpaceUsed = sort_instr.spaceUsed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SORT_SPACE_TYPE_MEMORY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; groupInfo-&gt;totalMemorySpaceUsed += sort_instr.spaceUsed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sort_instr.spaceUsed &gt; groupInfo-&gt;maxMemorySpaceUsed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; groupInfo-&gt;maxMemorySpaceUsed = sort_instr.spaceUsed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Track each sort method we've used. */<br/></li>
<li></span>&nbsp; &nbsp; groupInfo-&gt;sortMethods |= sort_instr.sortMethod;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * <a href="#L164" title="executor/nodeIncrementalSort.c:164">preparePresortedCols</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Prepare information for presorted_keys comparisons.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L164">&#x200c;</a></span><span class="linkable">preparePresortedCols</span>(IncrementalSortState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IncrementalSort *plannode = castNode(IncrementalSort, node-&gt;ss.ps.plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node-&gt;presorted_keys =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (PresortedKeyData *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(plannode-&gt;nPresortedCols *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PresortedKeyData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pre-cache comparison <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for each pre-sorted key. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; plannode-&gt;nPresortedCols; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; equalityOp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; equalityFunc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PresortedKeyData *key;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key = &amp;node-&gt;presorted_keys[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;attno = plannode-&gt;sort.sortColIdx[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; equalityOp = <a href="../utils/cache/lsyscache.c.html#L267" title="utils/cache/lsyscache.c:267">get_equality_op_for_ordering_op</a>(plannode-&gt;sort.sortOperators[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(equalityOp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing equality operator for ordering operator </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plannode-&gt;sort.sortOperators[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; equalityFunc = <a href="../utils/cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(equalityOp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(equalityFunc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing function for operator </span><span class="Special">%u</span><span class="Constant">&quot;</span>, equalityOp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Lookup the comparison function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(equalityFunc, &amp;key-&gt;flinfo, <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the callinfo just once and re-use it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;fcinfo = <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(SizeForFunctionCallInfo(<span class="Constant">2</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; InitFunctionCallInfoData(*key-&gt;fcinfo, &amp;key-&gt;flinfo, <span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plannode-&gt;sort.collations[i], <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * <a href="#L212" title="executor/nodeIncrementalSort.c:212">isCurrentGroup</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check whether a given tuple belongs to the current sort group by comparing<br/></li>
<li></span><span class="Comment"> * the presorted column <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to the pivot tuple of the current group.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L212">&#x200c;</a></span><span class="linkable">isCurrentGroup</span>(IncrementalSortState *node, TupleTableSlot *pivot, TupleTableSlot *tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nPresortedCols;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nPresortedCols = castNode(IncrementalSort, node-&gt;ss.ps.plan)-&gt;nPresortedCols;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * That the input is sorted by keys * (0, ... n) implies that the tail<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keys are more likely to change. Therefore we do our comparison starting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the last pre-sorted column to <a href="../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> for early detection of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inequality and minimizing the number of function calls..<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = nPresortedCols - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datumA,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datumB,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnullA,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnullB;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attno = node-&gt;presorted_keys[i].attno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PresortedKeyData *key;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datumA = slot_getattr(pivot, attno, &amp;isnullA);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datumB = slot_getattr(tuple, attno, &amp;isnullB);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Special case for NULL-vs-NULL, else use standard comparison */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnullA || isnullB)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnullA == isnullB)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key = &amp;node-&gt;presorted_keys[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;fcinfo-&gt;args[<span class="Constant">0</span>].value = datumA;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;fcinfo-&gt;args[<span class="Constant">1</span>].value = datumB;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just for paranoia's sake, we reset isnull each time */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;fcinfo-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = FunctionCallInvoke(key-&gt;fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for null result, since caller is clearly not expecting one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key-&gt;fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%u</span><span class="Constant"> returned NULL&quot;</span>, key-&gt;flinfo.fn_oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!DatumGetBool(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * <a href="#L286" title="executor/nodeIncrementalSort.c:286">switchToPresortedPrefixMode</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When we determine that we've likely encountered a large batch of tuples all<br/></li>
<li></span><span class="Comment"> * having the same presorted prefix <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, we want to <a href="../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> tuplesort by<br/></li>
<li></span><span class="Comment"> * only sorting on unsorted suffix keys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The problem is that we've already accumulated several tuples in another<br/></li>
<li></span><span class="Comment"> * tuplesort configured to sort by all columns (assuming that there may be<br/></li>
<li></span><span class="Comment"> * more than one prefix key group). So to switch to presorted prefix mode we<br/></li>
<li></span><span class="Comment"> * have to go back and look at all the tuples we've already accumulated to<br/></li>
<li></span><span class="Comment"> * verify they're all part of the same prefix key group <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> sorting them<br/></li>
<li></span><span class="Comment"> * solely by unsorted suffix keys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * While it's likely that all tuples already fetched are all part of a single<br/></li>
<li></span><span class="Comment"> * prefix group, we also have to handle the possibility that there is at least<br/></li>
<li></span><span class="Comment"> * one different prefix key group <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the large prefix key group.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L286">&#x200c;</a></span><span class="linkable">switchToPresortedPrefixMode</span>(PlanState *pstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IncrementalSortState *node = castNode(IncrementalSortState, pstate);<br/></li>
<li>&nbsp; &nbsp; ScanDirection dir;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; nTuples;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc;<br/></li>
<li>&nbsp; &nbsp; PlanState&nbsp; *outerNode;<br/></li>
<li>&nbsp; &nbsp; IncrementalSort *plannode = castNode(IncrementalSort, node-&gt;ss.ps.plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dir = node-&gt;ss.ps.state-&gt;es_direction;<br/></li>
<li>&nbsp; &nbsp; outerNode = outerPlanState(node);<br/></li>
<li>&nbsp; &nbsp; tupDesc = <a href="execUtils.c.html#L493" title="executor/execUtils.c:493">ExecGetResultType</a>(outerNode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Configure the prefix sort state the first time around. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;prefixsort_state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *prefixsort_state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nPresortedCols = plannode-&gt;nPresortedCols;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Optimize the sort by assuming the prefix columns are all <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * thus we only need to sort by <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; prefixsort_state = <a href="../utils/sort/tuplesortvariants.c.html#L168" title="utils/sort/tuplesortvariants.c:168">tuplesort_begin_heap</a>(tupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plannode-&gt;sort.numCols - nPresortedCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;(plannode-&gt;sort.sortColIdx[nPresortedCols]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;(plannode-&gt;sort.sortOperators[nPresortedCols]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;(plannode-&gt;sort.collations[nPresortedCols]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;(plannode-&gt;sort.nullsFirst[nPresortedCols]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;bounded ? TUPLESORT_ALLOWBOUNDED : TUPLESORT_NONE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;prefixsort_state = prefixsort_state;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Next group of presorted data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L1039" title="utils/sort/tuplesort.c:1039">tuplesort_reset</a>(node-&gt;prefixsort_state);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the current node has a bound, then it's reasonably likely that a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * large prefix key group will benefit from bounded sort, so configure the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuplesort to allow for that optimization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;bounded)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SO1_printf(<span class="Constant">&quot;Setting bound on presorted prefix tuplesort to: &quot;</span> INT64_FORMAT <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;bound - node-&gt;bound_Done);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L843" title="utils/sort/tuplesort.c:843">tuplesort_set_bound</a>(node-&gt;prefixsort_state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;bound - node-&gt;bound_Done);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy as many tuples as we can (i.e., in the same prefix key group) from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the full sort state to the prefix sort state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (nTuples = <span class="Constant">0</span>; nTuples &lt; node-&gt;n_fullsort_remaining; nTuples++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When we encounter multiple prefix key groups inside the full sort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuplesort we have to carry over the last read tuple into the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * batch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nTuples == <span class="Constant">0</span> &amp;&amp; !TupIsNull(node-&gt;transfer_tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesortvariants.c.html#L669" title="utils/sort/tuplesortvariants.c:669">tuplesort_puttupleslot</a>(node-&gt;prefixsort_state, node-&gt;transfer_tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The carried over tuple is our new group pivot tuple. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecCopySlot(node-&gt;group_pivot, node-&gt;transfer_tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesortvariants.c.html#L890" title="utils/sort/tuplesortvariants.c:890">tuplesort_gettupleslot</a>(node-&gt;fullsort_state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanDirectionIsForward(dir),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, node-&gt;transfer_tuple, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is our first time through the loop, then we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * save the first tuple we get as our new group pivot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TupIsNull(node-&gt;group_pivot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecCopySlot(node-&gt;group_pivot, node-&gt;transfer_tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L212" title="executor/nodeIncrementalSort.c:212">isCurrentGroup</a>(node, node-&gt;group_pivot, node-&gt;transfer_tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesortvariants.c.html#L669" title="utils/sort/tuplesortvariants.c:669">tuplesort_puttupleslot</a>(node-&gt;prefixsort_state, node-&gt;transfer_tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The tuple isn't part of the current batch so we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * carry it over into the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> batch of tuples we transfer out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the full sort tuplesort into the presorted prefix<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuplesort. We don't actually have to do anything special to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * save the tuple since we've already loaded it into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * node-&gt;transfer_tuple slot, and, even though that slot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * points to memory inside the full sort tuplesort, we can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reset that tuplesort anyway until we've fully transferred<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * out its tuples, so this reference is safe. We do need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reset the group pivot tuple though since we've finished the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current prefix key group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(node-&gt;group_pivot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Break out of for-loop early */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Track how many tuples remain in the full sort batch so that we know if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we need to sort multiple prefix key groups <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> processing tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remaining in the large single prefix key group we think we've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * encountered.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SO1_printf(<span class="Constant">&quot;Moving &quot;</span> INT64_FORMAT <span class="Constant">&quot; tuples to presorted prefix tuplesort</span><span class="Special">\n</span><span class="Constant">&quot;</span>, nTuples);<br/></li>
<li>&nbsp; &nbsp; node-&gt;n_fullsort_remaining -= nTuples;<br/></li>
<li>&nbsp; &nbsp; SO1_printf(<span class="Constant">&quot;Setting n_fullsort_remaining to &quot;</span> INT64_FORMAT <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>, node-&gt;n_fullsort_remaining);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;n_fullsort_remaining == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We've found that all tuples remaining in the full sort batch are in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same prefix key group and moved all of those tuples into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * presorted prefix tuplesort.&nbsp; We don't know that we've yet found the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * last tuple in the current prefix key group, so save our pivot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comparison tuple and continue fetching tuples from the outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * execution node to load into the presorted prefix tuplesort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ExecCopySlot(node-&gt;group_pivot, node-&gt;transfer_tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SO_printf(<span class="Constant">&quot;Setting execution_status to INCSORT_LOADPREFIXSORT (<a href="#L286" title="executor/nodeIncrementalSort.c:286">switchToPresortedPrefixMode</a>)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;execution_status = INCSORT_LOADPREFIXSORT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure we clear the transfer tuple slot so that <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * encounter a large prefix key group we don't incorrectly assume we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have a tuple carried over from the previous group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(node-&gt;transfer_tuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We finished a group but didn't consume all of the tuples from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * full sort state, so we'll sort this batch, let the outer node read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * out all of those tuples, and then come back around to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * batch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SO1_printf(<span class="Constant">&quot;Sorting presorted prefix tuplesort with &quot;</span> INT64_FORMAT <span class="Constant">&quot; tuples</span><span class="Special">\n</span><span class="Constant">&quot;</span>, nTuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>(node-&gt;prefixsort_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L98" title="executor/nodeIncrementalSort.c:98">INSTRUMENT_SORT_GROUP</a>(node, prefixsort);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;bounded)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the current node has a bound and we've already sorted n<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples, then the functional bound remaining is (original bound<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * - n), so store the current number of processed tuples for use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in configuring sorting bound.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SO2_printf(<span class="Constant">&quot;Changing bound_Done from &quot;</span> INT64_FORMAT <span class="Constant">&quot; to &quot;</span> INT64_FORMAT <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(node-&gt;bound, node-&gt;bound_Done + nTuples), node-&gt;bound_Done);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;bound_Done = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(node-&gt;bound, node-&gt;bound_Done + nTuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SO_printf(<span class="Constant">&quot;Setting execution_status to INCSORT_READPREFIXSORT&nbsp; (<a href="#L286" title="executor/nodeIncrementalSort.c:286">switchToPresortedPrefixMode</a>)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;execution_status = INCSORT_READPREFIXSORT;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sorting many small groups with tuplesort is inefficient. In order to<br/></li>
<li></span><span class="Comment"> * cope with this problem we don't start a new group until the current one<br/></li>
<li></span><span class="Comment"> * contains at least <a href="#L467" title="executor/nodeIncrementalSort.c:467">DEFAULT_MIN_GROUP_SIZE</a> tuples (unfortunately this also<br/></li>
<li></span><span class="Comment"> * means we can't assume small groups of tuples all have the same prefix keys.)<br/></li>
<li></span><span class="Comment"> * When we have a bound that's less than <a href="#L467" title="executor/nodeIncrementalSort.c:467">DEFAULT_MIN_GROUP_SIZE</a> we start looking<br/></li>
<li></span><span class="Comment"> * for the new group as soon as we've met our bound to avoid fetching more<br/></li>
<li></span><span class="Comment"> * tuples than we absolutely have to fetch.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L467">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DEFAULT_MIN_GROUP_SIZE</span> </span><span class="Constant">32<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * While we've optimized for small prefix key groups by not starting our prefix<br/></li>
<li></span><span class="Comment"> * key comparisons until we've reached a minimum number of tuples, we don't want<br/></li>
<li></span><span class="Comment"> * that optimization to cause us to lose out on the benefits of being able to<br/></li>
<li></span><span class="Comment"> * assume a large group of tuples is fully presorted by its prefix keys.<br/></li>
<li></span><span class="Comment"> * Therefore we use the <a href="#L479" title="executor/nodeIncrementalSort.c:479">DEFAULT_MAX_FULL_SORT_GROUP_SIZE</a> cutoff as a heuristic<br/></li>
<li></span><span class="Comment"> * for determining when we believe we've encountered a large group, and, if we<br/></li>
<li></span><span class="Comment"> * get to that point without finding a new prefix key group we transition to<br/></li>
<li></span><span class="Comment"> * presorted prefix key mode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L479">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DEFAULT_MAX_FULL_SORT_GROUP_SIZE</span> (</span><span class="Constant">2</span><span class="PreProc"> * <a href="#L467" title="executor/nodeIncrementalSort.c:467">DEFAULT_MIN_GROUP_SIZE</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L495" title="executor/nodeIncrementalSort.c:495">ExecIncrementalSort</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Assuming that outer subtree returns tuple presorted by some prefix<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; of target sort columns, performs incremental sort.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Conditions:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -- <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Initial States:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -- the outer child is prepared to return the first tuple.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TupleTableSlot *<br/></li>
<li><a id="L495">&#x200c;</a><span class="linkable">ExecIncrementalSort</span>(PlanState *pstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IncrementalSortState *node = castNode(IncrementalSortState, pstate);<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate;<br/></li>
<li>&nbsp; &nbsp; ScanDirection dir;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *read_sortstate;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *fullsort_state;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li>&nbsp; &nbsp; IncrementalSort *plannode = (IncrementalSort *) node-&gt;ss.ps.plan;<br/></li>
<li>&nbsp; &nbsp; PlanState&nbsp; *outerNode;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; nTuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; minGroupSize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate = node-&gt;ss.ps.state;<br/></li>
<li>&nbsp; &nbsp; dir = estate-&gt;es_direction;<br/></li>
<li>&nbsp; &nbsp; fullsort_state = node-&gt;fullsort_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If a previous iteration has sorted a batch, then we need to check to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * see if there are <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining tuples in that batch that we can return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> moving on to other execution states.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;execution_status == INCSORT_READFULLSORT<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; || node-&gt;execution_status == INCSORT_READPREFIXSORT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Return <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple from the current sorted group set if available.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; read_sortstate = node-&gt;execution_status == INCSORT_READFULLSORT ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fullsort_state : node-&gt;prefixsort_state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot = node-&gt;ss.ps.ps_ResultTupleSlot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to populate the slot from the tuplesort <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> checking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * outerNodeDone because it will set the slot to NULL if no more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples remain. If the tuplesort is empty, but we don't have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more tuples available for sort from the outer node, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * outerNodeDone will have been set so we'll return that <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-empty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * slot to the caller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/sort/tuplesortvariants.c.html#L890" title="utils/sort/tuplesortvariants.c:890">tuplesort_gettupleslot</a>(read_sortstate, ScanDirectionIsForward(dir),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, slot, <span class="Constant">NULL</span>) || node-&gt;outerNodeDone)<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: there isn't a good test case for the node-&gt;outerNodeDone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check directly, but we need it for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> plan where the outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * node will fail when trying to fetch too many tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (node-&gt;n_fullsort_remaining &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When we transition to presorted prefix mode, we might have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * accumulated at least one additional prefix key group in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * full sort tuplesort. The first call to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L286" title="executor/nodeIncrementalSort.c:286">switchToPresortedPrefixMode</a>() will have pulled the first one of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * those groups out, and we've returned those tuples to the parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * node, but if at this point we still have tuples remaining in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the full sort state (i.e., n_fullsort_remaining &gt; 0), then we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to re-execute the prefix mode transition function to <a href="../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * out the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> prefix key group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SO1_printf(<span class="Constant">&quot;Re-calling <a href="#L286" title="executor/nodeIncrementalSort.c:286">switchToPresortedPrefixMode</a>() because n_fullsort_remaining is &gt; 0 (&quot;</span> INT64_FORMAT <span class="Constant">&quot;)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;n_fullsort_remaining);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L286" title="executor/nodeIncrementalSort.c:286">switchToPresortedPrefixMode</a>(pstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we don't have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sorted tuples to read and we're not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * currently transitioning into presorted prefix sort mode, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's time to start the process all over again by building a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * group in the full sort state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SO_printf(<span class="Constant">&quot;Setting execution_status to INCSORT_LOADFULLSORT (n_fullsort_remaining &gt; 0)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;execution_status = INCSORT_LOADFULLSORT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan the subplan in the forward direction while creating the sorted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; estate-&gt;es_direction = ForwardScanDirection;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; outerNode = outerPlanState(node);<br/></li>
<li>&nbsp; &nbsp; tupDesc = <a href="execUtils.c.html#L493" title="executor/execUtils.c:493">ExecGetResultType</a>(outerNode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Load tuples into the full sort state. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;execution_status == INCSORT_LOADFULLSORT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Initialize sorting structures.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fullsort_state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Initialize presorted column support structures for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L212" title="executor/nodeIncrementalSort.c:212">isCurrentGroup</a>(). It's correct to do this along with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * initial initialization for the full sort state (and not for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prefix sort state) since we always load the full sort state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L164" title="executor/nodeIncrementalSort.c:164">preparePresortedCols</a>(node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since we <a href="../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> small prefix key groups by accumulating a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * minimum number of tuples <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> sorting, we can't assume that a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * group of tuples all have the same prefix key <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. Hence we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * setup the full sort tuplesort to sort by all requested sort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fullsort_state = <a href="../utils/sort/tuplesortvariants.c.html#L168" title="utils/sort/tuplesortvariants.c:168">tuplesort_begin_heap</a>(tupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plannode-&gt;sort.numCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plannode-&gt;sort.sortColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plannode-&gt;sort.sortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plannode-&gt;sort.collations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plannode-&gt;sort.nullsFirst,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;bounded ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TUPLESORT_ALLOWBOUNDED :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TUPLESORT_NONE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;fullsort_state = fullsort_state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset sort for the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> batch. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L1039" title="utils/sort/tuplesort.c:1039">tuplesort_reset</a>(fullsort_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Calculate the remaining tuples left if bounded and configure both<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bounded sort and the minimum group size accordingly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;bounded)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; currentBound = node-&gt;bound - node-&gt;bound_Done;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Bounded sort isn't likely to be a useful optimization for full<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sort mode since we limit full sort mode to a relatively small<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * number of tuples and tuplesort doesn't switch over to top-n<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * heap sort anyway unless it hits (2 * bound) tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (currentBound &lt; <a href="#L467" title="executor/nodeIncrementalSort.c:467">DEFAULT_MIN_GROUP_SIZE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L843" title="utils/sort/tuplesort.c:843">tuplesort_set_bound</a>(fullsort_state, currentBound);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minGroupSize = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(<a href="#L467" title="executor/nodeIncrementalSort.c:467">DEFAULT_MIN_GROUP_SIZE</a>, currentBound);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minGroupSize = <a href="#L467" title="executor/nodeIncrementalSort.c:467">DEFAULT_MIN_GROUP_SIZE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Because we have to read the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out that we've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * encountered a new prefix key group, on subsequent groups we have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * carry over that extra tuple and add it to the new group's sort here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we read <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new tuples from the outer node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TupIsNull(node-&gt;group_pivot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesortvariants.c.html#L669" title="utils/sort/tuplesortvariants.c:669">tuplesort_puttupleslot</a>(fullsort_state, node-&gt;group_pivot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nTuples++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're in full sort mode accumulating a minimum number of tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and not checking for prefix key equality yet, so we can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assume the group pivot tuple will remain the same -- unless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we're using a minimum group size of 1, in which case the pivot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is obviously still the pivot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nTuples != minGroupSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(node-&gt;group_pivot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pull as many tuples from the outer node as possible given our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current operating mode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot = ExecProcNode(outerNode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the outer node can't provide us <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more tuples, then we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sort the current group and return those tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TupIsNull(slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to know later if the outer node has completed to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * able to distinguish between being done with a batch and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * being done with the whole node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;outerNodeDone = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SO1_printf(<span class="Constant">&quot;Sorting fullsort with &quot;</span> INT64_FORMAT <span class="Constant">&quot; tuples</span><span class="Special">\n</span><span class="Constant">&quot;</span>, nTuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>(fullsort_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L98" title="executor/nodeIncrementalSort.c:98">INSTRUMENT_SORT_GROUP</a>(node, fullsort);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SO_printf(<span class="Constant">&quot;Setting execution_status to INCSORT_READFULLSORT (final tuple)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;execution_status = INCSORT_READFULLSORT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Accumulate the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> group of presorted tuples. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nTuples &lt; minGroupSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we haven't yet hit our target minimum group size, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we don't need to bother checking for inclusion in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current prefix group since at this point we'll assume that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll full sort this batch to avoid a large number of very<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tiny (and thus inefficient) sorts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesortvariants.c.html#L669" title="utils/sort/tuplesortvariants.c:669">tuplesort_puttupleslot</a>(fullsort_state, slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nTuples++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we've reached our minimum group size, then we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * store the most recent tuple as a pivot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nTuples == minGroupSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecCopySlot(node-&gt;group_pivot, slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we've already accumulated enough tuples to reach our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * minimum group size, then we need to <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> additional<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples to our pivot tuple to see if we reach the end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that prefix key group. Only after we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> changed prefix<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keys can we guarantee sort stability of the tuples we've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already accumulated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L212" title="executor/nodeIncrementalSort.c:212">isCurrentGroup</a>(node, node-&gt;group_pivot, slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As long as the prefix keys match the pivot tuple then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * load the tuple into the tuplesort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesortvariants.c.html#L669" title="utils/sort/tuplesortvariants.c:669">tuplesort_puttupleslot</a>(fullsort_state, slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nTuples++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since the tuple we fetched isn't part of the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prefix key group we don't want to sort it as part of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the current batch. Instead we use the group_pivot slot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to carry it over to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> batch (even though we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * won't actually treat it as a group pivot).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecCopySlot(node-&gt;group_pivot, slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;bounded)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the current node has a bound, and we've already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sorted n tuples, then the functional bound<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remaining is (original bound - n), so store the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current number of processed tuples for later use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * configuring the sort state's bound.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SO2_printf(<span class="Constant">&quot;Changing bound_Done from &quot;</span> INT64_FORMAT <span class="Constant">&quot; to &quot;</span> INT64_FORMAT <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;bound_Done,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(node-&gt;bound, node-&gt;bound_Done + nTuples));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;bound_Done = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(node-&gt;bound, node-&gt;bound_Done + nTuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Once we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> changed prefix keys we can complete the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sort and transition modes to reading out the sorted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SO1_printf(<span class="Constant">&quot;Sorting fullsort tuplesort with &quot;</span> INT64_FORMAT <span class="Constant">&quot; tuples</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nTuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>(fullsort_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L98" title="executor/nodeIncrementalSort.c:98">INSTRUMENT_SORT_GROUP</a>(node, fullsort);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SO_printf(<span class="Constant">&quot;Setting execution_status to INCSORT_READFULLSORT (found end of group)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;execution_status = INCSORT_READFULLSORT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Unless we've already transitioned modes to reading from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * full sort state, then we assume that having read at least<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L479" title="executor/nodeIncrementalSort.c:479">DEFAULT_MAX_FULL_SORT_GROUP_SIZE</a> tuples means it's likely we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * processing a large group of tuples all having <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> prefix keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (but haven't yet found the final tuple in that prefix key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * group), so we need to transition into presorted prefix mode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nTuples &gt; <a href="#L479" title="executor/nodeIncrementalSort.c:479">DEFAULT_MAX_FULL_SORT_GROUP_SIZE</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;execution_status != INCSORT_READFULLSORT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The group pivot we have stored has already been put into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the tuplesort; we don't want to carry it over. Since we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * haven't yet found the end of the prefix key group, it might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * seem like we should keep this, but we don't actually know<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * how many prefix key groups might be represented in the full<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sort state, so we'll let the mode transition function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * manage this state for us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(node-&gt;group_pivot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Unfortunately the tuplesort API doesn't include a way to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * retrieve tuples unless a sort has been performed, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * perform the sort even though we could just as easily rely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on FIFO retrieval semantics when transferring them to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * presorted prefix tuplesort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SO1_printf(<span class="Constant">&quot;Sorting fullsort tuplesort with &quot;</span> INT64_FORMAT <span class="Constant">&quot; tuples</span><span class="Special">\n</span><span class="Constant">&quot;</span>, nTuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>(fullsort_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L98" title="executor/nodeIncrementalSort.c:98">INSTRUMENT_SORT_GROUP</a>(node, fullsort);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the full sort tuplesort happened to switch into top-n<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * heapsort mode then we will only be able to retrieve<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * currentBound tuples (since the tuplesort will have only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * retained the top-n tuples). This is safe even though we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * haven't yet completed fetching the current prefix key group<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because the tuples we've &quot;lost&quot; already sorted &quot;below&quot; the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * retained ones, and we're already contractually guaranteed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to not need <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more than the currentBound tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/sort/tuplesort.c.html#L891" title="utils/sort/tuplesort.c:891">tuplesort_used_bound</a>(node-&gt;fullsort_state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; currentBound = node-&gt;bound - node-&gt;bound_Done;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SO2_printf(<span class="Constant">&quot;Read &quot;</span> INT64_FORMAT <span class="Constant">&quot; tuples, but setting to &quot;</span> INT64_FORMAT <span class="Constant">&quot; because we used bounded sort</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nTuples, <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(currentBound, nTuples));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nTuples = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(currentBound, nTuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SO1_printf(<span class="Constant">&quot;Setting n_fullsort_remaining to &quot;</span> INT64_FORMAT <span class="Constant">&quot; and calling <a href="#L286" title="executor/nodeIncrementalSort.c:286">switchToPresortedPrefixMode</a>()</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nTuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We might have multiple prefix key groups in the full sort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * state, so the mode transition function needs to know that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it needs to move from the fullsort to presorted prefix<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;n_fullsort_remaining = nTuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Transition the tuples to the presorted prefix tuplesort. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L286" title="executor/nodeIncrementalSort.c:286">switchToPresortedPrefixMode</a>(pstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since we know we had tuples to move to the presorted prefix<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuplesort, we know that unless that transition has verified<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that all tuples belonged to the same prefix key group (in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which case we can go straight to continuing to load tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * into that tuplesort), we should have a tuple to return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Either way, the appropriate execution status should have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * been set by <a href="#L286" title="executor/nodeIncrementalSort.c:286">switchToPresortedPrefixMode</a>(), so we can drop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * out of the loop here and let the appropriate path kick in.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;execution_status == INCSORT_LOADPREFIXSORT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We only enter this state after the mode transition function has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * confirmed all remaining tuples from the full sort state have the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same prefix and moved those tuples to the prefix sort state. That<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function has also set a group pivot tuple (which doesn't need to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * carried over; it's already been put into the prefix sort state).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!TupIsNull(node-&gt;group_pivot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Read tuples from the outer node and load them into the prefix sort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * state until we encounter a tuple whose prefix keys don't match the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current group_pivot tuple, since we can't guarantee sort stability<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * until we have all tuples matching those prefix keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot = ExecProcNode(outerNode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we've exhausted tuples from the outer node we're done<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * loading the prefix sort state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TupIsNull(slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to know later if the outer node has completed to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * able to distinguish between being done with a batch and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * being done with the whole node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;outerNodeDone = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the tuple's prefix keys match our pivot tuple, we're not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * done yet and can load it into the prefix sort state. If not, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't want to sort it as part of the current batch. Instead we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use the group_pivot slot to carry it over to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> batch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (even though we won't actually treat it as a group pivot).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L212" title="executor/nodeIncrementalSort.c:212">isCurrentGroup</a>(node, node-&gt;group_pivot, slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesortvariants.c.html#L669" title="utils/sort/tuplesortvariants.c:669">tuplesort_puttupleslot</a>(node-&gt;prefixsort_state, slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nTuples++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecCopySlot(node-&gt;group_pivot, slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Perform the sort and begin returning the tuples to the parent plan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SO1_printf(<span class="Constant">&quot;Sorting presorted prefix tuplesort with &quot;</span> INT64_FORMAT <span class="Constant">&quot; tuples</span><span class="Special">\n</span><span class="Constant">&quot;</span>, nTuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>(node-&gt;prefixsort_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L98" title="executor/nodeIncrementalSort.c:98">INSTRUMENT_SORT_GROUP</a>(node, prefixsort);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SO_printf(<span class="Constant">&quot;Setting execution_status to INCSORT_READPREFIXSORT (found end of group)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;execution_status = INCSORT_READPREFIXSORT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;bounded)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the current node has a bound, and we've already sorted n<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples, then the functional bound remaining is (original bound<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * - n), so store the current number of processed tuples for use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in configuring sorting bound.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SO2_printf(<span class="Constant">&quot;Changing bound_Done from &quot;</span> INT64_FORMAT <span class="Constant">&quot; to &quot;</span> INT64_FORMAT <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;bound_Done,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(node-&gt;bound, node-&gt;bound_Done + nTuples));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;bound_Done = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(node-&gt;bound, node-&gt;bound_Done + nTuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore to user specified direction. */<br/></li>
<li></span>&nbsp; &nbsp; estate-&gt;es_direction = dir;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the first or <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple from tuplesort. Returns NULL if no more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; read_sortstate = node-&gt;execution_status == INCSORT_READFULLSORT ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fullsort_state : node-&gt;prefixsort_state;<br/></li>
<li>&nbsp; &nbsp; slot = node-&gt;ss.ps.ps_ResultTupleSlot;<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../utils/sort/tuplesortvariants.c.html#L890" title="utils/sort/tuplesortvariants.c:890">tuplesort_gettupleslot</a>(read_sortstate, ScanDirectionIsForward(dir),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, slot, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> slot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L976" title="executor/nodeIncrementalSort.c:976">ExecInitIncrementalSort</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Creates the run-time state information for the sort node<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; produced by the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> and initializes its outer subtree.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IncrementalSortState *<br/></li>
<li><a id="L976">&#x200c;</a><span class="linkable">ExecInitIncrementalSort</span>(IncrementalSort *node, EState *estate, <span class="Type">int</span> eflags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IncrementalSortState *incrsortstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SO_printf(<span class="Constant">&quot;<a href="#L976" title="executor/nodeIncrementalSort.c:976">ExecInitIncrementalSort</a>: initializing sort node</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Incremental sort can't be used with EXEC_FLAG_BACKWARD or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * EXEC_FLAG_MARK, because the current sort state contains only one sort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * batch rather than the full result set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert((eflags &amp; (EXEC_FLAG_BACKWARD | EXEC_FLAG_MARK)) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize state structure. */<br/></li>
<li></span>&nbsp; &nbsp; incrsortstate = makeNode(IncrementalSortState);<br/></li>
<li>&nbsp; &nbsp; incrsortstate-&gt;ss.ps.plan = (Plan *) node;<br/></li>
<li>&nbsp; &nbsp; incrsortstate-&gt;ss.ps.state = estate;<br/></li>
<li>&nbsp; &nbsp; incrsortstate-&gt;ss.ps.ExecProcNode = <a href="#L495" title="executor/nodeIncrementalSort.c:495">ExecIncrementalSort</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; incrsortstate-&gt;execution_status = INCSORT_LOADFULLSORT;<br/></li>
<li>&nbsp; &nbsp; incrsortstate-&gt;bounded = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; incrsortstate-&gt;outerNodeDone = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; incrsortstate-&gt;bound_Done = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; incrsortstate-&gt;fullsort_state = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; incrsortstate-&gt;prefixsort_state = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; incrsortstate-&gt;group_pivot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; incrsortstate-&gt;transfer_tuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; incrsortstate-&gt;n_fullsort_remaining = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; incrsortstate-&gt;presorted_keys = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (incrsortstate-&gt;ss.ps.instrument != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IncrementalSortGroupInfo *fullsortGroupInfo =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;incrsortstate-&gt;incsort_info.fullsortGroupInfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IncrementalSortGroupInfo *prefixsortGroupInfo =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;incrsortstate-&gt;incsort_info.prefixsortGroupInfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fullsortGroupInfo-&gt;groupCount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fullsortGroupInfo-&gt;maxDiskSpaceUsed = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fullsortGroupInfo-&gt;totalDiskSpaceUsed = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fullsortGroupInfo-&gt;maxMemorySpaceUsed = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fullsortGroupInfo-&gt;totalMemorySpaceUsed = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fullsortGroupInfo-&gt;sortMethods = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prefixsortGroupInfo-&gt;groupCount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prefixsortGroupInfo-&gt;maxDiskSpaceUsed = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prefixsortGroupInfo-&gt;totalDiskSpaceUsed = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prefixsortGroupInfo-&gt;maxMemorySpaceUsed = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prefixsortGroupInfo-&gt;totalMemorySpaceUsed = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prefixsortGroupInfo-&gt;sortMethods = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Miscellaneous initialization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sort nodes don't <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> their ExprContexts because they never call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ExecQual or ExecProject.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize child nodes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Incremental sort does not support backwards scans and mark/restore, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we don't bother removing the flags from eflags here. We allow passing a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * REWIND flag, because although incremental sort can't use it, the child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nodes may be able to do something more useful.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; outerPlanState(incrsortstate) = <a href="execProcnode.c.html#L142" title="executor/execProcnode.c:142">ExecInitNode</a>(outerPlan(node), estate, eflags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize scan slot and type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execUtils.c.html#L659" title="executor/execUtils.c:659">ExecCreateScanSlotFromOuterPlan</a>(estate, &amp;incrsortstate-&gt;ss, &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize return slot and type. No need to <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> projection info<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because we don't do <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> projections.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execTuples.c.html#L1886" title="executor/execTuples.c:1886">ExecInitResultTupleSlotTL</a>(&amp;incrsortstate-&gt;ss.ps, &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li>&nbsp; &nbsp; incrsortstate-&gt;ss.ps.ps_ProjInfo = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize standalone slots to store a tuple for pivot prefix keys and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for carrying over a tuple from one batch to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; incrsortstate-&gt;group_pivot =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>(<a href="execUtils.c.html#L493" title="executor/execUtils.c:493">ExecGetResultType</a>(outerPlanState(incrsortstate)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li>&nbsp; &nbsp; incrsortstate-&gt;transfer_tuple =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>(<a href="execUtils.c.html#L493" title="executor/execUtils.c:493">ExecGetResultType</a>(outerPlanState(incrsortstate)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SO_printf(<span class="Constant">&quot;<a href="#L976" title="executor/nodeIncrementalSort.c:976">ExecInitIncrementalSort</a>: sort node initialized</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> incrsortstate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1077" title="executor/nodeIncrementalSort.c:1077">ExecEndIncrementalSort</a>(node)<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1077">&#x200c;</a></span><span class="linkable">ExecEndIncrementalSort</span>(IncrementalSortState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SO_printf(<span class="Constant">&quot;<a href="#L1077" title="executor/nodeIncrementalSort.c:1077">ExecEndIncrementalSort</a>: shutting down sort node</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="execTuples.c.html#L1341" title="executor/execTuples.c:1341">ExecDropSingleTupleTableSlot</a>(node-&gt;group_pivot);<br/></li>
<li>&nbsp; &nbsp; <a href="execTuples.c.html#L1341" title="executor/execTuples.c:1341">ExecDropSingleTupleTableSlot</a>(node-&gt;transfer_tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release tuplesort resources.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;fullsort_state != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L971" title="utils/sort/tuplesort.c:971">tuplesort_end</a>(node-&gt;fullsort_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;fullsort_state = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;prefixsort_state != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L971" title="utils/sort/tuplesort.c:971">tuplesort_end</a>(node-&gt;prefixsort_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;prefixsort_state = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Shut down the subplan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execProcnode.c.html#L557" title="executor/execProcnode.c:557">ExecEndNode</a>(outerPlanState(node));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SO_printf(<span class="Constant">&quot;<a href="#L1077" title="executor/nodeIncrementalSort.c:1077">ExecEndIncrementalSort</a>: sort node shutdown</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1107">&#x200c;</a></span><span class="linkable">ExecReScanIncrementalSort</span>(IncrementalSortState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlanState&nbsp; *outerPlan = outerPlanState(node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Incremental sort doesn't support efficient rescan even when parameters<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * haven't changed (e.g., rewind) because unlike regular sort we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * store all tuples at once for the full sort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * So even if EXEC_FLAG_REWIND is set we just reset all of our state and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * re-execute the sort along with the child node. Incremental sort itself<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't do anything smarter, but maybe the child nodes can.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In theory if we've only filled the full sort with one batch (and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * haven't reset it for a new batch yet) then we could efficiently rewind,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but that seems a narrow enough case that it's not worth handling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * specially at this time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* must drop pointer to sort result tuple */<br/></li>
<li></span>&nbsp; &nbsp; ExecClearTuple(node-&gt;ss.ps.ps_ResultTupleSlot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;group_pivot != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(node-&gt;group_pivot);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;transfer_tuple != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(node-&gt;transfer_tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node-&gt;outerNodeDone = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;n_fullsort_remaining = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;bound_Done = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node-&gt;execution_status = INCSORT_LOADFULLSORT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we've set up either of the sort states yet, we need to reset them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We could end them and null out the pointers, but there's no reason to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * repay the setup cost, and because <a href="#L495" title="executor/nodeIncrementalSort.c:495">ExecIncrementalSort</a> guards presorted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * column <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> by checking to see if the full sort state has been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initialized yet, setting the sort states to null here might actually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cause a leak.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;fullsort_state != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L1039" title="utils/sort/tuplesort.c:1039">tuplesort_reset</a>(node-&gt;fullsort_state);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;prefixsort_state != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L1039" title="utils/sort/tuplesort.c:1039">tuplesort_reset</a>(node-&gt;prefixsort_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If chgParam of subnode is not null, then the plan will be re-scanned by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the first ExecProcNode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (outerPlan-&gt;chgParam == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execAmi.c.html#L76" title="executor/execAmi.c:76">ExecReScan</a>(outerPlan);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Parallel Query Support<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeSort.c.html#L416" title="executor/nodeSort.c:416">ExecSortEstimate</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Estimate space required to propagate sort statistics.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1173">&#x200c;</a></span><span class="linkable">ExecIncrementalSortEstimate</span>(IncrementalSortState *node, ParallelContext *pcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't need this if not instrumenting or no workers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!node-&gt;ss.ps.instrument || pcxt-&gt;nworkers == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = <a href="../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(pcxt-&gt;nworkers, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IncrementalSortInfo));<br/></li>
<li>&nbsp; &nbsp; size = <a href="../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, offsetof(SharedIncrementalSortInfo, sinfo));<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, size);<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeSort.c.html#L437" title="executor/nodeSort.c:437">ExecSortInitializeDSM</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Initialize DSM space for sort statistics.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1194">&#x200c;</a></span><span class="linkable">ExecIncrementalSortInitializeDSM</span>(IncrementalSortState *node, ParallelContext *pcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't need this if not instrumenting or no workers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!node-&gt;ss.ps.instrument || pcxt-&gt;nworkers == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = offsetof(SharedIncrementalSortInfo, sinfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; + pcxt-&gt;nworkers * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IncrementalSortInfo);<br/></li>
<li>&nbsp; &nbsp; node-&gt;shared_info = <a href="../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, size);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ensure <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unfilled slots will contain zeroes */<br/></li>
<li></span>&nbsp; &nbsp; memset(node-&gt;shared_info, <span class="Constant">0</span>, size);<br/></li>
<li>&nbsp; &nbsp; node-&gt;shared_info-&gt;num_workers = pcxt-&gt;nworkers;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, node-&gt;ss.ps.plan-&gt;plan_node_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;shared_info);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeSort.c.html#L462" title="executor/nodeSort.c:462">ExecSortInitializeWorker</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Attach worker to DSM space for sort statistics.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1219">&#x200c;</a></span><span class="linkable">ExecIncrementalSortInitializeWorker</span>(IncrementalSortState *node, ParallelWorkerContext *pwcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; node-&gt;shared_info =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(pwcxt-&gt;toc, node-&gt;ss.ps.plan-&gt;plan_node_id, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; node-&gt;am_worker = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeSort.c.html#L476" title="executor/nodeSort.c:476">ExecSortRetrieveInstrumentation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Transfer sort statistics from DSM to private memory.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1233">&#x200c;</a></span><span class="linkable">ExecIncrementalSortRetrieveInstrumentation</span>(IncrementalSortState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; SharedIncrementalSortInfo *si;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;shared_info == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = offsetof(SharedIncrementalSortInfo, sinfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; + node-&gt;shared_info-&gt;num_workers * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IncrementalSortInfo);<br/></li>
<li>&nbsp; &nbsp; si = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(size);<br/></li>
<li>&nbsp; &nbsp; memcpy(si, node-&gt;shared_info, size);<br/></li>
<li>&nbsp; &nbsp; node-&gt;shared_info = si;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
