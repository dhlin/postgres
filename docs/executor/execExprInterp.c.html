<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>executor/execExprInterp.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>executor/execExprInterp.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L112">dispatch_table</a></li>
<li><a href="#L115">reverse_dispatch_table</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L105">ExprEvalOpLookup</a></li>
<li><a href="#L109">ExprEvalOpLookup</a></li>
<li><a href="#L189">ScalarArrayOpExprHashEntry</a></li>
<li><a href="#L194">ScalarArrayOpExprHashEntry</a></li>
<li><a href="#L211">ScalarArrayOpExprHashTable</a></li>
<li><a href="#L217">ScalarArrayOpExprHashTable</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1923">CheckExprStillValid</a></li>
<li><a href="#L2025">CheckOpSlotCompatibility</a></li>
<li><a href="#L1974">CheckVarSlotCompatibility</a></li>
<li><a href="#L4960">ExecAggCopyTransValue</a></li>
<li><a href="#L4907">ExecAggInitGroup</a></li>
<li><a href="#L5159">ExecAggPlainTransByRef</a></li>
<li><a href="#L5127">ExecAggPlainTransByVal</a></li>
<li><a href="#L5099">ExecEvalAggOrderedTransDatum</a></li>
<li><a href="#L5113">ExecEvalAggOrderedTransTuple</a></li>
<li><a href="#L3047">ExecEvalArrayCoerce</a></li>
<li><a href="#L2833">ExecEvalArrayExpr</a></li>
<li><a href="#L2567">ExecEvalCoerceViaIOSafe</a></li>
<li><a href="#L3854">ExecEvalConstraintCheck</a></li>
<li><a href="#L3840">ExecEvalConstraintNotNull</a></li>
<li><a href="#L3360">ExecEvalConvertRowtype</a></li>
<li><a href="#L2694">ExecEvalCurrentOfExpr</a></li>
<li><a href="#L3161">ExecEvalFieldSelect</a></li>
<li><a href="#L3286">ExecEvalFieldStoreDeForm</a></li>
<li><a href="#L3336">ExecEvalFieldStoreForm</a></li>
<li><a href="#L2440">ExecEvalFuncExprFusage</a></li>
<li><a href="#L2461">ExecEvalFuncExprStrictFusage</a></li>
<li><a href="#L4579">ExecEvalGroupingFunc</a></li>
<li><a href="#L3658">ExecEvalHashedScalarArrayOp</a></li>
<li><a href="#L4538">ExecEvalJsonCoercion</a></li>
<li><a href="#L4557">ExecEvalJsonCoercionFinish</a></li>
<li><a href="#L4089">ExecEvalJsonConstructor</a></li>
<li><a href="#L4267">ExecEvalJsonExprPath</a></li>
<li><a href="#L4167">ExecEvalJsonIsPredicate</a></li>
<li><a href="#L4606">ExecEvalMergeSupportFunc</a></li>
<li><a href="#L3108">ExecEvalMinMax</a></li>
<li><a href="#L2705">ExecEvalNextValueExpr</a></li>
<li><a href="#L2498">ExecEvalParamExec</a></li>
<li><a href="#L2520">ExecEvalParamExtern</a></li>
<li><a href="#L5052">ExecEvalPreOrderedDistinctMulti</a></li>
<li><a href="#L5009">ExecEvalPreOrderedDistinctSingle</a></li>
<li><a href="#L3088">ExecEvalRow</a></li>
<li><a href="#L2740">ExecEvalRowNotNull</a></li>
<li><a href="#L2731">ExecEvalRowNull</a></li>
<li><a href="#L2747">ExecEvalRowNullInt</a></li>
<li><a href="#L2627">ExecEvalSQLValueFunction</a></li>
<li><a href="#L3455">ExecEvalScalarArrayOp</a></li>
<li><a href="#L2410">ExecEvalStepOp</a></li>
<li><a href="#L4643">ExecEvalSubPlan</a></li>
<li><a href="#L4887">ExecEvalSysVar</a></li>
<li><a href="#L4660">ExecEvalWholeRowVar</a></li>
<li><a href="#L3874">ExecEvalXmlExpr</a></li>
<li><a href="#L4463">ExecGetJsonValueItemString</a></li>
<li><a href="#L2378">ExecInitInterpreter</a></li>
<li><a href="#L396">ExecInterpExpr</a></li>
<li><a href="#L1903">ExecInterpExprStillValid</a></li>
<li><a href="#L2223">ExecJustApplyFuncToCase</a></li>
<li><a href="#L2202">ExecJustAssignInnerVar</a></li>
<li><a href="#L2336">ExecJustAssignInnerVarVirt</a></li>
<li><a href="#L2209">ExecJustAssignOuterVar</a></li>
<li><a href="#L2343">ExecJustAssignOuterVarVirt</a></li>
<li><a href="#L2216">ExecJustAssignScanVar</a></li>
<li><a href="#L2350">ExecJustAssignScanVarVirt</a></li>
<li><a href="#L2176">ExecJustAssignVarImpl</a></li>
<li><a href="#L2314">ExecJustAssignVarVirtImpl</a></li>
<li><a href="#L2261">ExecJustConst</a></li>
<li><a href="#L2155">ExecJustInnerVar</a></li>
<li><a href="#L2293">ExecJustInnerVarVirt</a></li>
<li><a href="#L2162">ExecJustOuterVar</a></li>
<li><a href="#L2300">ExecJustOuterVarVirt</a></li>
<li><a href="#L2169">ExecJustScanVar</a></li>
<li><a href="#L2307">ExecJustScanVarVirt</a></li>
<li><a href="#L2138">ExecJustVarImpl</a></li>
<li><a href="#L2271">ExecJustVarVirtImpl</a></li>
<li><a href="#L236">ExecReadyInterpretedExpr</a></li>
<li><a href="#L2361">dispatch_compare_ptr</a></li>
<li><a href="#L2072">get_cached_rowtype</a></li>
<li><a href="#L3608">saop_element_hash</a></li>
<li><a href="#L3627">saop_hash_element_match</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L118">EEO_CASE</a></li>
<li><a href="#L125">EEO_CASE</a></li>
<li><a href="#L119">EEO_DISPATCH</a></li>
<li><a href="#L126">EEO_DISPATCH</a></li>
<li><a href="#L137">EEO_JUMP</a></li>
<li><a href="#L131">EEO_NEXT</a></li>
<li><a href="#L120">EEO_OPCODE</a></li>
<li><a href="#L127">EEO_OPCODE</a></li>
<li><a href="#L117">EEO_SWITCH</a></li>
<li><a href="#L124">EEO_SWITCH</a></li>
<li><a href="#L89">EEO_USE_COMPUTED_GOTO</a></li>
<li><a href="#L200">SH_DECLARE</a></li>
<li><a href="#L229">SH_DEFINE</a></li>
<li><a href="#L197">SH_ELEMENT_TYPE</a></li>
<li><a href="#L221">SH_ELEMENT_TYPE</a></li>
<li><a href="#L225">SH_EQUAL</a></li>
<li><a href="#L228">SH_GET_HASH</a></li>
<li><a href="#L224">SH_HASH_KEY</a></li>
<li><a href="#L223">SH_KEY</a></li>
<li><a href="#L198">SH_KEY_TYPE</a></li>
<li><a href="#L222">SH_KEY_TYPE</a></li>
<li><a href="#L196">SH_PREFIX</a></li>
<li><a href="#L220">SH_PREFIX</a></li>
<li><a href="#L199">SH_SCOPE</a></li>
<li><a href="#L226">SH_SCOPE</a></li>
<li><a href="#L227">SH_STORE_HASH</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * execExprInterp.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Interpreted evaluation of an expression step list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This file provides either a &quot;direct threaded&quot; (for gcc, clang and<br/></li>
<li></span><span class="Comment"> * compatible) or a &quot;switch threaded&quot; (for all compilers) implementation of<br/></li>
<li></span><span class="Comment"> * expression evaluation.&nbsp; The former is amongst the fastest known methods<br/></li>
<li></span><span class="Comment"> * of interpreting programs without resorting to assembly level work, or<br/></li>
<li></span><span class="Comment"> * just-in-time compilation, but it requires support for computed gotos.<br/></li>
<li></span><span class="Comment"> * The latter is amongst the fastest approaches doable in standard C.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In either case we use ExprEvalStep-&gt;opcode to dispatch to the code block<br/></li>
<li></span><span class="Comment"> * within <a href="#L396" title="executor/execExprInterp.c:396">ExecInterpExpr</a>() that implements the specific opcode type.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Switch-threading uses a plain switch() statement to perform the<br/></li>
<li></span><span class="Comment"> * dispatch.&nbsp; This has the advantages of being plain C and allowing the<br/></li>
<li></span><span class="Comment"> * compiler to warn if implementation of a specific opcode has been forgotten.<br/></li>
<li></span><span class="Comment"> * The disadvantage is that dispatches will, as commonly implemented by<br/></li>
<li></span><span class="Comment"> * compilers, happen from a single location, requiring more jumps and causing<br/></li>
<li></span><span class="Comment"> * bad branch prediction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In direct threading, we use gcc's label-as-<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> extension - also adopted<br/></li>
<li></span><span class="Comment"> * by some other compilers - to replace ExprEvalStep-&gt;opcode with the address<br/></li>
<li></span><span class="Comment"> * of the block implementing the instruction. Dispatch to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> instruction<br/></li>
<li></span><span class="Comment"> * is done by a &quot;computed goto&quot;.&nbsp; This allows for better branch prediction<br/></li>
<li></span><span class="Comment"> * (as the jumps are happening from different locations) and fewer jumps<br/></li>
<li></span><span class="Comment"> * (as no preparatory jump to a common dispatch location is needed).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When using direct threading, <a href="#L236" title="executor/execExprInterp.c:236">ExecReadyInterpretedExpr</a> will replace<br/></li>
<li></span><span class="Comment"> * each step's opcode field with the address of the relevant code block and<br/></li>
<li></span><span class="Comment"> * ExprState-&gt;flags will contain EEO_FLAG_DIRECT_THREADED to remember that<br/></li>
<li></span><span class="Comment"> * that's been done.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For very simple instructions the overhead of the full interpreter<br/></li>
<li></span><span class="Comment"> * &quot;startup&quot;, as minimal as it is, is noticeable.&nbsp; Therefore<br/></li>
<li></span><span class="Comment"> * <a href="#L236" title="executor/execExprInterp.c:236">ExecReadyInterpretedExpr</a> will choose to implement certain simple<br/></li>
<li></span><span class="Comment"> * opcode patterns using special fast-path routines (ExecJust*).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Complex or uncommon instructions are not implemented in-line in<br/></li>
<li></span><span class="Comment"> * <a href="#L396" title="executor/execExprInterp.c:396">ExecInterpExpr</a>(), rather we call out to a helper function appearing later<br/></li>
<li></span><span class="Comment"> * in this file.&nbsp; For one reason, there'd not be a noticeable performance<br/></li>
<li></span><span class="Comment"> * benefit, but more importantly those complex routines are intended to be<br/></li>
<li></span><span class="Comment"> * shared between different expression evaluation approaches.&nbsp; For instance<br/></li>
<li></span><span class="Comment"> * a JIT compiler would generate calls to them.&nbsp; (This is why they are<br/></li>
<li></span><span class="Comment"> * exported rather than being &quot;static&quot; in this file.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/executor/execExprInterp.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/heaptoast.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/sequence.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/execExpr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeSubplan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/miscnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/date.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/expandedrecord.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/json.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/jsonfuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/jsonpath.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/typcache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/xml.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Use computed-goto-based opcode dispatch when computed gotos are available.<br/></li>
<li></span><span class="Comment"> * But use a separate symbol so that it's easy to adjust locally in this file<br/></li>
<li></span><span class="Comment"> * for development and testing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef HAVE_COMPUTED_GOTO<br/></li>
<li><a id="L89">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EEO_USE_COMPUTED_GOTO</span><br/></li>
<li></span><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* HAVE_COMPUTED_GOTO */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Macros for opcode dispatch.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L117" title="executor/execExprInterp.c:117">EEO_SWITCH</a> - just hides the switch if not in use.<br/></li>
<li></span><span class="Comment"> * <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a> - labels the implementation of named expression step type.<br/></li>
<li></span><span class="Comment"> * <a href="#L119" title="executor/execExprInterp.c:119">EEO_DISPATCH</a> - jump to the implementation of the step type for 'op'.<br/></li>
<li></span><span class="Comment"> * <a href="#L120" title="executor/execExprInterp.c:120">EEO_OPCODE</a> - compute opcode required by used expression evaluation method.<br/></li>
<li></span><span class="Comment"> * <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a> - increment 'op' and jump to correct <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> step type.<br/></li>
<li></span><span class="Comment"> * <a href="#L137" title="executor/execExprInterp.c:137">EEO_JUMP</a> - jump to the specified step number within the current expression.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#if defined(<a href="#L89" title="executor/execExprInterp.c:89">EEO_USE_COMPUTED_GOTO</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* struct for jump target -&gt; opcode lookup table */<br/></li>
<li><a id="L105">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ExprEvalOpLookup</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">void</span> *opcode;<br/></li>
<li>&nbsp; &nbsp; ExprEvalOp&nbsp; &nbsp; op;<br/></li>
<li><a id="L109">&#x200c;</a>} <span class="linkable">ExprEvalOpLookup</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* to make <a href="#L112" title="executor/execExprInterp.c:112">dispatch_table</a> accessible outside <a href="#L396" title="executor/execExprInterp.c:396">ExecInterpExpr</a>() */<br/></li>
<li><a id="L112">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">void</span> **<span class="linkable">dispatch_table</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* jump target -&gt; opcode lookup table */<br/></li>
<li><a id="L115">&#x200c;</a></span><span class="Type">static</span> <a href="#L105" title="executor/execExprInterp.c:105">ExprEvalOpLookup</a> <span class="linkable">reverse_dispatch_table</span>[EEOP_LAST];<br/></li>
<li><br/></li>
<li><a id="L117">&#x200c;</a><span class="PreProc">#define <span class="linkable">EEO_SWITCH</span>()<br/></li>
<li><a id="L118">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EEO_CASE</span>(name)&nbsp; &nbsp; &nbsp; &nbsp; CASE_##name:<br/></li>
<li><a id="L119">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EEO_DISPATCH</span>()&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">goto</span><span class="PreProc"> *((</span><span class="Type">void</span><span class="PreProc"> *) op-&gt;opcode)<br/></li>
<li><a id="L120">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EEO_OPCODE</span>(opcode)&nbsp; &nbsp; ((</span><span class="Type">intptr_t</span><span class="PreProc">) <a href="#L112" title="executor/execExprInterp.c:112">dispatch_table</a>[opcode])<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* !<a href="#L89" title="executor/execExprInterp.c:89">EEO_USE_COMPUTED_GOTO</a> */<br/></li>
<li></span><br/></li>
<li><a id="L124">&#x200c;</a><span class="PreProc">#define <span class="linkable">EEO_SWITCH</span>()&nbsp; &nbsp; &nbsp; &nbsp; starteval: </span><span class="Statement">switch</span><span class="PreProc"> ((ExprEvalOp) op-&gt;opcode)<br/></li>
<li><a id="L125">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EEO_CASE</span>(name)&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">case</span><span class="PreProc"> name:<br/></li>
<li><a id="L126">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EEO_DISPATCH</span>()&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">goto</span><span class="PreProc"> starteval<br/></li>
<li><a id="L127">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EEO_OPCODE</span>(opcode)&nbsp; &nbsp; (opcode)<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L89" title="executor/execExprInterp.c:89">EEO_USE_COMPUTED_GOTO</a> */<br/></li>
<li></span><br/></li>
<li><a id="L131">&#x200c;</a><span class="PreProc">#define <span class="linkable">EEO_NEXT</span>() \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; op++; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L119" title="executor/execExprInterp.c:119">EEO_DISPATCH</a>(); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L137">&#x200c;</a><span class="PreProc">#define <span class="linkable">EEO_JUMP</span>(stepno) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; op = &amp;state-&gt;steps[stepno]; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L119" title="executor/execExprInterp.c:119">EEO_DISPATCH</a>(); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> Datum <a href="#L396" title="executor/execExprInterp.c:396">ExecInterpExpr</a>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2378" title="executor/execExprInterp.c:2378">ExecInitInterpreter</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="Comment">/* support <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L1974" title="executor/execExprInterp.c:1974">CheckVarSlotCompatibility</a>(TupleTableSlot *slot, <span class="Type">int</span> attnum, Oid vartype);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2025" title="executor/execExprInterp.c:2025">CheckOpSlotCompatibility</a>(ExprEvalStep *op, TupleTableSlot *slot);<br/></li>
<li><span class="Type">static</span> TupleDesc <a href="#L2072" title="executor/execExprInterp.c:2072">get_cached_rowtype</a>(Oid type_id, int32 typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExprEvalRowtypeCache *rowcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *changed);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2747" title="executor/execExprInterp.c:2747">ExecEvalRowNullInt</a>(ExprState *state, ExprEvalStep *op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> checkisnull);<br/></li>
<li><br/></li>
<li><span class="Comment">/* fast-path evaluation <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> Datum <a href="#L2155" title="executor/execExprInterp.c:2155">ExecJustInnerVar</a>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L2162" title="executor/execExprInterp.c:2162">ExecJustOuterVar</a>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L2169" title="executor/execExprInterp.c:2169">ExecJustScanVar</a>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L2202" title="executor/execExprInterp.c:2202">ExecJustAssignInnerVar</a>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L2209" title="executor/execExprInterp.c:2209">ExecJustAssignOuterVar</a>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L2216" title="executor/execExprInterp.c:2216">ExecJustAssignScanVar</a>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L2223" title="executor/execExprInterp.c:2223">ExecJustApplyFuncToCase</a>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L2261" title="executor/execExprInterp.c:2261">ExecJustConst</a>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L2293" title="executor/execExprInterp.c:2293">ExecJustInnerVarVirt</a>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L2300" title="executor/execExprInterp.c:2300">ExecJustOuterVarVirt</a>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L2307" title="executor/execExprInterp.c:2307">ExecJustScanVarVirt</a>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L2336" title="executor/execExprInterp.c:2336">ExecJustAssignInnerVarVirt</a>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L2343" title="executor/execExprInterp.c:2343">ExecJustAssignOuterVarVirt</a>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L2350" title="executor/execExprInterp.c:2350">ExecJustAssignScanVarVirt</a>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull);<br/></li>
<li><br/></li>
<li><span class="Comment">/* execution helper <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> pg_attribute_always_inline <span class="Type">void</span> <a href="#L5127" title="executor/execExprInterp.c:5127">ExecAggPlainTransByVal</a>(AggState *aggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerTrans pertrans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerGroup pergroup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExprContext *aggcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> setno);<br/></li>
<li><span class="Type">static</span> pg_attribute_always_inline <span class="Type">void</span> <a href="#L5159" title="executor/execExprInterp.c:5159">ExecAggPlainTransByRef</a>(AggState *aggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerTrans pertrans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerGroup pergroup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExprContext *aggcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> setno);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L4463" title="executor/execExprInterp.c:4463">ExecGetJsonValueItemString</a>(JsonbValue *item, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *resnull);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L189" title="executor/execExprInterp.c:189">ScalarArrayOpExprHashEntry</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Hash table entry type used during EEOP_HASHED_SCALARARRAYOP<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L189">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ScalarArrayOpExprHashEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; key;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; status;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> status */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value (cached) */<br/></li>
<li><a id="L194">&#x200c;</a></span>} <span class="linkable">ScalarArrayOpExprHashEntry</span>;<br/></li>
<li><br/></li>
<li><a id="L196">&#x200c;</a><span class="PreProc">#define <span class="linkable">SH_PREFIX</span> saophash<br/></li>
<li><a id="L197">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_ELEMENT_TYPE</span> <a href="#L189" title="executor/execExprInterp.c:189">ScalarArrayOpExprHashEntry</a><br/></li>
<li><a id="L198">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_KEY_TYPE</span> Datum<br/></li>
<li><a id="L199">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_SCOPE</span> </span><span class="Type">static</span><span class="PreProc"> </span><span class="Type">inline<br/></li>
<li><a id="L200">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_DECLARE</span><br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/simplehash.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3627" title="executor/execExprInterp.c:3627">saop_hash_element_match</a>(<span class="Type">struct</span> saophash_hash *tb, Datum key1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum key2);<br/></li>
<li><span class="Type">static</span> uint32 <a href="#L3608" title="executor/execExprInterp.c:3608">saop_element_hash</a>(<span class="Type">struct</span> saophash_hash *tb, Datum key);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L211" title="executor/execExprInterp.c:211">ScalarArrayOpExprHashTable</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Hash table for EEOP_HASHED_SCALARARRAYOP<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L211">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ScalarArrayOpExprHashTable</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; saophash_hash *hashtab;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* underlying <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> ExprEvalStep *op;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; hash_finfo;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* function's lookup data */<br/></li>
<li></span>&nbsp; &nbsp; FunctionCallInfoBaseData hash_fcinfo_data;&nbsp; &nbsp; <span class="Comment">/* arguments etc */<br/></li>
<li><a id="L217">&#x200c;</a></span>} <span class="linkable">ScalarArrayOpExprHashTable</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Define parameters for ScalarArrayOpExpr <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table code generation. */<br/></li>
<li><a id="L220">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_PREFIX</span> saophash<br/></li>
<li><a id="L221">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_ELEMENT_TYPE</span> <a href="#L189" title="executor/execExprInterp.c:189">ScalarArrayOpExprHashEntry</a><br/></li>
<li><a id="L222">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_KEY_TYPE</span> Datum<br/></li>
<li><a id="L223">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_KEY</span> key<br/></li>
<li><a id="L224">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_HASH_KEY</span>(tb, key) <a href="#L3608" title="executor/execExprInterp.c:3608">saop_element_hash</a>(tb, key)<br/></li>
<li><a id="L225">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_EQUAL</span>(tb, a, b) <a href="#L3627" title="executor/execExprInterp.c:3627">saop_hash_element_match</a>(tb, a, b)<br/></li>
<li><a id="L226">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_SCOPE</span> </span><span class="Type">static</span><span class="PreProc"> </span><span class="Type">inline<br/></li>
<li><a id="L227">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_STORE_HASH</span><br/></li>
<li><a id="L228">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_GET_HASH</span>(tb, a) a-&gt;<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li><a id="L229">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_DEFINE</span><br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/simplehash.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare ExprState for interpreted execution.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L236">&#x200c;</a></span><span class="linkable">ExecReadyInterpretedExpr</span>(ExprState *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure one-time interpreter setup has been done */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2378" title="executor/execExprInterp.c:2378">ExecInitInterpreter</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Simple validity checks on expression */<br/></li>
<li></span>&nbsp; &nbsp; Assert(state-&gt;steps_len &gt;= <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;steps[state-&gt;steps_len - <span class="Constant">1</span>].opcode == EEOP_DONE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't perform redundant initialization. This is unreachable in current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases, but might be hit if there's additional expression evaluation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * methods that rely on interpreted execution to work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;flags &amp; EEO_FLAG_INTERPRETER_INITIALIZED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First time through, check whether attribute matches Var.&nbsp; Might not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ok anymore, due to schema changes. We do that by setting up a callback<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that does checking on the first call, which then sets the evalfunc<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * callback to the actual method of execution.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;evalfunc = <a href="#L1903" title="executor/execExprInterp.c:1903">ExecInterpExprStillValid</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* DIRECT_THREADED should not already be set */<br/></li>
<li></span>&nbsp; &nbsp; Assert((state-&gt;flags &amp; EEO_FLAG_DIRECT_THREADED) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There shouldn't be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> errors <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the expression is fully<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initialized, and even if so, it'd lead to the expression being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * abandoned.&nbsp; So we can set the flag <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> and save some code.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;flags |= EEO_FLAG_INTERPRETER_INITIALIZED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Select fast-path evalfuncs for very simple expressions.&nbsp; &quot;Starting up&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the full interpreter is a measurable overhead for these, and these<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * patterns occur often enough to be worth optimizing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;steps_len == <span class="Constant">3</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExprEvalOp&nbsp; &nbsp; step0 = state-&gt;steps[<span class="Constant">0</span>].opcode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExprEvalOp&nbsp; &nbsp; step1 = state-&gt;steps[<span class="Constant">1</span>].opcode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (step0 == EEOP_INNER_FETCHSOME &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; step1 == EEOP_INNER_VAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;evalfunc_private = (<span class="Type">void</span> *) <a href="#L2155" title="executor/execExprInterp.c:2155">ExecJustInnerVar</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (step0 == EEOP_OUTER_FETCHSOME &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; step1 == EEOP_OUTER_VAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;evalfunc_private = (<span class="Type">void</span> *) <a href="#L2162" title="executor/execExprInterp.c:2162">ExecJustOuterVar</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (step0 == EEOP_SCAN_FETCHSOME &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; step1 == EEOP_SCAN_VAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;evalfunc_private = (<span class="Type">void</span> *) <a href="#L2169" title="executor/execExprInterp.c:2169">ExecJustScanVar</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (step0 == EEOP_INNER_FETCHSOME &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; step1 == EEOP_ASSIGN_INNER_VAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;evalfunc_private = (<span class="Type">void</span> *) <a href="#L2202" title="executor/execExprInterp.c:2202">ExecJustAssignInnerVar</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (step0 == EEOP_OUTER_FETCHSOME &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; step1 == EEOP_ASSIGN_OUTER_VAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;evalfunc_private = (<span class="Type">void</span> *) <a href="#L2209" title="executor/execExprInterp.c:2209">ExecJustAssignOuterVar</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (step0 == EEOP_SCAN_FETCHSOME &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; step1 == EEOP_ASSIGN_SCAN_VAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;evalfunc_private = (<span class="Type">void</span> *) <a href="#L2216" title="executor/execExprInterp.c:2216">ExecJustAssignScanVar</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (step0 == EEOP_CASE_TESTVAL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; step1 == EEOP_FUNCEXPR_STRICT &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;steps[<span class="Constant">0</span>].d.casetest.value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;evalfunc_private = (<span class="Type">void</span> *) <a href="#L2223" title="executor/execExprInterp.c:2223">ExecJustApplyFuncToCase</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (state-&gt;steps_len == <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExprEvalOp&nbsp; &nbsp; step0 = state-&gt;steps[<span class="Constant">0</span>].opcode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (step0 == EEOP_CONST)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;evalfunc_private = (<span class="Type">void</span> *) <a href="#L2261" title="executor/execExprInterp.c:2261">ExecJustConst</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (step0 == EEOP_INNER_VAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;evalfunc_private = (<span class="Type">void</span> *) <a href="#L2293" title="executor/execExprInterp.c:2293">ExecJustInnerVarVirt</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (step0 == EEOP_OUTER_VAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;evalfunc_private = (<span class="Type">void</span> *) <a href="#L2300" title="executor/execExprInterp.c:2300">ExecJustOuterVarVirt</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (step0 == EEOP_SCAN_VAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;evalfunc_private = (<span class="Type">void</span> *) <a href="#L2307" title="executor/execExprInterp.c:2307">ExecJustScanVarVirt</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (step0 == EEOP_ASSIGN_INNER_VAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;evalfunc_private = (<span class="Type">void</span> *) <a href="#L2336" title="executor/execExprInterp.c:2336">ExecJustAssignInnerVarVirt</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (step0 == EEOP_ASSIGN_OUTER_VAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;evalfunc_private = (<span class="Type">void</span> *) <a href="#L2343" title="executor/execExprInterp.c:2343">ExecJustAssignOuterVarVirt</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (step0 == EEOP_ASSIGN_SCAN_VAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;evalfunc_private = (<span class="Type">void</span> *) <a href="#L2350" title="executor/execExprInterp.c:2350">ExecJustAssignScanVarVirt</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#if defined(<a href="#L89" title="executor/execExprInterp.c:89">EEO_USE_COMPUTED_GOTO</a>)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In the direct-threaded implementation, replace each opcode with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * address to jump to.&nbsp; (Use <a href="#L2410" title="executor/execExprInterp.c:2410">ExecEvalStepOp</a>() to get back the opcode.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> off = <span class="Constant">0</span>; off &lt; state-&gt;steps_len; off++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExprEvalStep *op = &amp;state-&gt;steps[off];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; op-&gt;opcode = <a href="#L120" title="executor/execExprInterp.c:120">EEO_OPCODE</a>(op-&gt;opcode);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;flags |= EEO_FLAG_DIRECT_THREADED;<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L89" title="executor/execExprInterp.c:89">EEO_USE_COMPUTED_GOTO</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; state-&gt;evalfunc_private = (<span class="Type">void</span> *) <a href="#L396" title="executor/execExprInterp.c:396">ExecInterpExpr</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate expression identified by &quot;state&quot; in the execution context<br/></li>
<li></span><span class="Comment"> * given by &quot;econtext&quot;.&nbsp; *isnull is set to the is-null flag for the result,<br/></li>
<li></span><span class="Comment"> * and the Datum value is the function result.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As a special case, return the dispatch table's address if state is NULL.<br/></li>
<li></span><span class="Comment"> * This is used by <a href="#L2378" title="executor/execExprInterp.c:2378">ExecInitInterpreter</a> to set up the <a href="#L112" title="executor/execExprInterp.c:112">dispatch_table</a> global.<br/></li>
<li></span><span class="Comment"> * (Only applies when <a href="#L89" title="executor/execExprInterp.c:89">EEO_USE_COMPUTED_GOTO</a> is defined.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L396">&#x200c;</a><span class="linkable">ExecInterpExpr</span>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExprEvalStep *op;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *resultslot;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *innerslot;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *outerslot;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *scanslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This array has to be in the same order as enum ExprEvalOp.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#if defined(<a href="#L89" title="executor/execExprInterp.c:89">EEO_USE_COMPUTED_GOTO</a>)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">const</span> <span class="Type">void</span> *<span class="Type">const</span> <a href="#L112" title="executor/execExprInterp.c:112">dispatch_table</a>[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_DONE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_INNER_FETCHSOME,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_OUTER_FETCHSOME,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_SCAN_FETCHSOME,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_INNER_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_OUTER_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_SCAN_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_INNER_SYSVAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_OUTER_SYSVAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_SCAN_SYSVAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_WHOLEROW,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_ASSIGN_INNER_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_ASSIGN_OUTER_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_ASSIGN_SCAN_VAR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_ASSIGN_TMP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_ASSIGN_TMP_MAKE_RO,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_CONST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_FUNCEXPR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_FUNCEXPR_STRICT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_FUNCEXPR_FUSAGE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_FUNCEXPR_STRICT_FUSAGE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_BOOL_AND_STEP_FIRST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_BOOL_AND_STEP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_BOOL_AND_STEP_LAST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_BOOL_OR_STEP_FIRST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_BOOL_OR_STEP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_BOOL_OR_STEP_LAST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_BOOL_NOT_STEP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_QUAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_JUMP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_JUMP_IF_NULL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_JUMP_IF_NOT_NULL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_JUMP_IF_NOT_TRUE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_NULLTEST_ISNULL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_NULLTEST_ISNOTNULL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_NULLTEST_ROWISNULL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_NULLTEST_ROWISNOTNULL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_BOOLTEST_IS_TRUE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_BOOLTEST_IS_NOT_TRUE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_BOOLTEST_IS_FALSE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_BOOLTEST_IS_NOT_FALSE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_PARAM_EXEC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_PARAM_EXTERN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_PARAM_CALLBACK,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_CASE_TESTVAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_MAKE_READONLY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_IOCOERCE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_IOCOERCE_SAFE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_DISTINCT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_NOT_DISTINCT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_NULLIF,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_SQLVALUEFUNCTION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_CURRENTOFEXPR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_NEXTVALUEEXPR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_ARRAYEXPR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_ARRAYCOERCE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_ROW,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_ROWCOMPARE_STEP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_ROWCOMPARE_FINAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_MINMAX,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_FIELDSELECT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_FIELDSTORE_DEFORM,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_FIELDSTORE_FORM,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_SBSREF_SUBSCRIPTS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_SBSREF_OLD,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_SBSREF_ASSIGN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_SBSREF_FETCH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_DOMAIN_TESTVAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_DOMAIN_NOTNULL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_DOMAIN_CHECK,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_CONVERT_ROWTYPE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_SCALARARRAYOP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_HASHED_SCALARARRAYOP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_XMLEXPR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_JSON_CONSTRUCTOR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_IS_JSON,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_JSONEXPR_PATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_JSONEXPR_COERCION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_JSONEXPR_COERCION_FINISH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_AGGREF,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_GROUPING_FUNC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_WINDOW_FUNC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_MERGE_SUPPORT_FUNC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_SUBPLAN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_AGG_STRICT_DESERIALIZE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_AGG_DESERIALIZE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_AGG_STRICT_INPUT_CHECK_ARGS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_AGG_STRICT_INPUT_CHECK_NULLS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_AGG_PLAIN_PERGROUP_NULLCHECK,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_AGG_PLAIN_TRANS_INIT_STRICT_BYVAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_AGG_PLAIN_TRANS_STRICT_BYVAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_AGG_PLAIN_TRANS_BYVAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_AGG_PLAIN_TRANS_INIT_STRICT_BYREF,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_AGG_PLAIN_TRANS_STRICT_BYREF,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_AGG_PLAIN_TRANS_BYREF,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_AGG_PRESORTED_DISTINCT_SINGLE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_AGG_PRESORTED_DISTINCT_MULTI,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_AGG_ORDERED_TRANS_DATUM,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_AGG_ORDERED_TRANS_TUPLE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp;CASE_EEOP_LAST<br/></li>
<li>&nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; StaticAssertDecl(lengthof(<a href="#L112" title="executor/execExprInterp.c:112">dispatch_table</a>) == EEOP_LAST + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="#L112" title="executor/execExprInterp.c:112">dispatch_table</a> out of whack with ExprEvalOp&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(state == <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<a href="#L112" title="executor/execExprInterp.c:112">dispatch_table</a>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; Assert(state != <span class="Constant">NULL</span>);<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L89" title="executor/execExprInterp.c:89">EEO_USE_COMPUTED_GOTO</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* setup state */<br/></li>
<li></span>&nbsp; &nbsp; op = state-&gt;steps;<br/></li>
<li>&nbsp; &nbsp; resultslot = state-&gt;resultslot;<br/></li>
<li>&nbsp; &nbsp; innerslot = econtext-&gt;ecxt_innertuple;<br/></li>
<li>&nbsp; &nbsp; outerslot = econtext-&gt;ecxt_outertuple;<br/></li>
<li>&nbsp; &nbsp; scanslot = econtext-&gt;ecxt_scantuple;<br/></li>
<li><br/></li>
<li><span class="PreProc">#if defined(<a href="#L89" title="executor/execExprInterp.c:89">EEO_USE_COMPUTED_GOTO</a>)<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L119" title="executor/execExprInterp.c:119">EEO_DISPATCH</a>();<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L117" title="executor/execExprInterp.c:117">EEO_SWITCH</a>()<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_DONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_INNER_FETCHSOME)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2025" title="executor/execExprInterp.c:2025">CheckOpSlotCompatibility</a>(op, innerslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot_getsomeattrs(innerslot, op-&gt;d.fetch.last_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_OUTER_FETCHSOME)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2025" title="executor/execExprInterp.c:2025">CheckOpSlotCompatibility</a>(op, outerslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot_getsomeattrs(outerslot, op-&gt;d.fetch.last_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_SCAN_FETCHSOME)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2025" title="executor/execExprInterp.c:2025">CheckOpSlotCompatibility</a>(op, scanslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot_getsomeattrs(scanslot, op-&gt;d.fetch.last_var);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_INNER_VAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = op-&gt;d.var.attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since we already extracted all referenced columns from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple with a FETCHSOME step, we can just grab the value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * directly out of the slot's decomposed-data arrays.&nbsp; But let's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have an Assert to check that that did happen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(attnum &gt;= <span class="Constant">0</span> &amp;&amp; attnum &lt; innerslot-&gt;tts_nvalid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = innerslot-&gt;tts_values[attnum];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = innerslot-&gt;tts_isnull[attnum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_OUTER_VAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = op-&gt;d.var.attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See EEOP_INNER_VAR comments */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(attnum &gt;= <span class="Constant">0</span> &amp;&amp; attnum &lt; outerslot-&gt;tts_nvalid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = outerslot-&gt;tts_values[attnum];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = outerslot-&gt;tts_isnull[attnum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_SCAN_VAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = op-&gt;d.var.attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See EEOP_INNER_VAR comments */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(attnum &gt;= <span class="Constant">0</span> &amp;&amp; attnum &lt; scanslot-&gt;tts_nvalid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = scanslot-&gt;tts_values[attnum];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = scanslot-&gt;tts_isnull[attnum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_INNER_SYSVAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4887" title="executor/execExprInterp.c:4887">ExecEvalSysVar</a>(state, op, econtext, innerslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_OUTER_SYSVAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4887" title="executor/execExprInterp.c:4887">ExecEvalSysVar</a>(state, op, econtext, outerslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_SCAN_SYSVAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4887" title="executor/execExprInterp.c:4887">ExecEvalSysVar</a>(state, op, econtext, scanslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_WHOLEROW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too complex for an inline implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4660" title="executor/execExprInterp.c:4660">ExecEvalWholeRowVar</a>(state, op, econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_ASSIGN_INNER_VAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultnum = op-&gt;d.assign_var.resultnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = op-&gt;d.assign_var.attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We do not need <a href="#L1974" title="executor/execExprInterp.c:1974">CheckVarSlotCompatibility</a> here; that was taken<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * care of at compilation time.&nbsp; But see EEOP_INNER_VAR comments.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(attnum &gt;= <span class="Constant">0</span> &amp;&amp; attnum &lt; innerslot-&gt;tts_nvalid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(resultnum &gt;= <span class="Constant">0</span> &amp;&amp; resultnum &lt; resultslot-&gt;tts_tupleDescriptor-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultslot-&gt;tts_values[resultnum] = innerslot-&gt;tts_values[attnum];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultslot-&gt;tts_isnull[resultnum] = innerslot-&gt;tts_isnull[attnum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_ASSIGN_OUTER_VAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultnum = op-&gt;d.assign_var.resultnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = op-&gt;d.assign_var.attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We do not need <a href="#L1974" title="executor/execExprInterp.c:1974">CheckVarSlotCompatibility</a> here; that was taken<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * care of at compilation time.&nbsp; But see EEOP_INNER_VAR comments.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(attnum &gt;= <span class="Constant">0</span> &amp;&amp; attnum &lt; outerslot-&gt;tts_nvalid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(resultnum &gt;= <span class="Constant">0</span> &amp;&amp; resultnum &lt; resultslot-&gt;tts_tupleDescriptor-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultslot-&gt;tts_values[resultnum] = outerslot-&gt;tts_values[attnum];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultslot-&gt;tts_isnull[resultnum] = outerslot-&gt;tts_isnull[attnum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_ASSIGN_SCAN_VAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultnum = op-&gt;d.assign_var.resultnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = op-&gt;d.assign_var.attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We do not need <a href="#L1974" title="executor/execExprInterp.c:1974">CheckVarSlotCompatibility</a> here; that was taken<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * care of at compilation time.&nbsp; But see EEOP_INNER_VAR comments.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(attnum &gt;= <span class="Constant">0</span> &amp;&amp; attnum &lt; scanslot-&gt;tts_nvalid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(resultnum &gt;= <span class="Constant">0</span> &amp;&amp; resultnum &lt; resultslot-&gt;tts_tupleDescriptor-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultslot-&gt;tts_values[resultnum] = scanslot-&gt;tts_values[attnum];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultslot-&gt;tts_isnull[resultnum] = scanslot-&gt;tts_isnull[attnum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_ASSIGN_TMP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultnum = op-&gt;d.assign_tmp.resultnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(resultnum &gt;= <span class="Constant">0</span> &amp;&amp; resultnum &lt; resultslot-&gt;tts_tupleDescriptor-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultslot-&gt;tts_values[resultnum] = state-&gt;resvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultslot-&gt;tts_isnull[resultnum] = state-&gt;resnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_ASSIGN_TMP_MAKE_RO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultnum = op-&gt;d.assign_tmp.resultnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(resultnum &gt;= <span class="Constant">0</span> &amp;&amp; resultnum &lt; resultslot-&gt;tts_tupleDescriptor-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultslot-&gt;tts_isnull[resultnum] = state-&gt;resnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!resultslot-&gt;tts_isnull[resultnum])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultslot-&gt;tts_values[resultnum] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/expandeddatum.c.html#L95" title="utils/adt/expandeddatum.c:95">MakeExpandedObjectReadOnlyInternal</a>(state-&gt;resvalue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultslot-&gt;tts_values[resultnum] = state-&gt;resvalue;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_CONST)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = op-&gt;d.constval.isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = op-&gt;d.constval.value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Function-call implementations. Arguments have previously been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * evaluated directly into fcinfo-&gt;args.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As both STRICT checks and function-usage are noticeable performance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wise, and function calls are a very hot-path (they also back<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operators!), it's worth having so many separate opcodes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: the reason for using a temporary variable &quot;d&quot;, here and in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other places, is that some compilers think &quot;*op-&gt;resvalue = f();&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * requires them to evaluate op-&gt;resvalue into a register <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * calling f(), just in case f() is able to modify op-&gt;resvalue<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * somehow.&nbsp; The extra line of code can save a useless register spill<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and reload across the function call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_FUNCEXPR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FunctionCallInfo fcinfo = op-&gt;d.func.fcinfo_data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; d;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d = op-&gt;d.func.fn_addr(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = d;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = fcinfo-&gt;isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_FUNCEXPR_STRICT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FunctionCallInfo fcinfo = op-&gt;d.func.fcinfo_data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NullableDatum *args = fcinfo-&gt;args;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nargs = op-&gt;d.func.nargs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; d;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* strict function, so check for NULL args */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> argno = <span class="Constant">0</span>; argno &lt; nargs; argno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (args[argno].isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> strictfail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d = op-&gt;d.func.fn_addr(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = d;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = fcinfo-&gt;isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">strictfail</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_FUNCEXPR_FUSAGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not common enough to inline */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2440" title="executor/execExprInterp.c:2440">ExecEvalFuncExprFusage</a>(state, op, econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_FUNCEXPR_STRICT_FUSAGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not common enough to inline */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2461" title="executor/execExprInterp.c:2461">ExecEvalFuncExprStrictFusage</a>(state, op, econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of its clauses is FALSE, an AND's result is FALSE regardless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the states of the rest of the clauses, so we can stop evaluating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and return FALSE immediately.&nbsp; If <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> are FALSE and one or more is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NULL, we return NULL; otherwise we return TRUE.&nbsp; This makes sense<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when you interpret NULL as &quot;don't know&quot;: perhaps one of the &quot;don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * knows&quot; would have been FALSE if we'd known its value.&nbsp; Only when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all the inputs are known to be TRUE can we state confidently that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the AND's result is TRUE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_BOOL_AND_STEP_FIRST)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;d.boolexpr.anynull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * EEOP_BOOL_AND_STEP_FIRST resets anynull, otherwise it's the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same as EEOP_BOOL_AND_STEP - so fall through to that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THROUGH */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_BOOL_AND_STEP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;d.boolexpr.anynull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!DatumGetBool(*op-&gt;resvalue))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* result is already set to FALSE, need not change it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* bail out early */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="executor/execExprInterp.c:137">EEO_JUMP</a>(op-&gt;d.boolexpr.jumpdone);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_BOOL_AND_STEP_LAST)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* result is already set to NULL, need not change it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!DatumGetBool(*op-&gt;resvalue))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* result is already set to FALSE, need not change it */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No point jumping early to jumpdone - would be same target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (as this is the last argument to the AND expression),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * except more expensive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*op-&gt;d.boolexpr.anynull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* result is already set to TRUE, need not change it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of its clauses is TRUE, an OR's result is TRUE regardless of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the states of the rest of the clauses, so we can stop evaluating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and return TRUE immediately.&nbsp; If <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> are TRUE and one or more is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NULL, we return NULL; otherwise we return FALSE.&nbsp; This makes sense<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when you interpret NULL as &quot;don't know&quot;: perhaps one of the &quot;don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * knows&quot; would have been TRUE if we'd known its value.&nbsp; Only when all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the inputs are known to be FALSE can we state confidently that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OR's result is FALSE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_BOOL_OR_STEP_FIRST)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;d.boolexpr.anynull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * EEOP_BOOL_OR_STEP_FIRST resets anynull, otherwise it's the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as EEOP_BOOL_OR_STEP - so fall through to that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THROUGH */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_BOOL_OR_STEP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;d.boolexpr.anynull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (DatumGetBool(*op-&gt;resvalue))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* result is already set to TRUE, need not change it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* bail out early */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="executor/execExprInterp.c:137">EEO_JUMP</a>(op-&gt;d.boolexpr.jumpdone);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_BOOL_OR_STEP_LAST)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* result is already set to NULL, need not change it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (DatumGetBool(*op-&gt;resvalue))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* result is already set to TRUE, need not change it */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No point jumping to jumpdone - would be same target (as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this is the last argument to the AND expression), except<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more expensive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*op-&gt;d.boolexpr.anynull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* result is already set to FALSE, need not change it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_BOOL_NOT_STEP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Evaluation of 'not' is simple... if expr is false, then return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 'true' and vice versa.&nbsp; It's safe to do this even on a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nominally null value, so we ignore resnull; that means that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NULL in produces NULL out, which is what we want.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(!DatumGetBool(*op-&gt;resvalue));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_QUAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* simplified version of BOOL_AND_STEP for use by ExecQual() */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If argument (also result) is false or null ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !DatumGetBool(*op-&gt;resvalue))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... bail out early, returning FALSE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="executor/execExprInterp.c:137">EEO_JUMP</a>(op-&gt;d.qualexpr.jumpdone);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, leave the TRUE value in place, in case this is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * last qual.&nbsp; Then, TRUE is the correct answer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_JUMP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unconditionally jump to target step */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="executor/execExprInterp.c:137">EEO_JUMP</a>(op-&gt;d.jump.jumpdone);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_JUMP_IF_NULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Transfer control if current result is null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="executor/execExprInterp.c:137">EEO_JUMP</a>(op-&gt;d.jump.jumpdone);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_JUMP_IF_NOT_NULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Transfer control if current result is non-null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="executor/execExprInterp.c:137">EEO_JUMP</a>(op-&gt;d.jump.jumpdone);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_JUMP_IF_NOT_TRUE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Transfer control if current result is null or false */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull || !DatumGetBool(*op-&gt;resvalue))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="executor/execExprInterp.c:137">EEO_JUMP</a>(op-&gt;d.jump.jumpdone);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_NULLTEST_ISNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(*op-&gt;resnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_NULLTEST_ISNOTNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(!*op-&gt;resnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_NULLTEST_ROWISNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* out of line implementation: too large */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2731" title="executor/execExprInterp.c:2731">ExecEvalRowNull</a>(state, op, econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_NULLTEST_ROWISNOTNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* out of line implementation: too large */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2740" title="executor/execExprInterp.c:2740">ExecEvalRowNotNull</a>(state, op, econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* BooleanTest implementations for all booltesttypes */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_BOOLTEST_IS_TRUE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else, input value is the correct output as well */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_BOOLTEST_IS_NOT_TRUE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(!DatumGetBool(*op-&gt;resvalue));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_BOOLTEST_IS_FALSE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(!DatumGetBool(*op-&gt;resvalue));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_BOOLTEST_IS_NOT_FALSE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else, input value is the correct output as well */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_PARAM_EXEC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* out of line implementation: too large */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2498" title="executor/execExprInterp.c:2498">ExecEvalParamExec</a>(state, op, econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_PARAM_EXTERN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* out of line implementation: too large */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2520" title="executor/execExprInterp.c:2520">ExecEvalParamExtern</a>(state, op, econtext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_PARAM_CALLBACK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allow an extension module to supply a PARAM_EXTERN value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.cparam.paramfunc(state, op, econtext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_CASE_TESTVAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Normally <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> parts of the expression tree have setup the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to be returned here, but some parts of the system<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * currently misuse {caseValue,domainValue}<a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>{datum,isNull} to set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * run-time data.&nbsp; So if no <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> have been set-up, use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ExprContext's.&nbsp; This isn't pretty, but also not *that* ugly,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and this is unlikely to be performance sensitive enough to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * worry about an extra branch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op-&gt;d.casetest.value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = *op-&gt;d.casetest.value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = *op-&gt;d.casetest.isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = econtext-&gt;caseValue_datum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = econtext-&gt;caseValue_isNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_DOMAIN_TESTVAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * See EEOP_CASE_TESTVAL comment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op-&gt;d.casetest.value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = *op-&gt;d.casetest.value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = *op-&gt;d.casetest.isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = econtext-&gt;domainValue_datum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = econtext-&gt;domainValue_isNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_MAKE_READONLY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Force a varlena value that might be read multiple times to R/O<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!*op-&gt;d.make_readonly.isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/expandeddatum.c.html#L95" title="utils/adt/expandeddatum.c:95">MakeExpandedObjectReadOnlyInternal</a>(*op-&gt;d.make_readonly.value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = *op-&gt;d.make_readonly.isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_IOCOERCE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Evaluate a CoerceViaIO node.&nbsp; This can be quite a hot path, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inline as much work as possible.&nbsp; The source value is in our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result variable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also look at <a href="#L2567" title="executor/execExprInterp.c:2567">ExecEvalCoerceViaIOSafe</a>() if you change anything<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* call output function (similar to <a href="../utils/fmgr/fmgr.c.html#L1683" title="utils/fmgr/fmgr.c:1683">OutputFunctionCall</a>) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* output <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are not called on nulls */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FunctionCallInfo fcinfo_out;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo_out = op-&gt;d.iocoerce.fcinfo_data_out;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo_out-&gt;args[<span class="Constant">0</span>].value = *op-&gt;resvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo_out-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo_out-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = DatumGetCString(FunctionCallInvoke(fcinfo_out));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../utils/fmgr/fmgr.c.html#L1683" title="utils/fmgr/fmgr.c:1683">OutputFunctionCall</a> assumes result isn't null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!fcinfo_out-&gt;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* call input function (similar to <a href="../utils/fmgr/fmgr.c.html#L1530" title="utils/fmgr/fmgr.c:1530">InputFunctionCall</a>) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!op-&gt;d.iocoerce.finfo_in-&gt;fn_strict || str != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FunctionCallInfo fcinfo_in;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; d;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo_in = op-&gt;d.iocoerce.fcinfo_data_in;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo_in-&gt;args[<span class="Constant">0</span>].value = PointerGetDatum(str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo_in-&gt;args[<span class="Constant">0</span>].isnull = *op-&gt;resnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* second and third arguments are already set up */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo_in-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d = FunctionCallInvoke(fcinfo_in);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = d;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Should get null result if and only if str is NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (str == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(*op-&gt;resnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(fcinfo_in-&gt;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!*op-&gt;resnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!fcinfo_in-&gt;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_IOCOERCE_SAFE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2567" title="executor/execExprInterp.c:2567">ExecEvalCoerceViaIOSafe</a>(state, op);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_DISTINCT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * IS DISTINCT FROM must evaluate arguments (already done into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fcinfo-&gt;args) to determine whether they are NULL; if either is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NULL then the result is determined.&nbsp; If neither is NULL, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * proceed to evaluate the comparison function, which is just the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * type's standard equality operator.&nbsp; We need not care whether<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that function is strict.&nbsp; Because the handling of nulls is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * different, we can't just reuse EEOP_FUNCEXPR.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FunctionCallInfo fcinfo = op-&gt;d.func.fcinfo_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check function arguments for NULLness */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;args[<span class="Constant">0</span>].isnull &amp;&amp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Both NULL? Then is not distinct... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (fcinfo-&gt;args[<span class="Constant">0</span>].isnull || fcinfo-&gt;args[<span class="Constant">1</span>].isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Only one is NULL? Then is distinct... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Neither null, so apply the equality function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; eqresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqresult = op-&gt;d.func.fn_addr(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must invert result of &quot;=&quot;; safe to do even if null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(!DatumGetBool(eqresult));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = fcinfo-&gt;isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see EEOP_DISTINCT for comments, this is just inverted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_NOT_DISTINCT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FunctionCallInfo fcinfo = op-&gt;d.func.fcinfo_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;args[<span class="Constant">0</span>].isnull &amp;&amp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (fcinfo-&gt;args[<span class="Constant">0</span>].isnull || fcinfo-&gt;args[<span class="Constant">1</span>].isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; eqresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqresult = op-&gt;d.func.fn_addr(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = eqresult;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = fcinfo-&gt;isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_NULLIF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The arguments are already evaluated into fcinfo-&gt;args.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FunctionCallInfo fcinfo = op-&gt;d.func.fcinfo_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if either argument is NULL they can't be <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!fcinfo-&gt;args[<span class="Constant">0</span>].isnull &amp;&amp; !fcinfo-&gt;args[<span class="Constant">1</span>].isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = op-&gt;d.func.fn_addr(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if the arguments are <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> return null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!fcinfo-&gt;isnull &amp;&amp; DatumGetBool(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Arguments aren't <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, so return the first one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = fcinfo-&gt;args[<span class="Constant">0</span>].value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = fcinfo-&gt;args[<span class="Constant">0</span>].isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_SQLVALUEFUNCTION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Doesn't seem worthwhile to have an inline implementation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * efficiency-wise.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2627" title="executor/execExprInterp.c:2627">ExecEvalSQLValueFunction</a>(state, op);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_CURRENTOFEXPR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* error invocation uses space, and shouldn't ever occur */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2694" title="executor/execExprInterp.c:2694">ExecEvalCurrentOfExpr</a>(state, op);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_NEXTVALUEEXPR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Doesn't seem worthwhile to have an inline implementation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * efficiency-wise.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2705" title="executor/execExprInterp.c:2705">ExecEvalNextValueExpr</a>(state, op);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_ARRAYEXPR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too complex for an inline implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2833" title="executor/execExprInterp.c:2833">ExecEvalArrayExpr</a>(state, op);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_ARRAYCOERCE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too complex for an inline implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3047" title="executor/execExprInterp.c:3047">ExecEvalArrayCoerce</a>(state, op, econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_ROW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too complex for an inline implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3088" title="executor/execExprInterp.c:3088">ExecEvalRow</a>(state, op);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_ROWCOMPARE_STEP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FunctionCallInfo fcinfo = op-&gt;d.rowcompare_step.fcinfo_data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; d;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* force NULL result if strict fn and NULL input */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op-&gt;d.rowcompare_step.finfo-&gt;fn_strict &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (fcinfo-&gt;args[<span class="Constant">0</span>].isnull || fcinfo-&gt;args[<span class="Constant">1</span>].isnull))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="executor/execExprInterp.c:137">EEO_JUMP</a>(op-&gt;d.rowcompare_step.jumpnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Apply comparison function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d = op-&gt;d.rowcompare_step.fn_addr(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = d;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* force NULL result if NULL function result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="executor/execExprInterp.c:137">EEO_JUMP</a>(op-&gt;d.rowcompare_step.jumpnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If unequal, no need to <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> remaining columns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetInt32(*op-&gt;resvalue) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="executor/execExprInterp.c:137">EEO_JUMP</a>(op-&gt;d.rowcompare_step.jumpdone);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_ROWCOMPARE_FINAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; cmpresult = DatumGetInt32(*op-&gt;resvalue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RowCompareType rctype = op-&gt;d.rowcompare_final.rctype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (rctype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* EQ and NE cases aren't allowed here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ROWCOMPARE_LT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(cmpresult &lt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ROWCOMPARE_LE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(cmpresult &lt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ROWCOMPARE_GE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(cmpresult &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ROWCOMPARE_GT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(cmpresult &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_MINMAX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too complex for an inline implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3108" title="executor/execExprInterp.c:3108">ExecEvalMinMax</a>(state, op);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_FIELDSELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too complex for an inline implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3161" title="executor/execExprInterp.c:3161">ExecEvalFieldSelect</a>(state, op, econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_FIELDSTORE_DEFORM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too complex for an inline implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3286" title="executor/execExprInterp.c:3286">ExecEvalFieldStoreDeForm</a>(state, op, econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_FIELDSTORE_FORM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too complex for an inline implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3336" title="executor/execExprInterp.c:3336">ExecEvalFieldStoreForm</a>(state, op, econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_SBSREF_SUBSCRIPTS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Precheck SubscriptingRef subscript(s) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op-&gt;d.sbsref_subscript.subscriptfunc(state, op, econtext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Subscript is null, short-circuit SubscriptingRef to NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="executor/execExprInterp.c:137">EEO_JUMP</a>(op-&gt;d.sbsref_subscript.jumpdone);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_SBSREF_OLD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_SBSREF_ASSIGN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_SBSREF_FETCH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Perform a SubscriptingRef fetch or assignment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.sbsref.subscriptfunc(state, op, econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_CONVERT_ROWTYPE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too complex for an inline implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3360" title="executor/execExprInterp.c:3360">ExecEvalConvertRowtype</a>(state, op, econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_SCALARARRAYOP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too complex for an inline implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3455" title="executor/execExprInterp.c:3455">ExecEvalScalarArrayOp</a>(state, op);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_HASHED_SCALARARRAYOP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too complex for an inline implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3658" title="executor/execExprInterp.c:3658">ExecEvalHashedScalarArrayOp</a>(state, op, econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_DOMAIN_NOTNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too complex for an inline implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3840" title="executor/execExprInterp.c:3840">ExecEvalConstraintNotNull</a>(state, op);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_DOMAIN_CHECK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too complex for an inline implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3854" title="executor/execExprInterp.c:3854">ExecEvalConstraintCheck</a>(state, op);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_XMLEXPR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too complex for an inline implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3874" title="executor/execExprInterp.c:3874">ExecEvalXmlExpr</a>(state, op);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_JSON_CONSTRUCTOR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too complex for an inline implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4089" title="executor/execExprInterp.c:4089">ExecEvalJsonConstructor</a>(state, op, econtext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_IS_JSON)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too complex for an inline implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4167" title="executor/execExprInterp.c:4167">ExecEvalJsonIsPredicate</a>(state, op);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_JSONEXPR_PATH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too complex for an inline implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="executor/execExprInterp.c:137">EEO_JUMP</a>(<a href="#L4267" title="executor/execExprInterp.c:4267">ExecEvalJsonExprPath</a>(state, op, econtext));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_JSONEXPR_COERCION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too complex for an inline implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4538" title="executor/execExprInterp.c:4538">ExecEvalJsonCoercion</a>(state, op, econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_JSONEXPR_COERCION_FINISH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too complex for an inline implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4557" title="executor/execExprInterp.c:4557">ExecEvalJsonCoercionFinish</a>(state, op);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_AGGREF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Returns a Datum whose value is the precomputed aggregate value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * found in the given expression context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggno = op-&gt;d.aggref.aggno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(econtext-&gt;ecxt_aggvalues != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = econtext-&gt;ecxt_aggvalues[aggno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = econtext-&gt;ecxt_aggnulls[aggno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_GROUPING_FUNC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too complex/uncommon for an inline implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4579" title="executor/execExprInterp.c:4579">ExecEvalGroupingFunc</a>(state, op);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_WINDOW_FUNC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Like Aggref, just return a precomputed value from the econtext.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WindowFuncExprState *wfunc = op-&gt;d.window_func.wfstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(econtext-&gt;ecxt_aggvalues != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = econtext-&gt;ecxt_aggvalues[wfunc-&gt;wfuncno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = econtext-&gt;ecxt_aggnulls[wfunc-&gt;wfuncno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_MERGE_SUPPORT_FUNC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too complex/uncommon for an inline implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4606" title="executor/execExprInterp.c:4606">ExecEvalMergeSupportFunc</a>(state, op, econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_SUBPLAN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too complex for an inline implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4643" title="executor/execExprInterp.c:4643">ExecEvalSubPlan</a>(state, op, econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* evaluate a strict aggregate deserialization function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_AGG_STRICT_DESERIALIZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't call a strict deserialization function with NULL input */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op-&gt;d.agg_deserialize.fcinfo_data-&gt;args[<span class="Constant">0</span>].isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="executor/execExprInterp.c:137">EEO_JUMP</a>(op-&gt;d.agg_deserialize.jumpnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fallthrough */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* evaluate aggregate deserialization function (non-strict portion) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_AGG_DESERIALIZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FunctionCallInfo fcinfo = op-&gt;d.agg_deserialize.fcinfo_data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggState&nbsp;&nbsp; *aggstate = castNode(AggState, state-&gt;parent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We run the deserialization <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in per-input-tuple memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldContext = MemoryContextSwitchTo(aggstate-&gt;tmpcontext-&gt;ecxt_per_tuple_memory);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = FunctionCallInvoke(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = fcinfo-&gt;isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check that a strict aggregate transition / combination function's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * input is not NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_AGG_STRICT_INPUT_CHECK_ARGS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NullableDatum *args = op-&gt;d.agg_strict_input_check.args;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nargs = op-&gt;d.agg_strict_input_check.nargs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> argno = <span class="Constant">0</span>; argno &lt; nargs; argno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (args[argno].isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="executor/execExprInterp.c:137">EEO_JUMP</a>(op-&gt;d.agg_strict_input_check.jumpnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_AGG_STRICT_INPUT_CHECK_NULLS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls = op-&gt;d.agg_strict_input_check.nulls;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nargs = op-&gt;d.agg_strict_input_check.nargs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> argno = <span class="Constant">0</span>; argno &lt; nargs; argno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nulls[argno])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="executor/execExprInterp.c:137">EEO_JUMP</a>(op-&gt;d.agg_strict_input_check.jumpnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for a NULL pointer to the per-group states.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_AGG_PLAIN_PERGROUP_NULLCHECK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggState&nbsp;&nbsp; *aggstate = castNode(AggState, state-&gt;parent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerGroup pergroup_allaggs =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;all_pergroups[op-&gt;d.agg_plain_pergroup_nullcheck.setoff];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pergroup_allaggs == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="executor/execExprInterp.c:137">EEO_JUMP</a>(op-&gt;d.agg_plain_pergroup_nullcheck.jumpnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Different types of aggregate transition <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are implemented<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as different types of steps, to avoid incurring unnecessary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overhead.&nbsp; There's a step type for each valid combination of having<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a by value / by reference transition type, [not] needing to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the transition value for the first row in a group from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * input, and [not] strict transition function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Could <a href="../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> further by splitting off by-reference for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fixed-length types, but currently that doesn't seem worth it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_AGG_PLAIN_TRANS_INIT_STRICT_BYVAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggState&nbsp;&nbsp; *aggstate = castNode(AggState, state-&gt;parent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerTrans pertrans = op-&gt;d.agg_trans.pertrans;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerGroup pergroup =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;aggstate-&gt;all_pergroups[op-&gt;d.agg_trans.setoff][op-&gt;d.agg_trans.transno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(pertrans-&gt;transtypeByVal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pergroup-&gt;noTransValue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If transValue has not yet been initialized, do so <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4907" title="executor/execExprInterp.c:4907">ExecAggInitGroup</a>(aggstate, pertrans, pergroup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.agg_trans.aggcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copied trans value from input, done this round */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (likely(!pergroup-&gt;transValueIsNull))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* invoke transition function, unless prevented by strictness */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5127" title="executor/execExprInterp.c:5127">ExecAggPlainTransByVal</a>(aggstate, pertrans, pergroup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.agg_trans.aggcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.agg_trans.setno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see comments above EEOP_AGG_PLAIN_TRANS_INIT_STRICT_BYVAL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_AGG_PLAIN_TRANS_STRICT_BYVAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggState&nbsp;&nbsp; *aggstate = castNode(AggState, state-&gt;parent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerTrans pertrans = op-&gt;d.agg_trans.pertrans;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerGroup pergroup =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;aggstate-&gt;all_pergroups[op-&gt;d.agg_trans.setoff][op-&gt;d.agg_trans.transno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(pertrans-&gt;transtypeByVal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (likely(!pergroup-&gt;transValueIsNull))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5127" title="executor/execExprInterp.c:5127">ExecAggPlainTransByVal</a>(aggstate, pertrans, pergroup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.agg_trans.aggcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.agg_trans.setno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see comments above EEOP_AGG_PLAIN_TRANS_INIT_STRICT_BYVAL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_AGG_PLAIN_TRANS_BYVAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggState&nbsp;&nbsp; *aggstate = castNode(AggState, state-&gt;parent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerTrans pertrans = op-&gt;d.agg_trans.pertrans;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerGroup pergroup =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;aggstate-&gt;all_pergroups[op-&gt;d.agg_trans.setoff][op-&gt;d.agg_trans.transno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(pertrans-&gt;transtypeByVal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5127" title="executor/execExprInterp.c:5127">ExecAggPlainTransByVal</a>(aggstate, pertrans, pergroup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.agg_trans.aggcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.agg_trans.setno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see comments above EEOP_AGG_PLAIN_TRANS_INIT_STRICT_BYVAL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_AGG_PLAIN_TRANS_INIT_STRICT_BYREF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggState&nbsp;&nbsp; *aggstate = castNode(AggState, state-&gt;parent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerTrans pertrans = op-&gt;d.agg_trans.pertrans;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerGroup pergroup =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;aggstate-&gt;all_pergroups[op-&gt;d.agg_trans.setoff][op-&gt;d.agg_trans.transno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!pertrans-&gt;transtypeByVal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pergroup-&gt;noTransValue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4907" title="executor/execExprInterp.c:4907">ExecAggInitGroup</a>(aggstate, pertrans, pergroup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.agg_trans.aggcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (likely(!pergroup-&gt;transValueIsNull))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5159" title="executor/execExprInterp.c:5159">ExecAggPlainTransByRef</a>(aggstate, pertrans, pergroup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.agg_trans.aggcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.agg_trans.setno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see comments above EEOP_AGG_PLAIN_TRANS_INIT_STRICT_BYVAL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_AGG_PLAIN_TRANS_STRICT_BYREF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggState&nbsp;&nbsp; *aggstate = castNode(AggState, state-&gt;parent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerTrans pertrans = op-&gt;d.agg_trans.pertrans;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerGroup pergroup =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;aggstate-&gt;all_pergroups[op-&gt;d.agg_trans.setoff][op-&gt;d.agg_trans.transno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!pertrans-&gt;transtypeByVal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (likely(!pergroup-&gt;transValueIsNull))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5159" title="executor/execExprInterp.c:5159">ExecAggPlainTransByRef</a>(aggstate, pertrans, pergroup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.agg_trans.aggcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.agg_trans.setno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see comments above EEOP_AGG_PLAIN_TRANS_INIT_STRICT_BYVAL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_AGG_PLAIN_TRANS_BYREF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggState&nbsp;&nbsp; *aggstate = castNode(AggState, state-&gt;parent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerTrans pertrans = op-&gt;d.agg_trans.pertrans;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerGroup pergroup =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;aggstate-&gt;all_pergroups[op-&gt;d.agg_trans.setoff][op-&gt;d.agg_trans.transno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!pertrans-&gt;transtypeByVal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5159" title="executor/execExprInterp.c:5159">ExecAggPlainTransByRef</a>(aggstate, pertrans, pergroup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.agg_trans.aggcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.agg_trans.setno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_AGG_PRESORTED_DISTINCT_SINGLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerTrans pertrans = op-&gt;d.agg_presorted_distinctcheck.pertrans;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggState&nbsp;&nbsp; *aggstate = castNode(AggState, state-&gt;parent);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L5009" title="executor/execExprInterp.c:5009">ExecEvalPreOrderedDistinctSingle</a>(aggstate, pertrans))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="executor/execExprInterp.c:137">EEO_JUMP</a>(op-&gt;d.agg_presorted_distinctcheck.jumpdistinct);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_AGG_PRESORTED_DISTINCT_MULTI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggState&nbsp;&nbsp; *aggstate = castNode(AggState, state-&gt;parent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerTrans pertrans = op-&gt;d.agg_presorted_distinctcheck.pertrans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L5052" title="executor/execExprInterp.c:5052">ExecEvalPreOrderedDistinctMulti</a>(aggstate, pertrans))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="executor/execExprInterp.c:137">EEO_JUMP</a>(op-&gt;d.agg_presorted_distinctcheck.jumpdistinct);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* process single-column ordered aggregate datum */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_AGG_ORDERED_TRANS_DATUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too complex for an inline implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5099" title="executor/execExprInterp.c:5099">ExecEvalAggOrderedTransDatum</a>(state, op, econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* process multi-column ordered aggregate tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_AGG_ORDERED_TRANS_TUPLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too complex for an inline implementation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5113" title="executor/execExprInterp.c:5113">ExecEvalAggOrderedTransTuple</a>(state, op, econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="executor/execExprInterp.c:131">EEO_NEXT</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execExprInterp.c:118">EEO_CASE</a>(EEOP_LAST)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unreachable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="Statement">out</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; *isnull = state-&gt;resnull;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state-&gt;resvalue;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Expression evaluation callback that performs extra checks <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> executing<br/></li>
<li></span><span class="Comment"> * the expression. Declared extern so other methods of execution can use it<br/></li>
<li></span><span class="Comment"> * too.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1903">&#x200c;</a><span class="linkable">ExecInterpExprStillValid</span>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isNull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First time through, check whether attribute matches Var.&nbsp; Might not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ok anymore, due to schema changes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1923" title="executor/execExprInterp.c:1923">CheckExprStillValid</a>(state, econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the check during further executions */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;evalfunc = (ExprStateEvalFunc) state-&gt;evalfunc_private;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and actually execute */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> state-&gt;evalfunc(state, econtext, isNull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check that an expression is still valid in the face of potential schema<br/></li>
<li></span><span class="Comment"> * changes since the plan has been created.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1923">&#x200c;</a></span><span class="linkable">CheckExprStillValid</span>(ExprState *state, ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *innerslot;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *outerslot;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *scanslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; innerslot = econtext-&gt;ecxt_innertuple;<br/></li>
<li>&nbsp; &nbsp; outerslot = econtext-&gt;ecxt_outertuple;<br/></li>
<li>&nbsp; &nbsp; scanslot = econtext-&gt;ecxt_scantuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; state-&gt;steps_len; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExprEvalStep *op = &amp;state-&gt;steps[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L2410" title="executor/execExprInterp.c:2410">ExecEvalStepOp</a>(state, op))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> EEOP_INNER_VAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = op-&gt;d.var.attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1974" title="executor/execExprInterp.c:1974">CheckVarSlotCompatibility</a>(innerslot, attnum + <span class="Constant">1</span>, op-&gt;d.var.vartype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> EEOP_OUTER_VAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = op-&gt;d.var.attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1974" title="executor/execExprInterp.c:1974">CheckVarSlotCompatibility</a>(outerslot, attnum + <span class="Constant">1</span>, op-&gt;d.var.vartype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> EEOP_SCAN_VAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = op-&gt;d.var.attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1974" title="executor/execExprInterp.c:1974">CheckVarSlotCompatibility</a>(scanslot, attnum + <span class="Constant">1</span>, op-&gt;d.var.vartype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether a user attribute in a slot can be referenced by a Var<br/></li>
<li></span><span class="Comment"> * expression.&nbsp; This should succeed unless there have been schema changes<br/></li>
<li></span><span class="Comment"> * since the expression tree has been created.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1974">&#x200c;</a></span><span class="linkable">CheckVarSlotCompatibility</span>(TupleTableSlot *slot, <span class="Type">int</span> attnum, Oid vartype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * What we have to check for here is the possibility of an attribute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * having been dropped or changed in type since the plan tree was created.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ideally the plan will get invalidated and not re-used, but just in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case, we keep these defenses.&nbsp; Fortunately it's sufficient to check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * once on the first time through.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: ideally we'd check typmod as well as typid, but that seems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * impractical at the moment: in many cases the tupdesc will have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * generated by <a href="execTuples.c.html#L2025" title="executor/execTuples.c:2025">ExecTypeFromTL</a>(), and that can't guarantee to generate an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * accurate typmod in all cases, because some expression node types don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * carry typmod.&nbsp; Fortunately, for precisely that reason, there should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no places with a critical dependency on the typmod of a value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * System attributes don't require checking since their types never<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * change.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attnum &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; slot_tupdesc = slot-&gt;tts_tupleDescriptor;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attnum &gt; slot_tupdesc-&gt;natts)&nbsp; &nbsp; <span class="Comment">/* should never happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;attribute number </span><span class="Special">%d</span><span class="Constant"> exceeds number of columns </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attnum, slot_tupdesc-&gt;natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attr = TupleDescAttr(slot_tupdesc, attnum - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attr-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;attribute </span><span class="Special">%d</span><span class="Constant"> of type </span><span class="Special">%s</span><span class="Constant"> has been dropped&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum, <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(slot_tupdesc-&gt;tdtypeid))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vartype != attr-&gt;atttypid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;attribute </span><span class="Special">%d</span><span class="Constant"> of type </span><span class="Special">%s</span><span class="Constant"> has wrong type&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum, <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(slot_tupdesc-&gt;tdtypeid)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Table has type </span><span class="Special">%s</span><span class="Constant">, but query expects </span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(attr-&gt;atttypid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(vartype))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Verify that the slot is compatible with a EEOP_*_FETCHSOME operation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2025">&#x200c;</a></span><span class="linkable">CheckOpSlotCompatibility</span>(ExprEvalStep *op, TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* there's nothing to check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!op-&gt;d.fetch.fixed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Should probably fixed at some point, but for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> it's easier to allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer and heap tuples to be used interchangeably.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;tts_ops == &amp;<a href="execTuples.c.html#L87" title="executor/execTuples.c:87">TTSOpsBufferHeapTuple</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.fetch.kind == &amp;<a href="execTuples.c.html#L85" title="executor/execTuples.c:85">TTSOpsHeapTuple</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;tts_ops == &amp;<a href="execTuples.c.html#L85" title="executor/execTuples.c:85">TTSOpsHeapTuple</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.fetch.kind == &amp;<a href="execTuples.c.html#L87" title="executor/execTuples.c:87">TTSOpsBufferHeapTuple</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At the moment we consider it OK if a virtual slot is used instead of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * specific type of slot, as a virtual slot never needs to be deformed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;tts_ops == &amp;<a href="execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(op-&gt;d.fetch.kind == slot-&gt;tts_ops);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2072" title="executor/execExprInterp.c:2072">get_cached_rowtype</a>: utility function to lookup a rowtype tupdesc<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * type_id, typmod: identity of the rowtype<br/></li>
<li></span><span class="Comment"> * rowcache: space for caching identity info<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (rowcache-&gt;cacheptr must be initialized to NULL)<br/></li>
<li></span><span class="Comment"> * changed: if not NULL, *changed is set to true on <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> update<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned TupleDesc is not guaranteed pinned; caller must pin it<br/></li>
<li></span><span class="Comment"> * to use it across <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> operation that might incur cache invalidation,<br/></li>
<li></span><span class="Comment"> * including for example detoasting of input tuples.<br/></li>
<li></span><span class="Comment"> * (The TupleDesc is always refcounted, so just use <a href="../access/common/tupdesc.c.html#L388" title="access/common/tupdesc.c:388">IncrTupleDescRefCount</a>.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: because composite types can change contents, we must be prepared<br/></li>
<li></span><span class="Comment"> * to re-do this during <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> node execution; cannot call just once during<br/></li>
<li></span><span class="Comment"> * expression initialization.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TupleDesc<br/></li>
<li><a id="L2072">&#x200c;</a><span class="linkable">get_cached_rowtype</span>(Oid type_id, int32 typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExprEvalRowtypeCache *rowcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *changed)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type_id != RECORDOID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's a named composite type, so use the regular typcache.&nbsp; Do a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lookup first time through, or if the composite type changed.&nbsp; Note:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;tupdesc_id == 0&quot; may look redundant, but it protects against the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * admittedly-theoretical possibility that type_id was RECORDOID the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * last time through, so that the cacheptr isn't TypeCacheEntry *.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *typentry = (TypeCacheEntry *) rowcache-&gt;cacheptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(typentry == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rowcache-&gt;tupdesc_id == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typentry-&gt;tupDesc_identifier != rowcache-&gt;tupdesc_id))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="../utils/cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(type_id, TYPECACHE_TUPDESC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;tupDesc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;type </span><span class="Special">%s</span><span class="Constant"> is not composite&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(type_id))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowcache-&gt;cacheptr = (<span class="Type">void</span> *) typentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowcache-&gt;tupdesc_id = typentry-&gt;tupDesc_identifier;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (changed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *changed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> typentry-&gt;tupDesc;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A RECORD type, once registered, doesn't change for the life of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backend.&nbsp; So we don't need a typcache entry as such, which is good<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because there isn't one.&nbsp; It's possible that the caller is asking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about a different type than <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc = (TupleDesc) rowcache-&gt;cacheptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(tupDesc == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rowcache-&gt;tupdesc_id != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; type_id != tupDesc-&gt;tdtypeid ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typmod != tupDesc-&gt;tdtypmod))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupDesc = <a href="../utils/cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(type_id, typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Drop pin acquired by <a href="../utils/cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReleaseTupleDesc(tupDesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowcache-&gt;cacheptr = (<span class="Type">void</span> *) tupDesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowcache-&gt;tupdesc_id = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* not a valid value for non-RECORD */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (changed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *changed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> tupDesc;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fast-path <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, for very simple expressions<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* implementation of ExecJust(Inner|Outer|Scan)Var */<br/></li>
<li></span><span class="Type">static</span> pg_attribute_always_inline Datum<br/></li>
<li><a id="L2138">&#x200c;</a><span class="linkable">ExecJustVarImpl</span>(ExprState *state, TupleTableSlot *slot, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExprEvalStep *op = &amp;state-&gt;steps[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = op-&gt;d.var.attnum + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2025" title="executor/execExprInterp.c:2025">CheckOpSlotCompatibility</a>(&amp;state-&gt;steps[<span class="Constant">0</span>], slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we use slot_getattr(), we don't need to implement the FETCHSOME<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * step explicitly, and we also needn't Assert that the attnum is in <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * --- slot_getattr() will take care of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> problems.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> slot_getattr(slot, attnum, isnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Simple reference to inner Var */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L2155">&#x200c;</a><span class="linkable">ExecJustInnerVar</span>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2138" title="executor/execExprInterp.c:2138">ExecJustVarImpl</a>(state, econtext-&gt;ecxt_innertuple, isnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Simple reference to outer Var */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L2162">&#x200c;</a><span class="linkable">ExecJustOuterVar</span>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2138" title="executor/execExprInterp.c:2138">ExecJustVarImpl</a>(state, econtext-&gt;ecxt_outertuple, isnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Simple reference to scan Var */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L2169">&#x200c;</a><span class="linkable">ExecJustScanVar</span>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2138" title="executor/execExprInterp.c:2138">ExecJustVarImpl</a>(state, econtext-&gt;ecxt_scantuple, isnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* implementation of ExecJustAssign(Inner|Outer|Scan)Var */<br/></li>
<li></span><span class="Type">static</span> pg_attribute_always_inline Datum<br/></li>
<li><a id="L2176">&#x200c;</a><span class="linkable">ExecJustAssignVarImpl</span>(ExprState *state, TupleTableSlot *inslot, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExprEvalStep *op = &amp;state-&gt;steps[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = op-&gt;d.assign_var.attnum + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultnum = op-&gt;d.assign_var.resultnum;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *outslot = state-&gt;resultslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2025" title="executor/execExprInterp.c:2025">CheckOpSlotCompatibility</a>(&amp;state-&gt;steps[<span class="Constant">0</span>], inslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do not need <a href="#L1974" title="executor/execExprInterp.c:1974">CheckVarSlotCompatibility</a> here; that was taken care of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at compilation time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we use slot_getattr(), we don't need to implement the FETCHSOME<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * step explicitly, and we also needn't Assert that the attnum is in <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * --- slot_getattr() will take care of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> problems.&nbsp; Nonetheless, check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that resultnum is in <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(resultnum &gt;= <span class="Constant">0</span> &amp;&amp; resultnum &lt; outslot-&gt;tts_tupleDescriptor-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; outslot-&gt;tts_values[resultnum] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot_getattr(inslot, attnum, &amp;outslot-&gt;tts_isnull[resultnum]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Evaluate inner Var and assign to appropriate column of result tuple */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L2202">&#x200c;</a><span class="linkable">ExecJustAssignInnerVar</span>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2176" title="executor/execExprInterp.c:2176">ExecJustAssignVarImpl</a>(state, econtext-&gt;ecxt_innertuple, isnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Evaluate outer Var and assign to appropriate column of result tuple */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L2209">&#x200c;</a><span class="linkable">ExecJustAssignOuterVar</span>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2176" title="executor/execExprInterp.c:2176">ExecJustAssignVarImpl</a>(state, econtext-&gt;ecxt_outertuple, isnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Evaluate scan Var and assign to appropriate column of result tuple */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L2216">&#x200c;</a><span class="linkable">ExecJustAssignScanVar</span>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2176" title="executor/execExprInterp.c:2176">ExecJustAssignVarImpl</a>(state, econtext-&gt;ecxt_scantuple, isnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Evaluate CASE_TESTVAL and apply a strict function to it */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L2223">&#x200c;</a><span class="linkable">ExecJustApplyFuncToCase</span>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExprEvalStep *op = &amp;state-&gt;steps[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; FunctionCallInfo fcinfo;<br/></li>
<li>&nbsp; &nbsp; NullableDatum *args;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nargs;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; d;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> with some redesign of the CaseTestExpr mechanism, maybe we could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get rid of this data shuffling?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *op-&gt;resvalue = *op-&gt;d.casetest.value;<br/></li>
<li>&nbsp; &nbsp; *op-&gt;resnull = *op-&gt;d.casetest.isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; op++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nargs = op-&gt;d.func.nargs;<br/></li>
<li>&nbsp; &nbsp; fcinfo = op-&gt;d.func.fcinfo_data;<br/></li>
<li>&nbsp; &nbsp; args = fcinfo-&gt;args;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* strict function, so check for NULL args */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> argno = <span class="Constant">0</span>; argno &lt; nargs; argno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (args[argno].isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; d = op-&gt;d.func.fn_addr(fcinfo);<br/></li>
<li>&nbsp; &nbsp; *isnull = fcinfo-&gt;isnull;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> d;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Simple Const expression */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L2261">&#x200c;</a><span class="linkable">ExecJustConst</span>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExprEvalStep *op = &amp;state-&gt;steps[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *isnull = op-&gt;d.constval.isnull;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> op-&gt;d.constval.value;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* implementation of ExecJust(Inner|Outer|Scan)VarVirt */<br/></li>
<li></span><span class="Type">static</span> pg_attribute_always_inline Datum<br/></li>
<li><a id="L2271">&#x200c;</a><span class="linkable">ExecJustVarVirtImpl</span>(ExprState *state, TupleTableSlot *slot, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExprEvalStep *op = &amp;state-&gt;steps[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = op-&gt;d.var.attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As it is guaranteed that a virtual slot is used, there never is a need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to perform tuple deforming (nor would it be possible). Therefore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * execExpr.c has not emitted an EEOP_*_FETCHSOME step. Verify, as much as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible, that that determination was accurate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(TTS_IS_VIRTUAL(slot));<br/></li>
<li>&nbsp; &nbsp; Assert(TTS_FIXED(slot));<br/></li>
<li>&nbsp; &nbsp; Assert(attnum &gt;= <span class="Constant">0</span> &amp;&amp; attnum &lt; slot-&gt;tts_nvalid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *isnull = slot-&gt;tts_isnull[attnum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> slot-&gt;tts_values[attnum];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Like <a href="#L2155" title="executor/execExprInterp.c:2155">ExecJustInnerVar</a>, optimized for virtual slots */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L2293">&#x200c;</a><span class="linkable">ExecJustInnerVarVirt</span>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2271" title="executor/execExprInterp.c:2271">ExecJustVarVirtImpl</a>(state, econtext-&gt;ecxt_innertuple, isnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Like <a href="#L2162" title="executor/execExprInterp.c:2162">ExecJustOuterVar</a>, optimized for virtual slots */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L2300">&#x200c;</a><span class="linkable">ExecJustOuterVarVirt</span>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2271" title="executor/execExprInterp.c:2271">ExecJustVarVirtImpl</a>(state, econtext-&gt;ecxt_outertuple, isnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Like <a href="#L2169" title="executor/execExprInterp.c:2169">ExecJustScanVar</a>, optimized for virtual slots */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L2307">&#x200c;</a><span class="linkable">ExecJustScanVarVirt</span>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2271" title="executor/execExprInterp.c:2271">ExecJustVarVirtImpl</a>(state, econtext-&gt;ecxt_scantuple, isnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* implementation of ExecJustAssign(Inner|Outer|Scan)VarVirt */<br/></li>
<li></span><span class="Type">static</span> pg_attribute_always_inline Datum<br/></li>
<li><a id="L2314">&#x200c;</a><span class="linkable">ExecJustAssignVarVirtImpl</span>(ExprState *state, TupleTableSlot *inslot, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExprEvalStep *op = &amp;state-&gt;steps[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = op-&gt;d.assign_var.attnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultnum = op-&gt;d.assign_var.resultnum;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *outslot = state-&gt;resultslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* see <a href="#L2271" title="executor/execExprInterp.c:2271">ExecJustVarVirtImpl</a> for comments */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; Assert(TTS_IS_VIRTUAL(inslot));<br/></li>
<li>&nbsp; &nbsp; Assert(TTS_FIXED(inslot));<br/></li>
<li>&nbsp; &nbsp; Assert(attnum &gt;= <span class="Constant">0</span> &amp;&amp; attnum &lt; inslot-&gt;tts_nvalid);<br/></li>
<li>&nbsp; &nbsp; Assert(resultnum &gt;= <span class="Constant">0</span> &amp;&amp; resultnum &lt; outslot-&gt;tts_tupleDescriptor-&gt;natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; outslot-&gt;tts_values[resultnum] = inslot-&gt;tts_values[attnum];<br/></li>
<li>&nbsp; &nbsp; outslot-&gt;tts_isnull[resultnum] = inslot-&gt;tts_isnull[attnum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Like <a href="#L2202" title="executor/execExprInterp.c:2202">ExecJustAssignInnerVar</a>, optimized for virtual slots */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L2336">&#x200c;</a><span class="linkable">ExecJustAssignInnerVarVirt</span>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2314" title="executor/execExprInterp.c:2314">ExecJustAssignVarVirtImpl</a>(state, econtext-&gt;ecxt_innertuple, isnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Like <a href="#L2209" title="executor/execExprInterp.c:2209">ExecJustAssignOuterVar</a>, optimized for virtual slots */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L2343">&#x200c;</a><span class="linkable">ExecJustAssignOuterVarVirt</span>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2314" title="executor/execExprInterp.c:2314">ExecJustAssignVarVirtImpl</a>(state, econtext-&gt;ecxt_outertuple, isnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Like <a href="#L2216" title="executor/execExprInterp.c:2216">ExecJustAssignScanVar</a>, optimized for virtual slots */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L2350">&#x200c;</a><span class="linkable">ExecJustAssignScanVarVirt</span>(ExprState *state, ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2314" title="executor/execExprInterp.c:2314">ExecJustAssignVarVirtImpl</a>(state, econtext-&gt;ecxt_scantuple, isnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#if defined(<a href="#L89" title="executor/execExprInterp.c:89">EEO_USE_COMPUTED_GOTO</a>)<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Comparator used when building address-&gt;opcode lookup table for<br/></li>
<li></span><span class="Comment"> * <a href="#L2410" title="executor/execExprInterp.c:2410">ExecEvalStepOp</a>() in the threaded dispatch case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2361">&#x200c;</a></span><span class="linkable">dispatch_compare_ptr</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L105" title="executor/execExprInterp.c:105">ExprEvalOpLookup</a> *la = (<span class="Type">const</span> <a href="#L105" title="executor/execExprInterp.c:105">ExprEvalOpLookup</a> *) a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L105" title="executor/execExprInterp.c:105">ExprEvalOpLookup</a> *lb = (<span class="Type">const</span> <a href="#L105" title="executor/execExprInterp.c:105">ExprEvalOpLookup</a> *) b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (la-&gt;opcode &lt; lb-&gt;opcode)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (la-&gt;opcode &gt; lb-&gt;opcode)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Do one-time initialization of interpretation machinery.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2378">&#x200c;</a></span><span class="linkable">ExecInitInterpreter</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#if defined(<a href="#L89" title="executor/execExprInterp.c:89">EEO_USE_COMPUTED_GOTO</a>)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Set up externally-visible pointer to dispatch table */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L112" title="executor/execExprInterp.c:112">dispatch_table</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L112" title="executor/execExprInterp.c:112">dispatch_table</a> = (<span class="Type">const</span> <span class="Type">void</span> **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetPointer(<a href="#L396" title="executor/execExprInterp.c:396">ExecInterpExpr</a>(<span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* build reverse lookup table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; EEOP_LAST; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L115" title="executor/execExprInterp.c:115">reverse_dispatch_table</a>[i].opcode = <a href="#L112" title="executor/execExprInterp.c:112">dispatch_table</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L115" title="executor/execExprInterp.c:115">reverse_dispatch_table</a>[i].op = (ExprEvalOp) i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make it bsearch()able */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qsort(<a href="#L115" title="executor/execExprInterp.c:115">reverse_dispatch_table</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EEOP_LAST <span class="Comment">/* nmembers */</span> ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L105" title="executor/execExprInterp.c:105">ExprEvalOpLookup</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2361" title="executor/execExprInterp.c:2361">dispatch_compare_ptr</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Function to return the opcode of an expression step.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When direct-threading is in use, ExprState-&gt;opcode isn't easily<br/></li>
<li></span><span class="Comment"> * decipherable. This function returns the appropriate enum member.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ExprEvalOp<br/></li>
<li><a id="L2410">&#x200c;</a><span class="linkable">ExecEvalStepOp</span>(ExprState *state, ExprEvalStep *op)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#if defined(<a href="#L89" title="executor/execExprInterp.c:89">EEO_USE_COMPUTED_GOTO</a>)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;flags &amp; EEO_FLAG_DIRECT_THREADED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L105" title="executor/execExprInterp.c:105">ExprEvalOpLookup</a> key;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L105" title="executor/execExprInterp.c:105">ExprEvalOpLookup</a> *res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key.opcode = (<span class="Type">void</span> *) op-&gt;opcode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = bsearch(&amp;key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L115" title="executor/execExprInterp.c:115">reverse_dispatch_table</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EEOP_LAST <span class="Comment">/* nmembers */</span> ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L105" title="executor/execExprInterp.c:105">ExprEvalOpLookup</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2361" title="executor/execExprInterp.c:2361">dispatch_compare_ptr</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(res);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unknown ops shouldn't get looked up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res-&gt;op;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (ExprEvalOp) op-&gt;opcode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Out-of-line helper <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for complex instructions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate EEOP_FUNCEXPR_FUSAGE<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2440">&#x200c;</a></span><span class="linkable">ExecEvalFuncExprFusage</span>(ExprState *state, ExprEvalStep *op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FunctionCallInfo fcinfo = op-&gt;d.func.fcinfo_data;<br/></li>
<li>&nbsp; &nbsp; PgStat_FunctionCallUsage fcusage;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; d;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/activity/pgstat_function.c.html#L72" title="utils/activity/pgstat_function.c:72">pgstat_init_function_usage</a>(fcinfo, &amp;fcusage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; d = op-&gt;d.func.fn_addr(fcinfo);<br/></li>
<li>&nbsp; &nbsp; *op-&gt;resvalue = d;<br/></li>
<li>&nbsp; &nbsp; *op-&gt;resnull = fcinfo-&gt;isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/activity/pgstat_function.c.html#L146" title="utils/activity/pgstat_function.c:146">pgstat_end_function_usage</a>(&amp;fcusage, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate EEOP_FUNCEXPR_STRICT_FUSAGE<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2461">&#x200c;</a></span><span class="linkable">ExecEvalFuncExprStrictFusage</span>(ExprState *state, ExprEvalStep *op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; FunctionCallInfo fcinfo = op-&gt;d.func.fcinfo_data;<br/></li>
<li>&nbsp; &nbsp; PgStat_FunctionCallUsage fcusage;<br/></li>
<li>&nbsp; &nbsp; NullableDatum *args = fcinfo-&gt;args;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nargs = op-&gt;d.func.nargs;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; d;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* strict function, so check for NULL args */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> argno = <span class="Constant">0</span>; argno &lt; nargs; argno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (args[argno].isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/activity/pgstat_function.c.html#L72" title="utils/activity/pgstat_function.c:72">pgstat_init_function_usage</a>(fcinfo, &amp;fcusage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; d = op-&gt;d.func.fn_addr(fcinfo);<br/></li>
<li>&nbsp; &nbsp; *op-&gt;resvalue = d;<br/></li>
<li>&nbsp; &nbsp; *op-&gt;resnull = fcinfo-&gt;isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/activity/pgstat_function.c.html#L146" title="utils/activity/pgstat_function.c:146">pgstat_end_function_usage</a>(&amp;fcusage, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate a PARAM_EXEC parameter.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * PARAM_EXEC params (<a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> executor parameters) are stored in the<br/></li>
<li></span><span class="Comment"> * ecxt_param_exec_vals array, and can be accessed by array index.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2498">&#x200c;</a></span><span class="linkable">ExecEvalParamExec</span>(ExprState *state, ExprEvalStep *op, ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParamExecData *prm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; prm = &amp;(econtext-&gt;ecxt_param_exec_vals[op-&gt;d.param.paramid]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(prm-&gt;execPlan != <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Parameter not evaluated yet, so go do it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeSubplan.c.html#L1092" title="executor/nodeSubplan.c:1092">ExecSetParamPlan</a>(prm-&gt;execPlan, econtext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="nodeSubplan.c.html#L1092" title="executor/nodeSubplan.c:1092">ExecSetParamPlan</a> should have processed this param... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(prm-&gt;execPlan == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *op-&gt;resvalue = prm-&gt;value;<br/></li>
<li>&nbsp; &nbsp; *op-&gt;resnull = prm-&gt;isnull;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate a PARAM_EXTERN parameter.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * PARAM_EXTERN parameters must be sought in ecxt_param_list_info.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2520">&#x200c;</a></span><span class="linkable">ExecEvalParamExtern</span>(ExprState *state, ExprEvalStep *op, ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParamListInfo paramInfo = econtext-&gt;ecxt_param_list_info;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramId = op-&gt;d.param.paramid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (likely(paramInfo &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; paramId &gt; <span class="Constant">0</span> &amp;&amp; paramId &lt;= paramInfo-&gt;numParams))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ParamExternData *prm;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ParamExternData prmdata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* give hook a chance in case parameter is dynamic */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (paramInfo-&gt;paramFetch != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prm = paramInfo-&gt;paramFetch(paramInfo, paramId, <span class="Constant">false</span>, &amp;prmdata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prm = &amp;paramInfo-&gt;params[paramId - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (likely(OidIsValid(prm-&gt;ptype)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* safety check in case hook did something unexpected */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(prm-&gt;ptype != op-&gt;d.param.paramtype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;type of parameter </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">) does not match that when preparing the plan (</span><span class="Special">%s</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(prm-&gt;ptype),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(op-&gt;d.param.paramtype))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = prm-&gt;value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = prm-&gt;isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no value found for parameter </span><span class="Special">%d</span><span class="Constant">&quot;</span>, paramId)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate a CoerceViaIO node in soft-error mode.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The source value is in op's result variable.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: This implements EEOP_IOCOERCE_SAFE. If you change anything here,<br/></li>
<li></span><span class="Comment"> * also look at the inline code for EEOP_IOCOERCE.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2567">&#x200c;</a></span><span class="linkable">ExecEvalCoerceViaIOSafe</span>(ExprState *state, ExprEvalStep *op)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* call output function (similar to <a href="../utils/fmgr/fmgr.c.html#L1683" title="utils/fmgr/fmgr.c:1683">OutputFunctionCall</a>) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* output <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are not called on nulls */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; str = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FunctionCallInfo fcinfo_out;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo_out = op-&gt;d.iocoerce.fcinfo_data_out;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo_out-&gt;args[<span class="Constant">0</span>].value = *op-&gt;resvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo_out-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo_out-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; str = DatumGetCString(FunctionCallInvoke(fcinfo_out));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../utils/fmgr/fmgr.c.html#L1683" title="utils/fmgr/fmgr.c:1683">OutputFunctionCall</a> assumes result isn't null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!fcinfo_out-&gt;isnull);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* call input function (similar to <a href="../utils/fmgr/fmgr.c.html#L1585" title="utils/fmgr/fmgr.c:1585">InputFunctionCallSafe</a>) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!op-&gt;d.iocoerce.finfo_in-&gt;fn_strict || str != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FunctionCallInfo fcinfo_in;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo_in = op-&gt;d.iocoerce.fcinfo_data_in;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo_in-&gt;args[<span class="Constant">0</span>].value = PointerGetDatum(str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo_in-&gt;args[<span class="Constant">0</span>].isnull = *op-&gt;resnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* second and third arguments are already set up */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ErrorSaveContext must be present. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(IsA(fcinfo_in-&gt;context, ErrorSaveContext));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo_in-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = FunctionCallInvoke(fcinfo_in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (SOFT_ERROR_OCCURRED(fcinfo_in-&gt;context))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Should get null result if and only if str is NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (str == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(*op-&gt;resnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!*op-&gt;resnull);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate a SQLValueFunction expression.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2627">&#x200c;</a></span><span class="linkable">ExecEvalSQLValueFunction</span>(ExprState *state, ExprEvalStep *op)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; SQLValueFunction *svf = op-&gt;d.sqlvaluefunction.svf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: <a href="../utils/adt/name.c.html#L279" title="utils/adt/name.c:279">current_schema</a>() can return NULL.&nbsp; <a href="../utils/adt/name.c.html#L263" title="utils/adt/name.c:263">current_user</a>() etc currently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cannot, but might as well code those cases the same way for safety.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (svf-&gt;op)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SVFOP_CURRENT_DATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = DateADTGetDatum(<a href="../utils/adt/date.c.html#L309" title="utils/adt/date.c:309">GetSQLCurrentDate</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SVFOP_CURRENT_TIME:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SVFOP_CURRENT_TIME_N:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = TimeTzADTPGetDatum(<a href="../utils/adt/date.c.html#L342" title="utils/adt/date.c:342">GetSQLCurrentTime</a>(svf-&gt;typmod));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SVFOP_CURRENT_TIMESTAMP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SVFOP_CURRENT_TIMESTAMP_N:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = TimestampTzGetDatum(<a href="../utils/adt/timestamp.c.html#L1672" title="utils/adt/timestamp.c:1672">GetSQLCurrentTimestamp</a>(svf-&gt;typmod));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SVFOP_LOCALTIME:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SVFOP_LOCALTIME_N:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = TimeADTGetDatum(<a href="../utils/adt/date.c.html#L362" title="utils/adt/date.c:362">GetSQLLocalTime</a>(svf-&gt;typmod));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SVFOP_LOCALTIMESTAMP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SVFOP_LOCALTIMESTAMP_N:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = TimestampGetDatum(<a href="../utils/adt/timestamp.c.html#L1686" title="utils/adt/timestamp.c:1686">GetSQLLocalTimestamp</a>(svf-&gt;typmod));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SVFOP_CURRENT_ROLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SVFOP_CURRENT_USER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SVFOP_USER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, <span class="Constant">NULL</span>, <span class="Constant">0</span>, InvalidOid, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = <a href="../utils/adt/name.c.html#L263" title="utils/adt/name.c:263">current_user</a>(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = fcinfo-&gt;isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SVFOP_SESSION_USER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, <span class="Constant">NULL</span>, <span class="Constant">0</span>, InvalidOid, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = <a href="../utils/adt/name.c.html#L269" title="utils/adt/name.c:269">session_user</a>(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = fcinfo-&gt;isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SVFOP_CURRENT_CATALOG:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, <span class="Constant">NULL</span>, <span class="Constant">0</span>, InvalidOid, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = <a href="../utils/adt/misc.c.html#L195" title="utils/adt/misc.c:195">current_database</a>(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = fcinfo-&gt;isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SVFOP_CURRENT_SCHEMA:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, <span class="Constant">NULL</span>, <span class="Constant">0</span>, InvalidOid, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = <a href="../utils/adt/name.c.html#L279" title="utils/adt/name.c:279">current_schema</a>(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = fcinfo-&gt;isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Raise error if a CURRENT OF expression is evaluated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> should convert CURRENT OF into a TidScan qualification, or some<br/></li>
<li></span><span class="Comment"> * other special handling in a ForeignScan node.&nbsp; So we have to be able to do<br/></li>
<li></span><span class="Comment"> * <a href="execExpr.c.html#L134" title="executor/execExpr.c:134">ExecInitExpr</a> on a CurrentOfExpr, but we shouldn't ever actually execute it.<br/></li>
<li></span><span class="Comment"> * If we get here, we suppose we must be dealing with CURRENT OF on a foreign<br/></li>
<li></span><span class="Comment"> * table whose FDW doesn't handle it, and complain accordingly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2694">&#x200c;</a></span><span class="linkable">ExecEvalCurrentOfExpr</span>(ExprState *state, ExprEvalStep *op)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;WHERE CURRENT OF is not supported for this table type&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate NextValueExpr.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2705">&#x200c;</a></span><span class="linkable">ExecEvalNextValueExpr</span>(ExprState *state, ExprEvalStep *op)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = <a href="../commands/sequence.c.html#L616" title="commands/sequence.c:616">nextval_internal</a>(op-&gt;d.nextvalueexpr.seqid, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (op-&gt;d.nextvalueexpr.seqtypid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT2OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = Int16GetDatum((int16) <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT4OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = Int32GetDatum((int32) <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT8OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = <a href="../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>((int64) <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unsupported sequence type </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.nextvalueexpr.seqtypid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate NullTest / IS NULL for rows.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2731">&#x200c;</a></span><span class="linkable">ExecEvalRowNull</span>(ExprState *state, ExprEvalStep *op, ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L2747" title="executor/execExprInterp.c:2747">ExecEvalRowNullInt</a>(state, op, econtext, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate NullTest / IS NOT NULL for rows.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2740">&#x200c;</a></span><span class="linkable">ExecEvalRowNotNull</span>(ExprState *state, ExprEvalStep *op, ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L2747" title="executor/execExprInterp.c:2747">ExecEvalRowNullInt</a>(state, op, econtext, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Common code for IS [NOT] NULL on a row value */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2747">&#x200c;</a></span><span class="linkable">ExecEvalRowNullInt</span>(ExprState *state, ExprEvalStep *op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExprContext *econtext, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> checkisnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; value = *op-&gt;resvalue;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull = *op-&gt;resnull;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader tuple;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupType;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; tupTypmod;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tmptup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NULL row variables are treated just as NULL scalar columns */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(checkisnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The SQL standard defines IS [NOT] NULL for a non-null rowtype argument<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;R IS NULL&quot; is true if every field is the null value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;R IS NOT NULL&quot; is true if no field is the null value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This definition is (apparently intentionally) not recursive; so our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tests on the fields are primitive attisnull tests, not recursive checks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to see if they are all-nulls or no-nulls rowtypes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The standard does not consider the possibility of zero-field rows, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here we consider them to vacuously satisfy both predicates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; tuple = DatumGetHeapTupleHeader(value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tupType = HeapTupleHeaderGetTypeId(tuple);<br/></li>
<li>&nbsp; &nbsp; tupTypmod = HeapTupleHeaderGetTypMod(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Lookup tupdesc if first time through or if type changes */<br/></li>
<li></span>&nbsp; &nbsp; tupDesc = <a href="#L2072" title="executor/execExprInterp.c:2072">get_cached_rowtype</a>(tupType, tupTypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;op-&gt;d.nulltest_row.rowcache, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../access/common/heaptuple.c.html#L455" title="access/common/heaptuple.c:455">heap_attisnull</a> needs a HeapTuple not a bare HeapTupleHeader.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tmptup.t_len = HeapTupleHeaderGetDatumLength(tuple);<br/></li>
<li>&nbsp; &nbsp; tmptup.t_data = tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> att = <span class="Constant">1</span>; att &lt;= tupDesc-&gt;natts; att++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore dropped columns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TupleDescAttr(tupDesc, att - <span class="Constant">1</span>)-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/common/heaptuple.c.html#L455" title="access/common/heaptuple.c:455">heap_attisnull</a>(&amp;tmptup, att, tupDesc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* null field disproves IS NOT NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!checkisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* non-null field disproves IS NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (checkisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(<span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate an ARRAY[] expression.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The individual array elements (or subarrays) have already been evaluated<br/></li>
<li></span><span class="Comment"> * into op-&gt;d.arrayexpr.elemvalues[]/elemnulls[].<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2833">&#x200c;</a></span><span class="linkable">ExecEvalArrayExpr</span>(ExprState *state, ExprEvalStep *op)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; element_type = op-&gt;d.arrayexpr.elemtype;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelems = op-&gt;d.arrayexpr.nelems;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndims = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dims[MAXDIM];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lbs[MAXDIM];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set non-null as default */<br/></li>
<li></span>&nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!op-&gt;d.arrayexpr.multidims)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Elements are presumably of scalar type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *dvalues = op-&gt;d.arrayexpr.elemvalues;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *dnulls = op-&gt;d.arrayexpr.elemnulls;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* setup for 1-D array of the given length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ndims = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dims[<span class="Constant">0</span>] = nelems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lbs[<span class="Constant">0</span>] = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../utils/adt/arrayfuncs.c.html#L3475" title="utils/adt/arrayfuncs.c:3475">construct_md_array</a>(dvalues, dnulls, ndims, dims, lbs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; element_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.arrayexpr.elemlength,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.arrayexpr.elembyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.arrayexpr.elemalign);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must be nested array expressions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_nelems = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elem_ndims = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *elem_dims = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *elem_lbs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; firstone = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; havenulls = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; haveempty = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; **subdata;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp; **subbitmaps;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *subbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *subnitems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; dataoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *dat;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subdata = (<span class="Type">char</span> **) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nelems * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span> *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subbitmaps = (bits8 **) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nelems * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(bits8 *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subbytes = (<span class="Type">int</span> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nelems * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subnitems = (<span class="Type">int</span> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nelems * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* loop through and get data area from each <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> elemoff = <span class="Constant">0</span>; elemoff &lt; nelems; elemoff++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arraydatum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; eisnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *array;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_ndims;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arraydatum = op-&gt;d.arrayexpr.elemvalues[elemoff];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eisnull = op-&gt;d.arrayexpr.elemnulls[elemoff];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* temporarily ignore null subarrays */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (eisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; haveempty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; array = DatumGetArrayTypeP(arraydatum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* run-time double-check on <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (element_type != ARR_ELEMTYPE(array))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> incompatible arrays&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Array with <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type </span><span class="Special">%s</span><span class="Constant"> cannot be &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;included in ARRAY construct with <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type </span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(ARR_ELEMTYPE(array)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(element_type))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_ndims = ARR_NDIM(array);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* temporarily ignore zero-dimensional subarrays */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (this_ndims &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; haveempty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (firstone)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get sub-array details from first member */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elem_ndims = this_ndims;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndims = elem_ndims + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndims &lt;= <span class="Constant">0</span> || ndims &gt; MAXDIM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;number of array dimensions (</span><span class="Special">%d</span><span class="Constant">) exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndims, MAXDIM)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elem_dims = (<span class="Type">int</span> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(elem_ndims * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(elem_dims, ARR_DIMS(array), elem_ndims * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elem_lbs = (<span class="Type">int</span> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(elem_ndims * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(elem_lbs, ARR_LBOUND(array), elem_ndims * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstone = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check other sub-arrays are compatible */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (elem_ndims != this_ndims ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcmp(elem_dims, ARR_DIMS(array),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elem_ndims * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>)) != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcmp(elem_lbs, ARR_LBOUND(array),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elem_ndims * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>)) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;multidimensional arrays must have array &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;expressions with matching dimensions&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subdata[outer_nelems] = ARR_DATA_PTR(array);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subbitmaps[outer_nelems] = ARR_NULLBITMAP(array);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subbytes[outer_nelems] = ARR_SIZE(array) - ARR_DATA_OFFSET(array);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes += subbytes[outer_nelems];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for overflow of total request */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!AllocSizeIsValid(nbytes))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array size exceeds the maximum allowed (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) MaxAllocSize)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subnitems[outer_nelems] = <a href="../utils/adt/arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(this_ndims,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ARR_DIMS(array));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; havenulls |= ARR_HASNULL(array);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_nelems++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If all items were null or empty arrays, return an empty array;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise, if some were and some weren't, raise error.&nbsp; (Note: we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must special-case this somehow to avoid trying to generate a 1-D<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * array formed from empty arrays.&nbsp; It's not ideal...)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (haveempty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndims == <span class="Constant">0</span>)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* didn't <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> nonempty array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = PointerGetDatum(<a href="../utils/adt/arrayfuncs.c.html#L3561" title="utils/adt/arrayfuncs.c:3561">construct_empty_array</a>(element_type));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;multidimensional arrays must have array &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;expressions with matching dimensions&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* setup for multi-D array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dims[<span class="Constant">0</span>] = outer_nelems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lbs[<span class="Constant">0</span>] = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">1</span>; i &lt; ndims; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dims[i] = elem_dims[i - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lbs[i] = elem_lbs[i - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for subscript overflow */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nitems = <a href="../utils/adt/arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ndims, dims);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/arrayutils.c.html#L117" title="utils/adt/arrayutils.c:117">ArrayCheckBounds</a>(ndims, dims, lbs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (havenulls)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nitems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes += dataoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dataoffset = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* marker for no null bitmap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes += ARR_OVERHEAD_NONULLS(ndims);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (ArrayType *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(nbytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(result, nbytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;ndim = ndims;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;dataoffset = dataoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;elemtype = element_type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ARR_DIMS(result), dims, ndims * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ARR_LBOUND(result), lbs, ndims * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dat = ARR_DATA_PTR(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iitem = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; outer_nelems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(dat, subdata[i], subbytes[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dat += subbytes[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (havenulls)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/arrayfuncs.c.html#L4947" title="utils/adt/arrayfuncs.c:4947">array_bitmap_copy</a>(ARR_NULLBITMAP(result), iitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subbitmaps[i], <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subnitems[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iitem += subnitems[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *op-&gt;resvalue = PointerGetDatum(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate an ArrayCoerceExpr expression.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Source array is in step's result variable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3047">&#x200c;</a></span><span class="linkable">ExecEvalArrayCoerce</span>(ExprState *state, ExprEvalStep *op, ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arraydatum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NULL array -&gt; NULL result */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; arraydatum = *op-&gt;resvalue;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's binary-compatible, modify the <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type in the array header,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but otherwise leave the array as we received it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (op-&gt;d.arraycoerce.elemexprstate == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Detoast input array if necessary, and copy in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *array = DatumGetArrayTypePCopy(arraydatum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ARR_ELEMTYPE(array) = op-&gt;d.arraycoerce.resultelemtype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = PointerGetDatum(array);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use <a href="../utils/adt/arrayfuncs.c.html#L3194" title="utils/adt/arrayfuncs.c:3194">array_map</a> to apply the sub-expression to each array <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *op-&gt;resvalue = <a href="../utils/adt/arrayfuncs.c.html#L3194" title="utils/adt/arrayfuncs.c:3194">array_map</a>(arraydatum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.arraycoerce.elemexprstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.arraycoerce.resultelemtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.arraycoerce.amstate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate a ROW() expression.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The individual columns have already been evaluated into<br/></li>
<li></span><span class="Comment"> * op-&gt;d.row.elemvalues[]/elemnulls[].<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3088">&#x200c;</a></span><span class="linkable">ExecEvalRow</span>(ExprState *state, ExprEvalStep *op)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build tuple from evaluated field <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; tuple = <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(op-&gt;d.row.tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.row.elemvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.row.elemnulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *op-&gt;resvalue = HeapTupleGetDatum(tuple);<br/></li>
<li>&nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate GREATEST() or LEAST() expression (note this is *not* MIN()/MAX()).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All of the to-be-compared expressions have already been evaluated into<br/></li>
<li></span><span class="Comment"> * op-&gt;d.minmax.<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[]/nulls[].<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3108">&#x200c;</a></span><span class="linkable">ExecEvalMinMax</span>(ExprState *state, ExprEvalStep *op)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = op-&gt;d.minmax.<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls = op-&gt;d.minmax.nulls;<br/></li>
<li>&nbsp; &nbsp; FunctionCallInfo fcinfo = op-&gt;d.minmax.fcinfo_data;<br/></li>
<li>&nbsp; &nbsp; MinMaxOp&nbsp; &nbsp; operator = op-&gt;d.minmax.op;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set at initialization */<br/></li>
<li></span>&nbsp; &nbsp; Assert(fcinfo-&gt;args[<span class="Constant">0</span>].isnull == <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(fcinfo-&gt;args[<span class="Constant">1</span>].isnull == <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* default to null result */<br/></li>
<li></span>&nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> off = <span class="Constant">0</span>; off &lt; op-&gt;d.minmax.nelems; off++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore NULL inputs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nulls[off])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first nonnull input, adopt value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[off];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmpresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* apply comparison function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = *op-&gt;resvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[off];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmpresult = DatumGetInt32(FunctionCallInvoke(fcinfo));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull) <span class="Comment">/* probably should not happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cmpresult &gt; <span class="Constant">0</span> &amp;&amp; operator == IS_LEAST)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[off];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (cmpresult &lt; <span class="Constant">0</span> &amp;&amp; operator == IS_GREATEST)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[off];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate a FieldSelect node.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Source record is in step's result variable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3161">&#x200c;</a></span><span class="linkable">ExecEvalFieldSelect</span>(ExprState *state, ExprEvalStep *op, ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; fieldnum = op-&gt;d.fieldselect.fieldnum;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; tupDatum;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader tuple;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupType;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; tupTypmod;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute attr;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tmptup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NULL record -&gt; NULL result */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tupDatum = *op-&gt;resvalue;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can special-case expanded <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> for speed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(tupDatum)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExpandedRecordHeader *erh = (ExpandedRecordHeader *) <a href="../utils/adt/expandeddatum.c.html#L29" title="utils/adt/expandeddatum.c:29">DatumGetEOHP</a>(tupDatum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(erh-&gt;er_magic == ER_MAGIC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Extract record's TupleDesc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tupDesc = expanded_record_get_tupdesc(erh);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find field's attr record.&nbsp; Note we don't support system columns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here: a datum tuple doesn't have valid <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for most of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interesting system columns anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fieldnum &lt;= <span class="Constant">0</span>)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should never happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unsupported reference to system column </span><span class="Special">%d</span><span class="Constant"> in FieldSelect&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fieldnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fieldnum &gt; tupDesc-&gt;natts)&nbsp; &nbsp; <span class="Comment">/* should never happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;attribute number </span><span class="Special">%d</span><span class="Constant"> exceeds number of columns </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fieldnum, tupDesc-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attr = TupleDescAttr(tupDesc, fieldnum - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for dropped column, and force a NULL result if so */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attr-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for type mismatch --- possible after ALTER COLUMN TYPE? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* As in <a href="#L1974" title="executor/execExprInterp.c:1974">CheckVarSlotCompatibility</a>, we should but can't check typmod */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op-&gt;d.fieldselect.resulttype != attr-&gt;atttypid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;attribute </span><span class="Special">%d</span><span class="Constant"> has wrong type&quot;</span>, fieldnum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Table has type </span><span class="Special">%s</span><span class="Constant">, but query expects </span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(attr-&gt;atttypid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(op-&gt;d.fieldselect.resulttype))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* extract the field */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = expanded_record_get_field(erh, fieldnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;resnull);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the composite datum and extract its type fields */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuple = DatumGetHeapTupleHeader(tupDatum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupType = HeapTupleHeaderGetTypeId(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupTypmod = HeapTupleHeaderGetTypMod(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Lookup tupdesc if first time through or if type changes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tupDesc = <a href="#L2072" title="executor/execExprInterp.c:2072">get_cached_rowtype</a>(tupType, tupTypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;op-&gt;d.fieldselect.rowcache, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find field's attr record.&nbsp; Note we don't support system columns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here: a datum tuple doesn't have valid <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for most of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interesting system columns anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fieldnum &lt;= <span class="Constant">0</span>)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should never happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unsupported reference to system column </span><span class="Special">%d</span><span class="Constant"> in FieldSelect&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fieldnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fieldnum &gt; tupDesc-&gt;natts)&nbsp; &nbsp; <span class="Comment">/* should never happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;attribute number </span><span class="Special">%d</span><span class="Constant"> exceeds number of columns </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fieldnum, tupDesc-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attr = TupleDescAttr(tupDesc, fieldnum - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for dropped column, and force a NULL result if so */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attr-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for type mismatch --- possible after ALTER COLUMN TYPE? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* As in <a href="#L1974" title="executor/execExprInterp.c:1974">CheckVarSlotCompatibility</a>, we should but can't check typmod */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op-&gt;d.fieldselect.resulttype != attr-&gt;atttypid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;attribute </span><span class="Special">%d</span><span class="Constant"> has wrong type&quot;</span>, fieldnum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Table has type </span><span class="Special">%s</span><span class="Constant">, but query expects </span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(attr-&gt;atttypid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(op-&gt;d.fieldselect.resulttype))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* heap_getattr needs a HeapTuple not a bare HeapTupleHeader */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tmptup.t_len = HeapTupleHeaderGetDatumLength(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmptup.t_data = tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* extract the field */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = heap_getattr(&amp;tmptup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fieldnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;resnull);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Deform source tuple, filling in the step's <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>/nulls arrays, <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * evaluating individual new <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> as part of a FieldStore expression.<br/></li>
<li></span><span class="Comment"> * Subsequent steps will overwrite individual elements of the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>/nulls<br/></li>
<li></span><span class="Comment"> * arrays with the new field <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, and then FIELDSTORE_FORM will build the<br/></li>
<li></span><span class="Comment"> * new tuple value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Source record is in step's result variable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3286">&#x200c;</a></span><span class="linkable">ExecEvalFieldStoreDeForm</span>(ExprState *state, ExprEvalStep *op, ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Convert null input tuple into an all-nulls row */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memset(op-&gt;d.fieldstore.nulls, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.fieldstore.ncolumns * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../access/common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a> needs a HeapTuple not a bare HeapTupleHeader. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set all the fields in the struct just in case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; tupDatum = *op-&gt;resvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeader tuphdr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleData tmptup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuphdr = DatumGetHeapTupleHeader(tupDatum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmptup.t_len = HeapTupleHeaderGetDatumLength(tuphdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSetInvalid(&amp;(tmptup.t_self));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmptup.t_tableOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmptup.t_data = tuphdr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Lookup tupdesc if first time through or if type changes.&nbsp; Because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we don't pin the tupdesc, we must not do this lookup until after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doing DatumGetHeapTupleHeader: that could do database access while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * detoasting the datum.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tupDesc = <a href="#L2072" title="executor/execExprInterp.c:2072">get_cached_rowtype</a>(op-&gt;d.fieldstore.fstore-&gt;resulttype, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.fieldstore.rowcache, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check that current tupdesc doesn't have more fields than allocated */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(tupDesc-&gt;natts &gt; op-&gt;d.fieldstore.ncolumns))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;too many columns in composite type </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.fieldstore.fstore-&gt;resulttype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(&amp;tmptup, tupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.fieldstore.<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.fieldstore.nulls);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the new composite datum after each individual field value of a<br/></li>
<li></span><span class="Comment"> * FieldStore expression has been evaluated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3336">&#x200c;</a></span><span class="linkable">ExecEvalFieldStoreForm</span>(ExprState *state, ExprEvalStep *op, ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Lookup tupdesc (should be valid already) */<br/></li>
<li></span>&nbsp; &nbsp; tupDesc = <a href="#L2072" title="executor/execExprInterp.c:2072">get_cached_rowtype</a>(op-&gt;d.fieldstore.fstore-&gt;resulttype, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.fieldstore.rowcache, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(tupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.fieldstore.<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.fieldstore.nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *op-&gt;resvalue = HeapTupleGetDatum(tuple);<br/></li>
<li>&nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate a rowtype coercion operation.<br/></li>
<li></span><span class="Comment"> * This may require rearranging field positions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Source record is in step's result variable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3360">&#x200c;</a></span><span class="linkable">ExecEvalConvertRowtype</span>(ExprState *state, ExprEvalStep *op, ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; tupDatum;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader tuple;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tmptup;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; indesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outdesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; changed = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NULL in -&gt; NULL out */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tupDatum = *op-&gt;resvalue;<br/></li>
<li>&nbsp; &nbsp; tuple = DatumGetHeapTupleHeader(tupDatum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lookup tupdescs if first time through or if type changes.&nbsp; We'd better<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pin them since type conversion <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> could do catalog lookups and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hence cause cache invalidation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indesc = <a href="#L2072" title="executor/execExprInterp.c:2072">get_cached_rowtype</a>(op-&gt;d.convert_rowtype.inputtype, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.convert_rowtype.incache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;changed);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L388" title="access/common/tupdesc.c:388">IncrTupleDescRefCount</a>(indesc);<br/></li>
<li>&nbsp; &nbsp; outdesc = <a href="#L2072" title="executor/execExprInterp.c:2072">get_cached_rowtype</a>(op-&gt;d.convert_rowtype.outputtype, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.convert_rowtype.outcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;changed);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L388" title="access/common/tupdesc.c:388">IncrTupleDescRefCount</a>(outdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We used to be able to assert that incoming tuples are marked with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exactly the rowtype of indesc.&nbsp; However, <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that <a href="#L4660" title="executor/execExprInterp.c:4660">ExecEvalWholeRowVar</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might change the tuples' marking to plain RECORD due to inserting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aliases, we can only make this weak test:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(HeapTupleHeaderGetTypeId(tuple) == indesc-&gt;tdtypeid ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTupleHeaderGetTypeId(tuple) == RECORDOID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if first time through, or after change, <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> conversion map */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (changed)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext old_cxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocate map in long-lived memory context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; old_cxt = MemoryContextSwitchTo(econtext-&gt;ecxt_per_query_memory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* prepare map from old to new attribute numbers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.convert_rowtype.map = <a href="../access/common/tupconvert.c.html#L102" title="access/common/tupconvert.c:102">convert_tuples_by_name</a>(indesc, outdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(old_cxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Following steps need a HeapTuple not a bare HeapTupleHeader */<br/></li>
<li></span>&nbsp; &nbsp; tmptup.t_len = HeapTupleHeaderGetDatumLength(tuple);<br/></li>
<li>&nbsp; &nbsp; tmptup.t_data = tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (op-&gt;d.convert_rowtype.map != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Full conversion with attribute rearrangement needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../access/common/tupconvert.c.html#L154" title="access/common/tupconvert.c:154">execute_attr_map_tuple</a>(&amp;tmptup, op-&gt;d.convert_rowtype.map);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Result already has appropriate composite-datum header fields */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = HeapTupleGetDatum(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The tuple is physically compatible as-is, but we need to insert the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * destination rowtype OID in its composite-datum header field, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have to copy it anyway.&nbsp; <a href="../access/common/heaptuple.c.html#L1080" title="access/common/heaptuple.c:1080">heap_copy_tuple_as_datum</a>() is convenient<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for this since it will both make the physical copy and insert the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * correct composite header fields.&nbsp; Note that we aren't expecting to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have to flatten <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> toasted fields: the input was a composite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * datum, so it shouldn't contain <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.&nbsp; So <a href="../access/common/heaptuple.c.html#L1080" title="access/common/heaptuple.c:1080">heap_copy_tuple_as_datum</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is overkill here, but its check for external fields is cheap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = <a href="../access/common/heaptuple.c.html#L1080" title="access/common/heaptuple.c:1080">heap_copy_tuple_as_datum</a>(&amp;tmptup, outdesc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L406" title="access/common/tupdesc.c:406">DecrTupleDescRefCount</a>(indesc);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L406" title="access/common/tupdesc.c:406">DecrTupleDescRefCount</a>(outdesc);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate &quot;scalar op ANY/ALL (array)&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Source array is in our result area, scalar arg is already evaluated into<br/></li>
<li></span><span class="Comment"> * fcinfo-&gt;args[0].<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The operator always yields boolean, and we <a href="../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> the results across all<br/></li>
<li></span><span class="Comment"> * array elements using OR and AND (for ANY and ALL respectively).&nbsp; Of course<br/></li>
<li></span><span class="Comment"> * we short-circuit as soon as the result is known.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3455">&#x200c;</a></span><span class="linkable">ExecEvalScalarArrayOp</span>(ExprState *state, ExprEvalStep *op)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FunctionCallInfo fcinfo = op-&gt;d.scalararrayop.fcinfo_data;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; useOr = op-&gt;d.scalararrayop.useOr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; strictfunc = op-&gt;d.scalararrayop.finfo-&gt;fn_strict;<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *arr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; resultnull;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typalign;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *bitmap;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the array is NULL then we return NULL --- it's not very meaningful<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to do anything else, even if the operator isn't strict.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else okay to fetch and detoast the array */<br/></li>
<li></span>&nbsp; &nbsp; arr = DatumGetArrayTypeP(*op-&gt;resvalue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the array is empty, we return either FALSE or TRUE per the useOr<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * flag.&nbsp; This is correct even if the scalar is NULL; since we would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * evaluate the operator zero times, it matters not whether it would want<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to return NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nitems = <a href="../utils/adt/arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ARR_NDIM(arr), ARR_DIMS(arr));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nitems &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(!useOr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the scalar is NULL, and the function is strict, return NULL; no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * point in iterating the loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;args[<span class="Constant">0</span>].isnull &amp;&amp; strictfunc)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We arrange to look up info about the <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type only once per series<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of calls, assuming the <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type doesn't change underneath us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (op-&gt;d.scalararrayop.element_type != ARR_ELEMTYPE(arr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L2271" title="utils/cache/lsyscache.c:2271">get_typlenbyvalalign</a>(ARR_ELEMTYPE(arr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;op-&gt;d.scalararrayop.typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;op-&gt;d.scalararrayop.typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;op-&gt;d.scalararrayop.typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.scalararrayop.element_type = ARR_ELEMTYPE(arr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typlen = op-&gt;d.scalararrayop.typlen;<br/></li>
<li>&nbsp; &nbsp; typbyval = op-&gt;d.scalararrayop.typbyval;<br/></li>
<li>&nbsp; &nbsp; typalign = op-&gt;d.scalararrayop.typalign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize result appropriately depending on useOr */<br/></li>
<li></span>&nbsp; &nbsp; result = BoolGetDatum(!useOr);<br/></li>
<li>&nbsp; &nbsp; resultnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop over the array elements */<br/></li>
<li></span>&nbsp; &nbsp; s = (<span class="Type">char</span> *) ARR_DATA_PTR(arr);<br/></li>
<li>&nbsp; &nbsp; bitmap = ARR_NULLBITMAP(arr);<br/></li>
<li>&nbsp; &nbsp; bitmask = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; elt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; thisresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get array <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, checking for NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bitmap &amp;&amp; (*bitmap &amp; bitmask) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elt = fetch_att(s, typbyval, typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = att_addlength_pointer(s, typlen, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = (<span class="Type">char</span> *) att_align_nominal(s, typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = elt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Call comparison function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;args[<span class="Constant">1</span>].isnull &amp;&amp; strictfunc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisresult = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisresult = op-&gt;d.scalararrayop.fn_addr(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Combine results per OR or AND semantics */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (useOr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(thisresult))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = BoolGetDatum(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* needn't look at <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more elements */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!DatumGetBool(thisresult))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = BoolGetDatum(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* needn't look at <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more elements */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* advance bitmap pointer if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bitmap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask &lt;&lt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bitmask == <span class="Constant">0x100</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmap++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *op-&gt;resvalue = result;<br/></li>
<li>&nbsp; &nbsp; *op-&gt;resnull = resultnull;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Hash function for scalar array <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> op elements.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use the <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type's default <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> opclass, and the column collation<br/></li>
<li></span><span class="Comment"> * if the type is collation-sensitive.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint32<br/></li>
<li><a id="L3608">&#x200c;</a><span class="linkable">saop_element_hash</span>(<span class="Type">struct</span> saophash_hash *tb, Datum key)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L211" title="executor/execExprInterp.c:211">ScalarArrayOpExprHashTable</a> *elements_tab = (<a href="#L211" title="executor/execExprInterp.c:211">ScalarArrayOpExprHashTable</a> *) tb-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; FunctionCallInfo fcinfo = &amp;elements_tab-&gt;hash_fcinfo_data;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = key;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = elements_tab-&gt;hash_finfo.fn_addr(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetUInt32(<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Matching function for scalar array <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> op elements, to be used in hashtable<br/></li>
<li></span><span class="Comment"> * lookups.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3627">&#x200c;</a></span><span class="linkable">saop_hash_element_match</span>(<span class="Type">struct</span> saophash_hash *tb, Datum key1, Datum key2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L211" title="executor/execExprInterp.c:211">ScalarArrayOpExprHashTable</a> *elements_tab = (<a href="#L211" title="executor/execExprInterp.c:211">ScalarArrayOpExprHashTable</a> *) tb-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; FunctionCallInfo fcinfo = elements_tab-&gt;op-&gt;d.hashedscalararrayop.fcinfo_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = key1;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = key2;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = elements_tab-&gt;op-&gt;d.hashedscalararrayop.finfo-&gt;fn_addr(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetBool(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate &quot;scalar op ANY (const array)&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Similar to <a href="#L3455" title="executor/execExprInterp.c:3455">ExecEvalScalarArrayOp</a>, but optimized for faster <a href="../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> lookups<br/></li>
<li></span><span class="Comment"> * by building a hashtable on the first lookup.&nbsp; This hashtable will be reused<br/></li>
<li></span><span class="Comment"> * by subsequent lookups.&nbsp; Unlike <a href="#L3455" title="executor/execExprInterp.c:3455">ExecEvalScalarArrayOp</a>, this version only<br/></li>
<li></span><span class="Comment"> * supports OR semantics.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Source array is in our result area, scalar arg is already evaluated into<br/></li>
<li></span><span class="Comment"> * fcinfo-&gt;args[0].<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The operator always yields boolean.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3658">&#x200c;</a></span><span class="linkable">ExecEvalHashedScalarArrayOp</span>(ExprState *state, ExprEvalStep *op, ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L211" title="executor/execExprInterp.c:211">ScalarArrayOpExprHashTable</a> *elements_tab = op-&gt;d.hashedscalararrayop.elements_tab;<br/></li>
<li>&nbsp; &nbsp; FunctionCallInfo fcinfo = op-&gt;d.hashedscalararrayop.fcinfo_data;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; inclause = op-&gt;d.hashedscalararrayop.inclause;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; strictfunc = op-&gt;d.hashedscalararrayop.finfo-&gt;fn_strict;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; scalar = fcinfo-&gt;args[<span class="Constant">0</span>].value;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; scalar_isnull = fcinfo-&gt;args[<span class="Constant">0</span>].isnull;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; resultnull;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hashfound;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We don't setup a hashed scalar array op if the array const is null. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!*op-&gt;resnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the scalar is NULL, and the function is strict, return NULL; no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * point in executing the search.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;args[<span class="Constant">0</span>].isnull &amp;&amp; strictfunc)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table on first evaluation */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (elements_tab == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScalarArrayOpExpr *saop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typalign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_nulls = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *bitmap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *arr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; saop = op-&gt;d.hashedscalararrayop.saop;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arr = DatumGetArrayTypeP(*op-&gt;resvalue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nitems = <a href="../utils/adt/arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ARR_NDIM(arr), ARR_DIMS(arr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L2271" title="utils/cache/lsyscache.c:2271">get_typlenbyvalalign</a>(ARR_ELEMTYPE(arr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;typalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(econtext-&gt;ecxt_per_query_memory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elements_tab = (<a href="#L211" title="executor/execExprInterp.c:211">ScalarArrayOpExprHashTable</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(offsetof(<a href="#L211" title="executor/execExprInterp.c:211">ScalarArrayOpExprHashTable</a>, hash_fcinfo_data) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SizeForFunctionCallInfo(<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.hashedscalararrayop.elements_tab = elements_tab;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elements_tab-&gt;op = op;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(saop-&gt;hashfuncid, &amp;elements_tab-&gt;hash_finfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fmgr_info_set_expr((Node *) saop, &amp;elements_tab-&gt;hash_finfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; InitFunctionCallInfoData(elements_tab-&gt;hash_fcinfo_data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;elements_tab-&gt;hash_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; saop-&gt;inputcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table sizing it according to the number of elements<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the array.&nbsp; This does assume that the array has no duplicates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the array happens to contain many duplicate <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> then it'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just mean that we sized the table a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> on the large side.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elements_tab-&gt;hashtab = saophash_create(<a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>, nitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elements_tab);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s = (<span class="Type">char</span> *) ARR_DATA_PTR(arr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitmap = ARR_NULLBITMAP(arr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitmask = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get array <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, checking for NULL. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bitmap &amp;&amp; (*bitmap &amp; bitmask) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has_nulls = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> = fetch_att(s, typbyval, typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = att_addlength_pointer(s, typlen, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = (<span class="Type">char</span> *) att_align_nominal(s, typalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saophash_insert(elements_tab-&gt;hashtab, <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, &amp;hashfound);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance bitmap pointer if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bitmap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask &lt;&lt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bitmask == <span class="Constant">0x100</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmap++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember if we had <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> nulls so that we know if we need to execute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-strict <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> with a null lhs value if no match is found.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.hashedscalararrayop.has_nulls = has_nulls;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> to see if we have a match. */<br/></li>
<li></span>&nbsp; &nbsp; hashfound = <span class="Constant">NULL</span> != saophash_lookup(elements_tab-&gt;hashtab, scalar);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the result depends on if the clause is an IN or NOT IN clause */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (inclause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = BoolGetDatum(hashfound);&nbsp; &nbsp; <span class="Comment">/* IN */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = BoolGetDatum(!hashfound);&nbsp; &nbsp; <span class="Comment">/* NOT IN */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; resultnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we didn't <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a match in the array, we still might need to handle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the possibility of null <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; We didn't put <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> NULLs into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hashtable, but instead marked if we found <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> when building the table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in has_nulls.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!hashfound &amp;&amp; op-&gt;d.hashedscalararrayop.has_nulls)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strictfunc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have nulls in the array so a non-null lhs and no match must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * yield NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Execute function will null rhs just once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> lookup path will have scribbled on the lhs argument so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we need to set it up also (even though we entered this function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with it already set).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = scalar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = scalar_isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = op-&gt;d.hashedscalararrayop.finfo-&gt;fn_addr(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultnull = fcinfo-&gt;isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reverse the result for NOT IN clauses since the above function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is the equality function and we need not-equals.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!inclause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = !result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *op-&gt;resvalue = result;<br/></li>
<li>&nbsp; &nbsp; *op-&gt;resnull = resultnull;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate a NOT NULL domain constraint.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3840">&#x200c;</a></span><span class="linkable">ExecEvalConstraintNotNull</span>(ExprState *state, ExprEvalStep *op)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errsave((Node *) op-&gt;d.domaincheck.escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NOT_NULL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;domain </span><span class="Special">%s</span><span class="Constant"> does not allow null <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(op-&gt;d.domaincheck.resulttype)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/domains.c.html#L407" title="utils/adt/domains.c:407">errdatatype</a>(op-&gt;d.domaincheck.resulttype)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate a CHECK domain constraint.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3854">&#x200c;</a></span><span class="linkable">ExecEvalConstraintCheck</span>(ExprState *state, ExprEvalStep *op)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!*op-&gt;d.domaincheck.checknull &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !DatumGetBool(*op-&gt;d.domaincheck.checkvalue))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errsave((Node *) op-&gt;d.domaincheck.escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CHECK_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;value for domain </span><span class="Special">%s</span><span class="Constant"> violates check constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(op-&gt;d.domaincheck.resulttype),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.domaincheck.constraintname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/domains.c.html#L431" title="utils/adt/domains.c:431">errdomainconstraint</a>(op-&gt;d.domaincheck.resulttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.domaincheck.constraintname)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate the various forms of XmlExpr.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Arguments have been evaluated into named_argvalue/named_argnull<br/></li>
<li></span><span class="Comment"> * and/or argvalue/argnull arrays.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3874">&#x200c;</a></span><span class="linkable">ExecEvalXmlExpr</span>(ExprState *state, ExprEvalStep *op)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XmlExpr&nbsp; &nbsp; *xexpr = op-&gt;d.xmlexpr.xexpr;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* until we get a result */<br/></li>
<li></span>&nbsp; &nbsp; *op-&gt;resvalue = (Datum) <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (xexpr-&gt;op)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_XMLCONCAT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *argvalue = op-&gt;d.xmlexpr.argvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *argnull = op-&gt;d.xmlexpr.argnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; list_length(xexpr-&gt;args); i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!argnull[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, DatumGetPointer(argvalue[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = PointerGetDatum(<a href="../utils/adt/xml.c.html#L553" title="utils/adt/xml.c:553">xmlconcat</a>(<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_XMLFOREST:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *argvalue = op-&gt;d.xmlexpr.named_argvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *argnull = op-&gt;d.xmlexpr.named_argnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forboth(lc, xexpr-&gt;named_args, lc2, xexpr-&gt;arg_names)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *e = (Expr *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *argname = strVal(lfirst(lc2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!argnull[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = argvalue[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;&lt;</span><span class="Special">%s</span><span class="Constant">&gt;</span><span class="Special">%s</span><span class="Constant">&lt;/</span><span class="Special">%s</span><span class="Constant">&gt;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; argname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/xml.c.html#L2413" title="utils/adt/xml.c:2413">map_sql_value_to_xml_value</a>(value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) e), <span class="Constant">true</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; argname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../utils/adt/varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(buf.data, buf.len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = PointerGetDatum(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf.data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_XMLELEMENT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = PointerGetDatum(<a href="../utils/adt/xml.c.html#L836" title="utils/adt/xml.c:836">xmlelement</a>(xexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.xmlexpr.named_argvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.xmlexpr.named_argnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.xmlexpr.argvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.xmlexpr.argnull));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_XMLPARSE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *argvalue = op-&gt;d.xmlexpr.argvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *argnull = op-&gt;d.xmlexpr.argnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; preserve_whitespace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* arguments are known to be text, <a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(xexpr-&gt;args) == <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (argnull[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = argvalue[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data = DatumGetTextPP(value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (argnull[<span class="Constant">1</span>]) <span class="Comment">/* probably can't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = argvalue[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; preserve_whitespace = DatumGetBool(value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = PointerGetDatum(<a href="../utils/adt/xml.c.html#L960" title="utils/adt/xml.c:960">xmlparse</a>(data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xexpr-&gt;<a href="../utils/adt/xml.c.html#L110" title="utils/adt/xml.c:110">xmloption</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; preserve_whitespace));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_XMLPI:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* optional argument is known to be text */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(xexpr-&gt;args) &lt;= <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xexpr-&gt;args)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull = op-&gt;d.xmlexpr.argnull[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg = DatumGetTextPP(op-&gt;d.xmlexpr.argvalue[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = PointerGetDatum(<a href="../utils/adt/xml.c.html#L978" title="utils/adt/xml.c:978">xmlpi</a>(xexpr-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;resnull));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_XMLROOT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *argvalue = op-&gt;d.xmlexpr.argvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *argnull = op-&gt;d.xmlexpr.argnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmltype&nbsp; &nbsp; *data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *version;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; standalone;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* arguments are known to be xml, text, int */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(xexpr-&gt;args) == <span class="Constant">3</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (argnull[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data = DatumGetXmlP(argvalue[<span class="Constant">0</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (argnull[<span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; version = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; version = DatumGetTextPP(argvalue[<span class="Constant">1</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!argnull[<span class="Constant">2</span>]);&nbsp; &nbsp; <span class="Comment">/* always present */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; standalone = DatumGetInt32(argvalue[<span class="Constant">2</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = PointerGetDatum(<a href="../utils/adt/xml.c.html#L1030" title="utils/adt/xml.c:1030">xmlroot</a>(data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; version,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; standalone));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_XMLSERIALIZE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *argvalue = op-&gt;d.xmlexpr.argvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *argnull = op-&gt;d.xmlexpr.argnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* argument type is known to be xml */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(xexpr-&gt;args) == <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (argnull[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = argvalue[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(<a href="../utils/adt/xml.c.html#L656" title="utils/adt/xml.c:656">xmltotext_with_options</a>(DatumGetXmlP(value),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xexpr-&gt;<a href="../utils/adt/xml.c.html#L110" title="utils/adt/xml.c:110">xmloption</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xexpr-&gt;indent));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IS_DOCUMENT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *argvalue = op-&gt;d.xmlexpr.argvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *argnull = op-&gt;d.xmlexpr.argnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* optional argument is known to be xml */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(xexpr-&gt;args) == <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (argnull[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = argvalue[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BoolGetDatum(<a href="../utils/adt/xml.c.html#L1096" title="utils/adt/xml.c:1096">xml_is_document</a>(DatumGetXmlP(value)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized XML operation&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate a JSON constructor expression.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4089">&#x200c;</a></span><span class="linkable">ExecEvalJsonConstructor</span>(ExprState *state, ExprEvalStep *op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; JsonConstructorExprState *jcstate = op-&gt;d.json_constructor.jcstate;<br/></li>
<li>&nbsp; &nbsp; JsonConstructorExpr *ctor = jcstate-&gt;constructor;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_jsonb = ctor-&gt;returning-&gt;format-&gt;<a href="../utils/adt/format_type.c.html#L60" title="utils/adt/format_type.c:60">format_type</a> == JS_FORMAT_JSONB;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ctor-&gt;type == JSCTOR_JSON_ARRAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = (is_jsonb ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/jsonb.c.html#L1210" title="utils/adt/jsonb.c:1210">jsonb_build_array_worker</a> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/json.c.html#L1321" title="utils/adt/json.c:1321">json_build_array_worker</a>) (jcstate-&gt;nargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jcstate-&gt;arg_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jcstate-&gt;arg_nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jcstate-&gt;arg_types,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jcstate-&gt;constructor-&gt;absent_on_null);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ctor-&gt;type == JSCTOR_JSON_OBJECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = (is_jsonb ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/jsonb.c.html#L1125" title="utils/adt/jsonb.c:1125">jsonb_build_object_worker</a> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/json.c.html#L1208" title="utils/adt/json.c:1208">json_build_object_worker</a>) (jcstate-&gt;nargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jcstate-&gt;arg_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jcstate-&gt;arg_nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jcstate-&gt;arg_types,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jcstate-&gt;constructor-&gt;absent_on_null,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jcstate-&gt;constructor-&gt;unique);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ctor-&gt;type == JSCTOR_JSON_SCALAR)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jcstate-&gt;arg_nulls[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; value = jcstate-&gt;arg_values[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outfuncid = jcstate-&gt;arg_type_cache[<span class="Constant">0</span>].outfuncid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonTypeCategory category = (JsonTypeCategory)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jcstate-&gt;arg_type_cache[<span class="Constant">0</span>].category;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_jsonb)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="../utils/adt/jsonb.c.html#L1112" title="utils/adt/jsonb.c:1112">datum_to_jsonb</a>(value, category, outfuncid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="../utils/adt/json.c.html#L754" title="utils/adt/json.c:754">datum_to_json</a>(value, category, outfuncid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ctor-&gt;type == JSCTOR_JSON_PARSE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jcstate-&gt;arg_nulls[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; value = jcstate-&gt;arg_values[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *js = DatumGetTextP(value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_jsonb)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="../utils/adt/jsonb.c.html#L147" title="utils/adt/jsonb.c:147">jsonb_from_text</a>(js, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../utils/adt/json.c.html#L1650" title="utils/adt/json.c:1650">json_validate</a>(js, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid JsonConstructorExpr type </span><span class="Special">%d</span><span class="Constant">&quot;</span>, ctor-&gt;type);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *op-&gt;resvalue = res;<br/></li>
<li>&nbsp; &nbsp; *op-&gt;resnull = isnull;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate a IS JSON predicate.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4167">&#x200c;</a></span><span class="linkable">ExecEvalJsonIsPredicate</span>(ExprState *state, ExprEvalStep *op)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonIsPredicate *pred = op-&gt;d.is_json.pred;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; js = *op-&gt;resvalue;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exprtype;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; exprtype = <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(pred-&gt;expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (exprtype == TEXTOID || exprtype == JSONOID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *json = DatumGetTextP(js);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pred-&gt;item_type == JS_TYPE_ANY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="../utils/adt/jsonfuncs.c.html#L5926" title="utils/adt/jsonfuncs.c:5926">json_get_first_token</a>(json, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSON_TOKEN_OBJECT_START:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = pred-&gt;item_type == JS_TYPE_OBJECT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSON_TOKEN_ARRAY_START:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = pred-&gt;item_type == JS_TYPE_ARRAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSON_TOKEN_STRING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSON_TOKEN_NUMBER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSON_TOKEN_TRUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSON_TOKEN_FALSE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSON_TOKEN_NULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = pred-&gt;item_type == JS_TYPE_SCALAR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do full parsing pass only for uniqueness check or for JSON text<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * validation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res &amp;&amp; (pred-&gt;unique_keys || exprtype == TEXTOID))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="../utils/adt/json.c.html#L1650" title="utils/adt/json.c:1650">json_validate</a>(json, pred-&gt;unique_keys, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (exprtype == JSONBOID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pred-&gt;item_type == JS_TYPE_ANY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *jb = DatumGetJsonbP(js);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (pred-&gt;item_type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JS_TYPE_OBJECT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = JB_ROOT_IS_OBJECT(jb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JS_TYPE_ARRAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = JB_ROOT_IS_ARRAY(jb) &amp;&amp; !JB_ROOT_IS_SCALAR(jb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JS_TYPE_SCALAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = JB_ROOT_IS_ARRAY(jb) &amp;&amp; JB_ROOT_IS_SCALAR(jb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Key uniqueness check is redundant for jsonb */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate a jsonpath against a document, both of which must have been<br/></li>
<li></span><span class="Comment"> * evaluated and their <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> saved in op-&gt;d.jsonexpr.jsestate.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If an error occurs during JsonPath* evaluation or when coercing its result<br/></li>
<li></span><span class="Comment"> * to the RETURNING type, JsonExprState.error is set to true, provided the<br/></li>
<li></span><span class="Comment"> * ON ERROR behavior is not ERROR.&nbsp; Similarly, if JsonPath{Query|Value}() found<br/></li>
<li></span><span class="Comment"> * no matching items, JsonExprState.empty is set to true, provided the ON <a href="../regex/regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a><br/></li>
<li></span><span class="Comment"> * behavior is not ERROR.&nbsp; That is to signal to the subsequent steps that check<br/></li>
<li></span><span class="Comment"> * those flags to return the ON ERROR / ON <a href="../regex/regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> expression.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value is the step address to be performed <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>.&nbsp; It will be one of<br/></li>
<li></span><span class="Comment"> * jump_error, jump_empty, jump_eval_coercion, or jump_end, all given in<br/></li>
<li></span><span class="Comment"> * op-&gt;d.jsonexpr.jsestate.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L4267">&#x200c;</a></span><span class="linkable">ExecEvalJsonExprPath</span>(ExprState *state, ExprEvalStep *op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonExprState *jsestate = op-&gt;d.jsonexpr.jsestate;<br/></li>
<li>&nbsp; &nbsp; JsonExpr&nbsp;&nbsp; *jsexpr = jsestate-&gt;jsexpr;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; item;<br/></li>
<li>&nbsp; &nbsp; JsonPath&nbsp;&nbsp; *path;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; throw_error = jsexpr-&gt;on_error-&gt;btype == JSON_BEHAVIOR_ERROR;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; error = <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; empty = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jump_eval_coercion = jsestate-&gt;jump_eval_coercion;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *val_string = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; item = jsestate-&gt;formatted_expr.value;<br/></li>
<li>&nbsp; &nbsp; path = DatumGetJsonPathP(jsestate-&gt;pathspec.value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set error/empty to false. */<br/></li>
<li></span>&nbsp; &nbsp; memset(&amp;jsestate-&gt;error, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(NullableDatum));<br/></li>
<li>&nbsp; &nbsp; memset(&amp;jsestate-&gt;empty, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(NullableDatum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also reset ErrorSaveContext contents for the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> row.&nbsp; Since we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set details_wanted, we don't need to also reset error_data, which would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be NULL anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!jsestate-&gt;escontext.details_wanted &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jsestate-&gt;escontext.error_data == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; jsestate-&gt;escontext.error_occurred = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (jsexpr-&gt;op)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSON_EXISTS_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; exists = <a href="../utils/adt/jsonpath_exec.c.html#L3878" title="utils/adt/jsonpath_exec.c:3878">JsonPathExists</a>(item, path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !throw_error ? &amp;error : <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jsestate-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = BoolGetDatum(exists);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSON_QUERY_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = <a href="../utils/adt/jsonpath_exec.c.html#L3901" title="utils/adt/jsonpath_exec.c:3901">JsonPathQuery</a>(item, path, jsexpr-&gt;wrapper, &amp;empty,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !throw_error ? &amp;error : <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jsestate-&gt;args,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jsexpr-&gt;column_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = (DatumGetPointer(*op-&gt;resvalue) == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Handle OMIT QUOTES. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!*op-&gt;resnull &amp;&amp; jsexpr-&gt;omit_quotes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val_string = <a href="../utils/adt/jsonb.c.html#L2166" title="utils/adt/jsonb.c:2166">JsonbUnquote</a>(DatumGetJsonbP(*op-&gt;resvalue));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pass the string as a text value to the cast expression if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one present.&nbsp; If not, use the input function call below to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do the coercion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jump_eval_coercion &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DirectFunctionCall1(<a href="../utils/adt/varlena.c.html#L579" title="utils/adt/varlena.c:579">textin</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(val_string));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSON_VALUE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonbValue *jbv = <a href="../utils/adt/jsonpath_exec.c.html#L3981" title="utils/adt/jsonpath_exec.c:3981">JsonPathValue</a>(item, path, &amp;empty,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !throw_error ? &amp;error : <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jsestate-&gt;args,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jsexpr-&gt;column_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jbv == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Will be coerced with coercion_expr, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!error &amp;&amp; !empty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jsexpr-&gt;returning-&gt;typid == JSONOID ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jsexpr-&gt;returning-&gt;typid == JSONBOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val_string = DatumGetCString(DirectFunctionCall1(<a href="../utils/adt/jsonb.c.html#L108" title="utils/adt/jsonb.c:108">jsonb_out</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JsonbPGetDatum(<a href="../utils/adt/jsonb_util.c.html#L92" title="utils/adt/jsonb_util.c:92">JsonbValueToJsonb</a>(jbv))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val_string = <a href="#L4463" title="executor/execExprInterp.c:4463">ExecGetJsonValueItemString</a>(jbv, op-&gt;resnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pass the string as a text value to the cast<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expression if one present.&nbsp; If not, use the input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function call below to do the coercion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = PointerGetDatum(val_string);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jump_eval_coercion &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = DirectFunctionCall1(<a href="../utils/adt/varlena.c.html#L579" title="utils/adt/varlena.c:579">textin</a>, *op-&gt;resvalue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* JSON_TABLE_OP can't happen here */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized SQL/JSON expression op </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) jsexpr-&gt;op);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Coerce the result value to the RETURNING type by calling its input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!*op-&gt;resnull &amp;&amp; jsexpr-&gt;use_io_coercion)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FunctionCallInfo fcinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(jump_eval_coercion == -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo = jsestate-&gt;input_fcinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(fcinfo != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(val_string != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = PointerGetDatum(val_string);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = *op-&gt;resnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Second and third arguments are already set up in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="execExpr.c.html#L4225" title="executor/execExpr.c:4225">ExecInitJsonExpr</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = FunctionCallInvoke(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (SOFT_ERROR_OCCURRED(&amp;jsestate-&gt;escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle ON <a href="../regex/regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (empty)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jsexpr-&gt;on_empty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jsexpr-&gt;on_empty-&gt;btype != JSON_BEHAVIOR_ERROR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jsestate-&gt;empty.value = BoolGetDatum(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(jsestate-&gt;jump_empty &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> jsestate-&gt;jump_empty;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (jsexpr-&gt;on_error-&gt;btype != JSON_BEHAVIOR_ERROR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jsestate-&gt;error.value = BoolGetDatum(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!throw_error &amp;&amp; jsestate-&gt;jump_error &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> jsestate-&gt;jump_error;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (jsexpr-&gt;column_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NO_SQL_JSON_ITEM),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no SQL/JSON item found for specified path of column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jsexpr-&gt;column_name));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NO_SQL_JSON_ITEM),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no SQL/JSON item found for specified path&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ON ERROR. Wouldn't get here if the behavior is ERROR, because they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would have already been thrown.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (error)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!throw_error &amp;&amp; jsestate-&gt;jump_error &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jsestate-&gt;error.value = BoolGetDatum(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> jsestate-&gt;jump_error;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> jump_eval_coercion &gt;= <span class="Constant">0</span> ? jump_eval_coercion : jsestate-&gt;jump_end;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert the given JsonbValue to its C string representation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *resnull is set if the JsonbValue is a jbvNull.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L4463">&#x200c;</a><span class="linkable">ExecGetJsonValueItemString</span>(JsonbValue *item, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *resnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; *resnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* get coercion state reference and datum of the corresponding SQL type */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (item-&gt;type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvNull:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *resnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvString:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(item-&gt;val.string.len + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(str, item-&gt;val.string.val, item-&gt;val.string.len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str[item-&gt;val.string.len] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> str;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvNumeric:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DatumGetCString(DirectFunctionCall1(<a href="../utils/adt/numeric.c.html#L807" title="utils/adt/numeric.c:807">numeric_out</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NumericGetDatum(item-&gt;val.<a href="../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvBool:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DatumGetCString(DirectFunctionCall1(<a href="../utils/adt/bool.c.html#L157" title="utils/adt/bool.c:157">boolout</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BoolGetDatum(item-&gt;val.boolean)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvDatetime:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (item-&gt;val.datetime.typid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DATEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DatumGetCString(DirectFunctionCall1(<a href="../utils/adt/date.c.html#L184" title="utils/adt/date.c:184">date_out</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; item-&gt;val.datetime.value));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DatumGetCString(DirectFunctionCall1(<a href="../utils/adt/date.c.html#L1501" title="utils/adt/date.c:1501">time_out</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; item-&gt;val.datetime.value));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMETZOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DatumGetCString(DirectFunctionCall1(<a href="../utils/adt/date.c.html#L2314" title="utils/adt/date.c:2314">timetz_out</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; item-&gt;val.datetime.value));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMESTAMPOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DatumGetCString(DirectFunctionCall1(<a href="../utils/adt/timestamp.c.html#L232" title="utils/adt/timestamp.c:232">timestamp_out</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; item-&gt;val.datetime.value));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMESTAMPTZOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DatumGetCString(DirectFunctionCall1(<a href="../utils/adt/timestamp.c.html#L785" title="utils/adt/timestamp.c:785">timestamptz_out</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; item-&gt;val.datetime.value));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected jsonb datetime type oid </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; item-&gt;val.datetime.typid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvArray:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvObject:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> jbvBinary:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DatumGetCString(DirectFunctionCall1(<a href="../utils/adt/jsonb.c.html#L108" title="utils/adt/jsonb.c:108">jsonb_out</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; JsonbPGetDatum(<a href="../utils/adt/jsonb_util.c.html#L92" title="utils/adt/jsonb_util.c:92">JsonbValueToJsonb</a>(item))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected jsonb value type </span><span class="Special">%d</span><span class="Constant">&quot;</span>, item-&gt;type);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; *resnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Coerce a jsonb value produced by <a href="#L4267" title="executor/execExprInterp.c:4267">ExecEvalJsonExprPath</a>() or an ON ERROR /<br/></li>
<li></span><span class="Comment"> * ON <a href="../regex/regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> behavior expression to the target type.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Any soft errors that occur here will be checked by<br/></li>
<li></span><span class="Comment"> * EEOP_JSONEXPR_COERCION_FINISH that will run after this.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4538">&#x200c;</a></span><span class="linkable">ExecEvalJsonCoercion</span>(ExprState *state, ExprEvalStep *op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorSaveContext *escontext = op-&gt;d.jsonexpr_coercion.escontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *op-&gt;resvalue = <a href="../utils/adt/jsonfuncs.c.html#L3335" title="utils/adt/jsonfuncs.c:3335">json_populate_type</a>(*op-&gt;resvalue, JSONBOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.jsonexpr_coercion.targettype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;d.jsonexpr_coercion.targettypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;op-&gt;d.jsonexpr_coercion.json_populate_type_cache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; econtext-&gt;ecxt_per_query_memory,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;resnull, (Node *) escontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Checks if an error occurred either when evaluating JsonExpr.coercion_expr or<br/></li>
<li></span><span class="Comment"> * in <a href="#L4538" title="executor/execExprInterp.c:4538">ExecEvalJsonCoercion</a>().&nbsp; If so, this sets JsonExprState.error to <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a><br/></li>
<li></span><span class="Comment"> * the ON ERROR handling steps.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4557">&#x200c;</a></span><span class="linkable">ExecEvalJsonCoercionFinish</span>(ExprState *state, ExprEvalStep *op)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JsonExprState *jsestate = op-&gt;d.jsonexpr.jsestate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (SOFT_ERROR_OCCURRED(&amp;jsestate-&gt;escontext))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jsestate-&gt;error.value = BoolGetDatum(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4579" title="executor/execExprInterp.c:4579">ExecEvalGroupingFunc</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Computes a bitmask with a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> for each (unevaluated) argument expression<br/></li>
<li></span><span class="Comment"> * (rightmost arg is least significant <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is set if the corresponding expression is NOT part of the set of<br/></li>
<li></span><span class="Comment"> * grouping expressions in the current grouping set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4579">&#x200c;</a></span><span class="linkable">ExecEvalGroupingFunc</span>(ExprState *state, ExprEvalStep *op)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AggState&nbsp;&nbsp; *aggstate = castNode(AggState, state-&gt;parent);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *grouped_cols = aggstate-&gt;grouped_cols;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, op-&gt;d.grouping_func.clauses)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = lfirst_int(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result &lt;&lt;= <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(attnum, grouped_cols))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result |= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *op-&gt;resvalue = Int32GetDatum(result);<br/></li>
<li>&nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4606" title="executor/execExprInterp.c:4606">ExecEvalMergeSupportFunc</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns information about the current MERGE action for its RETURNING list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4606">&#x200c;</a></span><span class="linkable">ExecEvalMergeSupportFunc</span>(ExprState *state, ExprEvalStep *op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ModifyTableState *mtstate = castNode(ModifyTableState, state-&gt;parent);<br/></li>
<li>&nbsp; &nbsp; MergeActionState *relaction = mtstate-&gt;mt_merge_action;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!relaction)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> action in progress&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return the MERGE action (&quot;INSERT&quot;, &quot;UPDATE&quot;, or &quot;DELETE&quot;) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (relaction-&gt;mas_action-&gt;commandType)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = PointerGetDatum(<a href="../utils/adt/varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(<span class="Constant">&quot;INSERT&quot;</span>, <span class="Constant">6</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = PointerGetDatum(<a href="../utils/adt/varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(<span class="Constant">&quot;UPDATE&quot;</span>, <span class="Constant">6</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resvalue = PointerGetDatum(<a href="../utils/adt/varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(<span class="Constant">&quot;DELETE&quot;</span>, <span class="Constant">6</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_NOTHING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> action: DO NOTHING&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized commandType: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) relaction-&gt;mas_action-&gt;commandType);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Hand off evaluation of a subplan to nodeSubplan.c<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4643">&#x200c;</a></span><span class="linkable">ExecEvalSubPlan</span>(ExprState *state, ExprEvalStep *op, ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SubPlanState *sstate = op-&gt;d.subplan.sstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* could potentially be nested, so make sure there's enough stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *op-&gt;resvalue = <a href="nodeSubplan.c.html#L62" title="executor/nodeSubplan.c:62">ExecSubPlan</a>(sstate, econtext, op-&gt;resnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate a wholerow Var expression.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a Datum whose value is the value of a whole-row <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> variable<br/></li>
<li></span><span class="Comment"> * with respect to given expression context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4660">&#x200c;</a></span><span class="linkable">ExecEvalWholeRowVar</span>(ExprState *state, ExprEvalStep *op, ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *variable = op-&gt;d.wholerow.var;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; output_tupdesc;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader dtuple;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This was checked by <a href="execExpr.c.html#L134" title="executor/execExpr.c:134">ExecInitExpr</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert(variable-&gt;varattno == InvalidAttrNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the input slot we want */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (variable-&gt;varno)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INNER_VAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* get the tuple from the inner node */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot = econtext-&gt;ecxt_innertuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OUTER_VAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* get the tuple from the outer node */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot = econtext-&gt;ecxt_outertuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* INDEX_VAR is handled by default case */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* get the tuple from the relation being scanned */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot = econtext-&gt;ecxt_scantuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Apply the junkfilter if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (op-&gt;d.wholerow.junkFilter != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot = <a href="execJunk.c.html#L247" title="executor/execJunk.c:247">ExecFilterJunk</a>(op-&gt;d.wholerow.junkFilter, slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If first time through, obtain tuple descriptor and check compatibility.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: It'd be great if this could be moved to the expression<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initialization phase, but due to using slots that's currently not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * feasible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (op-&gt;d.wholerow.first)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* optimistically assume we don't need slow path */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.wholerow.slow = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the Var identifies a named composite type, we must check that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the actual tuple type is compatible with it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (variable-&gt;vartype != RECORDOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; var_tupdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; slot_tupdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We really only care about numbers of attributes and data types.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also, we can ignore type mismatch on columns that are dropped<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the destination type, so long as (1) the physical storage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matches or (2) the actual column value is NULL.&nbsp; Case (1) is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * helpful in some cases involving out-of-date cached plans, while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case (2) is expected behavior in situations such as an INSERT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * into a table with dropped columns (the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> typically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * generates an INT4 NULL regardless of the dropped column type).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a dropped column and cannot verify that case (1)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * holds, we have to use the slow path to check (2) for each row.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If vartype is a domain over composite, just look through that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the base composite type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var_tupdesc = <a href="../utils/cache/typcache.c.html#L1889" title="utils/cache/typcache.c:1889">lookup_rowtype_tupdesc_domain</a>(variable-&gt;vartype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot_tupdesc = slot-&gt;tts_tupleDescriptor;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var_tupdesc-&gt;natts != slot_tupdesc-&gt;natts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;table row type and query-specified row type do not match&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1297" title="utils/error/elog.c:1297">errdetail_plural</a>(<span class="Constant">&quot;Table row contains </span><span class="Special">%d</span><span class="Constant"> attribute, but query expects </span><span class="Special">%d</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Table row contains </span><span class="Special">%d</span><span class="Constant"> attributes, but query expects </span><span class="Special">%d</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot_tupdesc-&gt;natts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot_tupdesc-&gt;natts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var_tupdesc-&gt;natts)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; var_tupdesc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute vattr = TupleDescAttr(var_tupdesc, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute sattr = TupleDescAttr(slot_tupdesc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vattr-&gt;atttypid == sattr-&gt;atttypid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; <span class="Comment">/* no worries */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!vattr-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;table row type and query-specified row type do not match&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Table has type </span><span class="Special">%s</span><span class="Constant"> at ordinal position </span><span class="Special">%d</span><span class="Constant">, but query expects </span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(sattr-&gt;atttypid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; i + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(vattr-&gt;atttypid))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vattr-&gt;attlen != sattr-&gt;attlen ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vattr-&gt;attalign != sattr-&gt;attalign)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.wholerow.slow = <span class="Constant">true</span>; <span class="Comment">/* need to check for nulls */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use the variable's declared rowtype as the descriptor for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * output <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; In particular, we *must* absorb <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attisdropped markings.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(econtext-&gt;ecxt_per_query_memory);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; output_tupdesc = <a href="../access/common/tupdesc.c.html#L133" title="access/common/tupdesc.c:133">CreateTupleDescCopy</a>(var_tupdesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReleaseTupleDesc(var_tupdesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the RECORD case, we use the input slot's rowtype as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * descriptor for the output <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, modulo possibly assigning new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column names below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(econtext-&gt;ecxt_per_query_memory);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; output_tupdesc = <a href="../access/common/tupdesc.c.html#L133" title="access/common/tupdesc.c:133">CreateTupleDescCopy</a>(slot-&gt;tts_tupleDescriptor);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's possible that the input slot is a relation scan slot and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so is marked with that relation's rowtype.&nbsp; But we're supposed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to be returning RECORD, so reset to that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; output_tupdesc-&gt;tdtypeid = RECORDOID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; output_tupdesc-&gt;tdtypmod = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We already got the correct physical datatype info above, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we should try to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the source RTE and adopt its column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aliases, since it's unlikely that the input slot has the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * desired names.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we can't locate the RTE, assume the column names we've got<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are OK.&nbsp; (As of this writing, the only cases where we can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * locate the RTE are in execution of <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> WHEN clauses, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then the Var will have the <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>'s relation's rowtype, so its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * names are fine.)&nbsp; Also, if the creator of the RTE didn't bother<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to fill in an eref field, assume our column names are OK. (This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * happens in COPY, and perhaps other places.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (econtext-&gt;ecxt_estate &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; variable-&gt;varno &lt;= econtext-&gt;ecxt_estate-&gt;es_range_table_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = exec_rt_fetch(variable-&gt;varno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; econtext-&gt;ecxt_estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;eref)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L2117" title="executor/execTuples.c:2117">ExecTypeSetColNames</a>(output_tupdesc, rte-&gt;eref-&gt;colnames);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Bless the tupdesc if needed, and save it in the execution state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.wholerow.tupdesc = <a href="execTuples.c.html#L2158" title="executor/execTuples.c:2158">BlessTupleDesc</a>(output_tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.wholerow.first = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure all columns of the slot are accessible in the slot's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Datum/isnull arrays.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; slot_getallattrs(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (op-&gt;d.wholerow.slow)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check to see if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> dropped attributes are non-null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupleDesc = slot-&gt;tts_tupleDescriptor;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; var_tupdesc = op-&gt;d.wholerow.tupdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(var_tupdesc-&gt;natts == tupleDesc-&gt;natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; var_tupdesc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute vattr = TupleDescAttr(var_tupdesc, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute sattr = TupleDescAttr(tupleDesc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!vattr-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* already checked non-dropped cols */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;tts_isnull[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* null is always okay */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vattr-&gt;attlen != sattr-&gt;attlen ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vattr-&gt;attalign != sattr-&gt;attalign)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;table row type and query-specified row type do not match&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Physical storage mismatch on dropped attribute at ordinal position </span><span class="Special">%d</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; i + <span class="Constant">1</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build a composite datum, making sure <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> toasted fields get detoasted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Note: it is critical that we not change the slot's state here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tuple = <a href="../access/heap/heaptoast.c.html#L563" title="access/heap/heaptoast.c:563">toast_build_flattened_tuple</a>(slot-&gt;tts_tupleDescriptor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_isnull);<br/></li>
<li>&nbsp; &nbsp; dtuple = tuple-&gt;t_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Label the datum with the composite type info we identified <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Note: we could <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> doing this by passing op-&gt;d.wholerow.tupdesc to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the tuple build step; but that seems a tad risky so let's not.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; HeapTupleHeaderSetTypeId(dtuple, op-&gt;d.wholerow.tupdesc-&gt;tdtypeid);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetTypMod(dtuple, op-&gt;d.wholerow.tupdesc-&gt;tdtypmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *op-&gt;resvalue = PointerGetDatum(dtuple);<br/></li>
<li>&nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L4887">&#x200c;</a></span><span class="linkable">ExecEvalSysVar</span>(ExprState *state, ExprEvalStep *op, ExprContext *econtext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; d;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* slot_getsysattr has sufficient defenses against bad attnums */<br/></li>
<li></span>&nbsp; &nbsp; d = slot_getsysattr(slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;d.var.attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;resnull);<br/></li>
<li>&nbsp; &nbsp; *op-&gt;resvalue = d;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* this ought to be unreachable, but it's cheap enough to check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(*op-&gt;resnull))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to fetch attribute from slot&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Transition value has not been initialized. This is the first non-NULL input<br/></li>
<li></span><span class="Comment"> * value for a group. We use it as the initial value for transValue.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4907">&#x200c;</a></span><span class="linkable">ExecAggInitGroup</span>(AggState *aggstate, AggStatePerTrans pertrans, AggStatePerGroup pergroup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExprContext *aggcontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FunctionCallInfo fcinfo = pertrans-&gt;transfn_fcinfo;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must copy the datum into aggcontext if it is pass-by-ref. We do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> the old transValue, since it's NULL.&nbsp; (We already checked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that the agg's input type is binary-compatible with its transtype, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * straight copy here is OK.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldContext = MemoryContextSwitchTo(aggcontext-&gt;ecxt_per_tuple_memory);<br/></li>
<li>&nbsp; &nbsp; pergroup-&gt;transValue = <a href="../utils/adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(fcinfo-&gt;args[<span class="Constant">1</span>].value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pertrans-&gt;transtypeByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pertrans-&gt;transtypeLen);<br/></li>
<li>&nbsp; &nbsp; pergroup-&gt;transValueIsNull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pergroup-&gt;noTransValue = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Ensure that the new transition value is stored in the aggcontext,<br/></li>
<li></span><span class="Comment"> * rather than the per-tuple context.&nbsp; This should be invoked only when<br/></li>
<li></span><span class="Comment"> * we know (a) the transition data type is pass-by-reference, and (b)<br/></li>
<li></span><span class="Comment"> * the newValue is distinct from the oldValue.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: This can change the current memory context.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We copy the presented newValue into the aggcontext, except when the datum<br/></li>
<li></span><span class="Comment"> * points to a R/W expanded object that is already a child of the aggcontext,<br/></li>
<li></span><span class="Comment"> * in which case we need not copy.&nbsp; We then delete the oldValue, if not null.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the presented datum points to a R/W expanded object that is a child of<br/></li>
<li></span><span class="Comment"> * some other context, ideally we would just reparent it under the aggcontext.<br/></li>
<li></span><span class="Comment"> * Unfortunately, that doesn't work easily, and it wouldn't <a href="../main/main.c.html#L320" title="main/main.c:320">help</a> anyway for<br/></li>
<li></span><span class="Comment"> * aggregate-aware transfns.&nbsp; We expect that a transfn that deals in expanded<br/></li>
<li></span><span class="Comment"> * objects and is aware of the memory management conventions for aggregate<br/></li>
<li></span><span class="Comment"> * transition <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> will (1) on first call, return a R/W expanded object that<br/></li>
<li></span><span class="Comment"> * is already in the right context, allowing us to do nothing here, and (2) on<br/></li>
<li></span><span class="Comment"> * subsequent calls, modify and return that same object, so that control<br/></li>
<li></span><span class="Comment"> * doesn't even reach here.&nbsp; However, if we have a generic transfn that<br/></li>
<li></span><span class="Comment"> * returns a new R/W expanded object (probably in the per-tuple context),<br/></li>
<li></span><span class="Comment"> * reparenting that result would cause problems.&nbsp; We'd pass that R/W object to<br/></li>
<li></span><span class="Comment"> * the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> invocation of the transfn, and then it would be at liberty to<br/></li>
<li></span><span class="Comment"> * change or delete that object, and if it deletes it then our own attempt to<br/></li>
<li></span><span class="Comment"> * delete the <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-old transvalue afterwards would be a double free.&nbsp; We avoid<br/></li>
<li></span><span class="Comment"> * this problem by forcing the stored transvalue to always be a flat<br/></li>
<li></span><span class="Comment"> * non-expanded object unless the transfn is visibly doing aggregate-aware<br/></li>
<li></span><span class="Comment"> * memory management.&nbsp; This is somewhat inefficient, but the best answer to<br/></li>
<li></span><span class="Comment"> * that is to write a smarter transfn.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4960">&#x200c;</a><span class="linkable">ExecAggCopyTransValue</span>(AggState *aggstate, AggStatePerTrans pertrans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum newValue, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> newValueIsNull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum oldValue, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> oldValueIsNull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(newValue != oldValue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!newValueIsNull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(aggstate-&gt;curaggcontext-&gt;ecxt_per_tuple_memory);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumIsReadWriteExpandedObject(newValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pertrans-&gt;transtypeLen) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L731" title="utils/mmgr/mcxt.c:731">MemoryContextGetParent</a>(<a href="../utils/adt/expandeddatum.c.html#L29" title="utils/adt/expandeddatum.c:29">DatumGetEOHP</a>(newValue)-&gt;eoh_context) == <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* do nothing */</span> ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newValue = <a href="../utils/adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(newValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pertrans-&gt;transtypeByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pertrans-&gt;transtypeLen);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ensure that AggStatePerGroup-&gt;transValue ends up being 0, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * callers can safely <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> newValue/oldValue without having to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check their respective nullness.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newValue = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!oldValueIsNull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumIsReadWriteExpandedObject(oldValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pertrans-&gt;transtypeLen))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/expandeddatum.c.html#L136" title="utils/adt/expandeddatum.c:136">DeleteExpandedObject</a>(oldValue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(oldValue));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newValue;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5009" title="executor/execExprInterp.c:5009">ExecEvalPreOrderedDistinctSingle</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns true when the aggregate transition value Datum is distinct<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; from the previous input Datum and returns false when the input Datum<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; matches the previous input Datum.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L5009">&#x200c;</a></span><span class="linkable">ExecEvalPreOrderedDistinctSingle</span>(AggState *aggstate, AggStatePerTrans pertrans)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; value = pertrans-&gt;transfn_fcinfo-&gt;args[<span class="Constant">1</span>].value;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull = pertrans-&gt;transfn_fcinfo-&gt;args[<span class="Constant">1</span>].isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!pertrans-&gt;haslast ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;lastisnull != isnull ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (!isnull &amp;&amp; !DatumGetBool(<a href="../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;pertrans-&gt;equalfnOne,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;aggCollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;lastdatum, value))))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pertrans-&gt;haslast &amp;&amp; !pertrans-&gt;inputtypeByVal &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !pertrans-&gt;lastisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(pertrans-&gt;lastdatum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;haslast = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldContext = MemoryContextSwitchTo(aggstate-&gt;curaggcontext-&gt;ecxt_per_tuple_memory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;lastdatum = <a href="../utils/adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(value, pertrans-&gt;inputtypeByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;inputtypeLen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;lastdatum = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;lastisnull = isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5052" title="executor/execExprInterp.c:5052">ExecEvalPreOrderedDistinctMulti</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns true when the aggregate input is distinct from the previous<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; input and returns false when the input matches the previous input, or<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; when there was no previous input.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L5052">&#x200c;</a></span><span class="linkable">ExecEvalPreOrderedDistinctMulti</span>(AggState *aggstate, AggStatePerTrans pertrans)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExprContext *tmpcontext = aggstate-&gt;tmpcontext;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isdistinct = <span class="Constant">false</span>; <span class="Comment">/* for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; TupleTableSlot *save_outer;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *save_inner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; pertrans-&gt;numTransInputs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;sortslot-&gt;tts_values[i] = pertrans-&gt;transfn_fcinfo-&gt;args[i + <span class="Constant">1</span>].value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;sortslot-&gt;tts_isnull[i] = pertrans-&gt;transfn_fcinfo-&gt;args[i + <span class="Constant">1</span>].isnull;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(pertrans-&gt;sortslot);<br/></li>
<li>&nbsp; &nbsp; pertrans-&gt;sortslot-&gt;tts_nvalid = pertrans-&gt;numInputs;<br/></li>
<li>&nbsp; &nbsp; <a href="execTuples.c.html#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a>(pertrans-&gt;sortslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* save the previous slots <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we overwrite them */<br/></li>
<li></span>&nbsp; &nbsp; save_outer = tmpcontext-&gt;ecxt_outertuple;<br/></li>
<li>&nbsp; &nbsp; save_inner = tmpcontext-&gt;ecxt_innertuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tmpcontext-&gt;ecxt_outertuple = pertrans-&gt;sortslot;<br/></li>
<li>&nbsp; &nbsp; tmpcontext-&gt;ecxt_innertuple = pertrans-&gt;uniqslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!pertrans-&gt;haslast ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !ExecQual(pertrans-&gt;equalfnMulti, tmpcontext))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pertrans-&gt;haslast)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(pertrans-&gt;uniqslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;haslast = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecCopySlot(pertrans-&gt;uniqslot, pertrans-&gt;sortslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isdistinct = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* restore the original slots */<br/></li>
<li></span>&nbsp; &nbsp; tmpcontext-&gt;ecxt_outertuple = save_outer;<br/></li>
<li>&nbsp; &nbsp; tmpcontext-&gt;ecxt_innertuple = save_inner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> isdistinct;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Invoke ordered transition function, with a datum argument.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5099">&#x200c;</a></span><span class="linkable">ExecEvalAggOrderedTransDatum</span>(ExprState *state, ExprEvalStep *op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AggStatePerTrans pertrans = op-&gt;d.agg_trans.pertrans;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setno = op-&gt;d.agg_trans.setno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/sort/tuplesortvariants.c.html#L826" title="utils/sort/tuplesortvariants.c:826">tuplesort_putdatum</a>(pertrans-&gt;sortstates[setno],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *op-&gt;resvalue, *op-&gt;resnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Invoke ordered transition function, with a tuple argument.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5113">&#x200c;</a></span><span class="linkable">ExecEvalAggOrderedTransTuple</span>(ExprState *state, ExprEvalStep *op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AggStatePerTrans pertrans = op-&gt;d.agg_trans.pertrans;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setno = op-&gt;d.agg_trans.setno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(pertrans-&gt;sortslot);<br/></li>
<li>&nbsp; &nbsp; pertrans-&gt;sortslot-&gt;tts_nvalid = pertrans-&gt;numInputs;<br/></li>
<li>&nbsp; &nbsp; <a href="execTuples.c.html#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a>(pertrans-&gt;sortslot);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/sort/tuplesortvariants.c.html#L669" title="utils/sort/tuplesortvariants.c:669">tuplesort_puttupleslot</a>(pertrans-&gt;sortstates[setno], pertrans-&gt;sortslot);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* implementation of transition function invocation for byval types */<br/></li>
<li></span><span class="Type">static</span> pg_attribute_always_inline <span class="Type">void<br/></li>
<li><a id="L5127">&#x200c;</a></span><span class="linkable">ExecAggPlainTransByVal</span>(AggState *aggstate, AggStatePerTrans pertrans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AggStatePerGroup pergroup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExprContext *aggcontext, <span class="Type">int</span> setno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FunctionCallInfo fcinfo = pertrans-&gt;transfn_fcinfo;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; newVal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cf. <a href="nodeAgg.c.html#L455" title="executor/nodeAgg.c:455">select_current_set</a>() */<br/></li>
<li></span>&nbsp; &nbsp; aggstate-&gt;curaggcontext = aggcontext;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;current_set = setno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set up aggstate-&gt;curpertrans for <a href="nodeAgg.c.html#L4555" title="executor/nodeAgg.c:4555">AggGetAggref</a>() */<br/></li>
<li></span>&nbsp; &nbsp; aggstate-&gt;curpertrans = pertrans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* invoke transition function in per-tuple context */<br/></li>
<li></span>&nbsp; &nbsp; oldContext = MemoryContextSwitchTo(aggstate-&gt;tmpcontext-&gt;ecxt_per_tuple_memory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = pergroup-&gt;transValue;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = pergroup-&gt;transValueIsNull;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;isnull = <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just in case transfn doesn't set it */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; newVal = FunctionCallInvoke(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pergroup-&gt;transValue = newVal;<br/></li>
<li>&nbsp; &nbsp; pergroup-&gt;transValueIsNull = fcinfo-&gt;isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* implementation of transition function invocation for byref types */<br/></li>
<li></span><span class="Type">static</span> pg_attribute_always_inline <span class="Type">void<br/></li>
<li><a id="L5159">&#x200c;</a></span><span class="linkable">ExecAggPlainTransByRef</span>(AggState *aggstate, AggStatePerTrans pertrans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AggStatePerGroup pergroup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExprContext *aggcontext, <span class="Type">int</span> setno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FunctionCallInfo fcinfo = pertrans-&gt;transfn_fcinfo;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; newVal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cf. <a href="nodeAgg.c.html#L455" title="executor/nodeAgg.c:455">select_current_set</a>() */<br/></li>
<li></span>&nbsp; &nbsp; aggstate-&gt;curaggcontext = aggcontext;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;current_set = setno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set up aggstate-&gt;curpertrans for <a href="nodeAgg.c.html#L4555" title="executor/nodeAgg.c:4555">AggGetAggref</a>() */<br/></li>
<li></span>&nbsp; &nbsp; aggstate-&gt;curpertrans = pertrans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* invoke transition function in per-tuple context */<br/></li>
<li></span>&nbsp; &nbsp; oldContext = MemoryContextSwitchTo(aggstate-&gt;tmpcontext-&gt;ecxt_per_tuple_memory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = pergroup-&gt;transValue;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = pergroup-&gt;transValueIsNull;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;isnull = <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just in case transfn doesn't set it */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; newVal = FunctionCallInvoke(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For pass-by-ref datatype, must copy the new value into aggcontext and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * free the prior transValue.&nbsp; But if transfn returned a pointer to its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first input, we don't need to do anything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's safe to <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> newVal with pergroup-&gt;transValue without regard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for either being NULL, because <a href="#L4960" title="executor/execExprInterp.c:4960">ExecAggCopyTransValue</a> takes care to set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transValue to 0 when NULL. Otherwise we could end up accidentally not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reparenting, when the transValue has the same numerical value as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * newValue, despite being NULL.&nbsp; This is a somewhat hot path, making it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * undesirable to instead solve this with another branch for the common<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case of the transition function returning its (modified) input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * argument.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (DatumGetPointer(newVal) != DatumGetPointer(pergroup-&gt;transValue))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newVal = <a href="#L4960" title="executor/execExprInterp.c:4960">ExecAggCopyTransValue</a>(aggstate, pertrans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newVal, fcinfo-&gt;isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pergroup-&gt;transValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pergroup-&gt;transValueIsNull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pergroup-&gt;transValue = newVal;<br/></li>
<li>&nbsp; &nbsp; pergroup-&gt;transValueIsNull = fcinfo-&gt;isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
