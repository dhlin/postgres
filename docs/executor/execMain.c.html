<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>executor/execMain.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>executor/execMain.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L71">ExecutorCheckPerms_hook</a></li>
<li><a href="#L68">ExecutorEnd_hook</a></li>
<li><a href="#L67">ExecutorFinish_hook</a></li>
<li><a href="#L66">ExecutorRun_hook</a></li>
<li><a href="#L65">ExecutorStart_hook</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1026">CheckValidResultRel</a></li>
<li><a href="#L1134">CheckValidRowMarkRel</a></li>
<li><a href="#L2470">EvalPlanQual</a></li>
<li><a href="#L2751">EvalPlanQualBegin</a></li>
<li><a href="#L2982">EvalPlanQualEnd</a></li>
<li><a href="#L2626">EvalPlanQualFetchRowMark</a></li>
<li><a href="#L2539">EvalPlanQualInit</a></li>
<li><a href="#L2735">EvalPlanQualNext</a></li>
<li><a href="#L2581">EvalPlanQualSetPlan</a></li>
<li><a href="#L2598">EvalPlanQualSlot</a></li>
<li><a href="#L2818">EvalPlanQualStart</a></li>
<li><a href="#L2400">ExecBuildAuxRowMark</a></li>
<li><a href="#L2214">ExecBuildSlotValueDescription</a></li>
<li><a href="#L643">ExecCheckOneRelPerms</a></li>
<li><a href="#L579">ExecCheckPermissions</a></li>
<li><a href="#L752">ExecCheckPermissionsModified</a></li>
<li><a href="#L799">ExecCheckXactReadOnly</a></li>
<li><a href="#L1577">ExecCloseRangeTableRelations</a></li>
<li><a href="#L1517">ExecCloseResultRelations</a></li>
<li><a href="#L1916">ExecConstraints</a></li>
<li><a href="#L1478">ExecEndPlan</a></li>
<li><a href="#L2377">ExecFindRowMark</a></li>
<li><a href="#L1372">ExecGetAncestorResultRels</a></li>
<li><a href="#L1296">ExecGetTriggerResultRel</a></li>
<li><a href="#L1792">ExecPartitionCheck</a></li>
<li><a href="#L1845">ExecPartitionCheckEmitError</a></li>
<li><a href="#L1432">ExecPostprocessPlan</a></li>
<li><a href="#L1717">ExecRelCheck</a></li>
<li><a href="#L2351">ExecUpdateLockMode</a></li>
<li><a href="#L2051">ExecWithCheckOptions</a></li>
<li><a href="#L1601">ExecutePlan</a></li>
<li><a href="#L467">ExecutorEnd</a></li>
<li><a href="#L407">ExecutorFinish</a></li>
<li><a href="#L533">ExecutorRewind</a></li>
<li><a href="#L297">ExecutorRun</a></li>
<li><a href="#L124">ExecutorStart</a></li>
<li><a href="#L833">InitPlan</a></li>
<li><a href="#L1199">InitResultRelInfo</a></li>
<li><a href="#L476">standard_ExecutorEnd</a></li>
<li><a href="#L416">standard_ExecutorFinish</a></li>
<li><a href="#L308">standard_ExecutorRun</a></li>
<li><a href="#L141">standard_ExecutorStart</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * execMain.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; top level executor interface routines<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * INTERFACE ROUTINES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L124" title="executor/execMain.c:124">ExecutorStart</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L297" title="executor/execMain.c:297">ExecutorRun</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L407" title="executor/execMain.c:407">ExecutorFinish</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L467" title="executor/execMain.c:467">ExecutorEnd</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; These four procedures are the external interface to the executor.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; In each case, the query descriptor is required as an argument.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L124" title="executor/execMain.c:124">ExecutorStart</a> must be called at the beginning of execution of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; query plan and <a href="#L467" title="executor/execMain.c:467">ExecutorEnd</a> must always be called at the end of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; execution of a plan (unless it is aborted due to error).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L297" title="executor/execMain.c:297">ExecutorRun</a> accepts direction and count arguments that specify whether<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the plan is to be executed forwards, backwards, and for how many tuples.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; In some cases <a href="#L297" title="executor/execMain.c:297">ExecutorRun</a> may be called multiple times to process all<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the tuples for a plan.&nbsp; It is also acceptable to stop short of executing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the whole plan (but only if it is a SELECT).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L407" title="executor/execMain.c:407">ExecutorFinish</a> must be called after the final <a href="#L297" title="executor/execMain.c:297">ExecutorRun</a> call and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="#L467" title="executor/execMain.c:467">ExecutorEnd</a>.&nbsp; This can be omitted only in case of EXPLAIN,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; which should also omit <a href="#L297" title="executor/execMain.c:297">ExecutorRun</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/executor/execMain.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/sysattr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tableam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/partition.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/matview.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeSubplan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;foreign/fdwapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;mb/pg_wchar.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_relation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteHandler.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/utility.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/acl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/backend_status.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/partcache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rls.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* Hooks for plugins to get control in <a href="#L124" title="executor/execMain.c:124">ExecutorStart</a>/Run/Finish/End */<br/></li>
<li><a id="L65">&#x200c;</a></span>ExecutorStart_hook_type <span class="linkable">ExecutorStart_hook</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L66">&#x200c;</a>ExecutorRun_hook_type <span class="linkable">ExecutorRun_hook</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L67">&#x200c;</a>ExecutorFinish_hook_type <span class="linkable">ExecutorFinish_hook</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L68">&#x200c;</a>ExecutorEnd_hook_type <span class="linkable">ExecutorEnd_hook</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Hook for plugin to get control in <a href="#L579" title="executor/execMain.c:579">ExecCheckPermissions</a>() */<br/></li>
<li><a id="L71">&#x200c;</a></span>ExecutorCheckPerms_hook_type <span class="linkable">ExecutorCheckPerms_hook</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* decls for local routines only used within this module */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L833" title="executor/execMain.c:833">InitPlan</a>(QueryDesc *queryDesc, <span class="Type">int</span> eflags);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1134" title="executor/execMain.c:1134">CheckValidRowMarkRel</a>(Relation rel, RowMarkType markType);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1432" title="executor/execMain.c:1432">ExecPostprocessPlan</a>(EState *estate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1478" title="executor/execMain.c:1478">ExecEndPlan</a>(PlanState *planstate, EState *estate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1601" title="executor/execMain.c:1601">ExecutePlan</a>(EState *estate, PlanState *planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> use_parallel_mode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CmdType operation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> sendTuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint64 numberTuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanDirection direction,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DestReceiver *dest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> execute_once);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L643" title="executor/execMain.c:643">ExecCheckOneRelPerms</a>(RTEPermissionInfo *perminfo);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L752" title="executor/execMain.c:752">ExecCheckPermissionsModified</a>(Oid relOid, Oid userid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Bitmapset *modifiedCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AclMode requiredPerms);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L799" title="executor/execMain.c:799">ExecCheckXactReadOnly</a>(PlannedStmt *plannedstmt);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L2214" title="executor/execMain.c:2214">ExecBuildSlotValueDescription</a>(Oid reloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleDesc tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Bitmapset *modifiedCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> maxfieldlen);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2818" title="executor/execMain.c:2818">EvalPlanQualStart</a>(EPQState *epqstate, Plan *planTree);<br/></li>
<li><br/></li>
<li><span class="Comment">/* end of local decls */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L124" title="executor/execMain.c:124">ExecutorStart</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This routine must be called at the beginning of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> execution of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; query plan<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Takes a QueryDesc previously created by <a href="../tcop/pquery.c.html#L67" title="tcop/pquery.c:67">CreateQueryDesc</a> (which is separate<br/></li>
<li></span><span class="Comment"> * only because some places use QueryDescs for utility commands).&nbsp; The tupDesc<br/></li>
<li></span><span class="Comment"> * field of the QueryDesc is filled in to describe the tuples that will be<br/></li>
<li></span><span class="Comment"> * returned, and the <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> fields (estate and planstate) are set up.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * eflags contains flag bits as described in executor.h.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: the <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> when this is called will become the parent<br/></li>
<li></span><span class="Comment"> * of the per-query context used for this Executor invocation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We provide a function hook variable that lets loadable plugins<br/></li>
<li></span><span class="Comment"> * get control when <a href="#L124" title="executor/execMain.c:124">ExecutorStart</a> is called.&nbsp; Such a plugin would<br/></li>
<li></span><span class="Comment"> * normally call <a href="#L141" title="executor/execMain.c:141">standard_ExecutorStart</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L124">&#x200c;</a></span><span class="linkable">ExecutorStart</span>(QueryDesc *queryDesc, <span class="Type">int</span> eflags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In some cases (e.g. an EXECUTE statement) a query execution will <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis, which means that the query_id won't be reported.&nbsp; Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that it's harmless to report the query_id multiple times, as the call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will be ignored if the top level query_id has already been reported.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/activity/backend_status.c.html#L613" title="utils/activity/backend_status.c:613">pgstat_report_query_id</a>(queryDesc-&gt;plannedstmt-&gt;queryId, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L65" title="executor/execMain.c:65">ExecutorStart_hook</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L65" title="executor/execMain.c:65">ExecutorStart_hook</a>) (queryDesc, eflags);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L141" title="executor/execMain.c:141">standard_ExecutorStart</a>(queryDesc, eflags);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L141">&#x200c;</a></span><span class="linkable">standard_ExecutorStart</span>(QueryDesc *queryDesc, <span class="Type">int</span> eflags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sanity checks: queryDesc must not be started already */<br/></li>
<li></span>&nbsp; &nbsp; Assert(queryDesc != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(queryDesc-&gt;estate == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* caller must ensure the query's snapshot is active */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../utils/time/snapmgr.c.html#L770" title="utils/time/snapmgr.c:770">GetActiveSnapshot</a>() == queryDesc-&gt;snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the transaction is read-only, we need to check if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> writes are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * planned to non-temporary tables.&nbsp; EXPLAIN is considered read-only.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't allow writes in parallel mode.&nbsp; Supporting UPDATE and DELETE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would require (a) storing the combo CID <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> in shared memory, rather<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than synchronizing it just once at the start of parallelism, and (b) an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * alternative to <a href="../access/heap/heapam.c.html#L3146" title="access/heap/heapam.c:3146">heap_update</a>()'s reliance on xmax for mutual exclusion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * INSERT may have no such troubles, but we forbid it to simplify the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level defenses in <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a> and elsewhere<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * against performing unsafe operations in parallel mode, but this gives a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more user-friendly error message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((<a href="../access/transam/xact.c.html#L80" title="access/transam/xact.c:80">XactReadOnly</a> || <a href="../access/transam/xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>()) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L799" title="executor/execMain.c:799">ExecCheckXactReadOnly</a>(queryDesc-&gt;plannedstmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build EState, switch into per-query memory context for startup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; estate = <a href="execUtils.c.html#L88" title="executor/execUtils.c:88">CreateExecutorState</a>();<br/></li>
<li>&nbsp; &nbsp; queryDesc-&gt;estate = estate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(estate-&gt;es_query_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill in external parameters, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, from queryDesc; and allocate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * workspace for <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> parameters<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; estate-&gt;es_param_list_info = queryDesc-&gt;params;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (queryDesc-&gt;plannedstmt-&gt;paramExecTypes != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nParamExec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nParamExec = list_length(queryDesc-&gt;plannedstmt-&gt;paramExecTypes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_param_exec_vals = (ParamExecData *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(nParamExec * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ParamExecData));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> require all callers to provide sourceText */<br/></li>
<li></span>&nbsp; &nbsp; Assert(queryDesc-&gt;sourceText != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_sourceText = queryDesc-&gt;sourceText;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill in the query environment, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, from queryDesc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; estate-&gt;es_queryEnv = queryDesc-&gt;queryEnv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If non-read-only query, set the command ID to mark output tuples with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (queryDesc-&gt;operation)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_SELECT:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * SELECT FOR [<a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>] UPDATE/SHARE and modifying CTEs need to mark<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (queryDesc-&gt;plannedstmt-&gt;rowMarks != NIL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryDesc-&gt;plannedstmt-&gt;hasModifyingCTE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_output_cid = <a href="../access/transam/xact.c.html#L826" title="access/transam/xact.c:826">GetCurrentCommandId</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A SELECT without modifying CTEs can't possibly queue triggers,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so force <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>-triggers mode. This is just a marginal efficiency<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hack, since <a href="../commands/trigger.c.html#L5018" title="commands/trigger.c:5018">AfterTriggerBeginQuery</a>/<a href="../commands/trigger.c.html#L5038" title="commands/trigger.c:5038">AfterTriggerEndQuery</a> aren't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all that expensive, but we might as well do it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!queryDesc-&gt;plannedstmt-&gt;hasModifyingCTE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eflags |= EXEC_FLAG_SKIP_TRIGGERS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_MERGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_output_cid = <a href="../access/transam/xact.c.html#L826" title="access/transam/xact.c:826">GetCurrentCommandId</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized operation code: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) queryDesc-&gt;operation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy other important information into the EState<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; estate-&gt;es_snapshot = <a href="../utils/time/snapmgr.c.html#L794" title="utils/time/snapmgr.c:794">RegisterSnapshot</a>(queryDesc-&gt;snapshot);<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_crosscheck_snapshot = <a href="../utils/time/snapmgr.c.html#L794" title="utils/time/snapmgr.c:794">RegisterSnapshot</a>(queryDesc-&gt;crosscheck_snapshot);<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_top_eflags = eflags;<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_instrument = queryDesc-&gt;instrument_options;<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_jit_flags = queryDesc-&gt;plannedstmt-&gt;jitFlags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up an AFTER-<a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> statement context, unless told not to, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unless it's EXPLAIN-only mode (when <a href="#L407" title="executor/execMain.c:407">ExecutorFinish</a> won't be called).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(eflags &amp; (EXEC_FLAG_SKIP_TRIGGERS | EXEC_FLAG_EXPLAIN_ONLY)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../commands/trigger.c.html#L5018" title="commands/trigger.c:5018">AfterTriggerBeginQuery</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the plan state tree<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L833" title="executor/execMain.c:833">InitPlan</a>(queryDesc, eflags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L297" title="executor/execMain.c:297">ExecutorRun</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> routine of the executor module. It accepts<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the query descriptor from the traffic cop and executes the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; query plan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L124" title="executor/execMain.c:124">ExecutorStart</a> must have been called already.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If direction is NoMovementScanDirection then nothing is done<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; except to start up/shut down the destination.&nbsp; Otherwise,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; we retrieve up to 'count' tuples in the specified direction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Note: count = 0 is interpreted as no portal limit, i.e., run to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; completion.&nbsp; Also note that the count limit is only applied to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; retrieved tuples, not for instance to those inserted/updated/deleted<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; by a ModifyTable plan node.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; There is no return value, but output tuples (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) are sent to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the destination receiver specified in the QueryDesc; and the number<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; of tuples processed at the top level can be found in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_processed.&nbsp; The total number of tuples processed in all<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the <a href="#L297" title="executor/execMain.c:297">ExecutorRun</a> calls can be found in estate-&gt;es_total_processed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We provide a function hook variable that lets loadable plugins<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; get control when <a href="#L297" title="executor/execMain.c:297">ExecutorRun</a> is called.&nbsp; Such a plugin would<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; normally call <a href="#L308" title="executor/execMain.c:308">standard_ExecutorRun</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L297">&#x200c;</a></span><span class="linkable">ExecutorRun</span>(QueryDesc *queryDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanDirection direction, uint64 count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> execute_once)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L66" title="executor/execMain.c:66">ExecutorRun_hook</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L66" title="executor/execMain.c:66">ExecutorRun_hook</a>) (queryDesc, direction, count, execute_once);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L308" title="executor/execMain.c:308">standard_ExecutorRun</a>(queryDesc, direction, count, execute_once);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L308">&#x200c;</a></span><span class="linkable">standard_ExecutorRun</span>(QueryDesc *queryDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanDirection direction, uint64 count, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> execute_once)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate;<br/></li>
<li>&nbsp; &nbsp; CmdType&nbsp; &nbsp; &nbsp; &nbsp; operation;<br/></li>
<li>&nbsp; &nbsp; DestReceiver *dest;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sendTuples;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sanity checks */<br/></li>
<li></span>&nbsp; &nbsp; Assert(queryDesc != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate = queryDesc-&gt;estate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(estate != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(!(estate-&gt;es_top_eflags &amp; EXEC_FLAG_EXPLAIN_ONLY));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* caller must ensure the query's snapshot is active */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../utils/time/snapmgr.c.html#L770" title="utils/time/snapmgr.c:770">GetActiveSnapshot</a>() == estate-&gt;es_snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Switch into per-query memory context<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(estate-&gt;es_query_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allow instrumentation of Executor overall runtime */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (queryDesc-&gt;totaltime)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="instrument.c.html#L68" title="executor/instrument.c:68">InstrStartNode</a>(queryDesc-&gt;totaltime);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extract information from the query descriptor and the query feature.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; operation = queryDesc-&gt;operation;<br/></li>
<li>&nbsp; &nbsp; dest = queryDesc-&gt;dest;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * startup tuple receiver, if we will be emitting tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; estate-&gt;es_processed = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sendTuples = (operation == CMD_SELECT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryDesc-&gt;plannedstmt-&gt;hasReturning);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sendTuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dest-&gt;rStartup(dest, operation, queryDesc-&gt;tupDesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * run plan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!ScanDirectionIsNoMovement(direction))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (execute_once &amp;&amp; queryDesc-&gt;already_executed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;can't re-execute query flagged for single execution&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; queryDesc-&gt;already_executed = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1601" title="executor/execMain.c:1601">ExecutePlan</a>(estate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryDesc-&gt;planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryDesc-&gt;plannedstmt-&gt;parallelModeNeeded,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sendTuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; direction,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; execute_once);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update es_total_processed to keep track of the number of tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processed across multiple <a href="#L297" title="executor/execMain.c:297">ExecutorRun</a>() calls.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; estate-&gt;es_total_processed += estate-&gt;es_processed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shutdown tuple receiver, if we started it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sendTuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dest-&gt;rShutdown(dest);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (queryDesc-&gt;totaltime)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="instrument.c.html#L84" title="executor/instrument.c:84">InstrStopNode</a>(queryDesc-&gt;totaltime, estate-&gt;es_processed);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L407" title="executor/execMain.c:407">ExecutorFinish</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This routine must be called after the last <a href="#L297" title="executor/execMain.c:297">ExecutorRun</a> call.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; It performs <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> such as firing AFTER triggers.&nbsp; It is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; separate from <a href="#L467" title="executor/execMain.c:467">ExecutorEnd</a> because EXPLAIN ANALYZE needs to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; include these actions in the total runtime.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We provide a function hook variable that lets loadable plugins<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; get control when <a href="#L407" title="executor/execMain.c:407">ExecutorFinish</a> is called.&nbsp; Such a plugin would<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; normally call <a href="#L416" title="executor/execMain.c:416">standard_ExecutorFinish</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L407">&#x200c;</a></span><span class="linkable">ExecutorFinish</span>(QueryDesc *queryDesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L67" title="executor/execMain.c:67">ExecutorFinish_hook</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L67" title="executor/execMain.c:67">ExecutorFinish_hook</a>) (queryDesc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L416" title="executor/execMain.c:416">standard_ExecutorFinish</a>(queryDesc);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L416">&#x200c;</a></span><span class="linkable">standard_ExecutorFinish</span>(QueryDesc *queryDesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sanity checks */<br/></li>
<li></span>&nbsp; &nbsp; Assert(queryDesc != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate = queryDesc-&gt;estate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(estate != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(!(estate-&gt;es_top_eflags &amp; EXEC_FLAG_EXPLAIN_ONLY));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This should be run once and only once per Executor instance */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!estate-&gt;es_finished);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Switch into per-query memory context */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(estate-&gt;es_query_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allow instrumentation of Executor overall runtime */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (queryDesc-&gt;totaltime)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="instrument.c.html#L68" title="executor/instrument.c:68">InstrStartNode</a>(queryDesc-&gt;totaltime);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Run ModifyTable nodes to completion */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1432" title="executor/execMain.c:1432">ExecPostprocessPlan</a>(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Execute queued AFTER triggers, unless told not to */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(estate-&gt;es_top_eflags &amp; EXEC_FLAG_SKIP_TRIGGERS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../commands/trigger.c.html#L5038" title="commands/trigger.c:5038">AfterTriggerEndQuery</a>(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (queryDesc-&gt;totaltime)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="instrument.c.html#L84" title="executor/instrument.c:84">InstrStopNode</a>(queryDesc-&gt;totaltime, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_finished = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L467" title="executor/execMain.c:467">ExecutorEnd</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This routine must be called at the end of execution of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; query plan<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We provide a function hook variable that lets loadable plugins<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; get control when <a href="#L467" title="executor/execMain.c:467">ExecutorEnd</a> is called.&nbsp; Such a plugin would<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; normally call <a href="#L476" title="executor/execMain.c:476">standard_ExecutorEnd</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L467">&#x200c;</a></span><span class="linkable">ExecutorEnd</span>(QueryDesc *queryDesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L68" title="executor/execMain.c:68">ExecutorEnd_hook</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L68" title="executor/execMain.c:68">ExecutorEnd_hook</a>) (queryDesc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L476" title="executor/execMain.c:476">standard_ExecutorEnd</a>(queryDesc);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L476">&#x200c;</a></span><span class="linkable">standard_ExecutorEnd</span>(QueryDesc *queryDesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sanity checks */<br/></li>
<li></span>&nbsp; &nbsp; Assert(queryDesc != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate = queryDesc-&gt;estate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(estate != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that <a href="#L407" title="executor/execMain.c:407">ExecutorFinish</a> was called, unless in EXPLAIN-only mode. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Assert is needed because <a href="#L407" title="executor/execMain.c:407">ExecutorFinish</a> is new as of 9.1, and callers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might forget to call it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(estate-&gt;es_finished ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (estate-&gt;es_top_eflags &amp; EXEC_FLAG_EXPLAIN_ONLY));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Switch into per-query memory context to run <a href="#L1478" title="executor/execMain.c:1478">ExecEndPlan</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(estate-&gt;es_query_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1478" title="executor/execMain.c:1478">ExecEndPlan</a>(queryDesc-&gt;planstate, estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do away with our snapshots */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L836" title="utils/time/snapmgr.c:836">UnregisterSnapshot</a>(estate-&gt;es_snapshot);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L836" title="utils/time/snapmgr.c:836">UnregisterSnapshot</a>(estate-&gt;es_crosscheck_snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must switch out of context <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> destroying it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release EState and per-query memory context.&nbsp; This should release<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * everything the executor has allocated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execUtils.c.html#L189" title="executor/execUtils.c:189">FreeExecutorState</a>(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset queryDesc fields that no longer point to anything */<br/></li>
<li></span>&nbsp; &nbsp; queryDesc-&gt;tupDesc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; queryDesc-&gt;estate = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; queryDesc-&gt;planstate = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; queryDesc-&gt;totaltime = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L533" title="executor/execMain.c:533">ExecutorRewind</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This routine may be called on an open queryDesc to rewind it<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; to the start.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L533">&#x200c;</a></span><span class="linkable">ExecutorRewind</span>(QueryDesc *queryDesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sanity checks */<br/></li>
<li></span>&nbsp; &nbsp; Assert(queryDesc != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate = queryDesc-&gt;estate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(estate != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* It's probably not sensible to rescan updating queries */<br/></li>
<li></span>&nbsp; &nbsp; Assert(queryDesc-&gt;operation == CMD_SELECT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Switch into per-query memory context<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(estate-&gt;es_query_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rescan plan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execAmi.c.html#L76" title="executor/execAmi.c:76">ExecReScan</a>(queryDesc-&gt;planstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L579" title="executor/execMain.c:579">ExecCheckPermissions</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Check access permissions of relations mentioned in a query<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if permissions are adequate.&nbsp; Otherwise, throws an appropriate<br/></li>
<li></span><span class="Comment"> * error if ereport_on_violation is true, or simply returns false otherwise.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this does NOT address row-level security policies (aka: RLS).&nbsp; If<br/></li>
<li></span><span class="Comment"> * rows will be returned to the user as a result of this permission check<br/></li>
<li></span><span class="Comment"> * passing, then RLS also needs to be consulted (and <a href="../utils/misc/rls.c.html#L52" title="utils/misc/rls.c:52">check_enable_rls</a>()).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See rewrite/rowsecurity.c.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: rangeTable is no longer used by us, but kept around for the hooks that<br/></li>
<li></span><span class="Comment"> * might still want to look at the RTEs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L579">&#x200c;</a></span><span class="linkable">ExecCheckPermissions</span>(List *rangeTable, List *rteperminfos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> ereport_on_violation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; Bitmapset&nbsp; *indexset = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that rteperminfos is consistent with rangeTable */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, rangeTable)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = lfirst_node(RangeTblEntry, l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;perminfoindex != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sanity checks */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Only relation RTEs and subquery RTEs that were once relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * RTEs (views) have their perminfoindex set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_RELATION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (rte-&gt;rtekind == RTE_SUBQUERY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;relkind == RELKIND_VIEW));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../parser/parse_relation.c.html#L3903" title="parser/parse_relation.c:3903">getRTEPermissionInfo</a>(rteperminfos, rte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Many-to-one mapping not allowed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(rte-&gt;perminfoindex, indexset));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexset = <a href="../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(indexset, rte-&gt;perminfoindex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* All rteperminfos are referenced */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../nodes/bitmapset.c.html#L751" title="nodes/bitmapset.c:751">bms_num_members</a>(indexset) == list_length(rteperminfos));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; foreach(l, rteperminfos)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RTEPermissionInfo *perminfo = lfirst_node(RTEPermissionInfo, l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(perminfo-&gt;relid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L643" title="executor/execMain.c:643">ExecCheckOneRelPerms</a>(perminfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ereport_on_violation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(ACLCHECK_NO_PRIV,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../catalog/objectaddress.c.html#L6057" title="catalog/objectaddress.c:6057">get_relkind_objtype</a>(<a href="../utils/cache/lsyscache.c.html#L2003" title="utils/cache/lsyscache.c:2003">get_rel_relkind</a>(perminfo-&gt;relid)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(perminfo-&gt;relid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L71" title="executor/execMain.c:71">ExecutorCheckPerms_hook</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (*<a href="#L71" title="executor/execMain.c:71">ExecutorCheckPerms_hook</a>) (rangeTable, rteperminfos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ereport_on_violation);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L643" title="executor/execMain.c:643">ExecCheckOneRelPerms</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Check access permissions for a single relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L643">&#x200c;</a></span><span class="linkable">ExecCheckOneRelPerms</span>(RTEPermissionInfo *perminfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AclMode&nbsp; &nbsp; &nbsp; &nbsp; requiredPerms;<br/></li>
<li>&nbsp; &nbsp; AclMode&nbsp; &nbsp; &nbsp; &nbsp; relPerms;<br/></li>
<li>&nbsp; &nbsp; AclMode&nbsp; &nbsp; &nbsp; &nbsp; remainingPerms;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; userid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relOid = perminfo-&gt;relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; requiredPerms = perminfo-&gt;requiredPerms;<br/></li>
<li>&nbsp; &nbsp; Assert(requiredPerms != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * userid to check as: current user unless we have a setuid indication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>() is presently fast enough that there's no harm in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calling it separately for each relation.&nbsp; If that stops being true, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could call it once in <a href="#L579" title="executor/execMain.c:579">ExecCheckPermissions</a> and pass the userid down<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from there.&nbsp; But for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, no need for the extra clutter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; userid = OidIsValid(perminfo-&gt;checkAsUser) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; perminfo-&gt;checkAsUser : <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must have *all* the requiredPerms bits, but some of the bits can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * satisfied from column-level rather than relation-level permissions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, remove <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> bits that are satisfied by relation permissions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relPerms = <a href="../catalog/aclchk.c.html#L3312" title="catalog/aclchk.c:3312">pg_class_aclmask</a>(relOid, userid, requiredPerms, ACLMASK_ALL);<br/></li>
<li>&nbsp; &nbsp; remainingPerms = requiredPerms &amp; ~relPerms;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (remainingPerms != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; col = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we lack <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> permissions that exist only as relation permissions,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we can fail straight away.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (remainingPerms &amp; ~(ACL_SELECT | ACL_INSERT | ACL_UPDATE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check to see if we have the needed privileges at column level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: failures just report a table-level error; it would be nicer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to report a column-level error if we have some but not all of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column privileges.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (remainingPerms &amp; ACL_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When the query doesn't explicitly reference <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> columns (for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * example, SELECT COUNT(*) FROM table), allow the query if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have SELECT on <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> column of the rel, as per SQL spec.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bms_is_empty(perminfo-&gt;selectedCols))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/aclchk.c.html#L3950" title="catalog/aclchk.c:3950">pg_attribute_aclcheck_all</a>(relOid, userid, ACL_SELECT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACLMASK_ANY) != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((col = <a href="../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(perminfo-&gt;selectedCols, col)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> #s are offset by FirstLowInvalidHeapAttributeNumber */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attno = col + FirstLowInvalidHeapAttributeNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attno == InvalidAttrNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Whole-row reference, must have priv on all cols */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/aclchk.c.html#L3950" title="catalog/aclchk.c:3950">pg_attribute_aclcheck_all</a>(relOid, userid, ACL_SELECT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACLMASK_ALL) != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/aclchk.c.html#L3908" title="catalog/aclchk.c:3908">pg_attribute_aclcheck</a>(relOid, attno, userid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_SELECT) != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Basically the same for the mod columns, for both INSERT and UPDATE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * privilege as specified by remainingPerms.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (remainingPerms &amp; ACL_INSERT &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L752" title="executor/execMain.c:752">ExecCheckPermissionsModified</a>(relOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; userid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perminfo-&gt;insertedCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_INSERT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (remainingPerms &amp; ACL_UPDATE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L752" title="executor/execMain.c:752">ExecCheckPermissionsModified</a>(relOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; userid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perminfo-&gt;updatedCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_UPDATE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L752" title="executor/execMain.c:752">ExecCheckPermissionsModified</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Check INSERT or UPDATE access permissions for a single relation (these<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; are processed uniformly).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L752">&#x200c;</a></span><span class="linkable">ExecCheckPermissionsModified</span>(Oid relOid, Oid userid, Bitmapset *modifiedCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AclMode requiredPerms)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; col = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When the query doesn't explicitly update <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> columns, allow the query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we have permission on <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> column of the rel.&nbsp; This is to handle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SELECT FOR UPDATE as well as possible corner cases in UPDATE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bms_is_empty(modifiedCols))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/aclchk.c.html#L3950" title="catalog/aclchk.c:3950">pg_attribute_aclcheck_all</a>(relOid, userid, requiredPerms,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACLMASK_ANY) != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((col = <a href="../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(modifiedCols, col)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> #s are offset by FirstLowInvalidHeapAttributeNumber */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attno = col + FirstLowInvalidHeapAttributeNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attno == InvalidAttrNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* whole-row reference can't happen here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;whole-row update is not implemented&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/aclchk.c.html#L3908" title="catalog/aclchk.c:3908">pg_attribute_aclcheck</a>(relOid, attno, userid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; requiredPerms) != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check that the query does not imply <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> writes to non-temp tables;<br/></li>
<li></span><span class="Comment"> * unless we're in parallel mode, in which case don't even allow writes<br/></li>
<li></span><span class="Comment"> * to temp tables.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: in a Hot Standby this would need to reject writes to temp<br/></li>
<li></span><span class="Comment"> * tables just as we do in parallel mode; but an HS standby can't have created<br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> temp tables in the first place, so no need to check that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L799">&#x200c;</a></span><span class="linkable">ExecCheckXactReadOnly</span>(PlannedStmt *plannedstmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fail if write permissions are requested in parallel mode for table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (temp or non-temp), otherwise fail for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-temp table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, plannedstmt-&gt;permInfos)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RTEPermissionInfo *perminfo = lfirst_node(RTEPermissionInfo, l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((perminfo-&gt;requiredPerms &amp; (~ACL_SELECT)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/namespace.c.html#L3634" title="catalog/namespace.c:3634">isTempNamespace</a>(<a href="../utils/cache/lsyscache.c.html#L1952" title="utils/cache/lsyscache.c:1952">get_rel_namespace</a>(perminfo-&gt;relid)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/utility.c.html#L404" title="tcop/utility.c:404">PreventCommandIfReadOnly</a>(CreateCommandName((Node *) plannedstmt));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plannedstmt-&gt;commandType != CMD_SELECT || plannedstmt-&gt;hasModifyingCTE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/utility.c.html#L422" title="tcop/utility.c:422">PreventCommandIfParallelMode</a>(CreateCommandName((Node *) plannedstmt));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L833" title="executor/execMain.c:833">InitPlan</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Initializes the query plan: open files, allocate storage<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and start up the rule manager<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L833">&#x200c;</a></span><span class="linkable">InitPlan</span>(QueryDesc *queryDesc, <span class="Type">int</span> eflags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CmdType&nbsp; &nbsp; &nbsp; &nbsp; operation = queryDesc-&gt;operation;<br/></li>
<li>&nbsp; &nbsp; PlannedStmt *plannedstmt = queryDesc-&gt;plannedstmt;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *plan = plannedstmt-&gt;planTree;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rangeTable = plannedstmt-&gt;rtable;<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate = queryDesc-&gt;estate;<br/></li>
<li>&nbsp; &nbsp; PlanState&nbsp; *planstate;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupType;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do permissions checks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L579" title="executor/execMain.c:579">ExecCheckPermissions</a>(rangeTable, plannedstmt-&gt;permInfos, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the node's execution state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execUtils.c.html#L728" title="executor/execUtils.c:728">ExecInitRangeTable</a>(estate, rangeTable, plannedstmt-&gt;permInfos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_plannedstmt = plannedstmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Next, build the ExecRowMark array from the PlanRowMark(s), if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plannedstmt-&gt;rowMarks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_rowmarks = (ExecRowMark **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(estate-&gt;es_range_table_size * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ExecRowMark *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, plannedstmt-&gt;rowMarks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlanRowMark *rc = (PlanRowMark *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; relation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecRowMark *erm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore &quot;parent&quot; rowmarks; they are irrelevant at runtime */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc-&gt;isParent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* get relation's OID (will produce InvalidOid if subquery) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = exec_rt_fetch(rc-&gt;rti, estate)-&gt;relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* open relation, if we need to access it for this mark type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (rc-&gt;markType)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ROW_MARK_EXCLUSIVE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ROW_MARK_NOKEYEXCLUSIVE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ROW_MARK_SHARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ROW_MARK_KEYSHARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ROW_MARK_REFERENCE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation = <a href="execUtils.c.html#L762" title="executor/execUtils.c:762">ExecGetRangeTableRelation</a>(estate, rc-&gt;rti);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ROW_MARK_COPY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no physical table access is required */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized markType: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, rc-&gt;markType);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check that relation is a legal target for marking */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1134" title="executor/execMain.c:1134">CheckValidRowMarkRel</a>(relation, rc-&gt;markType);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; erm = (ExecRowMark *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ExecRowMark));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; erm-&gt;relation = relation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; erm-&gt;relid = relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; erm-&gt;rti = rc-&gt;rti;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; erm-&gt;prti = rc-&gt;prti;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; erm-&gt;rowmarkId = rc-&gt;rowmarkId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; erm-&gt;markType = rc-&gt;markType;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; erm-&gt;strength = rc-&gt;strength;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; erm-&gt;waitPolicy = rc-&gt;waitPolicy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; erm-&gt;ermActive = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSetInvalid(&amp;(erm-&gt;curCtid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; erm-&gt;ermExtra = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(erm-&gt;rti &gt; <span class="Constant">0</span> &amp;&amp; erm-&gt;rti &lt;= estate-&gt;es_range_table_size &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; estate-&gt;es_rowmarks[erm-&gt;rti - <span class="Constant">1</span>] == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_rowmarks[erm-&gt;rti - <span class="Constant">1</span>] = erm;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the executor's tuple table to empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; estate-&gt;es_tupleTable = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* signal that this EState is not used for EPQ */<br/></li>
<li></span>&nbsp; &nbsp; estate-&gt;es_epq_active = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize private state information for each SubPlan.&nbsp; We must do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> running <a href="execProcnode.c.html#L142" title="executor/execProcnode.c:142">ExecInitNode</a> on the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> query tree, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="nodeSubplan.c.html#L823" title="executor/nodeSubplan.c:823">ExecInitSubPlan</a> expects to be able to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> these entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(estate-&gt;es_subplanstates == NIL);<br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* subplan indices count from 1 */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, plannedstmt-&gt;subplans)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan = (Plan *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlanState&nbsp; *subplanstate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sp_eflags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A subplan will never need to do BACKWARD scan nor MARK/RESTORE. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it is a parameterless subplan (not initplan), we suggest that it be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prepared to handle REWIND efficiently; otherwise there is no need.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sp_eflags = eflags<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp; ~(EXEC_FLAG_REWIND | EXEC_FLAG_BACKWARD | EXEC_FLAG_MARK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(i, plannedstmt-&gt;rewindPlanIDs))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sp_eflags |= EXEC_FLAG_REWIND;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subplanstate = <a href="execProcnode.c.html#L142" title="executor/execProcnode.c:142">ExecInitNode</a>(subplan, estate, sp_eflags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_subplanstates = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(estate-&gt;es_subplanstates,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subplanstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the private state information for all the nodes in the query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tree.&nbsp; This opens files, allocates storage and leaves us ready to start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processing tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; planstate = <a href="execProcnode.c.html#L142" title="executor/execProcnode.c:142">ExecInitNode</a>(plan, estate, eflags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the tuple descriptor describing the type of tuples to return.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tupType = <a href="execUtils.c.html#L493" title="executor/execUtils.c:493">ExecGetResultType</a>(planstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the junk filter if needed.&nbsp; SELECT queries need a filter if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there are <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> junk attrs in the top-level tlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (operation == CMD_SELECT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; junk_filter_needed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *tlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(tlist, plan-&gt;targetlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(tlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; junk_filter_needed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (junk_filter_needed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JunkFilter *j;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot = <a href="execTuples.c.html#L1918" title="executor/execTuples.c:1918">ExecInitExtraTupleSlot</a>(estate, <span class="Constant">NULL</span>, &amp;<a href="execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j = <a href="execJunk.c.html#L60" title="executor/execJunk.c:60">ExecInitJunkFilter</a>(planstate-&gt;plan-&gt;targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_junkFilter = j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Want to return the cleaned tuple type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupType = j-&gt;jf_cleanTupType;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; queryDesc-&gt;tupDesc = tupType;<br/></li>
<li>&nbsp; &nbsp; queryDesc-&gt;planstate = planstate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check that a proposed result relation is a legal target for the operation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Generally the parser and/or <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> should have noticed <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such mistake<br/></li>
<li></span><span class="Comment"> * already, but let's make sure.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For MERGE, mergeActions is the list of actions that may be performed.&nbsp; The<br/></li>
<li></span><span class="Comment"> * result relation is required to support every action, regardless of whether<br/></li>
<li></span><span class="Comment"> * or not they are all executed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: when changing this function, you probably also need to look at<br/></li>
<li></span><span class="Comment"> * <a href="#L1134" title="executor/execMain.c:1134">CheckValidRowMarkRel</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1026">&#x200c;</a></span><span class="linkable">CheckValidResultRel</span>(ResultRelInfo *resultRelInfo, CmdType operation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *mergeActions)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; resultRel = resultRelInfo-&gt;ri_RelationDesc;<br/></li>
<li>&nbsp; &nbsp; FdwRoutine *fdwroutine;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (resultRel-&gt;rd_rel-&gt;relkind)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_PARTITIONED_TABLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execReplication.c.html#L652" title="executor/execReplication.c:652">CheckCmdReplicaIdentity</a>(resultRel, operation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_SEQUENCE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot change sequence </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(resultRel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_TOASTVALUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot change TOAST relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(resultRel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_VIEW:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Okay only if there's a suitable INSTEAD OF <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.&nbsp; Otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * complain, but omit <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a> because we haven't got the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * information handy (and given that it really shouldn't happen,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's not worth great exertion to get).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../rewrite/rewriteHandler.c.html#L2486" title="rewrite/rewriteHandler.c:2486">view_has_instead_trigger</a>(resultRel, operation, mergeActions))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../rewrite/rewriteHandler.c.html#L3084" title="rewrite/rewriteHandler.c:3084">error_view_not_updatable</a>(resultRel, operation, mergeActions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_MATVIEW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../commands/matview.c.html#L936" title="commands/matview.c:936">MatViewIncrementalMaintenanceIsEnabled</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot change materialized view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(resultRel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_FOREIGN_TABLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Okay only if the FDW supports it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdwroutine = resultRelInfo-&gt;ri_FdwRoutine;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (operation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fdwroutine-&gt;ExecForeignInsert == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot insert into foreign table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(resultRel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fdwroutine-&gt;IsForeignRelUpdatable != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (fdwroutine-&gt;IsForeignRelUpdatable(resultRel) &amp; (<span class="Constant">1</span> &lt;&lt; CMD_INSERT)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;foreign table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not allow inserts&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(resultRel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fdwroutine-&gt;ExecForeignUpdate == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot update foreign table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(resultRel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fdwroutine-&gt;IsForeignRelUpdatable != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (fdwroutine-&gt;IsForeignRelUpdatable(resultRel) &amp; (<span class="Constant">1</span> &lt;&lt; CMD_UPDATE)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;foreign table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not allow updates&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(resultRel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fdwroutine-&gt;ExecForeignDelete == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot delete from foreign table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(resultRel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fdwroutine-&gt;IsForeignRelUpdatable != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (fdwroutine-&gt;IsForeignRelUpdatable(resultRel) &amp; (<span class="Constant">1</span> &lt;&lt; CMD_DELETE)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;foreign table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not allow deletes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(resultRel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized CmdType: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) operation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot change relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(resultRel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check that a proposed rowmark target relation is a legal target<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In most cases parser and/or <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> should have noticed this already, but<br/></li>
<li></span><span class="Comment"> * they don't cover all cases.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1134">&#x200c;</a></span><span class="linkable">CheckValidRowMarkRel</span>(Relation rel, RowMarkType markType)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FdwRoutine *fdwroutine;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (rel-&gt;rd_rel-&gt;relkind)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_PARTITIONED_TABLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_SEQUENCE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must disallow this because we don't <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> sequences */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot lock rows in sequence </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_TOASTVALUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We could allow this, but there seems no good reason to */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot lock rows in TOAST relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_VIEW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Should not get here; <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> should have expanded the view */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot lock rows in view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_MATVIEW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allow referencing a matview, but not actual locking clauses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (markType != ROW_MARK_REFERENCE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot lock rows in materialized view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_FOREIGN_TABLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Okay only if the FDW supports it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdwroutine = <a href="../foreign/foreign.c.html#L432" title="foreign/foreign.c:432">GetFdwRoutineForRelation</a>(rel, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fdwroutine-&gt;RefetchForeignRow == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot lock rows in foreign table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot lock rows in relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize ResultRelInfo data for one result relation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caution: <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> Postgres 9.1, this function included the relkind checking<br/></li>
<li></span><span class="Comment"> * that's <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> in <a href="#L1026" title="executor/execMain.c:1026">CheckValidResultRel</a>, and it also did <a href="execIndexing.c.html#L156" title="executor/execIndexing.c:156">ExecOpenIndices</a> if<br/></li>
<li></span><span class="Comment"> * appropriate.&nbsp; Be sure callers cover those needs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1199">&#x200c;</a></span><span class="linkable">InitResultRelInfo</span>(ResultRelInfo *resultRelInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation resultRelationDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index resultRelationIndex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResultRelInfo *partition_root_rri,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> instrument_options)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemSet(resultRelInfo, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ResultRelInfo));<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;type = T_ResultRelInfo;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_RangeTableIndex = resultRelationIndex;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_RelationDesc = resultRelationDesc;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_NumIndices = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_IndexRelationDescs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_IndexRelationInfo = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make a copy so as not to depend on relcache info not changing... */<br/></li>
<li></span>&nbsp; &nbsp; resultRelInfo-&gt;ri_TrigDesc = <a href="../commands/trigger.c.html#L2085" title="commands/trigger.c:2085">CopyTriggerDesc</a>(resultRelationDesc-&gt;trigdesc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (resultRelInfo-&gt;ri_TrigDesc)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = resultRelInfo-&gt;ri_TrigDesc-&gt;numtriggers;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; resultRelInfo-&gt;ri_TrigFunctions = (FmgrInfo *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(n * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FmgrInfo));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; resultRelInfo-&gt;ri_TrigWhenExprs = (ExprState **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(n * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ExprState *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (instrument_options)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultRelInfo-&gt;ri_TrigInstrument = <a href="instrument.c.html#L31" title="executor/instrument.c:31">InstrAlloc</a>(n, instrument_options, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; resultRelInfo-&gt;ri_TrigFunctions = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; resultRelInfo-&gt;ri_TrigWhenExprs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; resultRelInfo-&gt;ri_TrigInstrument = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (resultRelationDesc-&gt;rd_rel-&gt;relkind == RELKIND_FOREIGN_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; resultRelInfo-&gt;ri_FdwRoutine = <a href="../foreign/foreign.c.html#L432" title="foreign/foreign.c:432">GetFdwRoutineForRelation</a>(resultRelationDesc, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; resultRelInfo-&gt;ri_FdwRoutine = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The following fields are set later if needed */<br/></li>
<li></span>&nbsp; &nbsp; resultRelInfo-&gt;ri_RowIdAttNo = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_extraUpdatedCols = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_projectNew = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_newTupleSlot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_oldTupleSlot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_projectNewInfoValid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_FdwState = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_usesFdwDirectModify = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_ConstraintExprs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_GeneratedExprsI = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_GeneratedExprsU = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_projectReturning = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_onConflictArbiterIndexes = NIL;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_onConflict = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_ReturningSlot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_TrigOldSlot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_TrigNewSlot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_MergeActions[MERGE_WHEN_MATCHED] = NIL;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_MergeActions[MERGE_WHEN_NOT_MATCHED_BY_SOURCE] = NIL;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_MergeActions[MERGE_WHEN_NOT_MATCHED_BY_TARGET] = NIL;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_MergeJoinCondition = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Only <a href="execPartition.c.html#L495" title="executor/execPartition.c:495">ExecInitPartitionInfo</a>() and <a href="execPartition.c.html#L1092" title="executor/execPartition.c:1092">ExecInitPartitionDispatchInfo</a>() pass<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-NULL partition_root_rri.&nbsp; For child relations that are part of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initial query rather than being dynamically added by tuple routing,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this field is filled in <a href="nodeModifyTable.c.html#L4195" title="executor/nodeModifyTable.c:4195">ExecInitModifyTable</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; resultRelInfo-&gt;ri_RootResultRelInfo = partition_root_rri;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set by <a href="execUtils.c.html#L1232" title="executor/execUtils.c:1232">ExecGetRootToChildMap</a> */<br/></li>
<li></span>&nbsp; &nbsp; resultRelInfo-&gt;ri_RootToChildMap = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_RootToChildMapValid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set by <a href="execPartition.c.html#L984" title="executor/execPartition.c:984">ExecInitRoutingInfo</a> */<br/></li>
<li></span>&nbsp; &nbsp; resultRelInfo-&gt;ri_PartitionTupleSlot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_ChildToRootMap = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_ChildToRootMapValid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_CopyMultiInsertBuffer = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1296" title="executor/execMain.c:1296">ExecGetTriggerResultRel</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get a ResultRelInfo for a <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> target relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Most of the time, triggers are fired on one of the result relations of the<br/></li>
<li></span><span class="Comment"> * query, and so we can just return a member of the es_result_relations array,<br/></li>
<li></span><span class="Comment"> * or the es_tuple_routing_result_relations list (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>). (Note: in self-join<br/></li>
<li></span><span class="Comment"> * situations there might be multiple members with the same OID; if so it<br/></li>
<li></span><span class="Comment"> * doesn't matter which one we pick.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * However, it is sometimes necessary to fire triggers on other relations;<br/></li>
<li></span><span class="Comment"> * this happens mainly when an RI update <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> queues additional triggers<br/></li>
<li></span><span class="Comment"> * on other relations, which will be processed in the context of the outer<br/></li>
<li></span><span class="Comment"> * query.&nbsp; For efficiency's sake, we want to have a ResultRelInfo for those<br/></li>
<li></span><span class="Comment"> * triggers too; that can avoid repeated re-opening of the relation.&nbsp; (It<br/></li>
<li></span><span class="Comment"> * also provides a way for EXPLAIN ANALYZE to report the runtimes of such<br/></li>
<li></span><span class="Comment"> * triggers.)&nbsp; So we make additional ResultRelInfo's as needed, and save them<br/></li>
<li></span><span class="Comment"> * in es_trig_target_relations.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ResultRelInfo *<br/></li>
<li><a id="L1296">&#x200c;</a><span class="linkable">ExecGetTriggerResultRel</span>(EState *estate, Oid relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResultRelInfo *rootRelInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ResultRelInfo *rInfo;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Search through the query result relations */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, estate-&gt;es_opened_result_relations)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rInfo = lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationGetRelid(rInfo-&gt;ri_RelationDesc) == relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> rInfo;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Search through the result relations that were created during tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * routing, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, estate-&gt;es_tuple_routing_result_relations)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rInfo = (ResultRelInfo *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationGetRelid(rInfo-&gt;ri_RelationDesc) == relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> rInfo;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nope, but maybe we already made an extra ResultRelInfo for it */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, estate-&gt;es_trig_target_relations)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rInfo = (ResultRelInfo *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationGetRelid(rInfo-&gt;ri_RelationDesc) == relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> rInfo;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nope, so we need a new one */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open the target relation's relcache entry.&nbsp; We assume that an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appropriate lock is still held by the backend from whenever the <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * event got queued, so we need take no new lock here.&nbsp; Also, we need not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recheck the relkind, so no need for <a href="#L1026" title="executor/execMain.c:1026">CheckValidResultRel</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(relid, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make the new entry in the right context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(estate-&gt;es_query_cxt);<br/></li>
<li>&nbsp; &nbsp; rInfo = makeNode(ResultRelInfo);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1199" title="executor/execMain.c:1199">InitResultRelInfo</a>(rInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dummy rangetable index */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rootRelInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_instrument);<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_trig_target_relations =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(estate-&gt;es_trig_target_relations, rInfo);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Currently, we don't need <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index information in ResultRelInfos used<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only for triggers, so no need to call <a href="execIndexing.c.html#L156" title="executor/execIndexing.c:156">ExecOpenIndices</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rInfo;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the ancestor relations of a given leaf partition result relation<br/></li>
<li></span><span class="Comment"> * up to and including the query's root target relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These work much like the ones opened by <a href="#L1296" title="executor/execMain.c:1296">ExecGetTriggerResultRel</a>, except<br/></li>
<li></span><span class="Comment"> * that we need to keep them in a separate list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These are closed by <a href="#L1517" title="executor/execMain.c:1517">ExecCloseResultRelations</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1372">&#x200c;</a><span class="linkable">ExecGetAncestorResultRels</span>(EState *estate, ResultRelInfo *resultRelInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ResultRelInfo *rootRelInfo = resultRelInfo-&gt;ri_RootResultRelInfo;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; partRel = resultRelInfo-&gt;ri_RelationDesc;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rootRelOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!partRel-&gt;rd_rel-&gt;relispartition)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> ancestors of a non-partition result relation&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(rootRelInfo != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; rootRelOid = RelationGetRelid(rootRelInfo-&gt;ri_RelationDesc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (resultRelInfo-&gt;ri_ancestorResultRels == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *oids = <a href="../catalog/partition.c.html#L134" title="catalog/partition.c:134">get_partition_ancestors</a>(RelationGetRelid(partRel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *ancResultRels = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, oids)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ancOid = lfirst_oid(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; ancRel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResultRelInfo *rInfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore the root ancestor here, and use ri_RootResultRelInfo<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (below) for it instead.&nbsp; Also, we stop climbing up the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hierarchy when we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the table that was mentioned in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ancOid == rootRelOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * All ancestors up to the root target relation must have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * locked by the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> or <a href="../utils/cache/plancache.c.html#L1772" title="utils/cache/plancache.c:1772">AcquireExecutorLocks</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ancRel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(ancOid, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rInfo = makeNode(ResultRelInfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dummy rangetable index */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1199" title="executor/execMain.c:1199">InitResultRelInfo</a>(rInfo, ancRel, <span class="Constant">0</span>, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_instrument);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ancResultRels = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(ancResultRels, rInfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ancResultRels = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(ancResultRels, rootRelInfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; resultRelInfo-&gt;ri_ancestorResultRels = ancResultRels;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We must have found some ancestor */<br/></li>
<li></span>&nbsp; &nbsp; Assert(resultRelInfo-&gt;ri_ancestorResultRels != NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> resultRelInfo-&gt;ri_ancestorResultRels;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1432" title="executor/execMain.c:1432">ExecPostprocessPlan</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Give plan nodes a final chance to execute <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> shutdown<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1432">&#x200c;</a></span><span class="linkable">ExecPostprocessPlan</span>(EState *estate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure nodes run forward.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; estate-&gt;es_direction = ForwardScanDirection;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Run <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> secondary ModifyTable nodes to completion, in case the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * query did not fetch all rows from them.&nbsp; (We do this to ensure that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * such nodes have predictable results.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, estate-&gt;es_auxmodifytables)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlanState&nbsp; *ps = (PlanState *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset the per-output-tuple exprcontext each time */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResetPerTupleExprContext(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot = ExecProcNode(ps);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TupIsNull(slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1478" title="executor/execMain.c:1478">ExecEndPlan</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Cleans up the query plan -- closes files and frees up storage<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: we are no longer very worried about freeing storage per se<br/></li>
<li></span><span class="Comment"> * in this code; <a href="execUtils.c.html#L189" title="executor/execUtils.c:189">FreeExecutorState</a> should be guaranteed to release all<br/></li>
<li></span><span class="Comment"> * memory that needs to be released.&nbsp; What we are worried about doing<br/></li>
<li></span><span class="Comment"> * is closing relations and dropping buffer pins.&nbsp; Thus, for example,<br/></li>
<li></span><span class="Comment"> * tuple tables must be cleared or dropped to ensure pins are released.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1478">&#x200c;</a></span><span class="linkable">ExecEndPlan</span>(PlanState *planstate, EState *estate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shut down the node-type-specific query processing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execProcnode.c.html#L557" title="executor/execProcnode.c:557">ExecEndNode</a>(planstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for subplans too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, estate-&gt;es_subplanstates)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlanState&nbsp; *subplanstate = (PlanState *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execProcnode.c.html#L557" title="executor/execProcnode.c:557">ExecEndNode</a>(subplanstate);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * destroy the executor's tuple table.&nbsp; Actually we only care about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * releasing buffer pins and tupdesc refcounts; there's no need to <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the TupleTableSlots, since the containing memory context is about to go<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * away anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execTuples.c.html#L1278" title="executor/execTuples.c:1278">ExecResetTupleTable</a>(estate-&gt;es_tupleTable, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Close <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Relations that have been opened for <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> table entries or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * result relations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1517" title="executor/execMain.c:1517">ExecCloseResultRelations</a>(estate);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1577" title="executor/execMain.c:1577">ExecCloseRangeTableRelations</a>(estate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Close <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> relations that have been opened for ResultRelInfos.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1517">&#x200c;</a></span><span class="linkable">ExecCloseResultRelations</span>(EState *estate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * close indexes of result relation(s) if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.&nbsp; (Rels themselves are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * closed in <a href="#L1577" title="executor/execMain.c:1577">ExecCloseRangeTableRelations</a>())<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In addition, close the stub RTs that may be in each resultrel's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ri_ancestorResultRels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, estate-&gt;es_opened_result_relations)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ResultRelInfo *resultRelInfo = lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execIndexing.c.html#L231" title="executor/execIndexing.c:231">ExecCloseIndices</a>(resultRelInfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, resultRelInfo-&gt;ri_ancestorResultRels)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResultRelInfo *rInfo = lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ancestors with RTI &gt; 0 (should only be the root ancestor) are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * closed by <a href="#L1577" title="executor/execMain.c:1577">ExecCloseRangeTableRelations</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rInfo-&gt;ri_RangeTableIndex &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rInfo-&gt;ri_RelationDesc, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> relations that have been opened by <a href="#L1296" title="executor/execMain.c:1296">ExecGetTriggerResultRel</a>(). */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, estate-&gt;es_trig_target_relations)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ResultRelInfo *resultRelInfo = (ResultRelInfo *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Assert this is a &quot;dummy&quot; ResultRelInfo, see above.&nbsp; Otherwise we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might be issuing a duplicate close against a Relation opened by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="execUtils.c.html#L762" title="executor/execUtils.c:762">ExecGetRangeTableRelation</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(resultRelInfo-&gt;ri_RangeTableIndex == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since <a href="#L1296" title="executor/execMain.c:1296">ExecGetTriggerResultRel</a> doesn't call <a href="execIndexing.c.html#L156" title="executor/execIndexing.c:156">ExecOpenIndices</a> for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * these rels, we needn't call <a href="execIndexing.c.html#L231" title="executor/execIndexing.c:231">ExecCloseIndices</a> either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(resultRelInfo-&gt;ri_NumIndices == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(resultRelInfo-&gt;ri_RelationDesc, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Close all relations opened by <a href="execUtils.c.html#L762" title="executor/execUtils.c:762">ExecGetRangeTableRelation</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We do not release <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> locks we might hold on those rels.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1577">&#x200c;</a></span><span class="linkable">ExecCloseRangeTableRelations</span>(EState *estate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; estate-&gt;es_range_table_size; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (estate-&gt;es_relations[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(estate-&gt;es_relations[i], NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1601" title="executor/execMain.c:1601">ExecutePlan</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Processes the query plan until we have retrieved 'numberTuples' tuples,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; moving in the specified direction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Runs to completion if numberTuples is 0<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the ctid attribute is a 'junk' attribute that is removed <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment"> * user can see it<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1601">&#x200c;</a></span><span class="linkable">ExecutePlan</span>(EState *estate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlanState *planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> use_parallel_mode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CmdType operation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> sendTuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint64 numberTuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanDirection direction,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DestReceiver *dest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> execute_once)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; current_tuple_count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> local variables<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; current_tuple_count = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set the direction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; estate-&gt;es_direction = direction;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the plan might potentially be executed multiple times, we must force<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it to run without parallelism, because we might exit early.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!execute_once)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; use_parallel_mode = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_use_parallel_mode = use_parallel_mode;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (use_parallel_mode)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1048" title="access/transam/xact.c:1048">EnterParallelMode</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop until we've processed the proper number of tuples from the plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset the per-output-tuple exprcontext */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ResetPerTupleExprContext(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Execute the plan and obtain a tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; slot = ExecProcNode(planstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if the tuple is null, then we assume there is nothing more to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * process so we just end the loop...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TupIsNull(slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have a junk filter, then project a new tuple with the junk<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * removed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Store this new &quot;clean&quot; tuple in the junkfilter's resultSlot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Formerly, we stored it back over the &quot;dirty&quot; tuple, which is WRONG<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because that tuple slot has the wrong descriptor.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (estate-&gt;es_junkFilter != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot = <a href="execJunk.c.html#L247" title="executor/execJunk.c:247">ExecFilterJunk</a>(estate-&gt;es_junkFilter, slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are supposed to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the tuple somewhere, do so. (In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * practice, this is probably always the case at this point.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sendTuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are not able to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the tuple, we assume the destination<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * has closed and no more tuples can be sent. If that's the case,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end the loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!dest-&gt;receiveSlot(slot, dest))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Count tuples processed, if this is a SELECT.&nbsp; (For other operation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * types, the ModifyTable plan node must count the appropriate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * events.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (operation == CMD_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (estate-&gt;es_processed)++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check our tuple count.. if we've processed the proper number then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * quit, else loop again and process more tuples.&nbsp; Zero numberTuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * means no limit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; current_tuple_count++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (numberTuples &amp;&amp; numberTuples == current_tuple_count)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we know we won't need to back up, we can release resources at this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(estate-&gt;es_top_eflags &amp; EXEC_FLAG_BACKWARD))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execProcnode.c.html#L767" title="executor/execProcnode.c:767">ExecShutdownNode</a>(planstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (use_parallel_mode)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1061" title="access/transam/xact.c:1061">ExitParallelMode</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1717" title="executor/execMain.c:1717">ExecRelCheck</a> --- check that tuple meets constraints for result relation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns NULL if OK, else name of failed check constraint<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1717">&#x200c;</a><span class="linkable">ExecRelCheck</span>(ResultRelInfo *resultRelInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *slot, EState *estate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = resultRelInfo-&gt;ri_RelationDesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncheck = rel-&gt;rd_att-&gt;constr-&gt;num_check;<br/></li>
<li>&nbsp; &nbsp; ConstrCheck *check = rel-&gt;rd_att-&gt;constr-&gt;check;<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/cache/relcache.c.html#L4539" title="utils/cache/relcache.c:4539">CheckConstraintFetch</a> let this pass with only a warning, but <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should fail rather than possibly failing to enforce an important<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ncheck != rel-&gt;rd_rel-&gt;relchecks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant"> pg_constraint record(s) missing for relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;rd_rel-&gt;relchecks - ncheck, RelationGetRelationName(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If first time through for this result relation, build expression<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nodetrees for rel's constraint expressions.&nbsp; Keep them in the per-query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory context so they'll survive throughout the query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (resultRelInfo-&gt;ri_ConstraintExprs == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldContext = MemoryContextSwitchTo(estate-&gt;es_query_cxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; resultRelInfo-&gt;ri_ConstraintExprs =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ExprState **) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncheck * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ExprState *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ncheck; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *checkconstr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checkconstr = <a href="../nodes/read.c.html#L90" title="nodes/read.c:90">stringToNode</a>(check[i].ccbin);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultRelInfo-&gt;ri_ConstraintExprs[i] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execExpr.c.html#L739" title="executor/execExpr.c:739">ExecPrepareExpr</a>(checkconstr, estate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We will use the EState's per-tuple context for evaluating constraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expressions (creating it if it's not already there).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; econtext = GetPerTupleExprContext(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Arrange for econtext's scan tuple to be the tuple under test */<br/></li>
<li></span>&nbsp; &nbsp; econtext-&gt;ecxt_scantuple = slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And evaluate the constraints */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ncheck; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExprState&nbsp; *checkconstr = resultRelInfo-&gt;ri_ConstraintExprs[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: SQL specifies that a NULL result from a constraint expression<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is not to be treated as a failure.&nbsp; Therefore, use <a href="execExpr.c.html#L846" title="executor/execExpr.c:846">ExecCheck</a> not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ExecQual.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="execExpr.c.html#L846" title="executor/execExpr.c:846">ExecCheck</a>(checkconstr, econtext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> check[i].ccname;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NULL result means no error */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1792" title="executor/execMain.c:1792">ExecPartitionCheck</a> --- check that tuple meets the partition constraint.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if it meets the partition constraint.&nbsp; If the constraint<br/></li>
<li></span><span class="Comment"> * fails and we're asked to emit an error, do so and don't return; otherwise<br/></li>
<li></span><span class="Comment"> * return false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1792">&#x200c;</a></span><span class="linkable">ExecPartitionCheck</span>(ResultRelInfo *resultRelInfo, TupleTableSlot *slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EState *estate, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> emitError)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; success;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If first time through, build expression state tree for the partition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check expression.&nbsp; (In the corner case where the partition check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expression is empty, ie there's a default partition and nothing else,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we'll be fooled into executing this code each time through.&nbsp; But it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pretty darn cheap in that case, so we don't worry about it.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (resultRelInfo-&gt;ri_PartitionCheckExpr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ensure that the qual tree and prepared expression are in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * query-lifespan context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcxt = MemoryContextSwitchTo(estate-&gt;es_query_cxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *qual = <a href="../utils/cache/partcache.c.html#L277" title="utils/cache/partcache.c:277">RelationGetPartitionQual</a>(resultRelInfo-&gt;ri_RelationDesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; resultRelInfo-&gt;ri_PartitionCheckExpr = <a href="execExpr.c.html#L790" title="executor/execExpr.c:790">ExecPrepareCheck</a>(qual, estate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We will use the EState's per-tuple context for evaluating constraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expressions (creating it if it's not already there).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; econtext = GetPerTupleExprContext(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Arrange for econtext's scan tuple to be the tuple under test */<br/></li>
<li></span>&nbsp; &nbsp; econtext-&gt;ecxt_scantuple = slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As in case of the cataloged constraints, we treat a NULL result as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * success here, not a failure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; success = <a href="execExpr.c.html#L846" title="executor/execExpr.c:846">ExecCheck</a>(resultRelInfo-&gt;ri_PartitionCheckExpr, econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if asked to emit error, don't actually return on failure */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!success &amp;&amp; emitError)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1845" title="executor/execMain.c:1845">ExecPartitionCheckEmitError</a>(resultRelInfo, slot, estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> success;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1845" title="executor/execMain.c:1845">ExecPartitionCheckEmitError</a> - Form and emit an error message after a failed<br/></li>
<li></span><span class="Comment"> * partition constraint check.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1845">&#x200c;</a></span><span class="linkable">ExecPartitionCheckEmitError</span>(ResultRelInfo *resultRelInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EState *estate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root_relid;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *val_desc;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *modifiedCols;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the tuple has been routed, it's been converted to the partition's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rowtype, which might differ from the root table's.&nbsp; We must convert it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * back to the root table's rowtype so that val_desc in the error message<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matches the input tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (resultRelInfo-&gt;ri_RootResultRelInfo)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ResultRelInfo *rootrel = resultRelInfo-&gt;ri_RootResultRelInfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; old_tupdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrMap&nbsp; &nbsp; *map;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root_relid = RelationGetRelid(rootrel-&gt;ri_RelationDesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupdesc = RelationGetDescr(rootrel-&gt;ri_RelationDesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; old_tupdesc = RelationGetDescr(resultRelInfo-&gt;ri_RelationDesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* a reverse map */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; map = <a href="../access/common/attmap.c.html#L263" title="access/common/attmap.c:263">build_attrmap_by_name_if_req</a>(old_tupdesc, tupdesc, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Partition-specific slot's tupdesc can't be changed, so allocate a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (map != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot = <a href="../access/common/tupconvert.c.html#L192" title="access/common/tupconvert.c:192">execute_attr_map_slot</a>(map, slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="execTuples.c.html#L1199" title="executor/execTuples.c:1199">MakeTupleTableSlot</a>(tupdesc, &amp;<a href="execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; modifiedCols = <a href="../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(<a href="execUtils.c.html#L1267" title="executor/execUtils.c:1267">ExecGetInsertedCols</a>(rootrel, estate),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="execUtils.c.html#L1288" title="executor/execUtils.c:1288">ExecGetUpdatedCols</a>(rootrel, estate));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root_relid = RelationGetRelid(resultRelInfo-&gt;ri_RelationDesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupdesc = RelationGetDescr(resultRelInfo-&gt;ri_RelationDesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; modifiedCols = <a href="../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(<a href="execUtils.c.html#L1267" title="executor/execUtils.c:1267">ExecGetInsertedCols</a>(resultRelInfo, estate),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="execUtils.c.html#L1288" title="executor/execUtils.c:1288">ExecGetUpdatedCols</a>(resultRelInfo, estate));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; val_desc = <a href="#L2214" title="executor/execMain.c:2214">ExecBuildSlotValueDescription</a>(root_relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; modifiedCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">64</span>);<br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CHECK_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;new row for relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> violates partition constraint&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(resultRelInfo-&gt;ri_RelationDesc)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; val_desc ? <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failing row contains </span><span class="Special">%s</span><span class="Constant">.&quot;</span>, val_desc) : <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/relcache.c.html#L5945" title="utils/cache/relcache.c:5945">errtable</a>(resultRelInfo-&gt;ri_RelationDesc)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1916" title="executor/execMain.c:1916">ExecConstraints</a> - check constraints of the tuple in 'slot'<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This checks the traditional NOT NULL and check constraints.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The partition constraint is *NOT* checked.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: 'slot' contains the tuple to check the constraints of, which may<br/></li>
<li></span><span class="Comment"> * have been converted from the original input tuple after tuple routing.<br/></li>
<li></span><span class="Comment"> * 'resultRelInfo' is the final result relation, after tuple routing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1916">&#x200c;</a></span><span class="linkable">ExecConstraints</span>(ResultRelInfo *resultRelInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *slot, EState *estate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = resultRelInfo-&gt;ri_RelationDesc;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc = RelationGetDescr(rel);<br/></li>
<li>&nbsp; &nbsp; TupleConstr *constr = tupdesc-&gt;constr;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *modifiedCols;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(constr);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we should not be called otherwise */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (constr-&gt;has_not_null)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; natts = tupdesc-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrChk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (attrChk = <span class="Constant">1</span>; attrChk &lt;= natts; attrChk++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(tupdesc, attrChk - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attnotnull &amp;&amp; slot_attisnull(slot, attrChk))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *val_desc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; orig_rel = rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; orig_tupdesc = RelationGetDescr(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the tuple has been routed, it's been converted to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition's rowtype, which might differ from the root<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * table's.&nbsp; We must convert it back to the root table's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rowtype so that val_desc shown error message matches the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * input tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (resultRelInfo-&gt;ri_RootResultRelInfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResultRelInfo *rootrel = resultRelInfo-&gt;ri_RootResultRelInfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrMap&nbsp; &nbsp; *map;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupdesc = RelationGetDescr(rootrel-&gt;ri_RelationDesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* a reverse map */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map = <a href="../access/common/attmap.c.html#L263" title="access/common/attmap.c:263">build_attrmap_by_name_if_req</a>(orig_tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Partition-specific slot's tupdesc can't be changed, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allocate a new one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (map != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot = <a href="../access/common/tupconvert.c.html#L192" title="access/common/tupconvert.c:192">execute_attr_map_slot</a>(map, slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="execTuples.c.html#L1199" title="executor/execTuples.c:1199">MakeTupleTableSlot</a>(tupdesc, &amp;<a href="execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modifiedCols = <a href="../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(<a href="execUtils.c.html#L1267" title="executor/execUtils.c:1267">ExecGetInsertedCols</a>(rootrel, estate),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="execUtils.c.html#L1288" title="executor/execUtils.c:1288">ExecGetUpdatedCols</a>(rootrel, estate));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel = rootrel-&gt;ri_RelationDesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modifiedCols = <a href="../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(<a href="execUtils.c.html#L1267" title="executor/execUtils.c:1267">ExecGetInsertedCols</a>(resultRelInfo, estate),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="execUtils.c.html#L1288" title="executor/execUtils.c:1288">ExecGetUpdatedCols</a>(resultRelInfo, estate));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val_desc = <a href="#L2214" title="executor/execMain.c:2214">ExecBuildSlotValueDescription</a>(RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; modifiedCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">64</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NOT_NULL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;null value in column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> violates not-null constraint&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(att-&gt;attname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(orig_rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; val_desc ? <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failing row contains </span><span class="Special">%s</span><span class="Constant">.&quot;</span>, val_desc) : <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/relcache.c.html#L5962" title="utils/cache/relcache.c:5962">errtablecol</a>(orig_rel, attrChk)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relchecks &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *failed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((failed = <a href="#L1717" title="executor/execMain.c:1717">ExecRelCheck</a>(resultRelInfo, slot, estate)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *val_desc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; orig_rel = rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See the comment above. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (resultRelInfo-&gt;ri_RootResultRelInfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResultRelInfo *rootrel = resultRelInfo-&gt;ri_RootResultRelInfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; old_tupdesc = RelationGetDescr(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrMap&nbsp; &nbsp; *map;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupdesc = RelationGetDescr(rootrel-&gt;ri_RelationDesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* a reverse map */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map = <a href="../access/common/attmap.c.html#L263" title="access/common/attmap.c:263">build_attrmap_by_name_if_req</a>(old_tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Partition-specific slot's tupdesc can't be changed, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allocate a new one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (map != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot = <a href="../access/common/tupconvert.c.html#L192" title="access/common/tupconvert.c:192">execute_attr_map_slot</a>(map, slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="execTuples.c.html#L1199" title="executor/execTuples.c:1199">MakeTupleTableSlot</a>(tupdesc, &amp;<a href="execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modifiedCols = <a href="../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(<a href="execUtils.c.html#L1267" title="executor/execUtils.c:1267">ExecGetInsertedCols</a>(rootrel, estate),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="execUtils.c.html#L1288" title="executor/execUtils.c:1288">ExecGetUpdatedCols</a>(rootrel, estate));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel = rootrel-&gt;ri_RelationDesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modifiedCols = <a href="../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(<a href="execUtils.c.html#L1267" title="executor/execUtils.c:1267">ExecGetInsertedCols</a>(resultRelInfo, estate),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="execUtils.c.html#L1288" title="executor/execUtils.c:1288">ExecGetUpdatedCols</a>(resultRelInfo, estate));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val_desc = <a href="#L2214" title="executor/execMain.c:2214">ExecBuildSlotValueDescription</a>(RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; modifiedCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">64</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CHECK_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;new row for relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> violates check constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(orig_rel), failed),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; val_desc ? <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failing row contains </span><span class="Special">%s</span><span class="Constant">.&quot;</span>, val_desc) : <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/relcache.c.html#L5999" title="utils/cache/relcache.c:5999">errtableconstraint</a>(orig_rel, failed)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2051" title="executor/execMain.c:2051">ExecWithCheckOptions</a> -- check that tuple satisfies <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WITH CHECK OPTIONs<br/></li>
<li></span><span class="Comment"> * of the specified kind.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this needs to be called multiple times to ensure that all kinds of<br/></li>
<li></span><span class="Comment"> * WITH CHECK OPTIONs are handled (both those from views which have the WITH<br/></li>
<li></span><span class="Comment"> * CHECK OPTION set and from row-level security policies).&nbsp; See <a href="nodeModifyTable.c.html#L749" title="executor/nodeModifyTable.c:749">ExecInsert</a>()<br/></li>
<li></span><span class="Comment"> * and <a href="nodeModifyTable.c.html#L2259" title="executor/nodeModifyTable.c:2259">ExecUpdate</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2051">&#x200c;</a></span><span class="linkable">ExecWithCheckOptions</span>(WCOKind kind, ResultRelInfo *resultRelInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *slot, EState *estate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = resultRelInfo-&gt;ri_RelationDesc;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc = RelationGetDescr(rel);<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *l2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We will use the EState's per-tuple context for evaluating constraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expressions (creating it if it's not already there).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; econtext = GetPerTupleExprContext(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Arrange for econtext's scan tuple to be the tuple under test */<br/></li>
<li></span>&nbsp; &nbsp; econtext-&gt;ecxt_scantuple = slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check each of the constraints */<br/></li>
<li></span>&nbsp; &nbsp; forboth(l1, resultRelInfo-&gt;ri_WithCheckOptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l2, resultRelInfo-&gt;ri_WithCheckOptionExprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WithCheckOption *wco = (WithCheckOption *) lfirst(l1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExprState&nbsp; *wcoExpr = (ExprState *) lfirst(l2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Skip <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WCOs which are not the kind we are looking for at this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wco-&gt;kind != kind)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WITH CHECK OPTION checks are intended to ensure that the new tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is visible (in the case of a view) or that it passes the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 'with-check' policy (in the case of row security). If the qual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * evaluates to NULL or FALSE, then the new tuple won't be included in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the view or doesn't pass the 'with-check' policy for the table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ExecQual(wcoExpr, econtext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *val_desc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *modifiedCols;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (wco-&gt;kind)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For WITH CHECK OPTIONs coming from views, we might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * able to provide the details on the row, depending on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the permissions on the relation (that is, if the user<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could view it directly anyway).&nbsp; For RLS violations, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't include the data since we don't know if the user<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should be able to view the tuple as that depends on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * USING policy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WCO_VIEW_CHECK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See the comment in <a href="#L1916" title="executor/execMain.c:1916">ExecConstraints</a>(). */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (resultRelInfo-&gt;ri_RootResultRelInfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResultRelInfo *rootrel = resultRelInfo-&gt;ri_RootResultRelInfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; old_tupdesc = RelationGetDescr(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrMap&nbsp; &nbsp; *map;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupdesc = RelationGetDescr(rootrel-&gt;ri_RelationDesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* a reverse map */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map = <a href="../access/common/attmap.c.html#L263" title="access/common/attmap.c:263">build_attrmap_by_name_if_req</a>(old_tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Partition-specific slot's tupdesc can't be changed,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so allocate a new one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (map != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot = <a href="../access/common/tupconvert.c.html#L192" title="access/common/tupconvert.c:192">execute_attr_map_slot</a>(map, slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="execTuples.c.html#L1199" title="executor/execTuples.c:1199">MakeTupleTableSlot</a>(tupdesc, &amp;<a href="execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modifiedCols = <a href="../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(<a href="execUtils.c.html#L1267" title="executor/execUtils.c:1267">ExecGetInsertedCols</a>(rootrel, estate),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="execUtils.c.html#L1288" title="executor/execUtils.c:1288">ExecGetUpdatedCols</a>(rootrel, estate));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel = rootrel-&gt;ri_RelationDesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modifiedCols = <a href="../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(<a href="execUtils.c.html#L1267" title="executor/execUtils.c:1267">ExecGetInsertedCols</a>(resultRelInfo, estate),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="execUtils.c.html#L1288" title="executor/execUtils.c:1288">ExecGetUpdatedCols</a>(resultRelInfo, estate));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val_desc = <a href="#L2214" title="executor/execMain.c:2214">ExecBuildSlotValueDescription</a>(RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; modifiedCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">64</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WITH_CHECK_OPTION_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;new row violates check option for view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wco-&gt;relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; val_desc ? <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failing row contains </span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val_desc) : <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WCO_RLS_INSERT_CHECK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WCO_RLS_UPDATE_CHECK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wco-&gt;polname != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;new row violates row-level security policy </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> for table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wco-&gt;polname, wco-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;new row violates row-level security policy for table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wco-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WCO_RLS_MERGE_UPDATE_CHECK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WCO_RLS_MERGE_DELETE_CHECK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wco-&gt;polname != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;target row violates row-level security policy </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> (USING expression) for table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wco-&gt;polname, wco-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;target row violates row-level security policy (USING expression) for table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wco-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WCO_RLS_CONFLICT_CHECK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wco-&gt;polname != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;new row violates row-level security policy </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> (USING expression) for table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wco-&gt;polname, wco-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;new row violates row-level security policy (USING expression) for table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wco-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized WCO kind: </span><span class="Special">%u</span><span class="Constant">&quot;</span>, wco-&gt;kind);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2214" title="executor/execMain.c:2214">ExecBuildSlotValueDescription</a> -- construct a string representing a tuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is intentionally very similar to <a href="../access/index/genam.c.html#L174" title="access/index/genam.c:174">BuildIndexValueDescription</a>, but<br/></li>
<li></span><span class="Comment"> * unlike that function, we truncate long field <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (to at most maxfieldlen<br/></li>
<li></span><span class="Comment"> * bytes).&nbsp; That seems necessary here since heap field <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> could be very<br/></li>
<li></span><span class="Comment"> * long, whereas index entries typically aren't so wide.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also, unlike the case with index entries, we need to be prepared to ignore<br/></li>
<li></span><span class="Comment"> * dropped columns.&nbsp; We used to use the slot's tuple descriptor to decode the<br/></li>
<li></span><span class="Comment"> * data, but the slot's descriptor doesn't identify dropped columns, so we<br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> need to be passed the relation's descriptor.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that, like <a href="../access/index/genam.c.html#L174" title="access/index/genam.c:174">BuildIndexValueDescription</a>, if the user does not have<br/></li>
<li></span><span class="Comment"> * permission to view <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the columns involved, a NULL is returned.&nbsp; Unlike<br/></li>
<li></span><span class="Comment"> * <a href="../access/index/genam.c.html#L174" title="access/index/genam.c:174">BuildIndexValueDescription</a>, if the user has access to view a <a href="../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of the<br/></li>
<li></span><span class="Comment"> * column involved, that <a href="../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> will be returned with a key identifying which<br/></li>
<li></span><span class="Comment"> * columns they are.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L2214">&#x200c;</a><span class="linkable">ExecBuildSlotValueDescription</span>(Oid reloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDesc tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bitmapset *modifiedCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> maxfieldlen)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; StringInfoData collist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; write_comma = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; write_comma_collist = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; AclResult&nbsp; &nbsp; aclresult;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; table_perm = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; any_perm = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if RLS is enabled and should be active for the relation; if so,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then don't return anything.&nbsp; Otherwise, go through normal permission<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/rls.c.html#L52" title="utils/misc/rls.c:52">check_enable_rls</a>(reloid, InvalidOid, <span class="Constant">true</span>) == RLS_ENABLED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;buf, <span class="Constant">'('</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if the user has permissions to see the row.&nbsp; Table-level SELECT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allows access to all columns.&nbsp; If the user does not have table-level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SELECT then we check each column and include those the user has SELECT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rights on.&nbsp; Additionally, we always include columns the user provided<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data for.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L4079" title="catalog/aclchk.c:4079">pg_class_aclcheck</a>(reloid, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(), ACL_SELECT);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set up the buffer for the column list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;collist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;collist, <span class="Constant">'('</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; table_perm = any_perm = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure the tuple is fully deconstructed */<br/></li>
<li></span>&nbsp; &nbsp; slot_getallattrs(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; tupdesc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; column_perm = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vallen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(tupdesc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore dropped columns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!table_perm)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No table-level SELECT, so need to make sure they either have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * SELECT rights on the column or that they have provided the data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for the column.&nbsp; If not, omit this column from the error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L3908" title="catalog/aclchk.c:3908">pg_attribute_aclcheck</a>(reloid, att-&gt;attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(), ACL_SELECT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(att-&gt;attnum - FirstLowInvalidHeapAttributeNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modifiedCols) || aclresult == ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column_perm = any_perm = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (write_comma_collist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;collist, <span class="Constant">&quot;, &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; write_comma_collist = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;collist, NameStr(att-&gt;attname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (table_perm || column_perm)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;tts_isnull[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = <span class="Constant">&quot;null&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foutoid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typisvarlena;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L2907" title="utils/cache/lsyscache.c:2907">getTypeOutputInfo</a>(att-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;foutoid, &amp;typisvarlena);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = <a href="../utils/fmgr/fmgr.c.html#L1763" title="utils/fmgr/fmgr.c:1763">OidOutputFunctionCall</a>(foutoid, slot-&gt;tts_values[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (write_comma)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot;, &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; write_comma = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* truncate if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vallen = strlen(val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vallen &lt;= maxfieldlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(&amp;buf, val, vallen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vallen = <a href="../utils/mb/mbutils.c.html#L1083" title="utils/mb/mbutils.c:1083">pg_mbcliplen</a>(val, vallen, maxfieldlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(&amp;buf, val, vallen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot;...&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we end up with zero columns being returned, then return NULL. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!any_perm)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;buf, <span class="Constant">')'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!table_perm)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;collist, <span class="Constant">&quot;) = &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(&amp;collist, buf.data, buf.len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> collist.data;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf.data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2351" title="executor/execMain.c:2351">ExecUpdateLockMode</a> -- <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the appropriate UPDATE tuple lock mode for a<br/></li>
<li></span><span class="Comment"> * given ResultRelInfo<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LockTupleMode<br/></li>
<li><a id="L2351">&#x200c;</a><span class="linkable">ExecUpdateLockMode</span>(EState *estate, ResultRelInfo *relinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *keyCols;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *updatedCols;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute lock mode to use.&nbsp; If columns that are part of the key have not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * been modified, then we can use a weaker lock, allowing for better<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concurrency.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; updatedCols = <a href="execUtils.c.html#L1324" title="executor/execUtils.c:1324">ExecGetAllUpdatedCols</a>(relinfo, estate);<br/></li>
<li>&nbsp; &nbsp; keyCols = <a href="../utils/cache/relcache.c.html#L5231" title="utils/cache/relcache.c:5231">RelationGetIndexAttrBitmap</a>(relinfo-&gt;ri_RelationDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INDEX_ATTR_BITMAP_KEY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(keyCols, updatedCols))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> LockTupleExclusive;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> LockTupleNoKeyExclusive;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2377" title="executor/execMain.c:2377">ExecFindRowMark</a> -- <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the ExecRowMark struct for given rangetable index<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If no such struct, either return NULL or throw error depending on missing_ok<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ExecRowMark *<br/></li>
<li><a id="L2377">&#x200c;</a><span class="linkable">ExecFindRowMark</span>(EState *estate, Index rti, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rti &gt; <span class="Constant">0</span> &amp;&amp; rti &lt;= estate-&gt;es_range_table_size &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_rowmarks != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecRowMark *erm = estate-&gt;es_rowmarks[rti - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (erm)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> erm;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!missing_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> ExecRowMark for rangetable index </span><span class="Special">%u</span><span class="Constant">&quot;</span>, rti);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2400" title="executor/execMain.c:2400">ExecBuildAuxRowMark</a> -- create an ExecAuxRowMark struct<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Inputs are the underlying ExecRowMark struct and the targetlist of the<br/></li>
<li></span><span class="Comment"> * input plan node (not planstate node!).&nbsp; We need the latter to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out<br/></li>
<li></span><span class="Comment"> * the column numbers of the resjunk columns.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ExecAuxRowMark *<br/></li>
<li><a id="L2400">&#x200c;</a><span class="linkable">ExecBuildAuxRowMark</span>(ExecRowMark *erm, List *targetlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExecAuxRowMark *aerm = (ExecAuxRowMark *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ExecAuxRowMark));<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; resname[<span class="Constant">32</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; aerm-&gt;rowmark = erm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look up the resjunk columns associated with this rowmark */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (erm-&gt;markType != ROW_MARK_COPY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* need ctid for all methods other than COPY */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(resname, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(resname), <span class="Constant">&quot;ctid</span><span class="Special">%u</span><span class="Constant">&quot;</span>, erm-&gt;rowmarkId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aerm-&gt;ctidAttNo = <a href="execJunk.c.html#L222" title="executor/execJunk.c:222">ExecFindJunkAttributeInTlist</a>(targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; resname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!AttributeNumberIsValid(aerm-&gt;ctidAttNo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> junk </span><span class="Special">%s</span><span class="Constant"> column&quot;</span>, resname);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* need wholerow if COPY */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(resname, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(resname), <span class="Constant">&quot;wholerow</span><span class="Special">%u</span><span class="Constant">&quot;</span>, erm-&gt;rowmarkId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aerm-&gt;wholeAttNo = <a href="execJunk.c.html#L222" title="executor/execJunk.c:222">ExecFindJunkAttributeInTlist</a>(targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!AttributeNumberIsValid(aerm-&gt;wholeAttNo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> junk </span><span class="Special">%s</span><span class="Constant"> column&quot;</span>, resname);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if child rel, need tableoid */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (erm-&gt;rti != erm-&gt;prti)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(resname, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(resname), <span class="Constant">&quot;tableoid</span><span class="Special">%u</span><span class="Constant">&quot;</span>, erm-&gt;rowmarkId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aerm-&gt;toidAttNo = <a href="execJunk.c.html#L222" title="executor/execJunk.c:222">ExecFindJunkAttributeInTlist</a>(targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; resname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!AttributeNumberIsValid(aerm-&gt;toidAttNo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> junk </span><span class="Special">%s</span><span class="Constant"> column&quot;</span>, resname);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> aerm;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2470" title="executor/execMain.c:2470">EvalPlanQual</a> logic --- recheck modified tuple(s) to see if we want to<br/></li>
<li></span><span class="Comment"> * process the updated version under READ COMMITTED rules.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See backend/executor/README for some info about how this works.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check the updated version of a tuple to see if we want to process it under<br/></li>
<li></span><span class="Comment"> * READ COMMITTED rules.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; epqstate - state for <a href="#L2470" title="executor/execMain.c:2470">EvalPlanQual</a> rechecking<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; relation - table containing tuple<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rti - rangetable index of table containing tuple<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; inputslot - tuple for processing - this can be the slot from<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2598" title="executor/execMain.c:2598">EvalPlanQualSlot</a>() for this rel, for increased efficiency.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This tests whether the tuple in inputslot still matches the relevant<br/></li>
<li></span><span class="Comment"> * quals. For that result to be useful, typically the input tuple has to be<br/></li>
<li></span><span class="Comment"> * last row version (otherwise the result isn't particularly useful) and<br/></li>
<li></span><span class="Comment"> * locked (otherwise the result might be out of date). That's typically<br/></li>
<li></span><span class="Comment"> * achieved by using table_tuple_lock() with the<br/></li>
<li></span><span class="Comment"> * TUPLE_LOCK_FLAG_FIND_LAST_VERSION flag.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a slot containing the new candidate update/delete tuple, or<br/></li>
<li></span><span class="Comment"> * NULL if we determine we shouldn't process the row.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleTableSlot *<br/></li>
<li><a id="L2470">&#x200c;</a><span class="linkable">EvalPlanQual</span>(EPQState *epqstate, Relation relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index rti, TupleTableSlot *inputslot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *testslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(rti &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Need to run a recheck subquery.&nbsp; Initialize or reinitialize EPQ state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2751" title="executor/execMain.c:2751">EvalPlanQualBegin</a>(epqstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Callers will often use the <a href="#L2598" title="executor/execMain.c:2598">EvalPlanQualSlot</a> to store the tuple to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an unnecessary copy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; testslot = <a href="#L2598" title="executor/execMain.c:2598">EvalPlanQualSlot</a>(epqstate, relation, rti);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (testslot != inputslot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecCopySlot(testslot, inputslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark that an EPQ tuple is available for this relation.&nbsp; (If there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more than one result relation, the others remain marked as having no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple available.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; epqstate-&gt;relsubs_done[rti - <span class="Constant">1</span>] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; epqstate-&gt;relsubs_blocked[rti - <span class="Constant">1</span>] = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Run the EPQ query.&nbsp; We assume it will return at most one tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; slot = <a href="#L2735" title="executor/execMain.c:2735">EvalPlanQualNext</a>(epqstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we got a tuple, force the slot to materialize the tuple so that it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is not dependent on <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> local state in the EPQ query (in particular,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's highly likely that the slot contains references to <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pass-by-ref<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * datums that may be present in copyTuple).&nbsp; As with the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> step, this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is to guard against early re-use of the EPQ query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TupIsNull(slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecMaterializeSlot(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clear out the test tuple, and mark that no tuple is available here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is needed in case the EPQ state is re-used to test a tuple for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * different target relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ExecClearTuple(testslot);<br/></li>
<li>&nbsp; &nbsp; epqstate-&gt;relsubs_blocked[rti - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> slot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2539" title="executor/execMain.c:2539">EvalPlanQualInit</a> -- <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> during creation of a plan state node<br/></li>
<li></span><span class="Comment"> * that might need to invoke EPQ processing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the caller intends to use <a href="#L2470" title="executor/execMain.c:2470">EvalPlanQual</a>(), resultRelations should be<br/></li>
<li></span><span class="Comment"> * a list of RT indexes of potential target relations for <a href="#L2470" title="executor/execMain.c:2470">EvalPlanQual</a>(),<br/></li>
<li></span><span class="Comment"> * and we will arrange that the other listed relations don't return <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * tuple during an <a href="#L2470" title="executor/execMain.c:2470">EvalPlanQual</a>() call.&nbsp; Otherwise resultRelations<br/></li>
<li></span><span class="Comment"> * should be NIL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: subplan/auxrowmarks can be NULL/NIL if they will be set later<br/></li>
<li></span><span class="Comment"> * with <a href="#L2581" title="executor/execMain.c:2581">EvalPlanQualSetPlan</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2539">&#x200c;</a></span><span class="linkable">EvalPlanQualInit</span>(EPQState *epqstate, EState *parentestate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Plan *subplan, List *auxrowmarks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> epqParam, List *resultRelations)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; rtsize = parentestate-&gt;es_range_table_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> data not changing over EPQState's lifetime */<br/></li>
<li></span>&nbsp; &nbsp; epqstate-&gt;parentestate = parentestate;<br/></li>
<li>&nbsp; &nbsp; epqstate-&gt;epqParam = epqParam;<br/></li>
<li>&nbsp; &nbsp; epqstate-&gt;resultRelations = resultRelations;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate space to reference a slot for each potential rti - do so <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rather than in <a href="#L2751" title="executor/execMain.c:2751">EvalPlanQualBegin</a>(), as done for other dynamically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocated resources, so <a href="#L2598" title="executor/execMain.c:2598">EvalPlanQualSlot</a>() can be used to hold tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that *may* need EPQ later, without forcing the overhead of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2751" title="executor/execMain.c:2751">EvalPlanQualBegin</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; epqstate-&gt;tuple_table = NIL;<br/></li>
<li>&nbsp; &nbsp; epqstate-&gt;relsubs_slot = (TupleTableSlot **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(rtsize * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TupleTableSlot *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and remember data that <a href="#L2751" title="executor/execMain.c:2751">EvalPlanQualBegin</a> will need */<br/></li>
<li></span>&nbsp; &nbsp; epqstate-&gt;plan = subplan;<br/></li>
<li>&nbsp; &nbsp; epqstate-&gt;arowMarks = auxrowmarks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and mark the EPQ state inactive */<br/></li>
<li></span>&nbsp; &nbsp; epqstate-&gt;origslot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; epqstate-&gt;recheckestate = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; epqstate-&gt;recheckplanstate = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; epqstate-&gt;relsubs_rowmark = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; epqstate-&gt;relsubs_done = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; epqstate-&gt;relsubs_blocked = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2581" title="executor/execMain.c:2581">EvalPlanQualSetPlan</a> -- set or change subplan of an EPQState.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We used to need this so that ModifyTable could deal with multiple subplans.<br/></li>
<li></span><span class="Comment"> * It could <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> be refactored out of existence.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2581">&#x200c;</a></span><span class="linkable">EvalPlanQualSetPlan</span>(EPQState *epqstate, Plan *subplan, List *auxrowmarks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we have a live EPQ query, shut it down */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2982" title="executor/execMain.c:2982">EvalPlanQualEnd</a>(epqstate);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And set/change the plan pointer */<br/></li>
<li></span>&nbsp; &nbsp; epqstate-&gt;plan = subplan;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The rowmarks depend on the plan, too */<br/></li>
<li></span>&nbsp; &nbsp; epqstate-&gt;arowMarks = auxrowmarks;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return, and create if necessary, a slot for an EPQ test tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note this only requires <a href="#L2539" title="executor/execMain.c:2539">EvalPlanQualInit</a>() to have been called,<br/></li>
<li></span><span class="Comment"> * <a href="#L2751" title="executor/execMain.c:2751">EvalPlanQualBegin</a>() is not necessary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleTableSlot *<br/></li>
<li><a id="L2598">&#x200c;</a><span class="linkable">EvalPlanQualSlot</span>(EPQState *epqstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation relation, Index rti)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot **slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(relation);<br/></li>
<li>&nbsp; &nbsp; Assert(rti &gt; <span class="Constant">0</span> &amp;&amp; rti &lt;= epqstate-&gt;parentestate-&gt;es_range_table_size);<br/></li>
<li>&nbsp; &nbsp; slot = &amp;epqstate-&gt;relsubs_slot[rti - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*slot == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(epqstate-&gt;parentestate-&gt;es_query_cxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *slot = <a href="../access/table/tableam.c.html#L91" title="access/table/tableam.c:91">table_slot_create</a>(relation, &amp;epqstate-&gt;tuple_table);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> *slot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch the current row value for a non-locked relation, identified by rti,<br/></li>
<li></span><span class="Comment"> * that needs to be scanned by an <a href="#L2470" title="executor/execMain.c:2470">EvalPlanQual</a> operation.&nbsp; origslot must have<br/></li>
<li></span><span class="Comment"> * been set to contain the current result row (top-level row) that we need to<br/></li>
<li></span><span class="Comment"> * recheck.&nbsp; Returns true if a substitution tuple was found, false if not.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2626">&#x200c;</a></span><span class="linkable">EvalPlanQualFetchRowMark</span>(EPQState *epqstate, Index rti, TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExecAuxRowMark *earm = epqstate-&gt;relsubs_rowmark[rti - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; ExecRowMark *erm = earm-&gt;rowmark;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(earm != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(epqstate-&gt;origslot != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RowMarkRequiresRowShareLock(erm-&gt;markType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L2470" title="executor/execMain.c:2470">EvalPlanQual</a> doesn't support locking rowmarks&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if child rel, must check whether it produced this row */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (erm-&gt;rti != erm-&gt;prti)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tableoid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum = ExecGetJunkAttribute(epqstate-&gt;origslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; earm-&gt;toidAttNo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;isNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* non-locked rels could be on the inside of outer joins */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tableoid = DatumGetObjectId(datum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(erm-&gt;relid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tableoid != erm-&gt;relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this child is inactive right <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (erm-&gt;markType == ROW_MARK_REFERENCE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(erm-&gt;relation != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fetch the tuple's ctid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; datum = ExecGetJunkAttribute(epqstate-&gt;origslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; earm-&gt;ctidAttNo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;isNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* non-locked rels could be on the inside of outer joins */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fetch requests on foreign tables must be passed to their FDW */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (erm-&gt;relation-&gt;rd_rel-&gt;relkind == RELKIND_FOREIGN_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FdwRoutine *fdwroutine;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; updated = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdwroutine = <a href="../foreign/foreign.c.html#L432" title="foreign/foreign.c:432">GetFdwRoutineForRelation</a>(erm-&gt;relation, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this should have been checked already, but let's be safe */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fdwroutine-&gt;RefetchForeignRow == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot lock rows in foreign table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(erm-&gt;relation))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdwroutine-&gt;RefetchForeignRow(epqstate-&gt;recheckestate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; erm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;updated);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TupIsNull(slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to fetch tuple for <a href="#L2470" title="executor/execMain.c:2470">EvalPlanQual</a> recheck&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ideally we'd insist on updated == false here, but that assumes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that FDWs can track that exactly, which they might not be able<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to.&nbsp; So just ignore the flag.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ordinary table, fetch the tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!table_tuple_fetch_row_version(erm-&gt;relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (ItemPointer) DatumGetPointer(datum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SnapshotAny, slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to fetch tuple for <a href="#L2470" title="executor/execMain.c:2470">EvalPlanQual</a> recheck&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(erm-&gt;markType == ROW_MARK_COPY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fetch the whole-row Var for the relation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; datum = ExecGetJunkAttribute(epqstate-&gt;origslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; earm-&gt;wholeAttNo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;isNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* non-locked rels could be on the inside of outer joins */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L1693" title="executor/execTuples.c:1693">ExecStoreHeapTupleDatum</a>(datum, slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> row (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) from <a href="#L2470" title="executor/execMain.c:2470">EvalPlanQual</a> testing<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (In practice, there should never be more than one row...)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleTableSlot *<br/></li>
<li><a id="L2735">&#x200c;</a><span class="linkable">EvalPlanQualNext</span>(EPQState *epqstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(epqstate-&gt;recheckestate-&gt;es_query_cxt);<br/></li>
<li>&nbsp; &nbsp; slot = ExecProcNode(epqstate-&gt;recheckplanstate);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> slot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize or reset an <a href="#L2470" title="executor/execMain.c:2470">EvalPlanQual</a> state tree<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2751">&#x200c;</a></span><span class="linkable">EvalPlanQualBegin</span>(EPQState *epqstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *parentestate = epqstate-&gt;parentestate;<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *recheckestate = epqstate-&gt;recheckestate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (recheckestate == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First time through, so create a child EState */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2818" title="executor/execMain.c:2818">EvalPlanQualStart</a>(epqstate, epqstate-&gt;plan);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We already have a suitable child EPQ tree, so just reset it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; rtsize = parentestate-&gt;es_range_table_size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlanState&nbsp; *rcplanstate = epqstate-&gt;recheckplanstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset the relsubs_done[] flags to <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> relsubs_blocked[], so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the EPQ run will never attempt to fetch tuples from blocked target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(epqstate-&gt;relsubs_done, epqstate-&gt;relsubs_blocked,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtsize * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recopy current <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of parent parameters */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parentestate-&gt;es_plannedstmt-&gt;paramExecTypes != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Force evaluation of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="#L833" title="executor/execMain.c:833">InitPlan</a> outputs that could be needed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by the subplan, just in case they got reset since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2818" title="executor/execMain.c:2818">EvalPlanQualStart</a> (see comments therein).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeSubplan.c.html#L1268" title="executor/nodeSubplan.c:1268">ExecSetParamPlanMulti</a>(rcplanstate-&gt;plan-&gt;extParam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GetPerTupleExprContext(parentestate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = list_length(parentestate-&gt;es_plannedstmt-&gt;paramExecTypes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (--i &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy value if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, but not execPlan link */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recheckestate-&gt;es_param_exec_vals[i].value =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentestate-&gt;es_param_exec_vals[i].value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recheckestate-&gt;es_param_exec_vals[i].isnull =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentestate-&gt;es_param_exec_vals[i].isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Mark child plan tree as needing rescan at all scan nodes.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first ExecProcNode will take care of actually doing the rescan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rcplanstate-&gt;chgParam = <a href="../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(rcplanstate-&gt;chgParam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; epqstate-&gt;epqParam);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Start execution of an <a href="#L2470" title="executor/execMain.c:2470">EvalPlanQual</a> plan tree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a cut-down version of <a href="#L124" title="executor/execMain.c:124">ExecutorStart</a>(): we copy some state from<br/></li>
<li></span><span class="Comment"> * the top-level estate rather than initializing it fresh.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2818">&#x200c;</a></span><span class="linkable">EvalPlanQualStart</span>(EPQState *epqstate, Plan *planTree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *parentestate = epqstate-&gt;parentestate;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; rtsize = parentestate-&gt;es_range_table_size;<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *rcestate;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; epqstate-&gt;recheckestate = rcestate = <a href="execUtils.c.html#L88" title="executor/execUtils.c:88">CreateExecutorState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(rcestate-&gt;es_query_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* signal that this is an EState for executing EPQ */<br/></li>
<li></span>&nbsp; &nbsp; rcestate-&gt;es_epq_active = epqstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Child EPQ EStates share the parent's copy of unchanging state such as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the snapshot, rangetable, and external Param info.&nbsp; They need their own<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copies of local state, including a tuple table, es_param_exec_vals,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * result-rel info, etc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rcestate-&gt;es_direction = ForwardScanDirection;<br/></li>
<li>&nbsp; &nbsp; rcestate-&gt;es_snapshot = parentestate-&gt;es_snapshot;<br/></li>
<li>&nbsp; &nbsp; rcestate-&gt;es_crosscheck_snapshot = parentestate-&gt;es_crosscheck_snapshot;<br/></li>
<li>&nbsp; &nbsp; rcestate-&gt;es_range_table = parentestate-&gt;es_range_table;<br/></li>
<li>&nbsp; &nbsp; rcestate-&gt;es_range_table_size = parentestate-&gt;es_range_table_size;<br/></li>
<li>&nbsp; &nbsp; rcestate-&gt;es_relations = parentestate-&gt;es_relations;<br/></li>
<li>&nbsp; &nbsp; rcestate-&gt;es_rowmarks = parentestate-&gt;es_rowmarks;<br/></li>
<li>&nbsp; &nbsp; rcestate-&gt;es_rteperminfos = parentestate-&gt;es_rteperminfos;<br/></li>
<li>&nbsp; &nbsp; rcestate-&gt;es_plannedstmt = parentestate-&gt;es_plannedstmt;<br/></li>
<li>&nbsp; &nbsp; rcestate-&gt;es_junkFilter = parentestate-&gt;es_junkFilter;<br/></li>
<li>&nbsp; &nbsp; rcestate-&gt;es_output_cid = parentestate-&gt;es_output_cid;<br/></li>
<li>&nbsp; &nbsp; rcestate-&gt;es_queryEnv = parentestate-&gt;es_queryEnv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ResultRelInfos needed by subplans are initialized from scratch when the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subplans themselves are initialized.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rcestate-&gt;es_result_relations = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* es_trig_target_relations must NOT be copied */<br/></li>
<li></span>&nbsp; &nbsp; rcestate-&gt;es_top_eflags = parentestate-&gt;es_top_eflags;<br/></li>
<li>&nbsp; &nbsp; rcestate-&gt;es_instrument = parentestate-&gt;es_instrument;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* es_auxmodifytables must NOT be copied */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The external param list is simply shared from parent.&nbsp; The <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * param workspace has to be local state, but we copy the initial <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the parent, so as to have access to <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> param <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already set from other parts of the parent's plan tree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rcestate-&gt;es_param_list_info = parentestate-&gt;es_param_list_info;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parentestate-&gt;es_plannedstmt-&gt;paramExecTypes != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Force evaluation of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="#L833" title="executor/execMain.c:833">InitPlan</a> outputs that could be needed by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the subplan.&nbsp; (With more complexity, maybe we could postpone this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * till the subplan actually demands them, but it doesn't seem worth<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the trouble; this is a corner case already, since usually the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * InitPlans would have been evaluated <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> reaching <a href="#L2470" title="executor/execMain.c:2470">EvalPlanQual</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This will not touch output params of InitPlans that occur somewhere<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * within the subplan tree, only those that are attached to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ModifyTable node or above it and are referenced within the subplan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * That's OK though, because the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> would only attach such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * InitPlans to a <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level SubqueryScan node, and EPQ execution<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will not descend into a SubqueryScan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The EState's per-output-tuple econtext is sufficiently short-lived<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for this, since it should get reset <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> there is <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> chance of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doing <a href="#L2470" title="executor/execMain.c:2470">EvalPlanQual</a> again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeSubplan.c.html#L1268" title="executor/nodeSubplan.c:1268">ExecSetParamPlanMulti</a>(planTree-&gt;extParam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GetPerTupleExprContext(parentestate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> make the <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> param workspace ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; i = list_length(parentestate-&gt;es_plannedstmt-&gt;paramExecTypes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rcestate-&gt;es_param_exec_vals = (ParamExecData *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(i * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ParamExecData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and copy down all <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, whether really needed or not */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (--i &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy value if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, but not execPlan link */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rcestate-&gt;es_param_exec_vals[i].value =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentestate-&gt;es_param_exec_vals[i].value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rcestate-&gt;es_param_exec_vals[i].isnull =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentestate-&gt;es_param_exec_vals[i].isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize private state information for each SubPlan.&nbsp; We must do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> running <a href="execProcnode.c.html#L142" title="executor/execProcnode.c:142">ExecInitNode</a> on the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> query tree, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="nodeSubplan.c.html#L823" title="executor/nodeSubplan.c:823">ExecInitSubPlan</a> expects to be able to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> these entries. Some of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SubPlans might not be used in the part of the plan tree we intend to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * run, but since it's not easy to tell which, we just <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rcestate-&gt;es_subplanstates == NIL);<br/></li>
<li>&nbsp; &nbsp; foreach(l, parentestate-&gt;es_plannedstmt-&gt;subplans)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan = (Plan *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlanState&nbsp; *subplanstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subplanstate = <a href="execProcnode.c.html#L142" title="executor/execProcnode.c:142">ExecInitNode</a>(subplan, rcestate, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rcestate-&gt;es_subplanstates = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rcestate-&gt;es_subplanstates,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subplanstate);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build an RTI indexed array of rowmarks, so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2626" title="executor/execMain.c:2626">EvalPlanQualFetchRowMark</a>() can efficiently access the to be fetched<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rowmark.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; epqstate-&gt;relsubs_rowmark = (ExecAuxRowMark **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(rtsize * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ExecAuxRowMark *));<br/></li>
<li>&nbsp; &nbsp; foreach(l, epqstate-&gt;arowMarks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecAuxRowMark *earm = (ExecAuxRowMark *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; epqstate-&gt;relsubs_rowmark[earm-&gt;rowmark-&gt;rti - <span class="Constant">1</span>] = earm;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize per-relation EPQ tuple states.&nbsp; Result relations, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get marked as blocked; others as not-fetched.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; epqstate-&gt;relsubs_done = palloc_array(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>, rtsize);<br/></li>
<li>&nbsp; &nbsp; epqstate-&gt;relsubs_blocked = palloc0_array(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>, rtsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, epqstate-&gt;resultRelations)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtindex = lfirst_int(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rtindex &gt; <span class="Constant">0</span> &amp;&amp; rtindex &lt;= rtsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; epqstate-&gt;relsubs_blocked[rtindex - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(epqstate-&gt;relsubs_done, epqstate-&gt;relsubs_blocked,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtsize * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the private state information for all the nodes in the part<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the plan tree we need to run.&nbsp; This opens files, allocates storage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and leaves us ready to start processing tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; epqstate-&gt;recheckplanstate = <a href="execProcnode.c.html#L142" title="executor/execProcnode.c:142">ExecInitNode</a>(planTree, rcestate, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2982" title="executor/execMain.c:2982">EvalPlanQualEnd</a> -- shut down at termination of parent plan state node,<br/></li>
<li></span><span class="Comment"> * or if we are done with the current EPQ child.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a cut-down version of <a href="#L467" title="executor/execMain.c:467">ExecutorEnd</a>(); basically we want to do most<br/></li>
<li></span><span class="Comment"> * of the normal <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>, but *not* close result relations (which we are<br/></li>
<li></span><span class="Comment"> * just sharing from the outer query).&nbsp; We do, however, have to close <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * result and <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> target relations that got opened, since those are not<br/></li>
<li></span><span class="Comment"> * shared.&nbsp; (There probably shouldn't be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the latter, but just in<br/></li>
<li></span><span class="Comment"> * case...)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2982">&#x200c;</a></span><span class="linkable">EvalPlanQualEnd</span>(EPQState *epqstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate = epqstate-&gt;recheckestate;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; rtsize;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rtsize = epqstate-&gt;parentestate-&gt;es_range_table_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We may have a tuple table, even if EPQ wasn't started, because we allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use of <a href="#L2598" title="executor/execMain.c:2598">EvalPlanQualSlot</a>() without calling <a href="#L2751" title="executor/execMain.c:2751">EvalPlanQualBegin</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (epqstate-&gt;tuple_table != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(epqstate-&gt;relsubs_slot, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtsize * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TupleTableSlot *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L1278" title="executor/execTuples.c:1278">ExecResetTupleTable</a>(epqstate-&gt;tuple_table, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; epqstate-&gt;tuple_table = NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* EPQ wasn't started, nothing further to do */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (estate == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(estate-&gt;es_query_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="execProcnode.c.html#L557" title="executor/execProcnode.c:557">ExecEndNode</a>(epqstate-&gt;recheckplanstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, estate-&gt;es_subplanstates)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlanState&nbsp; *subplanstate = (PlanState *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execProcnode.c.html#L557" title="executor/execProcnode.c:557">ExecEndNode</a>(subplanstate);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* throw away the per-estate tuple table, some node may have used it */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execTuples.c.html#L1278" title="executor/execTuples.c:1278">ExecResetTupleTable</a>(estate-&gt;es_tupleTable, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> result and <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> target relations attached to this EState */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1517" title="executor/execMain.c:1517">ExecCloseResultRelations</a>(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="execUtils.c.html#L189" title="executor/execUtils.c:189">FreeExecutorState</a>(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark EPQState idle */<br/></li>
<li></span>&nbsp; &nbsp; epqstate-&gt;origslot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; epqstate-&gt;recheckestate = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; epqstate-&gt;recheckplanstate = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; epqstate-&gt;relsubs_rowmark = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; epqstate-&gt;relsubs_done = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; epqstate-&gt;relsubs_blocked = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
