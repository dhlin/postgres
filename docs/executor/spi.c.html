<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>executor/spi.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>executor/spi.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L44">SPI_processed</a></li>
<li><a href="#L46">SPI_result</a></li>
<li><a href="#L45">SPI_tuptable</a></li>
<li><a href="#L51">_SPI_connected</a></li>
<li><a href="#L49">_SPI_current</a></li>
<li><a href="#L48">_SPI_stack</a></li>
<li><a href="#L50">_SPI_stack_depth</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L53">SPICallbackArg</a></li>
<li><a href="#L57">SPICallbackArg</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L482">AtEOSubXact_SPI</a></li>
<li><a href="#L428">AtEOXact_SPI</a></li>
<li><a href="#L320">SPI_commit</a></li>
<li><a href="#L326">SPI_commit_and_chain</a></li>
<li><a href="#L94">SPI_connect</a></li>
<li><a href="#L100">SPI_connect_ext</a></li>
<li><a href="#L1044">SPI_copytuple</a></li>
<li><a href="#L1859">SPI_cursor_close</a></li>
<li><a href="#L1803">SPI_cursor_fetch</a></li>
<li><a href="#L1791">SPI_cursor_find</a></li>
<li><a href="#L1818">SPI_cursor_move</a></li>
<li><a href="#L1442">SPI_cursor_open</a></li>
<li><a href="#L1574">SPI_cursor_open_internal</a></li>
<li><a href="#L1469">SPI_cursor_open_with_args</a></li>
<li><a href="#L1522">SPI_cursor_open_with_paramlist</a></li>
<li><a href="#L1530">SPI_cursor_parse_open</a></li>
<li><a href="#L1358">SPI_datumTransfer</a></li>
<li><a href="#L627">SPI_exec</a></li>
<li><a href="#L701">SPI_execp</a></li>
<li><a href="#L593">SPI_execute</a></li>
<li><a href="#L634">SPI_execute_extended</a></li>
<li><a href="#L669">SPI_execute_plan</a></li>
<li><a href="#L708">SPI_execute_plan_extended</a></li>
<li><a href="#L730">SPI_execute_plan_with_paramlist</a></li>
<li><a href="#L770">SPI_execute_snapshot</a></li>
<li><a href="#L809">SPI_execute_with_args</a></li>
<li><a href="#L182">SPI_finish</a></li>
<li><a href="#L1195">SPI_fname</a></li>
<li><a href="#L1172">SPI_fnumber</a></li>
<li><a href="#L1022">SPI_freeplan</a></li>
<li><a href="#L1376">SPI_freetuple</a></li>
<li><a href="#L1383">SPI_freetuptable</a></li>
<li><a href="#L1887">SPI_getargcount</a></li>
<li><a href="#L1872">SPI_getargtypeid</a></li>
<li><a href="#L1249">SPI_getbinval</a></li>
<li><a href="#L1329">SPI_getnspname</a></li>
<li><a href="#L1323">SPI_getrelname</a></li>
<li><a href="#L1265">SPI_gettype</a></li>
<li><a href="#L1305">SPI_gettypeid</a></li>
<li><a href="#L1217">SPI_getvalue</a></li>
<li><a href="#L581">SPI_inside_nonatomic_context</a></li>
<li><a href="#L1907">SPI_is_cursor_plan</a></li>
<li><a href="#L973">SPI_keepplan</a></li>
<li><a href="#L1103">SPI_modifytuple</a></li>
<li><a href="#L1335">SPI_palloc</a></li>
<li><a href="#L1351">SPI_pfree</a></li>
<li><a href="#L2071">SPI_plan_get_cached_plan</a></li>
<li><a href="#L2052">SPI_plan_get_plan_sources</a></li>
<li><a href="#L1945">SPI_plan_is_valid</a></li>
<li><a href="#L857">SPI_prepare</a></li>
<li><a href="#L863">SPI_prepare_cursor</a></li>
<li><a href="#L899">SPI_prepare_extended</a></li>
<li><a href="#L935">SPI_prepare_params</a></li>
<li><a href="#L3277">SPI_register_relation</a></li>
<li><a href="#L3344">SPI_register_trigger_data</a></li>
<li><a href="#L1344">SPI_repalloc</a></li>
<li><a href="#L1969">SPI_result_code_string</a></li>
<li><a href="#L1071">SPI_returntuple</a></li>
<li><a href="#L413">SPI_rollback</a></li>
<li><a href="#L419">SPI_rollback_and_chain</a></li>
<li><a href="#L1000">SPI_saveplan</a></li>
<li><a href="#L1832">SPI_scroll_cursor_fetch</a></li>
<li><a href="#L1847">SPI_scroll_cursor_move</a></li>
<li><a href="#L222">SPI_start_transaction</a></li>
<li><a href="#L3311">SPI_unregister_relation</a></li>
<li><a href="#L3057">_SPI_begin_call</a></li>
<li><a href="#L3097">_SPI_checktuples</a></li>
<li><a href="#L227">_SPI_commit</a></li>
<li><a href="#L2829">_SPI_convert_params</a></li>
<li><a href="#L2987">_SPI_cursor_operation</a></li>
<li><a href="#L3081">_SPI_end_call</a></li>
<li><a href="#L2941">_SPI_error_callback</a></li>
<li><a href="#L3038">_SPI_execmem</a></li>
<li><a href="#L2394">_SPI_execute_plan</a></li>
<li><a href="#L3260">_SPI_find_ENR_by_name</a></li>
<li><a href="#L3121">_SPI_make_plan_non_temp</a></li>
<li><a href="#L2854">_SPI_pquery</a></li>
<li><a href="#L2324">_SPI_prepare_oneshot_plan</a></li>
<li><a href="#L2216">_SPI_prepare_plan</a></li>
<li><a href="#L3044">_SPI_procmem</a></li>
<li><a href="#L332">_SPI_rollback</a></li>
<li><a href="#L3189">_SPI_save_plan</a></li>
<li><a href="#L2118">spi_dest_startup</a></li>
<li><a href="#L2166">spi_printtup</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * spi.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Server Programming Interface<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/executor/spi.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/<a href="../access/common/printtup.c.html#L303" title="access/common/printtup.c:303">printtup</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/sysattr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/heap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/spi_priv.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/pquery.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/utility.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/typcache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These global variables are part of the API for various SPI <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> * (a horrible API choice, but it's too late <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>).&nbsp; To reduce the risk of<br/></li>
<li></span><span class="Comment"> * interference between different SPI callers, we save and restore them<br/></li>
<li></span><span class="Comment"> * when entering/exiting a SPI nesting level.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L44">&#x200c;</a></span>uint64&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">SPI_processed</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L45">&#x200c;</a>SPITupleTable *<span class="linkable">SPI_tuptable</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L46">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">SPI_result</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><a id="L48">&#x200c;</a><span class="Type">static</span> _SPI_connection *<span class="linkable">_SPI_stack</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L49">&#x200c;</a><span class="Type">static</span> _SPI_connection *<span class="linkable">_SPI_current</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L50">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">_SPI_stack_depth</span> = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* allocated size of <a href="#L48" title="executor/spi.c:48">_SPI_stack</a> */<br/></li>
<li><a id="L51">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">_SPI_connected</span> = -<span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* current stack index */<br/></li>
<li></span><br/></li>
<li><a id="L53">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">SPICallbackArg</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *query;<br/></li>
<li>&nbsp; &nbsp; RawParseMode mode;<br/></li>
<li><a id="L57">&#x200c;</a>} <span class="linkable">SPICallbackArg</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Portal <a href="#L1574" title="executor/spi.c:1574">SPI_cursor_open_internal</a>(<span class="Type">const</span> <span class="Type">char</span> *name, SPIPlanPtr plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ParamListInfo paramLI, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> read_only);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2216" title="executor/spi.c:2216">_SPI_prepare_plan</a>(<span class="Type">const</span> <span class="Type">char</span> *src, SPIPlanPtr plan);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2324" title="executor/spi.c:2324">_SPI_prepare_oneshot_plan</a>(<span class="Type">const</span> <span class="Type">char</span> *src, SPIPlanPtr plan);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2394" title="executor/spi.c:2394">_SPI_execute_plan</a>(SPIPlanPtr plan, <span class="Type">const</span> SPIExecuteOptions *options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Snapshot snapshot, Snapshot crosscheck_snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> fire_triggers);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> ParamListInfo <a href="#L2829" title="executor/spi.c:2829">_SPI_convert_params</a>(<span class="Type">int</span> nargs, Oid *argtypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *Values, <span class="Type">const</span> <span class="Type">char</span> *<a href="../bootstrap/bootstrap.c.html#L153" title="bootstrap/bootstrap.c:153">Nulls</a>);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2854" title="executor/spi.c:2854">_SPI_pquery</a>(QueryDesc *queryDesc, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> fire_triggers, uint64 tcount);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2941" title="executor/spi.c:2941">_SPI_error_callback</a>(<span class="Type">void</span> *arg);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2987" title="executor/spi.c:2987">_SPI_cursor_operation</a>(Portal portal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FetchDirection direction, <span class="Type">long</span> count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DestReceiver *dest);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> SPIPlanPtr <a href="#L3121" title="executor/spi.c:3121">_SPI_make_plan_non_temp</a>(SPIPlanPtr plan);<br/></li>
<li><span class="Type">static</span> SPIPlanPtr <a href="#L3189" title="executor/spi.c:3189">_SPI_save_plan</a>(SPIPlanPtr plan);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L3057" title="executor/spi.c:3057">_SPI_begin_call</a>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> use_exec);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L3081" title="executor/spi.c:3081">_SPI_end_call</a>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> use_exec);<br/></li>
<li><span class="Type">static</span> MemoryContext <a href="#L3038" title="executor/spi.c:3038">_SPI_execmem</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> MemoryContext <a href="#L3044" title="executor/spi.c:3044">_SPI_procmem</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3097" title="executor/spi.c:3097">_SPI_checktuples</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* =================== interface <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> =================== */<br/></li>
<li></span><br/></li>
<li><span class="Type">int<br/></li>
<li><a id="L94">&#x200c;</a></span><span class="linkable">SPI_connect</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L100" title="executor/spi.c:100">SPI_connect_ext</a>(<span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">int<br/></li>
<li><a id="L100">&#x200c;</a></span><span class="linkable">SPI_connect_ext</span>(<span class="Type">int</span> options)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdepth;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Enlarge stack if necessary */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L48" title="executor/spi.c:48">_SPI_stack</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L51" title="executor/spi.c:51">_SPI_connected</a> != -<span class="Constant">1</span> || <a href="#L50" title="executor/spi.c:50">_SPI_stack_depth</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;SPI stack corrupted&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newdepth = <span class="Constant">16</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L48" title="executor/spi.c:48">_SPI_stack</a> = (_SPI_connection *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newdepth * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(_SPI_connection));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L50" title="executor/spi.c:50">_SPI_stack_depth</a> = newdepth;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L50" title="executor/spi.c:50">_SPI_stack_depth</a> &lt;= <span class="Constant">0</span> || <a href="#L50" title="executor/spi.c:50">_SPI_stack_depth</a> &lt;= <a href="#L51" title="executor/spi.c:51">_SPI_connected</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;SPI stack corrupted&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L50" title="executor/spi.c:50">_SPI_stack_depth</a> == <a href="#L51" title="executor/spi.c:51">_SPI_connected</a> + <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdepth = <a href="#L50" title="executor/spi.c:50">_SPI_stack_depth</a> * <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L48" title="executor/spi.c:48">_SPI_stack</a> = (_SPI_connection *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(<a href="#L48" title="executor/spi.c:48">_SPI_stack</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newdepth * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(_SPI_connection));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L50" title="executor/spi.c:50">_SPI_stack_depth</a> = newdepth;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Enter new stack level */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L51" title="executor/spi.c:51">_SPI_connected</a>++;<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L51" title="executor/spi.c:51">_SPI_connected</a> &gt;= <span class="Constant">0</span> &amp;&amp; <a href="#L51" title="executor/spi.c:51">_SPI_connected</a> &lt; <a href="#L50" title="executor/spi.c:50">_SPI_stack_depth</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a> = &amp;(<a href="#L48" title="executor/spi.c:48">_SPI_stack</a>[<a href="#L51" title="executor/spi.c:51">_SPI_connected</a>]);<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;processed = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;tuptable = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;execSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; slist_init(&amp;<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;tuptables);<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;procCxt = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* in case we fail to create 'em */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;execCxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;connectSubid = <a href="../access/transam/xact.c.html#L788" title="access/transam/xact.c:788">GetCurrentSubTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;queryEnv = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;atomic = (options &amp; SPI_OPT_NONATOMIC ? <span class="Constant">false</span> : <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;internal_xact = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;outer_processed = <a href="#L44" title="executor/spi.c:44">SPI_processed</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;outer_tuptable = <a href="#L45" title="executor/spi.c:45">SPI_tuptable</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;outer_result = <a href="#L46" title="executor/spi.c:46">SPI_result</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create memory contexts for this procedure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In atomic contexts (the normal case), we use <a href="../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise <a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a>, so that it lives across transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * boundaries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> It could be better to use <a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a> as the parent context in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all cases, but we may not be inside a portal (consider deferred-<a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * execution).&nbsp; Perhaps <a href="../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a> could be an option?&nbsp; For <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it doesn't matter because we clean up explicitly in <a href="#L482" title="executor/spi.c:482">AtEOSubXact_SPI</a>();<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but see also <a href="#L428" title="executor/spi.c:428">AtEOXact_SPI</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;procCxt = AllocSetContextCreate(<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;atomic ? <a href="../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a> : <a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;SPI Proc&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;execCxt = AllocSetContextCreate(<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;atomic ? <a href="../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a> : <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;procCxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;SPI Exec&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and switch to procedure's context */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;savedcxt = MemoryContextSwitchTo(<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;procCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset API global variables so that current caller cannot accidentally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * depend on state of an outer caller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L44" title="executor/spi.c:44">SPI_processed</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="executor/spi.c:45">SPI_tuptable</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> SPI_OK_CONNECT;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">int<br/></li>
<li><a id="L182">&#x200c;</a></span><span class="linkable">SPI_finish</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L3057" title="executor/spi.c:3057">_SPI_begin_call</a>(<span class="Constant">false</span>);&nbsp; &nbsp; <span class="Comment">/* just check we're connected */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (res &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore memory context as it was <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> procedure call */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;savedcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release memory used in procedure call (including tuptables) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;execCxt);<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;execCxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;procCxt);<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;procCxt = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Restore outer API variables, especially <a href="#L45" title="executor/spi.c:45">SPI_tuptable</a> which is probably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pointing at a just-deleted tuptable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L44" title="executor/spi.c:44">SPI_processed</a> = <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;outer_processed;<br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="executor/spi.c:45">SPI_tuptable</a> = <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;outer_tuptable;<br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;outer_result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exit stack level */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L51" title="executor/spi.c:51">_SPI_connected</a>--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L51" title="executor/spi.c:51">_SPI_connected</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a> = &amp;(<a href="#L48" title="executor/spi.c:48">_SPI_stack</a>[<a href="#L51" title="executor/spi.c:51">_SPI_connected</a>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> SPI_OK_FINISH;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L222" title="executor/spi.c:222">SPI_start_transaction</a> is a no-op, kept for backwards compatibility.<br/></li>
<li></span><span class="Comment"> * SPI callers are *always* inside a transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L222">&#x200c;</a></span><span class="linkable">SPI_start_transaction</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L227">&#x200c;</a></span><span class="linkable">_SPI_commit</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> chain)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext = <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; SavedTransactionCharacteristics savetc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Complain if we are in a context that doesn't permit transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * termination.&nbsp; (Note: here and <a href="#L332" title="executor/spi.c:332">_SPI_rollback</a> should be the only places<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that throw ERRCODE_INVALID_TRANSACTION_TERMINATION, so that callers can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * test for that with security that they know what happened.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;atomic)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TRANSACTION_TERMINATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid transaction termination&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This restriction is required by PLs implemented on top of SPI.&nbsp; They<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use subtransactions to establish exception blocks that are supposed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be rolled back together if there is an error.&nbsp; Terminating the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * top-level transaction in such a block violates that idea.&nbsp; A future PL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * implementation might have different ideas about this, in which case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this restriction would have to be refined or the check possibly be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * moved out of SPI into the PLs.&nbsp; Note however that the code below relies<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on not being within a subtransaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xact.c.html#L4988" title="access/transam/xact.c:4988">IsSubTransaction</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TRANSACTION_TERMINATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot commit while a subtransaction is active&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (chain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3072" title="access/transam/xact.c:3072">SaveTransactionCharacteristics</a>(&amp;savetc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Catch <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error occurring during the COMMIT */<br/></li>
<li></span>&nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Protect current SPI stack entry against deletion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;internal_xact = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Hold <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pinned portals that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> PLs might be using.&nbsp; We have to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> changing transaction state, since this will run<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * user-defined code that might throw an error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/portalmem.c.html#L1204" title="utils/mmgr/portalmem.c:1204">HoldPinnedPortals</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release snapshots associated with portals */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/portalmem.c.html#L1253" title="utils/mmgr/portalmem.c:1253">ForgetPortalSnapshots</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do the deed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Immediately start a new transaction */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (chain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3080" title="access/transam/xact.c:3080">RestoreTransactionCharacteristics</a>(&amp;savetc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;internal_xact = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ErrorData&nbsp; *edata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Save error info in caller's context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; edata = <a href="../utils/error/elog.c.html#L1731" title="utils/error/elog.c:1731">CopyErrorData</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1836" title="utils/error/elog.c:1836">FlushErrorState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Abort the failed transaction.&nbsp; If this fails too, we'll just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * propagate the error out ... there's not that much we can do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3387" title="access/transam/xact.c:3387">AbortCurrentTransaction</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and start a new one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (chain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3080" title="access/transam/xact.c:3080">RestoreTransactionCharacteristics</a>(&amp;savetc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;internal_xact = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now that we've cleaned up the transaction, re-throw the error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1920" title="utils/error/elog.c:1920">ReThrowError</a>(edata);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_TRY();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L320">&#x200c;</a></span><span class="linkable">SPI_commit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L227" title="executor/spi.c:227">_SPI_commit</a>(<span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L326">&#x200c;</a></span><span class="linkable">SPI_commit_and_chain</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L227" title="executor/spi.c:227">_SPI_commit</a>(<span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L332">&#x200c;</a></span><span class="linkable">_SPI_rollback</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> chain)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext = <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; SavedTransactionCharacteristics savetc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* see under <a href="#L320" title="executor/spi.c:320">SPI_commit</a>() */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;atomic)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TRANSACTION_TERMINATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid transaction termination&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* see under <a href="#L320" title="executor/spi.c:320">SPI_commit</a>() */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xact.c.html#L4988" title="access/transam/xact.c:4988">IsSubTransaction</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TRANSACTION_TERMINATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot roll back while a subtransaction is active&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (chain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3072" title="access/transam/xact.c:3072">SaveTransactionCharacteristics</a>(&amp;savetc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Catch <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error occurring during the ROLLBACK */<br/></li>
<li></span>&nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Protect current SPI stack entry against deletion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;internal_xact = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Hold <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pinned portals that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> PLs might be using.&nbsp; We have to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> changing transaction state, since this will run<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * user-defined code that might throw an error, and in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * couldn't be run in an already-aborted transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/portalmem.c.html#L1204" title="utils/mmgr/portalmem.c:1204">HoldPinnedPortals</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release snapshots associated with portals */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/portalmem.c.html#L1253" title="utils/mmgr/portalmem.c:1253">ForgetPortalSnapshots</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do the deed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3387" title="access/transam/xact.c:3387">AbortCurrentTransaction</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Immediately start a new transaction */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (chain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3080" title="access/transam/xact.c:3080">RestoreTransactionCharacteristics</a>(&amp;savetc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;internal_xact = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ErrorData&nbsp; *edata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Save error info in caller's context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; edata = <a href="../utils/error/elog.c.html#L1731" title="utils/error/elog.c:1731">CopyErrorData</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1836" title="utils/error/elog.c:1836">FlushErrorState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try again to abort the failed transaction.&nbsp; If this fails too,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll just propagate the error out ... there's not that much we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3387" title="access/transam/xact.c:3387">AbortCurrentTransaction</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and start a new one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (chain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3080" title="access/transam/xact.c:3080">RestoreTransactionCharacteristics</a>(&amp;savetc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;internal_xact = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now that we've cleaned up the transaction, re-throw the error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1920" title="utils/error/elog.c:1920">ReThrowError</a>(edata);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_TRY();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L413">&#x200c;</a></span><span class="linkable">SPI_rollback</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L332" title="executor/spi.c:332">_SPI_rollback</a>(<span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L419">&#x200c;</a></span><span class="linkable">SPI_rollback_and_chain</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L332" title="executor/spi.c:332">_SPI_rollback</a>(<span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Clean up SPI state at transaction commit or abort.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L428">&#x200c;</a></span><span class="linkable">AtEOXact_SPI</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Pop stack entries, stopping if we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one marked internal_xact (that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one belongs to the caller of <a href="#L320" title="executor/spi.c:320">SPI_commit</a> or <a href="#L413" title="executor/spi.c:413">SPI_rollback</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L51" title="executor/spi.c:51">_SPI_connected</a> &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _SPI_connection *connection = &amp;(<a href="#L48" title="executor/spi.c:48">_SPI_stack</a>[<a href="#L51" title="executor/spi.c:51">_SPI_connected</a>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (connection-&gt;internal_xact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need not release the procedure's memory contexts explicitly, as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * they'll go away automatically when their parent context does; see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * notes in <a href="#L100" title="executor/spi.c:100">SPI_connect_ext</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Restore outer global variables and pop the stack entry.&nbsp; Unlike<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L182" title="executor/spi.c:182">SPI_finish</a>(), we don't risk switching to memory contexts that might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be already gone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L44" title="executor/spi.c:44">SPI_processed</a> = connection-&gt;outer_processed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L45" title="executor/spi.c:45">SPI_tuptable</a> = connection-&gt;outer_tuptable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = connection-&gt;outer_result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L51" title="executor/spi.c:51">_SPI_connected</a>--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L51" title="executor/spi.c:51">_SPI_connected</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a> = &amp;(<a href="#L48" title="executor/spi.c:48">_SPI_stack</a>[<a href="#L51" title="executor/spi.c:51">_SPI_connected</a>]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We should only <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> entries to pop during an ABORT. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (found &amp;&amp; isCommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WARNING),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;transaction left non-empty SPI stack&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Check for missing </span><span class="Special">\&quot;</span><span class="Constant"><a href="#L182" title="executor/spi.c:182">SPI_finish</a></span><span class="Special">\&quot;</span><span class="Constant"> calls.&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Clean up SPI state at subtransaction commit or abort.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * During commit, there shouldn't be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unclosed entries remaining from<br/></li>
<li></span><span class="Comment"> * the current subtransaction; we emit a warning if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> are found.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L482">&#x200c;</a></span><span class="linkable">AtEOSubXact_SPI</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit, SubTransactionId mySubid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L51" title="executor/spi.c:51">_SPI_connected</a> &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _SPI_connection *connection = &amp;(<a href="#L48" title="executor/spi.c:48">_SPI_stack</a>[<a href="#L51" title="executor/spi.c:51">_SPI_connected</a>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (connection-&gt;connectSubid != mySubid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* couldn't be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> underneath it either */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (connection-&gt;internal_xact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Release procedure memory explicitly (see note in <a href="#L94" title="executor/spi.c:94">SPI_connect</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (connection-&gt;execCxt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(connection-&gt;execCxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; connection-&gt;execCxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (connection-&gt;procCxt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(connection-&gt;procCxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; connection-&gt;procCxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Restore outer global variables and pop the stack entry.&nbsp; Unlike<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L182" title="executor/spi.c:182">SPI_finish</a>(), we don't risk switching to memory contexts that might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be already gone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L44" title="executor/spi.c:44">SPI_processed</a> = connection-&gt;outer_processed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L45" title="executor/spi.c:45">SPI_tuptable</a> = connection-&gt;outer_tuptable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = connection-&gt;outer_result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L51" title="executor/spi.c:51">_SPI_connected</a>--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L51" title="executor/spi.c:51">_SPI_connected</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a> = &amp;(<a href="#L48" title="executor/spi.c:48">_SPI_stack</a>[<a href="#L51" title="executor/spi.c:51">_SPI_connected</a>]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (found &amp;&amp; isCommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WARNING),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;subtransaction left non-empty SPI stack&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Check for missing </span><span class="Special">\&quot;</span><span class="Constant"><a href="#L182" title="executor/spi.c:182">SPI_finish</a></span><span class="Special">\&quot;</span><span class="Constant"> calls.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are aborting a subtransaction and there is an open SPI context<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * surrounding the subxact, clean up to prevent memory leakage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L49" title="executor/spi.c:49">_SPI_current</a> &amp;&amp; !isCommit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slist_mutable_iter siter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Throw away executor state if current executor operation was started<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * within current subxact (essentially, force a <a href="#L3081" title="executor/spi.c:3081">_SPI_end_call</a>(true)).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;execSubid &gt;= mySubid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;execSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;execCxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* throw away <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuple tables created within current subxact */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; slist_foreach_modify(siter, &amp;<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;tuptables)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SPITupleTable *tuptable;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuptable = slist_container(SPITupleTable, <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>, siter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tuptable-&gt;subid &gt;= mySubid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we used <a href="#L1383" title="executor/spi.c:1383">SPI_freetuptable</a>() here, its <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> search of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the tuptables list would make this operation O(N^2).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Instead, just free the tuptable manually.&nbsp; This should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * match what <a href="#L1383" title="executor/spi.c:1383">SPI_freetuptable</a>() does.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slist_delete_current(&amp;siter);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tuptable == <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;tuptable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;tuptable = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tuptable == <a href="#L45" title="executor/spi.c:45">SPI_tuptable</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L45" title="executor/spi.c:45">SPI_tuptable</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(tuptable-&gt;tuptabcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Are we executing inside a procedure (that is, a nonatomic SPI context)?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L581">&#x200c;</a></span><span class="linkable">SPI_inside_nonatomic_context</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L49" title="executor/spi.c:49">_SPI_current</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SPI context at all */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;atomic)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it's atomic (ie function not procedure) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* Parse, plan, and execute a query string */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L593">&#x200c;</a></span><span class="linkable">SPI_execute</span>(<span class="Type">const</span> <span class="Type">char</span> *src, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> read_only, <span class="Type">long</span> tcount)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; _SPI_plan&nbsp; &nbsp; plan;<br/></li>
<li>&nbsp; &nbsp; SPIExecuteOptions options;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (src == <span class="Constant">NULL</span> || tcount &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SPI_ERROR_ARGUMENT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L3057" title="executor/spi.c:3057">_SPI_begin_call</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;plan, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(_SPI_plan));<br/></li>
<li>&nbsp; &nbsp; plan.magic = _SPI_PLAN_MAGIC;<br/></li>
<li>&nbsp; &nbsp; plan.parse_mode = RAW_PARSE_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; plan.cursor_options = CURSOR_OPT_PARALLEL_OK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2324" title="executor/spi.c:2324">_SPI_prepare_oneshot_plan</a>(src, &amp;plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;options, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(options));<br/></li>
<li>&nbsp; &nbsp; options.read_only = read_only;<br/></li>
<li>&nbsp; &nbsp; options.tcount = tcount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L2394" title="executor/spi.c:2394">_SPI_execute_plan</a>(&amp;plan, &amp;options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidSnapshot, InvalidSnapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3081" title="executor/spi.c:3081">_SPI_end_call</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Obsolete version of <a href="#L593" title="executor/spi.c:593">SPI_execute</a> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L627">&#x200c;</a></span><span class="linkable">SPI_exec</span>(<span class="Type">const</span> <span class="Type">char</span> *src, <span class="Type">long</span> tcount)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L593" title="executor/spi.c:593">SPI_execute</a>(src, <span class="Constant">false</span>, tcount);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Parse, plan, and execute a query string, with extensible options */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L634">&#x200c;</a></span><span class="linkable">SPI_execute_extended</span>(<span class="Type">const</span> <span class="Type">char</span> *src,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> SPIExecuteOptions *options)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; _SPI_plan&nbsp; &nbsp; plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (src == <span class="Constant">NULL</span> || options == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SPI_ERROR_ARGUMENT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L3057" title="executor/spi.c:3057">_SPI_begin_call</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;plan, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(_SPI_plan));<br/></li>
<li>&nbsp; &nbsp; plan.magic = _SPI_PLAN_MAGIC;<br/></li>
<li>&nbsp; &nbsp; plan.parse_mode = RAW_PARSE_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; plan.cursor_options = CURSOR_OPT_PARALLEL_OK;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (options-&gt;params)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan.parserSetup = options-&gt;params-&gt;parserSetup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan.parserSetupArg = options-&gt;params-&gt;parserSetupArg;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2324" title="executor/spi.c:2324">_SPI_prepare_oneshot_plan</a>(src, &amp;plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L2394" title="executor/spi.c:2394">_SPI_execute_plan</a>(&amp;plan, options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidSnapshot, InvalidSnapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3081" title="executor/spi.c:3081">_SPI_end_call</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Execute a previously prepared plan */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L669">&#x200c;</a></span><span class="linkable">SPI_execute_plan</span>(SPIPlanPtr plan, Datum *Values, <span class="Type">const</span> <span class="Type">char</span> *<a href="../bootstrap/bootstrap.c.html#L153" title="bootstrap/bootstrap.c:153">Nulls</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> read_only, <span class="Type">long</span> tcount)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SPIExecuteOptions options;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan == <span class="Constant">NULL</span> || plan-&gt;magic != _SPI_PLAN_MAGIC || tcount &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SPI_ERROR_ARGUMENT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan-&gt;nargs &gt; <span class="Constant">0</span> &amp;&amp; Values == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SPI_ERROR_PARAM;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L3057" title="executor/spi.c:3057">_SPI_begin_call</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;options, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(options));<br/></li>
<li>&nbsp; &nbsp; options.params = <a href="#L2829" title="executor/spi.c:2829">_SPI_convert_params</a>(plan-&gt;nargs, plan-&gt;argtypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Values, <a href="../bootstrap/bootstrap.c.html#L153" title="bootstrap/bootstrap.c:153">Nulls</a>);<br/></li>
<li>&nbsp; &nbsp; options.read_only = read_only;<br/></li>
<li>&nbsp; &nbsp; options.tcount = tcount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L2394" title="executor/spi.c:2394">_SPI_execute_plan</a>(plan, &amp;options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidSnapshot, InvalidSnapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3081" title="executor/spi.c:3081">_SPI_end_call</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Obsolete version of <a href="#L669" title="executor/spi.c:669">SPI_execute_plan</a> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L701">&#x200c;</a></span><span class="linkable">SPI_execp</span>(SPIPlanPtr plan, Datum *Values, <span class="Type">const</span> <span class="Type">char</span> *<a href="../bootstrap/bootstrap.c.html#L153" title="bootstrap/bootstrap.c:153">Nulls</a>, <span class="Type">long</span> tcount)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L669" title="executor/spi.c:669">SPI_execute_plan</a>(plan, Values, <a href="../bootstrap/bootstrap.c.html#L153" title="bootstrap/bootstrap.c:153">Nulls</a>, <span class="Constant">false</span>, tcount);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Execute a previously prepared plan */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L708">&#x200c;</a></span><span class="linkable">SPI_execute_plan_extended</span>(SPIPlanPtr plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> SPIExecuteOptions *options)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan == <span class="Constant">NULL</span> || plan-&gt;magic != _SPI_PLAN_MAGIC || options == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SPI_ERROR_ARGUMENT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L3057" title="executor/spi.c:3057">_SPI_begin_call</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L2394" title="executor/spi.c:2394">_SPI_execute_plan</a>(plan, options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidSnapshot, InvalidSnapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3081" title="executor/spi.c:3081">_SPI_end_call</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Execute a previously prepared plan */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L730">&#x200c;</a></span><span class="linkable">SPI_execute_plan_with_paramlist</span>(SPIPlanPtr plan, ParamListInfo params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> read_only, <span class="Type">long</span> tcount)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SPIExecuteOptions options;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan == <span class="Constant">NULL</span> || plan-&gt;magic != _SPI_PLAN_MAGIC || tcount &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SPI_ERROR_ARGUMENT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L3057" title="executor/spi.c:3057">_SPI_begin_call</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;options, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(options));<br/></li>
<li>&nbsp; &nbsp; options.params = params;<br/></li>
<li>&nbsp; &nbsp; options.read_only = read_only;<br/></li>
<li>&nbsp; &nbsp; options.tcount = tcount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L2394" title="executor/spi.c:2394">_SPI_execute_plan</a>(plan, &amp;options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidSnapshot, InvalidSnapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3081" title="executor/spi.c:3081">_SPI_end_call</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L770" title="executor/spi.c:770">SPI_execute_snapshot</a> -- identical to <a href="#L669" title="executor/spi.c:669">SPI_execute_plan</a>, except that we allow<br/></li>
<li></span><span class="Comment"> * the caller to specify exactly which snapshots to use, which will be<br/></li>
<li></span><span class="Comment"> * registered here.&nbsp; Also, the caller may specify that AFTER triggers should be<br/></li>
<li></span><span class="Comment"> * queued as part of the outer query rather than being fired immediately at the<br/></li>
<li></span><span class="Comment"> * end of the command.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is currently not documented in spi.sgml because it is only intended<br/></li>
<li></span><span class="Comment"> * for use by RI triggers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Passing snapshot == InvalidSnapshot will <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> the normal behavior of<br/></li>
<li></span><span class="Comment"> * fetching a new snapshot for each query.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L770">&#x200c;</a></span><span class="linkable">SPI_execute_snapshot</span>(SPIPlanPtr plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *Values, <span class="Type">const</span> <span class="Type">char</span> *<a href="../bootstrap/bootstrap.c.html#L153" title="bootstrap/bootstrap.c:153">Nulls</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Snapshot snapshot, Snapshot crosscheck_snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> read_only, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> fire_triggers, <span class="Type">long</span> tcount)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SPIExecuteOptions options;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan == <span class="Constant">NULL</span> || plan-&gt;magic != _SPI_PLAN_MAGIC || tcount &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SPI_ERROR_ARGUMENT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan-&gt;nargs &gt; <span class="Constant">0</span> &amp;&amp; Values == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SPI_ERROR_PARAM;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L3057" title="executor/spi.c:3057">_SPI_begin_call</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;options, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(options));<br/></li>
<li>&nbsp; &nbsp; options.params = <a href="#L2829" title="executor/spi.c:2829">_SPI_convert_params</a>(plan-&gt;nargs, plan-&gt;argtypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Values, <a href="../bootstrap/bootstrap.c.html#L153" title="bootstrap/bootstrap.c:153">Nulls</a>);<br/></li>
<li>&nbsp; &nbsp; options.read_only = read_only;<br/></li>
<li>&nbsp; &nbsp; options.tcount = tcount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L2394" title="executor/spi.c:2394">_SPI_execute_plan</a>(plan, &amp;options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snapshot, crosscheck_snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fire_triggers);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3081" title="executor/spi.c:3081">_SPI_end_call</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L809" title="executor/spi.c:809">SPI_execute_with_args</a> -- plan and execute a query with supplied arguments<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is functionally equivalent to <a href="#L857" title="executor/spi.c:857">SPI_prepare</a> followed by<br/></li>
<li></span><span class="Comment"> * <a href="#L669" title="executor/spi.c:669">SPI_execute_plan</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L809">&#x200c;</a></span><span class="linkable">SPI_execute_with_args</span>(<span class="Type">const</span> <span class="Type">char</span> *src,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nargs, Oid *argtypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *Values, <span class="Type">const</span> <span class="Type">char</span> *<a href="../bootstrap/bootstrap.c.html#L153" title="bootstrap/bootstrap.c:153">Nulls</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> read_only, <span class="Type">long</span> tcount)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; _SPI_plan&nbsp; &nbsp; plan;<br/></li>
<li>&nbsp; &nbsp; ParamListInfo paramLI;<br/></li>
<li>&nbsp; &nbsp; SPIExecuteOptions options;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (src == <span class="Constant">NULL</span> || nargs &lt; <span class="Constant">0</span> || tcount &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SPI_ERROR_ARGUMENT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nargs &gt; <span class="Constant">0</span> &amp;&amp; (argtypes == <span class="Constant">NULL</span> || Values == <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SPI_ERROR_PARAM;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L3057" title="executor/spi.c:3057">_SPI_begin_call</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;plan, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(_SPI_plan));<br/></li>
<li>&nbsp; &nbsp; plan.magic = _SPI_PLAN_MAGIC;<br/></li>
<li>&nbsp; &nbsp; plan.parse_mode = RAW_PARSE_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; plan.cursor_options = CURSOR_OPT_PARALLEL_OK;<br/></li>
<li>&nbsp; &nbsp; plan.nargs = nargs;<br/></li>
<li>&nbsp; &nbsp; plan.argtypes = argtypes;<br/></li>
<li>&nbsp; &nbsp; plan.parserSetup = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan.parserSetupArg = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; paramLI = <a href="#L2829" title="executor/spi.c:2829">_SPI_convert_params</a>(nargs, argtypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Values, <a href="../bootstrap/bootstrap.c.html#L153" title="bootstrap/bootstrap.c:153">Nulls</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2324" title="executor/spi.c:2324">_SPI_prepare_oneshot_plan</a>(src, &amp;plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;options, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(options));<br/></li>
<li>&nbsp; &nbsp; options.params = paramLI;<br/></li>
<li>&nbsp; &nbsp; options.read_only = read_only;<br/></li>
<li>&nbsp; &nbsp; options.tcount = tcount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L2394" title="executor/spi.c:2394">_SPI_execute_plan</a>(&amp;plan, &amp;options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidSnapshot, InvalidSnapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3081" title="executor/spi.c:3081">_SPI_end_call</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>SPIPlanPtr<br/></li>
<li><a id="L857">&#x200c;</a><span class="linkable">SPI_prepare</span>(<span class="Type">const</span> <span class="Type">char</span> *src, <span class="Type">int</span> nargs, Oid *argtypes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L863" title="executor/spi.c:863">SPI_prepare_cursor</a>(src, nargs, argtypes, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>SPIPlanPtr<br/></li>
<li><a id="L863">&#x200c;</a><span class="linkable">SPI_prepare_cursor</span>(<span class="Type">const</span> <span class="Type">char</span> *src, <span class="Type">int</span> nargs, Oid *argtypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> cursorOptions)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; _SPI_plan&nbsp; &nbsp; plan;<br/></li>
<li>&nbsp; &nbsp; SPIPlanPtr&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (src == <span class="Constant">NULL</span> || nargs &lt; <span class="Constant">0</span> || (nargs &gt; <span class="Constant">0</span> &amp;&amp; argtypes == <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = SPI_ERROR_ARGUMENT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = <a href="#L3057" title="executor/spi.c:3057">_SPI_begin_call</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L46" title="executor/spi.c:46">SPI_result</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;plan, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(_SPI_plan));<br/></li>
<li>&nbsp; &nbsp; plan.magic = _SPI_PLAN_MAGIC;<br/></li>
<li>&nbsp; &nbsp; plan.parse_mode = RAW_PARSE_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; plan.cursor_options = cursorOptions;<br/></li>
<li>&nbsp; &nbsp; plan.nargs = nargs;<br/></li>
<li>&nbsp; &nbsp; plan.argtypes = argtypes;<br/></li>
<li>&nbsp; &nbsp; plan.parserSetup = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan.parserSetupArg = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2216" title="executor/spi.c:2216">_SPI_prepare_plan</a>(src, &amp;plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy plan to procedure context */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="#L3121" title="executor/spi.c:3121">_SPI_make_plan_non_temp</a>(&amp;plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3081" title="executor/spi.c:3081">_SPI_end_call</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>SPIPlanPtr<br/></li>
<li><a id="L899">&#x200c;</a><span class="linkable">SPI_prepare_extended</span>(<span class="Type">const</span> <span class="Type">char</span> *src,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> SPIPrepareOptions *options)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; _SPI_plan&nbsp; &nbsp; plan;<br/></li>
<li>&nbsp; &nbsp; SPIPlanPtr&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (src == <span class="Constant">NULL</span> || options == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = SPI_ERROR_ARGUMENT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = <a href="#L3057" title="executor/spi.c:3057">_SPI_begin_call</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L46" title="executor/spi.c:46">SPI_result</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;plan, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(_SPI_plan));<br/></li>
<li>&nbsp; &nbsp; plan.magic = _SPI_PLAN_MAGIC;<br/></li>
<li>&nbsp; &nbsp; plan.parse_mode = options-&gt;parseMode;<br/></li>
<li>&nbsp; &nbsp; plan.cursor_options = options-&gt;cursorOptions;<br/></li>
<li>&nbsp; &nbsp; plan.nargs = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; plan.argtypes = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan.parserSetup = options-&gt;parserSetup;<br/></li>
<li>&nbsp; &nbsp; plan.parserSetupArg = options-&gt;parserSetupArg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2216" title="executor/spi.c:2216">_SPI_prepare_plan</a>(src, &amp;plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy plan to procedure context */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="#L3121" title="executor/spi.c:3121">_SPI_make_plan_non_temp</a>(&amp;plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3081" title="executor/spi.c:3081">_SPI_end_call</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>SPIPlanPtr<br/></li>
<li><a id="L935">&#x200c;</a><span class="linkable">SPI_prepare_params</span>(<span class="Type">const</span> <span class="Type">char</span> *src,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ParserSetupHook parserSetup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *parserSetupArg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> cursorOptions)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; _SPI_plan&nbsp; &nbsp; plan;<br/></li>
<li>&nbsp; &nbsp; SPIPlanPtr&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (src == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = SPI_ERROR_ARGUMENT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = <a href="#L3057" title="executor/spi.c:3057">_SPI_begin_call</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L46" title="executor/spi.c:46">SPI_result</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;plan, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(_SPI_plan));<br/></li>
<li>&nbsp; &nbsp; plan.magic = _SPI_PLAN_MAGIC;<br/></li>
<li>&nbsp; &nbsp; plan.parse_mode = RAW_PARSE_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; plan.cursor_options = cursorOptions;<br/></li>
<li>&nbsp; &nbsp; plan.nargs = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; plan.argtypes = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan.parserSetup = parserSetup;<br/></li>
<li>&nbsp; &nbsp; plan.parserSetupArg = parserSetupArg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2216" title="executor/spi.c:2216">_SPI_prepare_plan</a>(src, &amp;plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy plan to procedure context */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="#L3121" title="executor/spi.c:3121">_SPI_make_plan_non_temp</a>(&amp;plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3081" title="executor/spi.c:3081">_SPI_end_call</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">int<br/></li>
<li><a id="L973">&#x200c;</a></span><span class="linkable">SPI_keepplan</span>(SPIPlanPtr plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan == <span class="Constant">NULL</span> || plan-&gt;magic != _SPI_PLAN_MAGIC ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;saved || plan-&gt;oneshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SPI_ERROR_ARGUMENT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark it saved, reparent it under <a href="../utils/mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>, and mark all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * component CachedPlanSources as saved.&nbsp; This sequence cannot fail<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partway through, so there's no risk of long-term memory leakage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; plan-&gt;saved = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L637" title="utils/mmgr/mcxt.c:637">MemoryContextSetParent</a>(plan-&gt;plancxt, <a href="../utils/mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, plan-&gt;plancache_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CachedPlanSource *plansource = (CachedPlanSource *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/plancache.c.html#L482" title="utils/cache/plancache.c:482">SaveCachedPlan</a>(plansource);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>SPIPlanPtr<br/></li>
<li><a id="L1000">&#x200c;</a><span class="linkable">SPI_saveplan</span>(SPIPlanPtr plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SPIPlanPtr&nbsp; &nbsp; newplan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan == <span class="Constant">NULL</span> || plan-&gt;magic != _SPI_PLAN_MAGIC)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = SPI_ERROR_ARGUMENT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = <a href="#L3057" title="executor/spi.c:3057">_SPI_begin_call</a>(<span class="Constant">false</span>);&nbsp; &nbsp; <span class="Comment">/* don't change context */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L46" title="executor/spi.c:46">SPI_result</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newplan = <a href="#L3189" title="executor/spi.c:3189">_SPI_save_plan</a>(plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = <a href="#L3081" title="executor/spi.c:3081">_SPI_end_call</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newplan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">int<br/></li>
<li><a id="L1022">&#x200c;</a></span><span class="linkable">SPI_freeplan</span>(SPIPlanPtr plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan == <span class="Constant">NULL</span> || plan-&gt;magic != _SPI_PLAN_MAGIC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SPI_ERROR_ARGUMENT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release the plancache entries */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, plan-&gt;plancache_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CachedPlanSource *plansource = (CachedPlanSource *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/plancache.c.html#L526" title="utils/cache/plancache.c:526">DropCachedPlan</a>(plansource);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now get rid of the _SPI_plan and subsidiary data in its plancxt */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(plan-&gt;plancxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>HeapTuple<br/></li>
<li><a id="L1044">&#x200c;</a><span class="linkable">SPI_copytuple</span>(HeapTuple tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; ctuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tuple == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = SPI_ERROR_ARGUMENT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L49" title="executor/spi.c:49">_SPI_current</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = SPI_ERROR_UNCONNECTED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;savedcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctuple = <a href="../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ctuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>HeapTupleHeader<br/></li>
<li><a id="L1071">&#x200c;</a><span class="linkable">SPI_returntuple</span>(HeapTuple tuple, TupleDesc tupdesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader dtup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tuple == <span class="Constant">NULL</span> || tupdesc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = SPI_ERROR_ARGUMENT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L49" title="executor/spi.c:49">_SPI_current</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = SPI_ERROR_UNCONNECTED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For RECORD results, make sure a typmod has been assigned */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tupdesc-&gt;tdtypeid == RECORDOID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupdesc-&gt;tdtypmod &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/typcache.c.html#L1953" title="utils/cache/typcache.c:1953">assign_record_type_typmod</a>(tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;savedcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dtup = DatumGetHeapTupleHeader(<a href="../access/common/heaptuple.c.html#L1080" title="access/common/heaptuple.c:1080">heap_copy_tuple_as_datum</a>(tuple, tupdesc));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> dtup;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>HeapTuple<br/></li>
<li><a id="L1103">&#x200c;</a><span class="linkable">SPI_modifytuple</span>(Relation rel, HeapTuple tuple, <span class="Type">int</span> natts, <span class="Type">int</span> *attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *Values, <span class="Type">const</span> <span class="Type">char</span> *<a href="../bootstrap/bootstrap.c.html#L153" title="bootstrap/bootstrap.c:153">Nulls</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; mtuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numberOfAttributes;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *v;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *n;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel == <span class="Constant">NULL</span> || tuple == <span class="Constant">NULL</span> || natts &lt; <span class="Constant">0</span> || attnum == <span class="Constant">NULL</span> || Values == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = SPI_ERROR_ARGUMENT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L49" title="executor/spi.c:49">_SPI_current</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = SPI_ERROR_UNCONNECTED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;savedcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; numberOfAttributes = rel-&gt;rd_att-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; v = (Datum *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numberOfAttributes * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; n = (<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numberOfAttributes * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fetch old <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and nulls */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(tuple, rel-&gt;rd_att, v, n);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* replace <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and nulls */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attnum[i] &lt;= <span class="Constant">0</span> || attnum[i] &gt; numberOfAttributes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v[attnum[i] - <span class="Constant">1</span>] = Values[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n[attnum[i] - <span class="Constant">1</span>] = (<a href="../bootstrap/bootstrap.c.html#L153" title="bootstrap/bootstrap.c:153">Nulls</a> &amp;&amp; <a href="../bootstrap/bootstrap.c.html#L153" title="bootstrap/bootstrap.c:153">Nulls</a>[i] == <span class="Constant">'n'</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (i == natts)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no errors in *attnum */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mtuple = <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(rel-&gt;rd_att, v, n);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * copy the identification info of the old tuple: t_ctid, t_self, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OID (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mtuple-&gt;t_data-&gt;t_ctid = tuple-&gt;t_data-&gt;t_ctid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mtuple-&gt;t_self = tuple-&gt;t_self;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mtuple-&gt;t_tableOid = tuple-&gt;t_tableOid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mtuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = SPI_ERROR_NOATTRIBUTE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(v);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(n);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> mtuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">int<br/></li>
<li><a id="L1172">&#x200c;</a></span><span class="linkable">SPI_fnumber</span>(TupleDesc tupdesc, <span class="Type">const</span> <span class="Type">char</span> *fname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> FormData_pg_attribute *sysatt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (res = <span class="Constant">0</span>; res &lt; tupdesc-&gt;natts; res++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr = TupleDescAttr(tupdesc, res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/adt/name.c.html#L247" title="utils/adt/name.c:247">namestrcmp</a>(&amp;attr-&gt;attname, fname) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !attr-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sysatt = <a href="../catalog/heap.c.html#L252" title="catalog/heap.c:252">SystemAttributeByName</a>(fname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sysatt != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> sysatt-&gt;attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* SPI_ERROR_NOATTRIBUTE is different from all sys column numbers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> SPI_ERROR_NOATTRIBUTE;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">char</span> *<br/></li>
<li><a id="L1195">&#x200c;</a><span class="linkable">SPI_fname</span>(TupleDesc tupdesc, <span class="Type">int</span> fnumber)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> FormData_pg_attribute *att;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fnumber &gt; tupdesc-&gt;natts || fnumber == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fnumber &lt;= FirstLowInvalidHeapAttributeNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = SPI_ERROR_NOATTRIBUTE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fnumber &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att = TupleDescAttr(tupdesc, fnumber - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; att = <a href="../catalog/heap.c.html#L240" title="catalog/heap.c:240">SystemAttributeDefinition</a>(fnumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(att-&gt;attname));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">char</span> *<br/></li>
<li><a id="L1217">&#x200c;</a><span class="linkable">SPI_getvalue</span>(HeapTuple tuple, TupleDesc tupdesc, <span class="Type">int</span> fnumber)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foutoid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typisvarlena;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fnumber &gt; tupdesc-&gt;natts || fnumber == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fnumber &lt;= FirstLowInvalidHeapAttributeNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = SPI_ERROR_NOATTRIBUTE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; val = heap_getattr(tuple, fnumber, tupdesc, &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fnumber &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typoid = TupleDescAttr(tupdesc, fnumber - <span class="Constant">1</span>)-&gt;atttypid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typoid = (<a href="../catalog/heap.c.html#L240" title="catalog/heap.c:240">SystemAttributeDefinition</a>(fnumber))-&gt;atttypid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L2907" title="utils/cache/lsyscache.c:2907">getTypeOutputInfo</a>(typoid, &amp;foutoid, &amp;typisvarlena);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../utils/fmgr/fmgr.c.html#L1763" title="utils/fmgr/fmgr.c:1763">OidOutputFunctionCall</a>(foutoid, val);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1249">&#x200c;</a><span class="linkable">SPI_getbinval</span>(HeapTuple tuple, TupleDesc tupdesc, <span class="Type">int</span> fnumber, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fnumber &gt; tupdesc-&gt;natts || fnumber == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fnumber &lt;= FirstLowInvalidHeapAttributeNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = SPI_ERROR_NOATTRIBUTE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> heap_getattr(tuple, fnumber, tupdesc, isnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">char</span> *<br/></li>
<li><a id="L1265">&#x200c;</a><span class="linkable">SPI_gettype</span>(TupleDesc tupdesc, <span class="Type">int</span> fnumber)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typoid;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; typeTuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fnumber &gt; tupdesc-&gt;natts || fnumber == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fnumber &lt;= FirstLowInvalidHeapAttributeNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = SPI_ERROR_NOATTRIBUTE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fnumber &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typoid = TupleDescAttr(tupdesc, fnumber - <span class="Constant">1</span>)-&gt;atttypid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typoid = (<a href="../catalog/heap.c.html#L240" title="catalog/heap.c:240">SystemAttributeDefinition</a>(fnumber))-&gt;atttypid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typeTuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typoid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(typeTuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = SPI_ERROR_TYPUNKNOWN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(((Form_pg_type) GETSTRUCT(typeTuple))-&gt;typname));<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(typeTuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the data type OID for a column.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There's nothing similar for typmod and typcollation.&nbsp; The rare consumers<br/></li>
<li></span><span class="Comment"> * thereof should inspect the TupleDesc directly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L1305">&#x200c;</a><span class="linkable">SPI_gettypeid</span>(TupleDesc tupdesc, <span class="Type">int</span> fnumber)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fnumber &gt; tupdesc-&gt;natts || fnumber == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fnumber &lt;= FirstLowInvalidHeapAttributeNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = SPI_ERROR_NOATTRIBUTE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fnumber &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TupleDescAttr(tupdesc, fnumber - <span class="Constant">1</span>)-&gt;atttypid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<a href="../catalog/heap.c.html#L240" title="catalog/heap.c:240">SystemAttributeDefinition</a>(fnumber))-&gt;atttypid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">char</span> *<br/></li>
<li><a id="L1323">&#x200c;</a><span class="linkable">SPI_getrelname</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(RelationGetRelationName(rel));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">char</span> *<br/></li>
<li><a id="L1329">&#x200c;</a><span class="linkable">SPI_getnspname</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(RelationGetNamespace(rel));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void</span> *<br/></li>
<li><a id="L1335">&#x200c;</a><span class="linkable">SPI_palloc</span>(Size size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L49" title="executor/spi.c:49">_SPI_current</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L1335" title="executor/spi.c:1335">SPI_palloc</a> called while not connected to SPI&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;savedcxt, size);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void</span> *<br/></li>
<li><a id="L1344">&#x200c;</a><span class="linkable">SPI_repalloc</span>(<span class="Type">void</span> *pointer, Size size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No longer need to worry which context chunk was in... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(pointer, size);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1351">&#x200c;</a></span><span class="linkable">SPI_pfree</span>(<span class="Type">void</span> *pointer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No longer need to worry which context chunk was in... */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pointer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1358">&#x200c;</a><span class="linkable">SPI_datumTransfer</span>(Datum value, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> typByVal, <span class="Type">int</span> typLen)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L49" title="executor/spi.c:49">_SPI_current</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L1358" title="executor/spi.c:1358">SPI_datumTransfer</a> called while not connected to SPI&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;savedcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../utils/adt/datum.c.html#L194" title="utils/adt/datum.c:194">datumTransfer</a>(value, typByVal, typLen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1376">&#x200c;</a></span><span class="linkable">SPI_freetuple</span>(HeapTuple tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No longer need to worry which context tuple was in... */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1383">&#x200c;</a></span><span class="linkable">SPI_freetuptable</span>(SPITupleTable *tuptable)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ignore call if NULL pointer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tuptable == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Search only the topmost SPI context for a matching tuple table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L49" title="executor/spi.c:49">_SPI_current</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slist_mutable_iter siter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> tuptable in active list, then remove it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; slist_foreach_modify(siter, &amp;<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;tuptables)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SPITupleTable *tt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tt = slist_container(SPITupleTable, <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>, siter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tt == tuptable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slist_delete_current(&amp;siter);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Refuse the deletion if we didn't <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it in the topmost SPI context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is primarily a guard against double deletion, but might prevent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other errors as well.&nbsp; Since the worst consequence of not deleting a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuptable would be a transient memory leak, this is just a WARNING.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;attempt to delete invalid SPITupleTable </span><span class="Special">%p</span><span class="Constant">&quot;</span>, tuptable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* for safety, reset global variables that might point at tuptable */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tuptable == <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;tuptable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;tuptable = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tuptable == <a href="#L45" title="executor/spi.c:45">SPI_tuptable</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L45" title="executor/spi.c:45">SPI_tuptable</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* release all memory belonging to tuptable */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(tuptable-&gt;tuptabcxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1442" title="executor/spi.c:1442">SPI_cursor_open</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Open a prepared SPI plan as a portal<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Portal<br/></li>
<li><a id="L1442">&#x200c;</a><span class="linkable">SPI_cursor_open</span>(<span class="Type">const</span> <span class="Type">char</span> *name, SPIPlanPtr plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *Values, <span class="Type">const</span> <span class="Type">char</span> *<a href="../bootstrap/bootstrap.c.html#L153" title="bootstrap/bootstrap.c:153">Nulls</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> read_only)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal;<br/></li>
<li>&nbsp; &nbsp; ParamListInfo paramLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build transient ParamListInfo in caller's context */<br/></li>
<li></span>&nbsp; &nbsp; paramLI = <a href="#L2829" title="executor/spi.c:2829">_SPI_convert_params</a>(plan-&gt;nargs, plan-&gt;argtypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Values, <a href="../bootstrap/bootstrap.c.html#L153" title="bootstrap/bootstrap.c:153">Nulls</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; portal = <a href="#L1574" title="executor/spi.c:1574">SPI_cursor_open_internal</a>(name, plan, paramLI, read_only);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* done with the transient ParamListInfo */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (paramLI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(paramLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> portal;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1469" title="executor/spi.c:1469">SPI_cursor_open_with_args</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Parse and plan a query and open it as a portal.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Portal<br/></li>
<li><a id="L1469">&#x200c;</a><span class="linkable">SPI_cursor_open_with_args</span>(<span class="Type">const</span> <span class="Type">char</span> *name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *src,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nargs, Oid *argtypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *Values, <span class="Type">const</span> <span class="Type">char</span> *<a href="../bootstrap/bootstrap.c.html#L153" title="bootstrap/bootstrap.c:153">Nulls</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> read_only, <span class="Type">int</span> cursorOptions)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; _SPI_plan&nbsp; &nbsp; plan;<br/></li>
<li>&nbsp; &nbsp; ParamListInfo paramLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (src == <span class="Constant">NULL</span> || nargs &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L1469" title="executor/spi.c:1469">SPI_cursor_open_with_args</a> called with invalid arguments&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nargs &gt; <span class="Constant">0</span> &amp;&amp; (argtypes == <span class="Constant">NULL</span> || Values == <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L1469" title="executor/spi.c:1469">SPI_cursor_open_with_args</a> called with missing parameters&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = <a href="#L3057" title="executor/spi.c:3057">_SPI_begin_call</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L46" title="executor/spi.c:46">SPI_result</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L1469" title="executor/spi.c:1469">SPI_cursor_open_with_args</a> called while not connected&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;plan, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(_SPI_plan));<br/></li>
<li>&nbsp; &nbsp; plan.magic = _SPI_PLAN_MAGIC;<br/></li>
<li>&nbsp; &nbsp; plan.parse_mode = RAW_PARSE_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; plan.cursor_options = cursorOptions;<br/></li>
<li>&nbsp; &nbsp; plan.nargs = nargs;<br/></li>
<li>&nbsp; &nbsp; plan.argtypes = argtypes;<br/></li>
<li>&nbsp; &nbsp; plan.parserSetup = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plan.parserSetupArg = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build transient ParamListInfo in executor context */<br/></li>
<li></span>&nbsp; &nbsp; paramLI = <a href="#L2829" title="executor/spi.c:2829">_SPI_convert_params</a>(nargs, argtypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Values, <a href="../bootstrap/bootstrap.c.html#L153" title="bootstrap/bootstrap.c:153">Nulls</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2216" title="executor/spi.c:2216">_SPI_prepare_plan</a>(src, &amp;plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We needn't copy the plan; <a href="#L1574" title="executor/spi.c:1574">SPI_cursor_open_internal</a> will do so */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1574" title="executor/spi.c:1574">SPI_cursor_open_internal</a>(name, &amp;plan, paramLI, read_only);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And clean up */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3081" title="executor/spi.c:3081">_SPI_end_call</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1522" title="executor/spi.c:1522">SPI_cursor_open_with_paramlist</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Same as <a href="#L1442" title="executor/spi.c:1442">SPI_cursor_open</a> except that parameters (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) are passed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; as a ParamListInfo, which supports dynamic parameter set determination<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Portal<br/></li>
<li><a id="L1522">&#x200c;</a><span class="linkable">SPI_cursor_open_with_paramlist</span>(<span class="Type">const</span> <span class="Type">char</span> *name, SPIPlanPtr plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ParamListInfo params, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> read_only)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1574" title="executor/spi.c:1574">SPI_cursor_open_internal</a>(name, plan, params, read_only);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Parse a query and open it as a cursor */<br/></li>
<li></span>Portal<br/></li>
<li><a id="L1530">&#x200c;</a><span class="linkable">SPI_cursor_parse_open</span>(<span class="Type">const</span> <span class="Type">char</span> *name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *src,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> SPIParseOpenOptions *options)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; _SPI_plan&nbsp; &nbsp; plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (src == <span class="Constant">NULL</span> || options == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L1530" title="executor/spi.c:1530">SPI_cursor_parse_open</a> called with invalid arguments&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = <a href="#L3057" title="executor/spi.c:3057">_SPI_begin_call</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L46" title="executor/spi.c:46">SPI_result</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L1530" title="executor/spi.c:1530">SPI_cursor_parse_open</a> called while not connected&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;plan, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(_SPI_plan));<br/></li>
<li>&nbsp; &nbsp; plan.magic = _SPI_PLAN_MAGIC;<br/></li>
<li>&nbsp; &nbsp; plan.parse_mode = RAW_PARSE_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; plan.cursor_options = options-&gt;cursorOptions;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (options-&gt;params)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan.parserSetup = options-&gt;params-&gt;parserSetup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan.parserSetupArg = options-&gt;params-&gt;parserSetupArg;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2216" title="executor/spi.c:2216">_SPI_prepare_plan</a>(src, &amp;plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We needn't copy the plan; <a href="#L1574" title="executor/spi.c:1574">SPI_cursor_open_internal</a> will do so */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1574" title="executor/spi.c:1574">SPI_cursor_open_internal</a>(name, &amp;plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; options-&gt;params, options-&gt;read_only);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And clean up */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3081" title="executor/spi.c:3081">_SPI_end_call</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1574" title="executor/spi.c:1574">SPI_cursor_open_internal</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Common code for <a href="#L1442" title="executor/spi.c:1442">SPI_cursor_open</a> variants<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Portal<br/></li>
<li><a id="L1574">&#x200c;</a><span class="linkable">SPI_cursor_open_internal</span>(<span class="Type">const</span> <span class="Type">char</span> *name, SPIPlanPtr plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ParamListInfo paramLI, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> read_only)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CachedPlanSource *plansource;<br/></li>
<li>&nbsp; &nbsp; CachedPlan *cplan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *stmt_list;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *query_string;<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal;<br/></li>
<li>&nbsp; &nbsp; <a href="#L53" title="executor/spi.c:53">SPICallbackArg</a> spicallbackarg;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback spierrcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that the plan is something the Portal code will special-case as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * returning one tupleset.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1907" title="executor/spi.c:1907">SPI_is_cursor_plan</a>(plan))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* try to give a good error message */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *cmdtag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(plan-&gt;plancache_list) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_CURSOR_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot open multi-query plan as cursor&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plansource = (CachedPlanSource *) linitial(plan-&gt;plancache_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* A SELECT that fails <a href="#L1907" title="executor/spi.c:1907">SPI_is_cursor_plan</a>() must be SELECT INTO */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;commandTag == CMDTAG_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmdtag = <span class="Constant">&quot;SELECT INTO&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmdtag = <a href="../tcop/cmdtag.c.html#L47" title="tcop/cmdtag.c:47">GetCommandTagName</a>(plansource-&gt;commandTag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_CURSOR_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is name of a SQL command, eg INSERT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot open </span><span class="Special">%s</span><span class="Constant"> query as cursor&quot;</span>, cmdtag)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(list_length(plan-&gt;plancache_list) == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; plansource = (CachedPlanSource *) linitial(plan-&gt;plancache_list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push the SPI stack */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3057" title="executor/spi.c:3057">_SPI_begin_call</a>(<span class="Constant">true</span>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L1442" title="executor/spi.c:1442">SPI_cursor_open</a> called while not connected&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset SPI result (note we deliberately don't touch lastoid) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L44" title="executor/spi.c:44">SPI_processed</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="executor/spi.c:45">SPI_tuptable</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;processed = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;tuptable = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the portal */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (name == <span class="Constant">NULL</span> || name[<span class="Constant">0</span>] == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use a random nonconflicting name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; portal = <a href="../utils/mmgr/portalmem.c.html#L235" title="utils/mmgr/portalmem.c:235">CreateNewPortal</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In this path, error if portal of same name already exists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; portal = <a href="../utils/mmgr/portalmem.c.html#L175" title="utils/mmgr/portalmem.c:175">CreatePortal</a>(name, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy the plan's query string into the portal */<br/></li>
<li></span>&nbsp; &nbsp; query_string = <a href="../utils/mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(portal-&gt;portalContext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plansource-&gt;query_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Setup error traceback support for ereport(), in case <a href="../utils/cache/plancache.c.html#L1168" title="utils/cache/plancache.c:1168">GetCachedPlan</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * throws an error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; spicallbackarg.query = plansource-&gt;query_string;<br/></li>
<li>&nbsp; &nbsp; spicallbackarg.mode = plan-&gt;parse_mode;<br/></li>
<li>&nbsp; &nbsp; spierrcontext.callback = <a href="#L2941" title="executor/spi.c:2941">_SPI_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; spierrcontext.arg = &amp;spicallbackarg;<br/></li>
<li>&nbsp; &nbsp; spierrcontext.previous = <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;spierrcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: for a saved plan, we mustn't have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> failure occur between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/cache/plancache.c.html#L1168" title="utils/cache/plancache.c:1168">GetCachedPlan</a> and <a href="../utils/mmgr/portalmem.c.html#L282" title="utils/mmgr/portalmem.c:282">PortalDefineQuery</a>; that would result in leaking our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plancache refcount.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Replan if needed, and increment plan refcount for portal */<br/></li>
<li></span>&nbsp; &nbsp; cplan = <a href="../utils/cache/plancache.c.html#L1168" title="utils/cache/plancache.c:1168">GetCachedPlan</a>(plansource, paramLI, <span class="Constant">NULL</span>, <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;queryEnv);<br/></li>
<li>&nbsp; &nbsp; stmt_list = cplan-&gt;stmt_list;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!plan-&gt;saved)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't want the portal to depend on an unsaved CachedPlanSource,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so must copy the plan into the portal's context.&nbsp; An error here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will result in leaking our refcount on the plan, but it doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matter because the plan is unsaved and hence transient anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(portal-&gt;portalContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stmt_list = copyObject(stmt_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/plancache.c.html#L1291" title="utils/cache/plancache.c:1291">ReleaseCachedPlan</a>(cplan, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cplan = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* portal shouldn't depend on cplan */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up the portal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/portalmem.c.html#L282" title="utils/mmgr/portalmem.c:282">PortalDefineQuery</a>(portal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no statement name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;commandTag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cplan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up options for portal.&nbsp; Default SCROLL type is chosen the same way<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as <a href="../commands/portalcmds.c.html#L43" title="commands/portalcmds.c:43">PerformCursorOpen</a> does it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; portal-&gt;cursorOptions = plan-&gt;cursor_options;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(portal-&gt;cursorOptions &amp; (CURSOR_OPT_SCROLL | CURSOR_OPT_NO_SCROLL)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(stmt_list) == <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linitial_node(PlannedStmt, stmt_list)-&gt;commandType != CMD_UTILITY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linitial_node(PlannedStmt, stmt_list)-&gt;rowMarks == NIL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execAmi.c.html#L510" title="executor/execAmi.c:510">ExecSupportsBackwardScan</a>(linitial_node(PlannedStmt, stmt_list)-&gt;planTree))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;cursorOptions |= CURSOR_OPT_SCROLL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;cursorOptions |= CURSOR_OPT_NO_SCROLL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Disallow SCROLL with SELECT FOR UPDATE.&nbsp; This is not redundant with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check in <a href="../parser/analyze.c.html#L2868" title="parser/analyze.c:2868">transformDeclareCursorStmt</a> because the cursor options might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not have come through there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;cursorOptions &amp; CURSOR_OPT_SCROLL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(stmt_list) == <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linitial_node(PlannedStmt, stmt_list)-&gt;commandType != CMD_UTILITY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linitial_node(PlannedStmt, stmt_list)-&gt;rowMarks != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;DECLARE SCROLL CURSOR ... FOR UPDATE/SHARE is not supported&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Scrollable cursors must be READ ONLY.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make current query environment available to portal at execution time. */<br/></li>
<li></span>&nbsp; &nbsp; portal-&gt;queryEnv = <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;queryEnv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If told to be read-only, we'd better check for read-only queries. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't be done earlier because we need to look at the finished, planned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * queries.&nbsp; (In particular, we don't want to do it between <a href="../utils/cache/plancache.c.html#L1168" title="utils/cache/plancache.c:1168">GetCachedPlan</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and <a href="../utils/mmgr/portalmem.c.html#L282" title="utils/mmgr/portalmem.c:282">PortalDefineQuery</a>, because throwing an error between those steps<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would result in leaking our plancache refcount.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (read_only)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, stmt_list)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlannedStmt *pstmt = lfirst_node(PlannedStmt, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../tcop/utility.c.html#L94" title="tcop/utility.c:94">CommandIsReadOnly</a>(pstmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is a SQL statement name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> is not allowed in a non-volatile function&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CreateCommandName((Node *) pstmt))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up the snapshot to use. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (read_only)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snapshot = <a href="../utils/time/snapmgr.c.html#L770" title="utils/time/snapmgr.c:770">GetActiveSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snapshot = <a href="../utils/time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the plan has parameters, copy them into the portal.&nbsp; Note that this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must be done after revalidating the plan, because in dynamic parameter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases the set of parameters could have changed during re-parsing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (paramLI)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(portal-&gt;portalContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; paramLI = <a href="../nodes/params.c.html#L78" title="nodes/params.c:78">copyParamList</a>(paramLI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start portal execution.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/pquery.c.html#L433" title="tcop/pquery.c:433">PortalStart</a>(portal, paramLI, <span class="Constant">0</span>, snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(portal-&gt;strategy != PORTAL_MULTI_QUERY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = spierrcontext.previous;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the SPI stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3081" title="executor/spi.c:3081">_SPI_end_call</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return the created portal */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> portal;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1791" title="executor/spi.c:1791">SPI_cursor_find</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Find the portal of an existing open cursor<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Portal<br/></li>
<li><a id="L1791">&#x200c;</a><span class="linkable">SPI_cursor_find</span>(<span class="Type">const</span> <span class="Type">char</span> *name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../utils/mmgr/portalmem.c.html#L130" title="utils/mmgr/portalmem.c:130">GetPortalByName</a>(name);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1803" title="executor/spi.c:1803">SPI_cursor_fetch</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Fetch rows in a cursor<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1803">&#x200c;</a></span><span class="linkable">SPI_cursor_fetch</span>(Portal portal, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forward, <span class="Type">long</span> count)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L2987" title="executor/spi.c:2987">_SPI_cursor_operation</a>(portal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forward ? FETCH_FORWARD : FETCH_BACKWARD, count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/dest.c.html#L113" title="tcop/dest.c:113">CreateDestReceiver</a>(DestSPI));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we know that the DestSPI receiver doesn't need a destroy call */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1818" title="executor/spi.c:1818">SPI_cursor_move</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Move in a cursor<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1818">&#x200c;</a></span><span class="linkable">SPI_cursor_move</span>(Portal portal, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forward, <span class="Type">long</span> count)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L2987" title="executor/spi.c:2987">_SPI_cursor_operation</a>(portal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forward ? FETCH_FORWARD : FETCH_BACKWARD, count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/dest.c.html#L96" title="tcop/dest.c:96">None_Receiver</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1832" title="executor/spi.c:1832">SPI_scroll_cursor_fetch</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Fetch rows in a scrollable cursor<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1832">&#x200c;</a></span><span class="linkable">SPI_scroll_cursor_fetch</span>(Portal portal, FetchDirection direction, <span class="Type">long</span> count)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L2987" title="executor/spi.c:2987">_SPI_cursor_operation</a>(portal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; direction, count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/dest.c.html#L113" title="tcop/dest.c:113">CreateDestReceiver</a>(DestSPI));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we know that the DestSPI receiver doesn't need a destroy call */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1847" title="executor/spi.c:1847">SPI_scroll_cursor_move</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Move in a scrollable cursor<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1847">&#x200c;</a></span><span class="linkable">SPI_scroll_cursor_move</span>(Portal portal, FetchDirection direction, <span class="Type">long</span> count)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L2987" title="executor/spi.c:2987">_SPI_cursor_operation</a>(portal, direction, count, <a href="../tcop/dest.c.html#L96" title="tcop/dest.c:96">None_Receiver</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1859" title="executor/spi.c:1859">SPI_cursor_close</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Close a cursor<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1859">&#x200c;</a></span><span class="linkable">SPI_cursor_close</span>(Portal portal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PortalIsValid(portal))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid portal in SPI cursor operation&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/portalmem.c.html#L468" title="utils/mmgr/portalmem.c:468">PortalDrop</a>(portal, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns the Oid representing the type id for argument at argIndex. First<br/></li>
<li></span><span class="Comment"> * parameter is at index zero.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L1872">&#x200c;</a><span class="linkable">SPI_getargtypeid</span>(SPIPlanPtr plan, <span class="Type">int</span> argIndex)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan == <span class="Constant">NULL</span> || plan-&gt;magic != _SPI_PLAN_MAGIC ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; argIndex &lt; <span class="Constant">0</span> || argIndex &gt;= plan-&gt;nargs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = SPI_ERROR_ARGUMENT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan-&gt;argtypes[argIndex];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns the number of arguments for the prepared plan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1887">&#x200c;</a></span><span class="linkable">SPI_getargcount</span>(SPIPlanPtr plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan == <span class="Constant">NULL</span> || plan-&gt;magic != _SPI_PLAN_MAGIC)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = SPI_ERROR_ARGUMENT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan-&gt;nargs;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns true if the plan contains exactly one command<br/></li>
<li></span><span class="Comment"> * and that command returns tuples to the caller (eg, SELECT or<br/></li>
<li></span><span class="Comment"> * INSERT ... RETURNING, but not SELECT ... INTO). In essence,<br/></li>
<li></span><span class="Comment"> * the result indicates if the command can be used with <a href="#L1442" title="executor/spi.c:1442">SPI_cursor_open</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Parameters<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; plan: A plan previously prepared using <a href="#L857" title="executor/spi.c:857">SPI_prepare</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1907">&#x200c;</a></span><span class="linkable">SPI_is_cursor_plan</span>(SPIPlanPtr plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CachedPlanSource *plansource;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan == <span class="Constant">NULL</span> || plan-&gt;magic != _SPI_PLAN_MAGIC)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = SPI_ERROR_ARGUMENT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(plan-&gt;plancache_list) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not exactly 1 pre-rewrite command */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; plansource = (CachedPlanSource *) linitial(plan-&gt;plancache_list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We used to force revalidation of the cached plan here, but that seems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unnecessary: invalidation could mean a change in the rowtype of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuples returned by a plan, but not whether it returns tuples at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L46" title="executor/spi.c:46">SPI_result</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Does it return tuples? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;resultDesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1945" title="executor/spi.c:1945">SPI_plan_is_valid</a> --- test whether a SPI plan is currently valid<br/></li>
<li></span><span class="Comment"> * (that is, not marked as being in need of revalidation).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See notes for <a href="../utils/cache/plancache.c.html#L1627" title="utils/cache/plancache.c:1627">CachedPlanIsValid</a> <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> using this.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1945">&#x200c;</a></span><span class="linkable">SPI_plan_is_valid</span>(SPIPlanPtr plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(plan-&gt;magic == _SPI_PLAN_MAGIC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, plan-&gt;plancache_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CachedPlanSource *plansource = (CachedPlanSource *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/cache/plancache.c.html#L1627" title="utils/cache/plancache.c:1627">CachedPlanIsValid</a>(plansource))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1969" title="executor/spi.c:1969">SPI_result_code_string</a> --- convert <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SPI return code to a string<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is often useful in error messages.&nbsp; Most callers will probably<br/></li>
<li></span><span class="Comment"> * only pass negative (error-case) codes, but for generality we recognize<br/></li>
<li></span><span class="Comment"> * the success codes too.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1969">&#x200c;</a><span class="linkable">SPI_result_code_string</span>(<span class="Type">int</span> code)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">char</span> buf[<span class="Constant">64</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (code)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_ERROR_CONNECT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_ERROR_CONNECT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_ERROR_COPY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_ERROR_COPY&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_ERROR_OPUNKNOWN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_ERROR_OPUNKNOWN&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_ERROR_UNCONNECTED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_ERROR_UNCONNECTED&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_ERROR_ARGUMENT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_ERROR_ARGUMENT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_ERROR_PARAM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_ERROR_PARAM&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_ERROR_TRANSACTION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_ERROR_TRANSACTION&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_ERROR_NOATTRIBUTE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_ERROR_NOATTRIBUTE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_ERROR_NOOUTFUNC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_ERROR_NOOUTFUNC&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_ERROR_TYPUNKNOWN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_ERROR_TYPUNKNOWN&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_ERROR_REL_DUPLICATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_ERROR_REL_DUPLICATE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_ERROR_REL_NOT_FOUND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_ERROR_REL_NOT_FOUND&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_OK_CONNECT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_OK_CONNECT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_OK_FINISH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_OK_FINISH&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_OK_FETCH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_OK_FETCH&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_OK_UTILITY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_OK_UTILITY&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_OK_SELECT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_OK_SELECT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_OK_SELINTO:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_OK_SELINTO&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_OK_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_OK_INSERT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_OK_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_OK_DELETE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_OK_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_OK_UPDATE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_OK_CURSOR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_OK_CURSOR&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_OK_INSERT_RETURNING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_OK_INSERT_RETURNING&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_OK_DELETE_RETURNING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_OK_DELETE_RETURNING&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_OK_UPDATE_RETURNING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_OK_UPDATE_RETURNING&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_OK_REWRITTEN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_OK_REWRITTEN&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_OK_REL_REGISTER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_OK_REL_REGISTER&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_OK_REL_UNREGISTER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_OK_REL_UNREGISTER&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_OK_TD_REGISTER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_OK_TD_REGISTER&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_OK_MERGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_OK_MERGE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SPI_OK_MERGE_RETURNING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SPI_OK_MERGE_RETURNING&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unrecognized code ... return something useful ... */<br/></li>
<li></span>&nbsp; &nbsp; sprintf(buf, <span class="Constant">&quot;Unrecognized SPI code </span><span class="Special">%d</span><span class="Constant">&quot;</span>, code);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2052" title="executor/spi.c:2052">SPI_plan_get_plan_sources</a> --- get a SPI plan's underlying list of<br/></li>
<li></span><span class="Comment"> * CachedPlanSources.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exported so that PL/pgSQL can use it (this beats letting PL/pgSQL<br/></li>
<li></span><span class="Comment"> * look directly into the SPIPlan for itself).&nbsp; It's not documented in<br/></li>
<li></span><span class="Comment"> * spi.sgml because we'd just as soon not have too many places using this.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L2052">&#x200c;</a><span class="linkable">SPI_plan_get_plan_sources</span>(SPIPlanPtr plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(plan-&gt;magic == _SPI_PLAN_MAGIC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan-&gt;plancache_list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2071" title="executor/spi.c:2071">SPI_plan_get_cached_plan</a> --- get a SPI plan's generic CachedPlan,<br/></li>
<li></span><span class="Comment"> * if the SPI plan contains exactly one CachedPlanSource.&nbsp; If not,<br/></li>
<li></span><span class="Comment"> * return NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The plan's refcount is incremented (and logged in <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>,<br/></li>
<li></span><span class="Comment"> * if it's a saved plan).&nbsp; Caller is responsible for doing <a href="../utils/cache/plancache.c.html#L1291" title="utils/cache/plancache.c:1291">ReleaseCachedPlan</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exported so that PL/pgSQL can use it (this beats letting PL/pgSQL<br/></li>
<li></span><span class="Comment"> * look directly into the SPIPlan for itself).&nbsp; It's not documented in<br/></li>
<li></span><span class="Comment"> * spi.sgml because we'd just as soon not have too many places using this.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>CachedPlan *<br/></li>
<li><a id="L2071">&#x200c;</a><span class="linkable">SPI_plan_get_cached_plan</span>(SPIPlanPtr plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CachedPlanSource *plansource;<br/></li>
<li>&nbsp; &nbsp; CachedPlan *cplan;<br/></li>
<li>&nbsp; &nbsp; <a href="#L53" title="executor/spi.c:53">SPICallbackArg</a> spicallbackarg;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback spierrcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(plan-&gt;magic == _SPI_PLAN_MAGIC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't support one-shot plans here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plan-&gt;oneshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must have exactly one CachedPlanSource */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(plan-&gt;plancache_list) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plansource = (CachedPlanSource *) linitial(plan-&gt;plancache_list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Setup error traceback support for ereport() */<br/></li>
<li></span>&nbsp; &nbsp; spicallbackarg.query = plansource-&gt;query_string;<br/></li>
<li>&nbsp; &nbsp; spicallbackarg.mode = plan-&gt;parse_mode;<br/></li>
<li>&nbsp; &nbsp; spierrcontext.callback = <a href="#L2941" title="executor/spi.c:2941">_SPI_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; spierrcontext.arg = &amp;spicallbackarg;<br/></li>
<li>&nbsp; &nbsp; spierrcontext.previous = <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;spierrcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the generic plan for the query */<br/></li>
<li></span>&nbsp; &nbsp; cplan = <a href="../utils/cache/plancache.c.html#L1168" title="utils/cache/plancache.c:1168">GetCachedPlan</a>(plansource, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;saved ? <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> : <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;queryEnv);<br/></li>
<li>&nbsp; &nbsp; Assert(cplan == plansource-&gt;gplan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = spierrcontext.previous;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cplan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* =================== private <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> =================== */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2118" title="executor/spi.c:2118">spi_dest_startup</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Initialize to receive tuples from Executor into SPITupleTable<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; of current SPI procedure<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2118">&#x200c;</a></span><span class="linkable">spi_dest_startup</span>(DestReceiver *self, <span class="Type">int</span> operation, TupleDesc typeinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SPITupleTable *tuptable;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; MemoryContext tuptabcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L49" title="executor/spi.c:49">_SPI_current</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L2118" title="executor/spi.c:2118">spi_dest_startup</a> called while not connected to SPI&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;tuptable != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;improper call to <a href="#L2118" title="executor/spi.c:2118">spi_dest_startup</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We create the tuple table context as a child of procCxt */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; oldcxt = <a href="#L3044" title="executor/spi.c:3044">_SPI_procmem</a>();&nbsp; &nbsp; <span class="Comment">/* switch to procedure memory context */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; tuptabcxt = AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;SPI TupTable&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(tuptabcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;tuptable = tuptable = (SPITupleTable *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SPITupleTable));<br/></li>
<li>&nbsp; &nbsp; tuptable-&gt;tuptabcxt = tuptabcxt;<br/></li>
<li>&nbsp; &nbsp; tuptable-&gt;subid = <a href="../access/transam/xact.c.html#L788" title="access/transam/xact.c:788">GetCurrentSubTransactionId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The tuptable is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> valid enough to be freed by <a href="#L482" title="executor/spi.c:482">AtEOSubXact_SPI</a>, so put<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it onto the SPI context's tuptables list.&nbsp; This will ensure it's not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leaked even in the unlikely event the following few lines fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; slist_push_head(&amp;<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;tuptables, &amp;tuptable-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set up initial allocations */<br/></li>
<li></span>&nbsp; &nbsp; tuptable-&gt;alloced = <span class="Constant">128</span>;<br/></li>
<li>&nbsp; &nbsp; tuptable-&gt;vals = (HeapTuple *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(tuptable-&gt;alloced * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HeapTuple));<br/></li>
<li>&nbsp; &nbsp; tuptable-&gt;numvals = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; tuptable-&gt;tupdesc = <a href="../access/common/tupdesc.c.html#L133" title="access/common/tupdesc.c:133">CreateTupleDescCopy</a>(typeinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2166" title="executor/spi.c:2166">spi_printtup</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; store tuple retrieved by Executor into SPITupleTable<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; of current SPI procedure<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2166">&#x200c;</a></span><span class="linkable">spi_printtup</span>(TupleTableSlot *slot, DestReceiver *self)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SPITupleTable *tuptable;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L49" title="executor/spi.c:49">_SPI_current</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L2166" title="executor/spi.c:2166">spi_printtup</a> called while not connected to SPI&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuptable = <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;tuptable;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tuptable == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;improper call to <a href="#L2166" title="executor/spi.c:2166">spi_printtup</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(tuptable-&gt;tuptabcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tuptable-&gt;numvals &gt;= tuptable-&gt;alloced)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Double the size of the pointer array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; newalloced = tuptable-&gt;alloced * <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuptable-&gt;vals = (HeapTuple *) <a href="../utils/mmgr/mcxt.c.html#L1671" title="utils/mmgr/mcxt.c:1671">repalloc_huge</a>(tuptable-&gt;vals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newalloced * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HeapTuple));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuptable-&gt;alloced = newalloced;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuptable-&gt;vals[tuptable-&gt;numvals] = ExecCopySlotHeapTuple(slot);<br/></li>
<li>&nbsp; &nbsp; (tuptable-&gt;numvals)++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Static <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Parse and <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> a querystring.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At entry, plan-&gt;argtypes and plan-&gt;nargs (or alternatively plan-&gt;parserSetup<br/></li>
<li></span><span class="Comment"> * and plan-&gt;parserSetupArg) must be valid, as must plan-&gt;parse_mode and<br/></li>
<li></span><span class="Comment"> * plan-&gt;cursor_options.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Results are stored into *plan (specifically, plan-&gt;plancache_list).<br/></li>
<li></span><span class="Comment"> * Note that the result data is all in <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> or child contexts<br/></li>
<li></span><span class="Comment"> * thereof; in practice this means it is in the SPI executor context, and<br/></li>
<li></span><span class="Comment"> * what we are creating is a &quot;temporary&quot; SPIPlan.&nbsp; Cruft generated during<br/></li>
<li></span><span class="Comment"> * parsing is also left in <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2216">&#x200c;</a></span><span class="linkable">_SPI_prepare_plan</span>(<span class="Type">const</span> <span class="Type">char</span> *src, SPIPlanPtr plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *raw_parsetree_list;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *plancache_list;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *list_item;<br/></li>
<li>&nbsp; &nbsp; <a href="#L53" title="executor/spi.c:53">SPICallbackArg</a> spicallbackarg;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback spierrcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Setup error traceback support for ereport()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; spicallbackarg.query = src;<br/></li>
<li>&nbsp; &nbsp; spicallbackarg.mode = plan-&gt;parse_mode;<br/></li>
<li>&nbsp; &nbsp; spierrcontext.callback = <a href="#L2941" title="executor/spi.c:2941">_SPI_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; spierrcontext.arg = &amp;spicallbackarg;<br/></li>
<li>&nbsp; &nbsp; spierrcontext.previous = <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;spierrcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Parse the request string into a list of raw <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> trees.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; raw_parsetree_list = <a href="../parser/parser.c.html#L42" title="parser/parser.c:42">raw_parser</a>(src, plan-&gt;parse_mode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis and rule rewrite for each raw parsetree, storing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * results into unsaved plancache entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; plancache_list = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(list_item, raw_parsetree_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RawStmt&nbsp; &nbsp; *parsetree = lfirst_node(RawStmt, list_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *stmt_list;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CachedPlanSource *plansource;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create the CachedPlanSource <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we do <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis, since it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * needs to see the unmodified raw <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; plansource = <a href="../utils/cache/plancache.c.html#L192" title="utils/cache/plancache.c:192">CreateCachedPlan</a>(parsetree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/utility.c.html#L2359" title="tcop/utility.c:2359">CreateCommandTag</a>(parsetree-&gt;stmt));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Parameter datatypes are driven by parserSetup hook if provided,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise we use the fixed parameter list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plan-&gt;parserSetup != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(plan-&gt;nargs == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt_list = <a href="../tcop/postgres.c.html#L764" title="tcop/postgres.c:764">pg_analyze_and_rewrite_withcb</a>(parsetree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;parserSetup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;parserSetupArg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;queryEnv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt_list = <a href="../tcop/postgres.c.html#L671" title="tcop/postgres.c:671">pg_analyze_and_rewrite_fixedparams</a>(parsetree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; src,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plan-&gt;argtypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plan-&gt;nargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;queryEnv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Finish filling in the CachedPlanSource */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/plancache.c.html#L366" title="utils/cache/plancache.c:366">CompleteCachedPlan</a>(plansource,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plan-&gt;argtypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plan-&gt;nargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plan-&gt;parserSetup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plan-&gt;parserSetupArg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plan-&gt;cursor_options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);&nbsp; &nbsp; <span class="Comment">/* not fixed result */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plancache_list = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(plancache_list, plansource);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;plancache_list = plancache_list;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;oneshot = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Pop the error context stack<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = spierrcontext.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Parse, but don't <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>, a querystring.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a stripped-down version of <a href="#L2216" title="executor/spi.c:2216">_SPI_prepare_plan</a> that only does the<br/></li>
<li></span><span class="Comment"> * initial raw parsing.&nbsp; It creates &quot;one shot&quot; CachedPlanSources<br/></li>
<li></span><span class="Comment"> * that still require <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> execution is possible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The advantage of using the &quot;one shot&quot; form of CachedPlanSource is that<br/></li>
<li></span><span class="Comment"> * we eliminate data copying and invalidation overhead.&nbsp; Postponing <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a><br/></li>
<li></span><span class="Comment"> * analysis also prevents issues if some of the raw parsetrees are DDL<br/></li>
<li></span><span class="Comment"> * commands that affect validity of later parsetrees.&nbsp; Both of these<br/></li>
<li></span><span class="Comment"> * attributes are good things for <a href="#L593" title="executor/spi.c:593">SPI_execute</a>() and similar cases.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Results are stored into *plan (specifically, plan-&gt;plancache_list).<br/></li>
<li></span><span class="Comment"> * Note that the result data is all in <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> or child contexts<br/></li>
<li></span><span class="Comment"> * thereof; in practice this means it is in the SPI executor context, and<br/></li>
<li></span><span class="Comment"> * what we are creating is a &quot;temporary&quot; SPIPlan.&nbsp; Cruft generated during<br/></li>
<li></span><span class="Comment"> * parsing is also left in <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2324">&#x200c;</a></span><span class="linkable">_SPI_prepare_oneshot_plan</span>(<span class="Type">const</span> <span class="Type">char</span> *src, SPIPlanPtr plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *raw_parsetree_list;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *plancache_list;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *list_item;<br/></li>
<li>&nbsp; &nbsp; <a href="#L53" title="executor/spi.c:53">SPICallbackArg</a> spicallbackarg;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback spierrcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Setup error traceback support for ereport()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; spicallbackarg.query = src;<br/></li>
<li>&nbsp; &nbsp; spicallbackarg.mode = plan-&gt;parse_mode;<br/></li>
<li>&nbsp; &nbsp; spierrcontext.callback = <a href="#L2941" title="executor/spi.c:2941">_SPI_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; spierrcontext.arg = &amp;spicallbackarg;<br/></li>
<li>&nbsp; &nbsp; spierrcontext.previous = <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;spierrcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Parse the request string into a list of raw <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> trees.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; raw_parsetree_list = <a href="../parser/parser.c.html#L42" title="parser/parser.c:42">raw_parser</a>(src, plan-&gt;parse_mode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct plancache entries, but don't do <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; plancache_list = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(list_item, raw_parsetree_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RawStmt&nbsp; &nbsp; *parsetree = lfirst_node(RawStmt, list_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CachedPlanSource *plansource;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plansource = <a href="../utils/cache/plancache.c.html#L276" title="utils/cache/plancache.c:276">CreateOneShotCachedPlan</a>(parsetree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; src,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../tcop/utility.c.html#L2359" title="tcop/utility.c:2359">CreateCommandTag</a>(parsetree-&gt;stmt));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plancache_list = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(plancache_list, plansource);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plan-&gt;plancache_list = plancache_list;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;oneshot = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Pop the error context stack<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = spierrcontext.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2394" title="executor/spi.c:2394">_SPI_execute_plan</a>: execute the given plan with the given options<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * options contains options accessible from outside SPI:<br/></li>
<li></span><span class="Comment"> * params: parameter <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to pass to query<br/></li>
<li></span><span class="Comment"> * read_only: true for read-only execution (no <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>)<br/></li>
<li></span><span class="Comment"> * allow_nonatomic: true to allow nonatomic CALL/DO execution<br/></li>
<li></span><span class="Comment"> * must_return_tuples: throw error if query doesn't return tuples<br/></li>
<li></span><span class="Comment"> * tcount: execution tuple-count limit, or 0 for <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a><br/></li>
<li></span><span class="Comment"> * dest: DestReceiver to receive output, or NULL for normal SPI output<br/></li>
<li></span><span class="Comment"> * owner: ResourceOwner that will be used to hold refcount on plan;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; if NULL, <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> is used (ignored for non-saved plan)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Additional, only-internally-accessible options:<br/></li>
<li></span><span class="Comment"> * snapshot: query snapshot to use, or InvalidSnapshot for the normal<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; behavior of taking a new snapshot for each query.<br/></li>
<li></span><span class="Comment"> * crosscheck_snapshot: for RI use, all others pass InvalidSnapshot<br/></li>
<li></span><span class="Comment"> * fire_triggers: true to fire AFTER triggers at end of query (normal case);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; false means <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> AFTER triggers are postponed to end of outer query<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2394">&#x200c;</a></span><span class="linkable">_SPI_execute_plan</span>(SPIPlanPtr plan, <span class="Type">const</span> SPIExecuteOptions *options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Snapshot snapshot, Snapshot crosscheck_snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> fire_triggers)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my_res = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; my_processed = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; SPITupleTable *my_tuptable = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; pushed_active_snap = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ResourceOwner plan_owner = options-&gt;owner;<br/></li>
<li>&nbsp; &nbsp; <a href="#L53" title="executor/spi.c:53">SPICallbackArg</a> spicallbackarg;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback spierrcontext;<br/></li>
<li>&nbsp; &nbsp; CachedPlan *cplan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Setup error traceback support for ereport()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; spicallbackarg.query = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* we'll fill this below */<br/></li>
<li></span>&nbsp; &nbsp; spicallbackarg.mode = plan-&gt;parse_mode;<br/></li>
<li>&nbsp; &nbsp; spierrcontext.callback = <a href="#L2941" title="executor/spi.c:2941">_SPI_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; spierrcontext.arg = &amp;spicallbackarg;<br/></li>
<li>&nbsp; &nbsp; spierrcontext.previous = <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;spierrcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We support four distinct snapshot management behaviors:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot != InvalidSnapshot, read_only = true: use exactly the given<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot != InvalidSnapshot, read_only = false: use the given snapshot,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * modified by advancing its command ID <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> each querytree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot == InvalidSnapshot, read_only = true: use the entry-time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/time/snapmgr.c.html#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> (if there isn't one, we run with no snapshot).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot == InvalidSnapshot, read_only = false: take a full new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot for each user command, and advance its command ID <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * querytree within the command.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In the first two cases, we can just <a href="../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> the snap onto the stack once<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the whole plan list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that snapshot != InvalidSnapshot implies an atomic execution<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (snapshot != InvalidSnapshot)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!options-&gt;allow_nonatomic);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (options-&gt;read_only)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L648" title="utils/time/snapmgr.c:648">PushActiveSnapshot</a>(snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushed_active_snap = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure we have a private copy of the snapshot to modify */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L700" title="utils/time/snapmgr.c:700">PushCopiedSnapshot</a>(snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushed_active_snap = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ensure that we have a resource owner if plan is saved, and not if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * isn't.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!plan-&gt;saved)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan_owner = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (plan_owner == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan_owner = <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We interpret must_return_tuples as &quot;there must be at least one query,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and all of them must return tuples&quot;.&nbsp; This is a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> laxer than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1907" title="executor/spi.c:1907">SPI_is_cursor_plan</a>'s check, but there seems no reason to enforce that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there be only one query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (options-&gt;must_return_tuples &amp;&amp; plan-&gt;plancache_list == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;empty query does not return tuples&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc1, plan-&gt;plancache_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CachedPlanSource *plansource = (CachedPlanSource *) lfirst(lc1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *stmt_list;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; spicallbackarg.query = plansource-&gt;query_string;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is a one-shot plan, we still need to do <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plan-&gt;oneshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RawStmt&nbsp; &nbsp; *parsetree = plansource-&gt;raw_parse_tree;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *src = plansource-&gt;query_string;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *querytree_list;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Parameter datatypes are driven by parserSetup hook if provided,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise we use the fixed parameter list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parsetree == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; querytree_list = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (plan-&gt;parserSetup != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(plan-&gt;nargs == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; querytree_list = <a href="../tcop/postgres.c.html#L764" title="tcop/postgres.c:764">pg_analyze_and_rewrite_withcb</a>(parsetree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; src,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plan-&gt;parserSetup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plan-&gt;parserSetupArg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;queryEnv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; querytree_list = <a href="../tcop/postgres.c.html#L671" title="tcop/postgres.c:671">pg_analyze_and_rewrite_fixedparams</a>(parsetree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;argtypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;nargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;queryEnv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Finish filling in the CachedPlanSource */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/plancache.c.html#L366" title="utils/cache/plancache.c:366">CompleteCachedPlan</a>(plansource,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; querytree_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plan-&gt;argtypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plan-&gt;nargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plan-&gt;parserSetup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plan-&gt;parserSetupArg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plan-&gt;cursor_options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);&nbsp; &nbsp; <span class="Comment">/* not fixed result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If asked to, complain when query does not return tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Replanning can't change this, so we can check it <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, we can't check it till after <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis, so in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case of a one-shot plan this is the earliest we could check.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (options-&gt;must_return_tuples &amp;&amp; !plansource-&gt;resultDesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* try to give a good error message */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *cmdtag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* A SELECT without resultDesc must be SELECT INTO */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;commandTag == CMDTAG_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmdtag = <span class="Constant">&quot;SELECT INTO&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmdtag = <a href="../tcop/cmdtag.c.html#L47" title="tcop/cmdtag.c:47">GetCommandTagName</a>(plansource-&gt;commandTag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is name of a SQL command, eg INSERT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> query does not return tuples&quot;</span>, cmdtag)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Replan if needed, and increment plan refcount.&nbsp; If it's a saved<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * plan, the refcount must be backed by the plan_owner.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cplan = <a href="../utils/cache/plancache.c.html#L1168" title="utils/cache/plancache.c:1168">GetCachedPlan</a>(plansource, options-&gt;params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan_owner, <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;queryEnv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stmt_list = cplan-&gt;stmt_list;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we weren't given a specific snapshot to use, and the statement<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list requires a snapshot, set that up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (snapshot == InvalidSnapshot &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (list_length(stmt_list) &gt; <span class="Constant">1</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (list_length(stmt_list) == <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/pquery.c.html#L1732" title="tcop/pquery.c:1732">PlannedStmtRequiresSnapshot</a>(linitial_node(PlannedStmt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt_list)))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First, ensure there's a Portal-level snapshot.&nbsp; This back-fills<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the snapshot stack in case the previous operation was a COMMIT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or ROLLBACK inside a procedure or DO block.&nbsp; (We can't put back<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the Portal snapshot <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sooner, or we'd break cases like doing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> or LOCK just after COMMIT.)&nbsp; It's enough to check once per<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * statement list, since COMMIT/ROLLBACK/CALL/DO can't appear<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * within a multi-statement list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/pquery.c.html#L1780" title="tcop/pquery.c:1780">EnsurePortalSnapshotExists</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the default non-read-only case, get a new per-statement-list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * snapshot, replacing <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> that we pushed in a previous cycle.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Skip it when doing non-atomic execution, though (we rely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entirely on the Portal snapshot in that case).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!options-&gt;read_only &amp;&amp; !options-&gt;allow_nonatomic)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pushed_active_snap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L648" title="utils/time/snapmgr.c:648">PushActiveSnapshot</a>(<a href="../utils/time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushed_active_snap = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, stmt_list)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; canSetTag = stmt-&gt;canSetTag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DestReceiver *dest;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset output state.&nbsp; (Note that if a non-SPI receiver is used,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;processed will stay zero, and that's what we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * report to the caller.&nbsp; It's the receiver's job to count tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in that case.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;processed = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;tuptable = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for unsupported cases. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;utilityStmt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(stmt-&gt;utilityStmt, CopyStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CopyStmt&nbsp;&nbsp; *cstmt = (CopyStmt *) stmt-&gt;utilityStmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cstmt-&gt;filename == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my_res = SPI_ERROR_COPY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(stmt-&gt;utilityStmt, TransactionStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my_res = SPI_ERROR_TRANSACTION;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (options-&gt;read_only &amp;&amp; !<a href="../tcop/utility.c.html#L94" title="tcop/utility.c:94">CommandIsReadOnly</a>(stmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is a SQL statement name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> is not allowed in a non-volatile function&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CreateCommandName((Node *) stmt))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If not read-only mode, advance the command counter <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * command and update the snapshot.&nbsp; (But <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it if the snapshot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * isn't under our control.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!options-&gt;read_only &amp;&amp; pushed_active_snap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L712" title="utils/time/snapmgr.c:712">UpdateActiveSnapshotCommandId</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Select appropriate tuple receiver.&nbsp; Output from non-canSetTag<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subqueries always goes to the <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> bucket.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!canSetTag)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dest = <a href="../tcop/dest.c.html#L113" title="tcop/dest.c:113">CreateDestReceiver</a>(DestNone);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (options-&gt;dest)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dest = options-&gt;dest;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dest = <a href="../tcop/dest.c.html#L113" title="tcop/dest.c:113">CreateDestReceiver</a>(DestSPI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;utilityStmt == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QueryDesc&nbsp; *qdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Snapshot&nbsp; &nbsp; snap;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/time/snapmgr.c.html#L782" title="utils/time/snapmgr.c:782">ActiveSnapshotSet</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snap = <a href="../utils/time/snapmgr.c.html#L770" title="utils/time/snapmgr.c:770">GetActiveSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snap = InvalidSnapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qdesc = <a href="../tcop/pquery.c.html#L67" title="tcop/pquery.c:67">CreateQueryDesc</a>(stmt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;query_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snap, crosscheck_snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; options-&gt;params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;queryEnv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L2854" title="executor/spi.c:2854">_SPI_pquery</a>(qdesc, fire_triggers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; canSetTag ? options-&gt;tcount : <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/pquery.c.html#L105" title="tcop/pquery.c:105">FreeQueryDesc</a>(qdesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ProcessUtilityContext context;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QueryCompletion qc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the SPI context is atomic, or we were not told to allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nonatomic operations, tell <a href="../tcop/utility.c.html#L499" title="tcop/utility.c:499">ProcessUtility</a> this is an atomic<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * execution context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;atomic || !options-&gt;allow_nonatomic)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context = PROCESS_UTILITY_QUERY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context = PROCESS_UTILITY_QUERY_NONATOMIC;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/cmdtag.c.html#L40" title="tcop/cmdtag.c:40">InitializeQueryCompletion</a>(&amp;qc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/utility.c.html#L499" title="tcop/utility.c:499">ProcessUtility</a>(stmt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plansource-&gt;query_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,&nbsp; &nbsp; <span class="Comment">/* protect plancache's node tree */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; options-&gt;params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;queryEnv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;qc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update &quot;processed&quot; if stmt returned tuples */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;tuptable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;processed = <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;tuptable-&gt;numvals;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = SPI_OK_UTILITY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Some utility statements return a row count, even though the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples are not returned to the caller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(stmt-&gt;utilityStmt, CreateTableAsStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CreateTableAsStmt *ctastmt = (CreateTableAsStmt *) stmt-&gt;utilityStmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qc.commandTag == CMDTAG_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;processed = qc.nprocessed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Must be an IF NOT EXISTS that did nothing, or a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * CREATE ... WITH NO DATA.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ctastmt-&gt;if_not_exists ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ctastmt-&gt;into-&gt;skipData);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;processed = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For historical reasons, if CREATE TABLE AS was spelled<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as SELECT INTO, return a special return code.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ctastmt-&gt;is_select_into)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = SPI_OK_SELINTO;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(stmt-&gt;utilityStmt, CopyStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(qc.commandTag == CMDTAG_COPY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;processed = qc.nprocessed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The last canSetTag query sets the status <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> returned to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caller.&nbsp; Be careful to free <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuptables not returned, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * avoid intra-transaction memory leak.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (canSetTag)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my_processed = <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;processed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1383" title="executor/spi.c:1383">SPI_freetuptable</a>(my_tuptable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my_tuptable = <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;tuptable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my_res = res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1383" title="executor/spi.c:1383">SPI_freetuptable</a>(<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;tuptable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;tuptable = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't issue a destroy call to the receiver.&nbsp; The SPI and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * None receivers would ignore it anyway, while if the caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * supplied a receiver, it's not our job to destroy it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my_res = res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Done with this plan, so release refcount */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/plancache.c.html#L1291" title="utils/cache/plancache.c:1291">ReleaseCachedPlan</a>(cplan, plan_owner);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cplan = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If not read-only mode, advance the command counter after the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * command.&nbsp; This ensures that its effects are visible, in case it was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * DDL that would affect the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> CachedPlanSource.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!options-&gt;read_only)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="Statement">fail</span><span class="cUserCont">:<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the snapshot off the stack if we pushed one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pushed_active_snap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We no longer need the cached plan refcount, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cplan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/plancache.c.html#L1291" title="utils/cache/plancache.c:1291">ReleaseCachedPlan</a>(cplan, plan_owner);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Pop the error context stack<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = spierrcontext.previous;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save results for caller */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L44" title="executor/spi.c:44">SPI_processed</a> = my_processed;<br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="executor/spi.c:45">SPI_tuptable</a> = my_tuptable;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* tuptable <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> is caller's responsibility, not SPI's */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;tuptable = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of the queries had canSetTag, return SPI_OK_REWRITTEN. Prior to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 8.4, we used return the last query's result code, but not its auxiliary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * results, but that's confusing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (my_res == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_res = SPI_OK_REWRITTEN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> my_res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert arrays of query parameters to form wanted by <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> and executor<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ParamListInfo<br/></li>
<li><a id="L2829">&#x200c;</a><span class="linkable">_SPI_convert_params</span>(<span class="Type">int</span> nargs, Oid *argtypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *Values, <span class="Type">const</span> <span class="Type">char</span> *<a href="../bootstrap/bootstrap.c.html#L153" title="bootstrap/bootstrap.c:153">Nulls</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParamListInfo paramLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nargs &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; paramLI = <a href="../nodes/params.c.html#L44" title="nodes/params.c:44">makeParamList</a>(nargs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nargs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParamExternData *prm = &amp;paramLI-&gt;params[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prm-&gt;value = Values[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prm-&gt;isnull = (<a href="../bootstrap/bootstrap.c.html#L153" title="bootstrap/bootstrap.c:153">Nulls</a> &amp;&amp; <a href="../bootstrap/bootstrap.c.html#L153" title="bootstrap/bootstrap.c:153">Nulls</a>[i] == <span class="Constant">'n'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prm-&gt;pflags = PARAM_FLAG_CONST;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prm-&gt;ptype = argtypes[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; paramLI = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> paramLI;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2854">&#x200c;</a></span><span class="linkable">_SPI_pquery</span>(QueryDesc *queryDesc, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> fire_triggers, uint64 tcount)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operation = queryDesc-&gt;operation;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eflags;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (operation)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_SELECT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (queryDesc-&gt;dest-&gt;mydest == DestNone)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't return SPI_OK_SELECT if we're discarding result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = SPI_OK_UTILITY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = SPI_OK_SELECT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (queryDesc-&gt;plannedstmt-&gt;hasReturning)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = SPI_OK_INSERT_RETURNING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = SPI_OK_INSERT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (queryDesc-&gt;plannedstmt-&gt;hasReturning)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = SPI_OK_DELETE_RETURNING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = SPI_OK_DELETE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (queryDesc-&gt;plannedstmt-&gt;hasReturning)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = SPI_OK_UPDATE_RETURNING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = SPI_OK_UPDATE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_MERGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (queryDesc-&gt;plannedstmt-&gt;hasReturning)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = SPI_OK_MERGE_RETURNING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = SPI_OK_MERGE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SPI_ERROR_OPUNKNOWN;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef SPI_EXECUTOR_STATS<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ShowExecutorStats)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/postgres.c.html#L4993" title="tcop/postgres.c:4993">ResetUsage</a>();<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Select execution options */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fire_triggers)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eflags = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* default run-to-completion flags */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; eflags = EXEC_FLAG_SKIP_TRIGGERS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="execMain.c.html#L124" title="executor/execMain.c:124">ExecutorStart</a>(queryDesc, eflags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="execMain.c.html#L297" title="executor/execMain.c:297">ExecutorRun</a>(queryDesc, ForwardScanDirection, tcount, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;processed = queryDesc-&gt;estate-&gt;es_processed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((res == SPI_OK_SELECT || queryDesc-&gt;plannedstmt-&gt;hasReturning) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; queryDesc-&gt;dest-&gt;mydest == DestSPI)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3097" title="executor/spi.c:3097">_SPI_checktuples</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;consistency check on SPI tuple count failed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="execMain.c.html#L407" title="executor/execMain.c:407">ExecutorFinish</a>(queryDesc);<br/></li>
<li>&nbsp; &nbsp; <a href="execMain.c.html#L467" title="executor/execMain.c:467">ExecutorEnd</a>(queryDesc);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../tcop/pquery.c.html#L105" title="tcop/pquery.c:105">FreeQueryDesc</a> is done by the caller */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef SPI_EXECUTOR_STATS<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ShowExecutorStats)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/postgres.c.html#L5000" title="tcop/postgres.c:5000">ShowUsage</a>(<span class="Constant">&quot;SPI EXECUTOR STATS&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2941" title="executor/spi.c:2941">_SPI_error_callback</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Add context information when a query invoked via SPI fails<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2941">&#x200c;</a></span><span class="linkable">_SPI_error_callback</span>(<span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L53" title="executor/spi.c:53">SPICallbackArg</a> *carg = (<a href="#L53" title="executor/spi.c:53">SPICallbackArg</a> *) arg;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *query = carg-&gt;query;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; syntaxerrposition;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (query == <span class="Constant">NULL</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in case arg wasn't set yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is a syntax error position, convert to <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> syntax error;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise treat the query as an item of context stack<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; syntaxerrposition = <a href="../utils/error/elog.c.html#L1580" title="utils/error/elog.c:1580">geterrposition</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (syntaxerrposition &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1448" title="utils/error/elog.c:1448">errposition</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1464" title="utils/error/elog.c:1464">internalerrposition</a>(syntaxerrposition);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1484" title="utils/error/elog.c:1484">internalerrquery</a>(query);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use the <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> mode to decide how to describe the query */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (carg-&gt;mode)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RAW_PARSE_PLPGSQL_EXPR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;SQL expression </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RAW_PARSE_PLPGSQL_ASSIGN1:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RAW_PARSE_PLPGSQL_ASSIGN2:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RAW_PARSE_PLPGSQL_ASSIGN3:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;PL/pgSQL assignment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;SQL statement </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2987" title="executor/spi.c:2987">_SPI_cursor_operation</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Do a FETCH or MOVE in a cursor<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2987">&#x200c;</a></span><span class="linkable">_SPI_cursor_operation</span>(Portal portal, FetchDirection direction, <span class="Type">long</span> count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DestReceiver *dest)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; nfetched;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that the portal is valid */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!PortalIsValid(portal))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid portal in SPI cursor operation&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push the SPI stack */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3057" title="executor/spi.c:3057">_SPI_begin_call</a>(<span class="Constant">true</span>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;SPI cursor operation called while not connected&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset the SPI result (note we deliberately don't touch lastoid) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L44" title="executor/spi.c:44">SPI_processed</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="executor/spi.c:45">SPI_tuptable</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;processed = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;tuptable = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Run the cursor */<br/></li>
<li></span>&nbsp; &nbsp; nfetched = <a href="../tcop/pquery.c.html#L1391" title="tcop/pquery.c:1391">PortalRunFetch</a>(portal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; direction,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dest);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Think not to <a href="../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> this store with the preceding function call. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the portal contains calls to <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that use SPI, then <a href="#L48" title="executor/spi.c:48">_SPI_stack</a> is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * likely to move around while the portal runs.&nbsp; When control returns,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L49" title="executor/spi.c:49">_SPI_current</a> will point to the correct stack entry... but the pointer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * may be different than it was beforehand. So we must be sure to re-fetch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the pointer after the function call completes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;processed = nfetched;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dest-&gt;mydest == DestSPI &amp;&amp; <a href="#L3097" title="executor/spi.c:3097">_SPI_checktuples</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;consistency check on SPI tuple count failed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Put the result into place for access by caller */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L44" title="executor/spi.c:44">SPI_processed</a> = <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;processed;<br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="executor/spi.c:45">SPI_tuptable</a> = <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;tuptable;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* tuptable <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> is caller's responsibility, not SPI's */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;tuptable = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the SPI stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3081" title="executor/spi.c:3081">_SPI_end_call</a>(<span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> MemoryContext<br/></li>
<li><a id="L3038">&#x200c;</a><span class="linkable">_SPI_execmem</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> MemoryContextSwitchTo(<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;execCxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> MemoryContext<br/></li>
<li><a id="L3044">&#x200c;</a><span class="linkable">_SPI_procmem</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> MemoryContextSwitchTo(<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;procCxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3057" title="executor/spi.c:3057">_SPI_begin_call</a>: begin a SPI operation within a connected procedure<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * use_exec is true if we intend to make use of the procedure's execCxt<br/></li>
<li></span><span class="Comment"> * during this SPI operation.&nbsp; We'll switch into that context, and arrange<br/></li>
<li></span><span class="Comment"> * for it to be cleaned up at <a href="#L3081" title="executor/spi.c:3081">_SPI_end_call</a> or if an error occurs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L3057">&#x200c;</a></span><span class="linkable">_SPI_begin_call</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> use_exec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L49" title="executor/spi.c:49">_SPI_current</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SPI_ERROR_UNCONNECTED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (use_exec)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remember when the Executor operation started */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;execSubid = <a href="../access/transam/xact.c.html#L788" title="access/transam/xact.c:788">GetCurrentSubTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* switch to the Executor memory context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3038" title="executor/spi.c:3038">_SPI_execmem</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3081" title="executor/spi.c:3081">_SPI_end_call</a>: end a SPI operation within a connected procedure<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * use_exec must be the same as in the previous <a href="#L3057" title="executor/spi.c:3057">_SPI_begin_call</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this currently has no failure return cases, so callers don't check<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L3081">&#x200c;</a></span><span class="linkable">_SPI_end_call</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> use_exec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (use_exec)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* switch to the procedure memory context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3044" title="executor/spi.c:3044">_SPI_procmem</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mark Executor context no longer in use */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;execSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and free Executor memory */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;execCxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3097">&#x200c;</a></span><span class="linkable">_SPI_checktuples</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; processed = <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;processed;<br/></li>
<li>&nbsp; &nbsp; SPITupleTable *tuptable = <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;tuptable;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; failed = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tuptable == <span class="Constant">NULL</span>)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L2118" title="executor/spi.c:2118">spi_dest_startup</a> was not called */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; failed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (processed != tuptable-&gt;numvals)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; failed = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> failed;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert a &quot;temporary&quot; SPIPlan into an &quot;unsaved&quot; plan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The passed _SPI_plan struct is on the stack, and all its subsidiary data<br/></li>
<li></span><span class="Comment"> * is in or under the current SPI executor context.&nbsp; Copy the plan into the<br/></li>
<li></span><span class="Comment"> * SPI procedure context so it will survive <a href="#L3081" title="executor/spi.c:3081">_SPI_end_call</a>().&nbsp; To minimize<br/></li>
<li></span><span class="Comment"> * data copying, this destructively modifies the input plan, by taking the<br/></li>
<li></span><span class="Comment"> * plancache entries away from it and reparenting them to the new SPIPlan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> SPIPlanPtr<br/></li>
<li><a id="L3121">&#x200c;</a><span class="linkable">_SPI_make_plan_non_temp</span>(SPIPlanPtr plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SPIPlanPtr&nbsp; &nbsp; newplan;<br/></li>
<li>&nbsp; &nbsp; MemoryContext parentcxt = <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;procCxt;<br/></li>
<li>&nbsp; &nbsp; MemoryContext plancxt;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assert the input is a temporary SPIPlan */<br/></li>
<li></span>&nbsp; &nbsp; Assert(plan-&gt;magic == _SPI_PLAN_MAGIC);<br/></li>
<li>&nbsp; &nbsp; Assert(plan-&gt;plancxt == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* One-shot plans can't be saved */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!plan-&gt;oneshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a memory context for the plan, underneath the procedure context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't expect the plan to be very large.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; plancxt = AllocSetContextCreate(parentcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;SPI Plan&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_SMALL_SIZES);<br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(plancxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy the _SPI_plan struct and subsidiary data into the new context */<br/></li>
<li></span>&nbsp; &nbsp; newplan = (SPIPlanPtr) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(_SPI_plan));<br/></li>
<li>&nbsp; &nbsp; newplan-&gt;magic = _SPI_PLAN_MAGIC;<br/></li>
<li>&nbsp; &nbsp; newplan-&gt;plancxt = plancxt;<br/></li>
<li>&nbsp; &nbsp; newplan-&gt;parse_mode = plan-&gt;parse_mode;<br/></li>
<li>&nbsp; &nbsp; newplan-&gt;cursor_options = plan-&gt;cursor_options;<br/></li>
<li>&nbsp; &nbsp; newplan-&gt;nargs = plan-&gt;nargs;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan-&gt;nargs &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newplan-&gt;argtypes = (Oid *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(plan-&gt;nargs * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(newplan-&gt;argtypes, plan-&gt;argtypes, plan-&gt;nargs * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newplan-&gt;argtypes = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; newplan-&gt;parserSetup = plan-&gt;parserSetup;<br/></li>
<li>&nbsp; &nbsp; newplan-&gt;parserSetupArg = plan-&gt;parserSetupArg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reparent all the CachedPlanSources into the procedure context.&nbsp; In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * theory this could fail partway through due to the pallocs, but we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * care too much since both the procedure context and the executor context<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would go away on error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, plan-&gt;plancache_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CachedPlanSource *plansource = (CachedPlanSource *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/plancache.c.html#L1498" title="utils/cache/plancache.c:1498">CachedPlanSetParentContext</a>(plansource, parentcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Build new list, with list cells in plancxt */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newplan-&gt;plancache_list = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newplan-&gt;plancache_list, plansource);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For safety, unlink the CachedPlanSources from the temporary plan */<br/></li>
<li></span>&nbsp; &nbsp; plan-&gt;plancache_list = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newplan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make a &quot;saved&quot; copy of the given plan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> SPIPlanPtr<br/></li>
<li><a id="L3189">&#x200c;</a><span class="linkable">_SPI_save_plan</span>(SPIPlanPtr plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SPIPlanPtr&nbsp; &nbsp; newplan;<br/></li>
<li>&nbsp; &nbsp; MemoryContext plancxt;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* One-shot plans can't be saved */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!plan-&gt;oneshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a memory context for the plan.&nbsp; We don't expect the plan to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * very large, so use smaller-than-default alloc parameters.&nbsp; It's a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transient context until we finish copying everything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; plancxt = AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;SPI Plan&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_SMALL_SIZES);<br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(plancxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy the SPI plan into its own context */<br/></li>
<li></span>&nbsp; &nbsp; newplan = (SPIPlanPtr) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(_SPI_plan));<br/></li>
<li>&nbsp; &nbsp; newplan-&gt;magic = _SPI_PLAN_MAGIC;<br/></li>
<li>&nbsp; &nbsp; newplan-&gt;plancxt = plancxt;<br/></li>
<li>&nbsp; &nbsp; newplan-&gt;parse_mode = plan-&gt;parse_mode;<br/></li>
<li>&nbsp; &nbsp; newplan-&gt;cursor_options = plan-&gt;cursor_options;<br/></li>
<li>&nbsp; &nbsp; newplan-&gt;nargs = plan-&gt;nargs;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan-&gt;nargs &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newplan-&gt;argtypes = (Oid *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(plan-&gt;nargs * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(newplan-&gt;argtypes, plan-&gt;argtypes, plan-&gt;nargs * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newplan-&gt;argtypes = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; newplan-&gt;parserSetup = plan-&gt;parserSetup;<br/></li>
<li>&nbsp; &nbsp; newplan-&gt;parserSetupArg = plan-&gt;parserSetupArg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy all the plancache entries */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, plan-&gt;plancache_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CachedPlanSource *plansource = (CachedPlanSource *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CachedPlanSource *newsource;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newsource = <a href="../utils/cache/plancache.c.html#L1536" title="utils/cache/plancache.c:1536">CopyCachedPlan</a>(plansource);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newplan-&gt;plancache_list = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newplan-&gt;plancache_list, newsource);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark it saved, reparent it under <a href="../utils/mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>, and mark all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * component CachedPlanSources as saved.&nbsp; This sequence cannot fail<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partway through, so there's no risk of long-term memory leakage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newplan-&gt;saved = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L637" title="utils/mmgr/mcxt.c:637">MemoryContextSetParent</a>(newplan-&gt;plancxt, <a href="../utils/mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, newplan-&gt;plancache_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CachedPlanSource *plansource = (CachedPlanSource *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/plancache.c.html#L482" title="utils/cache/plancache.c:482">SaveCachedPlan</a>(plansource);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newplan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Internal lookup of ephemeral named relation by name.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> EphemeralNamedRelation<br/></li>
<li><a id="L3260">&#x200c;</a><span class="linkable">_SPI_find_ENR_by_name</span>(<span class="Type">const</span> <span class="Type">char</span> *name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> static function; <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error is bug in SPI itself */<br/></li>
<li></span>&nbsp; &nbsp; Assert(name != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fast exit if no tuplestores have been added */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;queryEnv == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../utils/misc/queryenvironment.c.html#L96" title="utils/misc/queryenvironment.c:96">get_ENR</a>(<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;queryEnv, name);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Register an ephemeral named relation for use by the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> and executor on<br/></li>
<li></span><span class="Comment"> * subsequent calls using this SPI connection.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L3277">&#x200c;</a></span><span class="linkable">SPI_register_relation</span>(EphemeralNamedRelation enr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EphemeralNamedRelation match;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (enr == <span class="Constant">NULL</span> || enr-&gt;md.name == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SPI_ERROR_ARGUMENT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L3057" title="executor/spi.c:3057">_SPI_begin_call</a>(<span class="Constant">false</span>);&nbsp; &nbsp; <span class="Comment">/* keep current memory context */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (res &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; match = <a href="#L3260" title="executor/spi.c:3260">_SPI_find_ENR_by_name</a>(enr-&gt;md.name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (match)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = SPI_ERROR_REL_DUPLICATE;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;queryEnv == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;queryEnv = <a href="../utils/misc/queryenvironment.c.html#L39" title="utils/misc/queryenvironment.c:39">create_queryEnv</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/queryenvironment.c.html#L69" title="utils/misc/queryenvironment.c:69">register_ENR</a>(<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;queryEnv, enr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = SPI_OK_REL_REGISTER;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3081" title="executor/spi.c:3081">_SPI_end_call</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Unregister an ephemeral named relation by name.&nbsp; This will probably be a<br/></li>
<li></span><span class="Comment"> * rarely used function, since <a href="#L182" title="executor/spi.c:182">SPI_finish</a> will clear it automatically.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L3311">&#x200c;</a></span><span class="linkable">SPI_unregister_relation</span>(<span class="Type">const</span> <span class="Type">char</span> *name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EphemeralNamedRelation match;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (name == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SPI_ERROR_ARGUMENT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L3057" title="executor/spi.c:3057">_SPI_begin_call</a>(<span class="Constant">false</span>);&nbsp; &nbsp; <span class="Comment">/* keep current memory context */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (res &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; match = <a href="#L3260" title="executor/spi.c:3260">_SPI_find_ENR_by_name</a>(name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (match)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/queryenvironment.c.html#L82" title="utils/misc/queryenvironment.c:82">unregister_ENR</a>(<a href="#L49" title="executor/spi.c:49">_SPI_current</a>-&gt;queryEnv, match-&gt;md.name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = SPI_OK_REL_UNREGISTER;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res = SPI_ERROR_REL_NOT_FOUND;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3081" title="executor/spi.c:3081">_SPI_end_call</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Register the transient relations from 'tdata' using this SPI connection.<br/></li>
<li></span><span class="Comment"> * This should be called by PL implementations' <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> handlers after<br/></li>
<li></span><span class="Comment"> * connecting, in order to make transition tables visible to <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> queries run<br/></li>
<li></span><span class="Comment"> * in this connection.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L3344">&#x200c;</a></span><span class="linkable">SPI_register_trigger_data</span>(TriggerData *tdata)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tdata == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> SPI_ERROR_ARGUMENT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tdata-&gt;tg_newtable)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EphemeralNamedRelation enr =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(EphemeralNamedRelationData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; enr-&gt;md.name = tdata-&gt;tg_trigger-&gt;tgnewtable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; enr-&gt;md.reliddesc = tdata-&gt;tg_relation-&gt;rd_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; enr-&gt;md.tupdesc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; enr-&gt;md.enrtype = ENR_NAMED_TUPLESTORE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; enr-&gt;md.enrtuples = <a href="../utils/sort/tuplestore.c.html#L546" title="utils/sort/tuplestore.c:546">tuplestore_tuple_count</a>(tdata-&gt;tg_newtable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; enr-&gt;reldata = tdata-&gt;tg_newtable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="#L3277" title="executor/spi.c:3277">SPI_register_relation</a>(enr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc != SPI_OK_REL_REGISTER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> rc;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tdata-&gt;tg_oldtable)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EphemeralNamedRelation enr =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(EphemeralNamedRelationData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; enr-&gt;md.name = tdata-&gt;tg_trigger-&gt;tgoldtable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; enr-&gt;md.reliddesc = tdata-&gt;tg_relation-&gt;rd_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; enr-&gt;md.tupdesc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; enr-&gt;md.enrtype = ENR_NAMED_TUPLESTORE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; enr-&gt;md.enrtuples = <a href="../utils/sort/tuplestore.c.html#L546" title="utils/sort/tuplestore.c:546">tuplestore_tuple_count</a>(tdata-&gt;tg_oldtable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; enr-&gt;reldata = tdata-&gt;tg_oldtable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="#L3277" title="executor/spi.c:3277">SPI_register_relation</a>(enr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc != SPI_OK_REL_REGISTER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> rc;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> SPI_OK_TD_REGISTER;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
