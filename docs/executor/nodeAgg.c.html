<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>executor/nodeAgg.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>executor/nodeAgg.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L360">FindColsContext</a></li>
<li><a href="#L365">FindColsContext</a></li>
<li><a href="#L350">HashAggBatch</a></li>
<li><a href="#L357">HashAggBatch</a></li>
<li><a href="#L331">HashAggSpill</a></li>
<li><a href="#L339">HashAggSpill</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L4511">AggCheckCallContext</a></li>
<li><a href="#L4555">AggGetAggref</a></li>
<li><a href="#L4589">AggGetTempMemoryContext</a></li>
<li><a href="#L4654">AggRegisterCallback</a></li>
<li><a href="#L4615">AggStateIsShared</a></li>
<li><a href="#L2158">ExecAgg</a></li>
<li><a href="#L4683">ExecAggEstimate</a></li>
<li><a href="#L4704">ExecAggInitializeDSM</a></li>
<li><a href="#L4729">ExecAggInitializeWorker</a></li>
<li><a href="#L4742">ExecAggRetrieveInstrumentation</a></li>
<li><a href="#L4304">ExecEndAgg</a></li>
<li><a href="#L3173">ExecInitAgg</a></li>
<li><a href="#L4364">ExecReScanAgg</a></li>
<li><a href="#L4288">GetAggInitVal</a></li>
<li><a href="#L816">advance_aggregates</a></li>
<li><a href="#L706">advance_transition_function</a></li>
<li><a href="#L2540">agg_fill_hash_table</a></li>
<li><a href="#L2594">agg_refill_hash_table</a></li>
<li><a href="#L2194">agg_retrieve_direct</a></li>
<li><a href="#L2746">agg_retrieve_hash_table</a></li>
<li><a href="#L2771">agg_retrieve_hash_table_in_memory</a></li>
<li><a href="#L1503">build_hash_table</a></li>
<li><a href="#L1468">build_hash_tables</a></li>
<li><a href="#L4038">build_pertrans_for_aggref</a></li>
<li><a href="#L547">fetch_input_tuple</a></li>
<li><a href="#L1046">finalize_aggregate</a></li>
<li><a href="#L1294">finalize_aggregates</a></li>
<li><a href="#L1146">finalize_partialaggregate</a></li>
<li><a href="#L1397">find_cols</a></li>
<li><a href="#L1420">find_cols_walker</a></li>
<li><a href="#L1563">find_hash_columns</a></li>
<li><a href="#L1856">hash_agg_check_limits</a></li>
<li><a href="#L1882">hash_agg_enter_spill_mode</a></li>
<li><a href="#L1694">hash_agg_entry_size</a></li>
<li><a href="#L1798">hash_agg_set_limits</a></li>
<li><a href="#L1917">hash_agg_update_metrics</a></li>
<li><a href="#L1966">hash_choose_num_buckets</a></li>
<li><a href="#L1991">hash_choose_num_partitions</a></li>
<li><a href="#L2991">hashagg_batch_new</a></li>
<li><a href="#L3010">hashagg_batch_read</a></li>
<li><a href="#L3059">hashagg_finish_initial_spills</a></li>
<li><a href="#L1741">hashagg_recompile_expressions</a></li>
<li><a href="#L3133">hashagg_reset_spill_state</a></li>
<li><a href="#L3093">hashagg_spill_finish</a></li>
<li><a href="#L2894">hashagg_spill_init</a></li>
<li><a href="#L2925">hashagg_spill_tuple</a></li>
<li><a href="#L578">initialize_aggregate</a></li>
<li><a href="#L665">initialize_aggregates</a></li>
<li><a href="#L2045">initialize_hash_entry</a></li>
<li><a href="#L477">initialize_phase</a></li>
<li><a href="#L2095">lookup_hash_entries</a></li>
<li><a href="#L1204">prepare_hash_slot</a></li>
<li><a href="#L1249">prepare_projection_slot</a></li>
<li><a href="#L949">process_ordered_aggregate_multi</a></li>
<li><a href="#L848">process_ordered_aggregate_single</a></li>
<li><a href="#L1371">project_aggregates</a></li>
<li><a href="#L455">select_current_set</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L320">CHUNKHDRSZ</a></li>
<li><a href="#L314">HASHAGG_HLL_BIT_WIDTH</a></li>
<li><a href="#L297">HASHAGG_MAX_PARTITIONS</a></li>
<li><a href="#L296">HASHAGG_MIN_PARTITIONS</a></li>
<li><a href="#L295">HASHAGG_PARTITION_FACTOR</a></li>
<li><a href="#L305">HASHAGG_READ_BUFFER_SIZE</a></li>
<li><a href="#L306">HASHAGG_WRITE_BUFFER_SIZE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * nodeAgg.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines to handle aggregate nodes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="#L2158" title="executor/nodeAgg.c:2158">ExecAgg</a> normally evaluates each aggregate in the following steps:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; transvalue = initcond<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; foreach input_tuple do<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transvalue = transfunc(transvalue, input_value(s))<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result = finalfunc(transvalue, direct_argument(s))<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; If a finalfunc is not supplied then the result is just the ending<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; value of transvalue.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Other behaviors can be selected by the &quot;aggsplit&quot; mode, which exists<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; to support partial aggregation.&nbsp; It is possible to:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; * Skip running the finalfunc, so that the output is always the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; final transvalue state.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; * Substitute the combinefunc for the transfunc, so that transvalue<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; states (propagated up from a child partial-aggregation step) are merged<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; rather than processing raw input rows.&nbsp; (The statements below about<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the transfunc apply equally to the combinefunc, when it's selected.)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; * Apply the serializefunc to the output <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (this only makes sense<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; when skipping the finalfunc, since the serializefunc works on the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; transvalue data type).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; * Apply the deserializefunc to the input <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (this only makes sense<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; when using the combinefunc, for similar reasons).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; It is the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>'s responsibility to <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> up Agg nodes using these<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; alternate behaviors in a way that makes sense, with partial aggregation<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; results being fed to nodes that expect them.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; If a normal aggregate call specifies DISTINCT or ORDER BY, we sort the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; input tuples and eliminate duplicates (if required) <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> performing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the above-depicted process.&nbsp; (However, we don't do that for ordered-set<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; aggregates; their &quot;ORDER BY&quot; inputs are ordinary aggregate arguments<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; so far as this module is concerned.)&nbsp; &nbsp; Note that partial aggregation<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; is not supported in these cases, since we couldn't ensure global<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; ordering or distinctness of the inputs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; If transfunc is marked &quot;strict&quot; in pg_proc and initcond is NULL,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; then the first non-NULL input_value is assigned directly to transvalue,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; and transfunc isn't applied until the second non-NULL input_value.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; The agg's first input type and transtype must be the same in this case!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; If transfunc is marked &quot;strict&quot; then NULL input_values are skipped,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; keeping the previous transvalue.&nbsp; If transfunc is not strict then it<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; is called for every input tuple and must deal with NULL initcond<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; or NULL input_values for itself.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; If finalfunc is marked &quot;strict&quot; then it is not called when the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; ending transvalue is NULL, instead a NULL result is created<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; automatically (this is just the usual handling of strict <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; of course).&nbsp; A non-strict finalfunc can make its own choice of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; what to return for a NULL ending transvalue.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Ordered-set aggregates are treated specially in one other way: we<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; evaluate <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> &quot;direct&quot; arguments and pass them to the finalfunc along<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; with the transition value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; A finalfunc can have additional arguments beyond the transvalue and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> &quot;direct&quot; arguments, corresponding to the input arguments of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; aggregate.&nbsp; These are always just passed as NULL.&nbsp; Such arguments may be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; needed to allow resolution of a polymorphic aggregate's result type.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; We compute aggregate input expressions and run the transition <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; in a temporary econtext (aggstate-&gt;tmpcontext).&nbsp; This is reset at least<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; once per input tuple, so when the transvalue datatype is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; pass-by-reference, we have to be careful to copy it into a longer-lived<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; memory context, and free the prior value to avoid memory leakage.&nbsp; We<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; store transvalues in another set of econtexts, aggstate-&gt;aggcontexts<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; (one per grouping set, see below), which are also used for the hashtable<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; structures in AGG_HASHED mode.&nbsp; These econtexts are rescanned, not just<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; reset, at group boundaries so that aggregate transition <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> can<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; register shutdown callbacks via <a href="#L4654" title="executor/nodeAgg.c:4654">AggRegisterCallback</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; The node's regular econtext (aggstate-&gt;ss.ps.ps_ExprContext) is used to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; run finalize <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> and compute the output tuple; this context can be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; reset once per output tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; The executor's AggState node is passed as the fmgr &quot;context&quot; value in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; all transfunc and finalfunc calls.&nbsp; It is not recommended that the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; transition <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> look at the AggState node directly, but they can<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; use <a href="#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>() to verify that they are being called by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; nodeAgg.c (and not as ordinary SQL <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>).&nbsp; The <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> reason a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; transition function might want to know this is so that it can avoid<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'ing a fixed-size pass-by-ref transition value on every call:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; it can instead just scribble on and return its left input.&nbsp; Ordinarily<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; it is completely forbidden for <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to modify pass-by-ref inputs,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; but in the aggregate case we know the left input is either the initial<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; transition value or a previous function result, and in either case its<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; value need not be preserved.&nbsp; See <a href="../utils/adt/int8.c.html#L719" title="utils/adt/int8.c:719">int8inc</a>() for an example.&nbsp; Notice that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the EEOP_AGG_PLAIN_TRANS step is coded to avoid a data copy step when<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the previous transition value pointer is returned.&nbsp; It is also possible<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; to avoid repeated data copying when the transition value is an expanded<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; object: to do that, the transition function must take care to return<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; an expanded object that is in a child context of the memory context<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; returned by <a href="#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>().&nbsp; Also, some transition <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> want<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; to store working state in addition to the nominal transition value; they<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; can use the memory context returned by <a href="#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>() to do that.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Note: <a href="#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>() is available as of PostgreSQL 9.0.&nbsp; The<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; AggState is available as context in earlier releases (back to 8.1),<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; but direct examination of the node is needed to use it <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> 9.0.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; As of 9.4, aggregate transition <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> can also use <a href="#L4555" title="executor/nodeAgg.c:4555">AggGetAggref</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; to get hold of the Aggref expression node for their aggregate call.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; This is mainly intended for ordered-set aggregates, which are not<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; supported as window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; (A regular aggregate function would<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; need some fallback logic to use this, since there's no Aggref node<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; for a window function.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Grouping sets:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; A list of grouping sets which is structurally equivalent to a ROLLUP<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; clause (e.g. (a,b,c), (a,b), (a)) can be processed in a single pass over<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; ordered data.&nbsp; We do this by keeping a separate set of transition <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; for each grouping set being concurrently processed; for each input tuple<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; we update them all, and on group boundaries we reset those states<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; (starting at the front of the list) whose grouping <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> have changed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; (the list of grouping sets is ordered from most specific to least<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; specific).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Where more complex grouping sets are used, we break them down into<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &quot;phases&quot;, where each phase has a different sort order (except phase 0<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; which is reserved for hashing).&nbsp; During each phase but the last, the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; input tuples are additionally stored in a tuplesort which is keyed to the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> phase's sort order; during each phase but the first, the input<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; tuples are drawn from the previously sorted data.&nbsp; (The sorting of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; data for the first phase is handled by the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>, as it might be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; satisfied by underlying nodes.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Hashing can be mixed with sorted grouping.&nbsp; To do this, we have an<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; AGG_MIXED strategy that populates the hashtables during the first sorted<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; phase, and switches to reading them out after completing all sort phases.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; We can also support AGG_HASHED with multiple <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables and no sorting<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; at all.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; From the perspective of aggregate transition and final <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; only issue regarding grouping sets is this: a single call site (flinfo)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; of an aggregate function may be used for updating several different<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; transition <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in turn. So the function must not cache in the flinfo<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; anything which logically belongs as part of the transition value (most<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; importantly, the memory context in which the transition value exists).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; The support API <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> (<a href="#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>, <a href="#L4654" title="executor/nodeAgg.c:4654">AggRegisterCallback</a>) are<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; sensitive to the grouping set for which the aggregate function is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; currently being called.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Plan structure:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; What we get from the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> is actually one &quot;real&quot; Agg node which is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; part of the plan tree proper, but which optionally has an additional list<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; of Agg nodes hung off the side via the &quot;chain&quot; field.&nbsp; This is because an<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Agg node happens to be a convenient representation of all the data we<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; need for grouping sets.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; For many purposes, we treat the &quot;real&quot; node as if it were just the first<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; node in the chain.&nbsp; The chain must be ordered such that hashed entries<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; come <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> sorted/plain entries; the real node is marked AGG_MIXED if<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; there are both types present (in which case the real node describes one<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; of the hashed groupings, other AGG_HASHED nodes may optionally follow in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the chain, followed in turn by AGG_SORTED or (one) AGG_PLAIN node).&nbsp; If<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the real node is marked AGG_HASHED or AGG_SORTED, then all the chained<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; nodes must be of the same type; if it is AGG_PLAIN, there can be no<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; chained nodes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; We collect all hashed nodes into a single &quot;phase&quot;, numbered 0, and create<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; a sorted phase (numbered 1..n) for each AGG_SORTED or AGG_PLAIN node.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Phase 0 is allocated even if there are no hashes, but remains unused in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; that case.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; AGG_HASHED nodes actually refer to only a single grouping set each,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; because for each hashed grouping we need a separate grpColIdx and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; numGroups estimate.&nbsp; AGG_SORTED nodes represent a &quot;rollup&quot;, a list of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; grouping sets that share a sort order.&nbsp; Each AGG_SORTED node other than<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the first one has an associated Sort node which describes the sort order<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; to be used; the first sorted node takes its input from the outer subtree,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; which the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> has already arranged to provide ordered data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Memory and ExprContext usage:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Because we're accumulating aggregate <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> across input rows, we need to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; use more memory contexts than just simple input/output tuple contexts.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; In fact, for a rollup, we need a separate context for each grouping set<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; so that we can reset the inner (finer-grained) aggregates on their group<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; boundaries while continuing to accumulate <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for outer<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; (coarser-grained) groupings.&nbsp; On top of this, we might be simultaneously<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; populating hashtables; however, we only need one context for all the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; hashtables.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; So we create an array, aggcontexts, with an ExprContext for each grouping<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; set in the largest rollup that we're going to process, and use the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; per-tuple memory context of those ExprContexts to store the aggregate<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; transition <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; hashcontext is the single context created to support<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; all <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Spilling To Disk<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; When performing <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> aggregation, if the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table memory exceeds the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; limit (see <a href="#L1856" title="executor/nodeAgg.c:1856">hash_agg_check_limits</a>()), we enter &quot;spill mode&quot;. In spill<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; mode, we advance the transition states only for groups already in the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table. For tuples that would need to create a new <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; entries (and <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> new transition states), we instead spill them to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; disk to be processed later. The tuples are spilled in a partitioned<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; manner, so that subsequent batches are smaller and less likely to exceed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; hash_mem (if a batch does exceed hash_mem, it must be spilled<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; recursively).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Spilled data is written to logical tapes. These provide better control<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; over memory usage, disk space, and the number of files than if we were<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; to use a <a href="../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a> for each spill.&nbsp; We don't know the number of tapes needed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; at the start of the algorithm (because it can recurse), so a tape set is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; allocated at the beginning, and individual tapes are created as needed.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; As a particular tape is read, logtape.c recycles its disk space. When a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; tape is read to completion, it is destroyed entirely.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Tapes' buffers can take up substantial memory when many tapes are open at<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; once. We only need one tape open at a time in read mode (using a buffer<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; that's a multiple of BLCKSZ); but we need one tape open in write mode (each<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; requiring a buffer of size BLCKSZ) for each partition.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Note that it's possible for transition states to start small but then<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; grow very large; for instance in the case of ARRAY_AGG. In such cases,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; it's still possible to significantly exceed hash_mem. We try to avoid<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; this situation by estimating what will fit in the available memory, and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; imposing a limit on the number of groups separately from the amount of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; memory consumed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Transition / Combine function invocation:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; For performance reasons transition <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, including <a href="../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, aren't invoked one-by-one from nodeAgg.c after computing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; arguments using the expression evaluation engine. Instead<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="execExpr.c.html#L3490" title="executor/execExpr.c:3490">ExecBuildAggTrans</a>() builds one large expression that does both argument<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; evaluation and transition function invocation. That avoids performance<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; issues due to repeated uses of expression evaluation, complications due<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; to filter expressions having to be evaluated early, and allows to JIT<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the entire expression into one native function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/executor/nodeAgg.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/parallel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/objectaccess.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_aggregate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/hashfn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/execExpr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeAgg.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/hyperloglog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_agg.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_coerce.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/acl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/dynahash.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/expandeddatum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/logtape.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/tuplesort.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Control how many partitions are created when spilling HashAgg to<br/></li>
<li></span><span class="Comment"> * disk.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L295" title="executor/nodeAgg.c:295">HASHAGG_PARTITION_FACTOR</a> is multiplied by the estimated number of<br/></li>
<li></span><span class="Comment"> * partitions needed such that each partition will fit in memory. The factor<br/></li>
<li></span><span class="Comment"> * is set higher than one because there's not a high cost to having a few too<br/></li>
<li></span><span class="Comment"> * many partitions, and it makes it less likely that a partition will need to<br/></li>
<li></span><span class="Comment"> * be spilled recursively. Another benefit of having more, smaller partitions<br/></li>
<li></span><span class="Comment"> * is that small <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables may perform better than large ones due to memory<br/></li>
<li></span><span class="Comment"> * caching effects.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also specify a min and max number of partitions per spill. Too few might<br/></li>
<li></span><span class="Comment"> * mean a lot of wasted I/O from repeated spilling of the same tuples. Too<br/></li>
<li></span><span class="Comment"> * many will result in lots of memory wasted buffering the spill files (which<br/></li>
<li></span><span class="Comment"> * could instead be spent on a larger <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L295">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">HASHAGG_PARTITION_FACTOR</span> </span><span class="Constant">1.50<br/></li>
<li><a id="L296">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">HASHAGG_MIN_PARTITIONS</span> </span><span class="Constant">4<br/></li>
<li><a id="L297">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">HASHAGG_MAX_PARTITIONS</span> </span><span class="Constant">1024<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * For reading from tapes, the buffer size must be a multiple of<br/></li>
<li></span><span class="Comment"> * BLCKSZ. Larger <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> <a href="../main/main.c.html#L320" title="main/main.c:320">help</a> when reading from multiple tapes concurrently,<br/></li>
<li></span><span class="Comment"> * but that doesn't happen in HashAgg, so we simply use BLCKSZ. Writing to a<br/></li>
<li></span><span class="Comment"> * tape always uses a buffer of size BLCKSZ.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L305">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">HASHAGG_READ_BUFFER_SIZE</span> BLCKSZ<br/></li>
<li><a id="L306">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">HASHAGG_WRITE_BUFFER_SIZE</span> BLCKSZ<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * HyperLogLog is used for estimating the cardinality of the spilled tuples in<br/></li>
<li></span><span class="Comment"> * a given partition. 5 bits corresponds to a size of about 32 bytes and a<br/></li>
<li></span><span class="Comment"> * worst-case error of around 18%. That's effective enough to choose a<br/></li>
<li></span><span class="Comment"> * reasonable number of partitions when recursing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L314">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">HASHAGG_HLL_BIT_WIDTH</span> </span><span class="Constant">5<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Estimate chunk overhead as a constant 16 bytes. </span><span class="Todo">XXX</span><span class="Comment">: should this be<br/></li>
<li></span><span class="Comment"> * improved?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L320">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CHUNKHDRSZ</span> </span><span class="Constant">16<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Represents partitioned spill data for a single hashtable. Contains the<br/></li>
<li></span><span class="Comment"> * necessary information to route tuples to the correct partition, and to<br/></li>
<li></span><span class="Comment"> * transform the spilled data into new batches.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The high bits are used for partition selection (when recursing, we ignore<br/></li>
<li></span><span class="Comment"> * the bits that have already been used for partition selection at an earlier<br/></li>
<li></span><span class="Comment"> * level).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L331">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">HashAggSpill</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npartitions;&nbsp; &nbsp; <span class="Comment">/* number of partitions */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/sort/logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> **partitions;&nbsp; &nbsp; <span class="Comment">/* spill partition tapes */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp;&nbsp; *ntuples;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of tuples in each partition */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; mask;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mask to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> partition from <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shift;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* after masking, shift by this amount */<br/></li>
<li></span>&nbsp; &nbsp; hyperLogLogState *hll_card; <span class="Comment">/* cardinality estimate for contents */<br/></li>
<li><a id="L339">&#x200c;</a></span>} <span class="linkable">HashAggSpill</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Represents work to be done for one pass of <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> aggregation (with only one<br/></li>
<li></span><span class="Comment"> * grouping set).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also tracks the bits of the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> already used for partition selection by<br/></li>
<li></span><span class="Comment"> * earlier iterations, so that this batch can use new bits. If all bits have<br/></li>
<li></span><span class="Comment"> * already been used, no partitioning will be done (<a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> spilled data will go<br/></li>
<li></span><span class="Comment"> * to a single output tape).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L350">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">HashAggBatch</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setno;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* grouping set */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; used_bits;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of bits of <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> already used */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/sort/logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *input_tape;&nbsp; &nbsp; <span class="Comment">/* input partition tape */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; input_tuples;&nbsp; &nbsp; <span class="Comment">/* number of tuples in this batch */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; input_card;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* estimated group cardinality */<br/></li>
<li><a id="L357">&#x200c;</a></span>} <span class="linkable">HashAggBatch</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* used to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> referenced colnos */<br/></li>
<li><a id="L360">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">FindColsContext</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_aggref;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* is under an aggref */<br/></li>
<li></span>&nbsp; &nbsp; Bitmapset&nbsp; *aggregated;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* column references under an aggref */<br/></li>
<li></span>&nbsp; &nbsp; Bitmapset&nbsp; *unaggregated;&nbsp; &nbsp; <span class="Comment">/* other column references */<br/></li>
<li><a id="L365">&#x200c;</a></span>} <span class="linkable">FindColsContext</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L455" title="executor/nodeAgg.c:455">select_current_set</a>(AggState *aggstate, <span class="Type">int</span> setno, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_hash);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L477" title="executor/nodeAgg.c:477">initialize_phase</a>(AggState *aggstate, <span class="Type">int</span> newphase);<br/></li>
<li><span class="Type">static</span> TupleTableSlot *<a href="#L547" title="executor/nodeAgg.c:547">fetch_input_tuple</a>(AggState *aggstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L665" title="executor/nodeAgg.c:665">initialize_aggregates</a>(AggState *aggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerGroup *pergroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> numReset);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L706" title="executor/nodeAgg.c:706">advance_transition_function</a>(AggState *aggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerTrans pertrans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerGroup pergroupstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L816" title="executor/nodeAgg.c:816">advance_aggregates</a>(AggState *aggstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L848" title="executor/nodeAgg.c:848">process_ordered_aggregate_single</a>(AggState *aggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AggStatePerTrans pertrans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AggStatePerGroup pergroupstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L949" title="executor/nodeAgg.c:949">process_ordered_aggregate_multi</a>(AggState *aggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerTrans pertrans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerGroup pergroupstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1046" title="executor/nodeAgg.c:1046">finalize_aggregate</a>(AggState *aggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AggStatePerAgg peragg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AggStatePerGroup pergroupstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *resultVal, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *resultIsNull);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1146" title="executor/nodeAgg.c:1146">finalize_partialaggregate</a>(AggState *aggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerAgg peragg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerGroup pergroupstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *resultVal, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *resultIsNull);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L1204" title="executor/nodeAgg.c:1204">prepare_hash_slot</a>(AggStatePerHash perhash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *inputslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *hashslot);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1249" title="executor/nodeAgg.c:1249">prepare_projection_slot</a>(AggState *aggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> currentSet);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1294" title="executor/nodeAgg.c:1294">finalize_aggregates</a>(AggState *aggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerAgg peraggs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerGroup pergroup);<br/></li>
<li><span class="Type">static</span> TupleTableSlot *<a href="#L1371" title="executor/nodeAgg.c:1371">project_aggregates</a>(AggState *aggstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1397" title="executor/nodeAgg.c:1397">find_cols</a>(AggState *aggstate, Bitmapset **aggregated,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bitmapset **unaggregated);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1420" title="executor/nodeAgg.c:1420">find_cols_walker</a>(Node *node, <a href="#L360" title="executor/nodeAgg.c:360">FindColsContext</a> *context);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1468" title="executor/nodeAgg.c:1468">build_hash_tables</a>(AggState *aggstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="nodeRecursiveunion.c.html#L32" title="executor/nodeRecursiveunion.c:32">build_hash_table</a>(AggState *aggstate, <span class="Type">int</span> setno, <span class="Type">long</span> nbuckets);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1741" title="executor/nodeAgg.c:1741">hashagg_recompile_expressions</a>(AggState *aggstate, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> minslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nullcheck);<br/></li>
<li><span class="Type">static</span> <span class="Type">long</span> <a href="#L1966" title="executor/nodeAgg.c:1966">hash_choose_num_buckets</a>(<span class="Type">double</span> hashentrysize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span> ngroups, Size memory);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1991" title="executor/nodeAgg.c:1991">hash_choose_num_partitions</a>(<span class="Type">double</span> input_groups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> hashentrysize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> used_bits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *log2_npartitions);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2045" title="executor/nodeAgg.c:2045">initialize_hash_entry</a>(AggState *aggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleHashTable hashtable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleHashEntry entry);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2095" title="executor/nodeAgg.c:2095">lookup_hash_entries</a>(AggState *aggstate);<br/></li>
<li><span class="Type">static</span> TupleTableSlot *<a href="#L2194" title="executor/nodeAgg.c:2194">agg_retrieve_direct</a>(AggState *aggstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2540" title="executor/nodeAgg.c:2540">agg_fill_hash_table</a>(AggState *aggstate);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2594" title="executor/nodeAgg.c:2594">agg_refill_hash_table</a>(AggState *aggstate);<br/></li>
<li><span class="Type">static</span> TupleTableSlot *<a href="#L2746" title="executor/nodeAgg.c:2746">agg_retrieve_hash_table</a>(AggState *aggstate);<br/></li>
<li><span class="Type">static</span> TupleTableSlot *<a href="#L2771" title="executor/nodeAgg.c:2771">agg_retrieve_hash_table_in_memory</a>(AggState *aggstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1856" title="executor/nodeAgg.c:1856">hash_agg_check_limits</a>(AggState *aggstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1882" title="executor/nodeAgg.c:1882">hash_agg_enter_spill_mode</a>(AggState *aggstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1917" title="executor/nodeAgg.c:1917">hash_agg_update_metrics</a>(AggState *aggstate, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> from_tape,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> npartitions);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3059" title="executor/nodeAgg.c:3059">hashagg_finish_initial_spills</a>(AggState *aggstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3133" title="executor/nodeAgg.c:3133">hashagg_reset_spill_state</a>(AggState *aggstate);<br/></li>
<li><span class="Type">static</span> <a href="#L350" title="executor/nodeAgg.c:350">HashAggBatch</a> *<a href="#L2991" title="executor/nodeAgg.c:2991">hashagg_batch_new</a>(<a href="../utils/sort/logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *input_tape, <span class="Type">int</span> setno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int64 input_tuples, <span class="Type">double</span> input_card,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> used_bits);<br/></li>
<li><span class="Type">static</span> MinimalTuple <a href="#L3010" title="executor/nodeAgg.c:3010">hashagg_batch_read</a>(<a href="#L350" title="executor/nodeAgg.c:350">HashAggBatch</a> *batch, uint32 *hashp);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2894" title="executor/nodeAgg.c:2894">hashagg_spill_init</a>(<a href="#L331" title="executor/nodeAgg.c:331">HashAggSpill</a> *spill, <a href="../utils/sort/logtape.c.html#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *tapeset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> used_bits, <span class="Type">double</span> input_groups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> hashentrysize);<br/></li>
<li><span class="Type">static</span> Size <a href="#L2925" title="executor/nodeAgg.c:2925">hashagg_spill_tuple</a>(AggState *aggstate, <a href="#L331" title="executor/nodeAgg.c:331">HashAggSpill</a> *spill,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *inputslot, uint32 <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3093" title="executor/nodeAgg.c:3093">hashagg_spill_finish</a>(AggState *aggstate, <a href="#L331" title="executor/nodeAgg.c:331">HashAggSpill</a> *spill,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> setno);<br/></li>
<li><span class="Type">static</span> Datum <a href="nodeWindowAgg.c.html#L3022" title="executor/nodeWindowAgg.c:3022">GetAggInitVal</a>(Datum textInitVal, Oid transtype);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4038" title="executor/nodeAgg.c:4038">build_pertrans_for_aggref</a>(AggStatePerTrans pertrans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggState *aggstate, EState *estate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Aggref *aggref, Oid transfn_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid aggtranstype, Oid aggserialfn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid aggdeserialfn, Datum initValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> initValueIsNull, Oid *inputTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> numArguments);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Select the current grouping set; affects current_set and<br/></li>
<li></span><span class="Comment"> * curaggcontext.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L455">&#x200c;</a></span><span class="linkable">select_current_set</span>(AggState *aggstate, <span class="Type">int</span> setno, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_hash)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When changing this, also adapt <a href="execExprInterp.c.html#L5127" title="executor/execExprInterp.c:5127">ExecAggPlainTransByVal</a>() and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="execExprInterp.c.html#L5159" title="executor/execExprInterp.c:5159">ExecAggPlainTransByRef</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_hash)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;curaggcontext = aggstate-&gt;hashcontext;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;curaggcontext = aggstate-&gt;aggcontexts[setno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;current_set = setno;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Switch to phase &quot;newphase&quot;, which must either be 0 or 1 (to reset) or<br/></li>
<li></span><span class="Comment"> * current_phase + 1. Juggle the tuplesorts accordingly.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Phase 0 is for hashing, which we currently handle last in the AGG_MIXED<br/></li>
<li></span><span class="Comment"> * case, so when entering phase 0, all we need to do is drop open sorts.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L477">&#x200c;</a></span><span class="linkable">initialize_phase</span>(AggState *aggstate, <span class="Type">int</span> newphase)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(newphase &lt;= <span class="Constant">1</span> || newphase == aggstate-&gt;current_phase + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Whatever the previous state, we're <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> done with whatever input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuplesort was in use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;sort_in)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L971" title="utils/sort/tuplesort.c:971">tuplesort_end</a>(aggstate-&gt;sort_in);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;sort_in = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newphase &lt;= <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Discard <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing output tuplesort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;sort_out)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L971" title="utils/sort/tuplesort.c:971">tuplesort_end</a>(aggstate-&gt;sort_out);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;sort_out = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The old output tuplesort becomes the new input one, and this is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * right time to actually sort it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;sort_in = aggstate-&gt;sort_out;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;sort_out = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(aggstate-&gt;sort_in);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>(aggstate-&gt;sort_in);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this isn't the last phase, we need to sort appropriately for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> phase in sequence.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newphase &gt; <span class="Constant">0</span> &amp;&amp; newphase &lt; aggstate-&gt;numphases - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sort&nbsp; &nbsp; &nbsp;&nbsp; *sortnode = aggstate-&gt;phases[newphase + <span class="Constant">1</span>].sortnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlanState&nbsp; *outerNode = outerPlanState(aggstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc = <a href="execUtils.c.html#L493" title="executor/execUtils.c:493">ExecGetResultType</a>(outerNode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;sort_out = <a href="../utils/sort/tuplesortvariants.c.html#L168" title="utils/sort/tuplesortvariants.c:168">tuplesort_begin_heap</a>(tupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortnode-&gt;numCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortnode-&gt;sortColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortnode-&gt;sortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortnode-&gt;collations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortnode-&gt;nullsFirst,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, TUPLESORT_NONE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;current_phase = newphase;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;phase = &amp;aggstate-&gt;phases[newphase];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch a tuple from either the outer plan (for phase 1) or from the sorter<br/></li>
<li></span><span class="Comment"> * populated by the previous phase.&nbsp; Copy it to the sorter for the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> phase<br/></li>
<li></span><span class="Comment"> * if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Callers cannot rely on memory for tuple in returned slot remaining valid<br/></li>
<li></span><span class="Comment"> * past <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subsequently fetched tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TupleTableSlot *<br/></li>
<li><a id="L547">&#x200c;</a><span class="linkable">fetch_input_tuple</span>(AggState *aggstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;sort_in)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure we check for interrupts in either path through here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/sort/tuplesortvariants.c.html#L890" title="utils/sort/tuplesortvariants.c:890">tuplesort_gettupleslot</a>(aggstate-&gt;sort_in, <span class="Constant">true</span>, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;sort_slot, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot = aggstate-&gt;sort_slot;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; slot = ExecProcNode(outerPlanState(aggstate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TupIsNull(slot) &amp;&amp; aggstate-&gt;sort_out)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesortvariants.c.html#L669" title="utils/sort/tuplesortvariants.c:669">tuplesort_puttupleslot</a>(aggstate-&gt;sort_out, slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> slot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * (Re)Initialize an individual aggregate.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function handles only one grouping set, already set in<br/></li>
<li></span><span class="Comment"> * aggstate-&gt;current_set.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When called, <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> should be the per-query context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L578">&#x200c;</a></span><span class="linkable">initialize_aggregate</span>(AggState *aggstate, AggStatePerTrans pertrans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AggStatePerGroup pergroupstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start a fresh sort operation for each DISTINCT/ORDER BY aggregate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pertrans-&gt;aggsortrequired)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In case of rescan, maybe there could be an uncompleted sort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operation?&nbsp; Clean it up if so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pertrans-&gt;sortstates[aggstate-&gt;current_set])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L971" title="utils/sort/tuplesort.c:971">tuplesort_end</a>(pertrans-&gt;sortstates[aggstate-&gt;current_set]);<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We use a plain Datum sorter when there's a single input column;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise sort the full tuple.&nbsp; (See comments for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L848" title="executor/nodeAgg.c:848">process_ordered_aggregate_single</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pertrans-&gt;numInputs == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr = TupleDescAttr(pertrans-&gt;sortdesc, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;sortstates[aggstate-&gt;current_set] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesortvariants.c.html#L584" title="utils/sort/tuplesortvariants.c:584">tuplesort_begin_datum</a>(attr-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;sortOperators[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;sortCollations[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;sortNullsFirst[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>, <span class="Constant">NULL</span>, TUPLESORT_NONE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;sortstates[aggstate-&gt;current_set] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesortvariants.c.html#L168" title="utils/sort/tuplesortvariants.c:168">tuplesort_begin_heap</a>(pertrans-&gt;sortdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pertrans-&gt;numSortCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pertrans-&gt;sortColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pertrans-&gt;sortOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pertrans-&gt;sortCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pertrans-&gt;sortNullsFirst,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>, <span class="Constant">NULL</span>, TUPLESORT_NONE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Re)set transValue to the initial value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that when the initial value is pass-by-ref, we must copy it (into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the aggcontext) since we will <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> the transValue later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pertrans-&gt;initValueIsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pergroupstate-&gt;transValue = pertrans-&gt;initValue;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldContext = MemoryContextSwitchTo(aggstate-&gt;curaggcontext-&gt;ecxt_per_tuple_memory);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pergroupstate-&gt;transValue = <a href="../utils/adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(pertrans-&gt;initValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;transtypeByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;transtypeLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pergroupstate-&gt;transValueIsNull = pertrans-&gt;initValueIsNull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the initial value for the transition state doesn't exist in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_aggregate table then we will let the first non-NULL value returned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the outer procNode become the initial value. (This is useful for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggregates like max() and min().) The noTransValue flag signals that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * still need to do this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pergroupstate-&gt;noTransValue = pertrans-&gt;initValueIsNull;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize all aggregate transition states for a new group of input <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there are multiple grouping sets, we <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> only the first numReset<br/></li>
<li></span><span class="Comment"> * of them (the grouping sets are ordered so that the most specific one, which<br/></li>
<li></span><span class="Comment"> * is reset most often, is first). As a convenience, if numReset is 0, we<br/></li>
<li></span><span class="Comment"> * reinitialize all sets.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: This cannot be used for <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> aggregates, as for those the grouping set<br/></li>
<li></span><span class="Comment"> * number has to be specified from further up.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When called, <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> should be the per-query context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L665">&#x200c;</a></span><span class="linkable">initialize_aggregates</span>(AggState *aggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerGroup *pergroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> numReset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numGroupingSets = Max(aggstate-&gt;phase-&gt;numsets, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numTrans = aggstate-&gt;numtrans;<br/></li>
<li>&nbsp; &nbsp; AggStatePerTrans transstates = aggstate-&gt;pertrans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numReset == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numReset = numGroupingSets;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (setno = <span class="Constant">0</span>; setno &lt; numReset; setno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggStatePerGroup pergroup = pergroups[setno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L455" title="executor/nodeAgg.c:455">select_current_set</a>(aggstate, setno, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (transno = <span class="Constant">0</span>; transno &lt; numTrans; transno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerTrans pertrans = &amp;transstates[transno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerGroup pergroupstate = &amp;pergroup[transno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L578" title="executor/nodeAgg.c:578">initialize_aggregate</a>(aggstate, pertrans, pergroupstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given new input value(s), advance the transition function of one aggregate<br/></li>
<li></span><span class="Comment"> * state within one grouping set only (already set in aggstate-&gt;current_set)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The new <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (and null flags) have been preloaded into argument positions<br/></li>
<li></span><span class="Comment"> * 1 and up in pertrans-&gt;transfn_fcinfo, so that we needn't copy them again to<br/></li>
<li></span><span class="Comment"> * pass to the transition function.&nbsp; We also expect that the static fields of<br/></li>
<li></span><span class="Comment"> * the fcinfo are already initialized; that was done by <a href="#L3173" title="executor/nodeAgg.c:3173">ExecInitAgg</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It doesn't matter which memory context this is called in.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L706">&#x200c;</a></span><span class="linkable">advance_transition_function</span>(AggState *aggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerTrans pertrans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerGroup pergroupstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FunctionCallInfo fcinfo = pertrans-&gt;transfn_fcinfo;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; newVal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pertrans-&gt;transfn.fn_strict)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For a strict transfn, nothing happens when there's a NULL input; we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just keep the prior transValue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numTransInputs = pertrans-&gt;numTransInputs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= numTransInputs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;args[i].isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pergroupstate-&gt;noTransValue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transValue has not been initialized. This is the first non-NULL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * input value. We use it as the initial value for transValue. (We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already checked that the agg's input type is binary-compatible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with its transtype, so straight copy here is OK.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must copy the datum into aggcontext if it is pass-by-ref. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do not need to <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> the old transValue, since it's NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldContext = MemoryContextSwitchTo(aggstate-&gt;curaggcontext-&gt;ecxt_per_tuple_memory);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pergroupstate-&gt;transValue = <a href="../utils/adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(fcinfo-&gt;args[<span class="Constant">1</span>].value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;transtypeByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;transtypeLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pergroupstate-&gt;transValueIsNull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pergroupstate-&gt;noTransValue = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pergroupstate-&gt;transValueIsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't call a strict function with NULL inputs.&nbsp; Note it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible to get here despite the above tests, if the transfn is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * strict *and* returned a NULL on a prior cycle. If that happens<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we will propagate the NULL all the way to the end.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We run the transition <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in per-input-tuple memory context */<br/></li>
<li></span>&nbsp; &nbsp; oldContext = MemoryContextSwitchTo(aggstate-&gt;tmpcontext-&gt;ecxt_per_tuple_memory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set up aggstate-&gt;curpertrans for <a href="#L4555" title="executor/nodeAgg.c:4555">AggGetAggref</a>() */<br/></li>
<li></span>&nbsp; &nbsp; aggstate-&gt;curpertrans = pertrans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK to call the transition function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = pergroupstate-&gt;transValue;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = pergroupstate-&gt;transValueIsNull;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;isnull = <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just in case transfn doesn't set it */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; newVal = FunctionCallInvoke(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;curpertrans = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If pass-by-ref datatype, must copy the new value into aggcontext and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * free the prior transValue.&nbsp; But if transfn returned a pointer to its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first input, we don't need to do anything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's safe to <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> newVal with pergroup-&gt;transValue without regard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for either being NULL, because <a href="execExprInterp.c.html#L4960" title="executor/execExprInterp.c:4960">ExecAggCopyTransValue</a> takes care to set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transValue to 0 when NULL. Otherwise we could end up accidentally not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reparenting, when the transValue has the same numerical value as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * newValue, despite being NULL.&nbsp; This is a somewhat hot path, making it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * undesirable to instead solve this with another branch for the common<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case of the transition function returning its (modified) input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * argument.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!pertrans-&gt;transtypeByVal &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DatumGetPointer(newVal) != DatumGetPointer(pergroupstate-&gt;transValue))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newVal = <a href="execExprInterp.c.html#L4960" title="executor/execExprInterp.c:4960">ExecAggCopyTransValue</a>(aggstate, pertrans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newVal, fcinfo-&gt;isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pergroupstate-&gt;transValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pergroupstate-&gt;transValueIsNull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pergroupstate-&gt;transValue = newVal;<br/></li>
<li>&nbsp; &nbsp; pergroupstate-&gt;transValueIsNull = fcinfo-&gt;isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Advance each aggregate transition state for one input tuple.&nbsp; The input<br/></li>
<li></span><span class="Comment"> * tuple has been stored in tmpcontext-&gt;ecxt_outertuple, so that it is<br/></li>
<li></span><span class="Comment"> * accessible to ExecEvalExpr.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We have two sets of transition states to handle: one for sorted aggregation<br/></li>
<li></span><span class="Comment"> * and one for hashed; we do them both here, to avoid multiple evaluation of<br/></li>
<li></span><span class="Comment"> * the inputs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When called, <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> should be the per-query context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L816">&#x200c;</a></span><span class="linkable">advance_aggregates</span>(AggState *aggstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dummynull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ExecEvalExprSwitchContext(aggstate-&gt;phase-&gt;evaltrans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;tmpcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;dummynull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Run the transition function for a DISTINCT or ORDER BY aggregate<br/></li>
<li></span><span class="Comment"> * with only one input.&nbsp; This is called after we have completed<br/></li>
<li></span><span class="Comment"> * entering all the input <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> into the sort object.&nbsp; We complete the<br/></li>
<li></span><span class="Comment"> * sort, read out the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in sorted order, and run the transition<br/></li>
<li></span><span class="Comment"> * function on each value (applying DISTINCT if appropriate).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the strictness of the transition function was checked when<br/></li>
<li></span><span class="Comment"> * entering the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> into the sort, so we don't check it again here;<br/></li>
<li></span><span class="Comment"> * we just apply standard SQL DISTINCT logic.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The one-input case is handled separately from the multi-input case<br/></li>
<li></span><span class="Comment"> * for performance reasons: for single by-value inputs, such as the<br/></li>
<li></span><span class="Comment"> * common case of count(distinct id), the <a href="../utils/sort/tuplesortvariants.c.html#L1018" title="utils/sort/tuplesortvariants.c:1018">tuplesort_getdatum</a> code path<br/></li>
<li></span><span class="Comment"> * is around 300% faster.&nbsp; (The speedup for by-reference types is less<br/></li>
<li></span><span class="Comment"> * but still noticeable.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function handles only one grouping set (already set in<br/></li>
<li></span><span class="Comment"> * aggstate-&gt;current_set).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When called, <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> should be the per-query context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L848">&#x200c;</a></span><span class="linkable">process_ordered_aggregate_single</span>(AggState *aggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AggStatePerTrans pertrans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AggStatePerGroup pergroupstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; oldVal = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; oldIsNull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; haveOldVal = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; MemoryContext workcontext = aggstate-&gt;tmpcontext-&gt;ecxt_per_tuple_memory;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isDistinct = (pertrans-&gt;numDistinctCols &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; newAbbrevVal = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; oldAbbrevVal = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; FunctionCallInfo fcinfo = pertrans-&gt;transfn_fcinfo;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *newVal;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *isNull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(pertrans-&gt;numDistinctCols &lt; <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>(pertrans-&gt;sortstates[aggstate-&gt;current_set]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Load the column into argument 1 (arg 0 will be transition value) */<br/></li>
<li></span>&nbsp; &nbsp; newVal = &amp;fcinfo-&gt;args[<span class="Constant">1</span>].value;<br/></li>
<li>&nbsp; &nbsp; isNull = &amp;fcinfo-&gt;args[<span class="Constant">1</span>].isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: if input type is pass-by-ref, the datums returned by the sort are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * freshly <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d in the per-query context, so we must be careful to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> them when they are no longer needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="../utils/sort/tuplesortvariants.c.html#L1018" title="utils/sort/tuplesortvariants.c:1018">tuplesort_getdatum</a>(pertrans-&gt;sortstates[aggstate-&gt;current_set],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>, newVal, isNull, &amp;newAbbrevVal))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Clear and <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> the working context for evaluation of the equality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function and transition function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(workcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldContext = MemoryContextSwitchTo(workcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If DISTINCT mode, and not distinct from prior, <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isDistinct &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; haveOldVal &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((oldIsNull &amp;&amp; *isNull) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (!oldIsNull &amp;&amp; !*isNull &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldAbbrevVal == newAbbrevVal &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetBool(<a href="../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;pertrans-&gt;equalfnOne,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pertrans-&gt;aggCollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldVal, *newVal)))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L706" title="executor/nodeAgg.c:706">advance_transition_function</a>(aggstate, pertrans, pergroupstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Forget the old value, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, and remember the new one for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subsequent equality checks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pertrans-&gt;inputtypeByVal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!oldIsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(oldVal));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!*isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldVal = <a href="../utils/adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(*newVal, pertrans-&gt;inputtypeByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pertrans-&gt;inputtypeLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldVal = *newVal;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldAbbrevVal = newAbbrevVal;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldIsNull = *isNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; haveOldVal = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!oldIsNull &amp;&amp; !pertrans-&gt;inputtypeByVal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(oldVal));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L971" title="utils/sort/tuplesort.c:971">tuplesort_end</a>(pertrans-&gt;sortstates[aggstate-&gt;current_set]);<br/></li>
<li>&nbsp; &nbsp; pertrans-&gt;sortstates[aggstate-&gt;current_set] = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Run the transition function for a DISTINCT or ORDER BY aggregate<br/></li>
<li></span><span class="Comment"> * with more than one input.&nbsp; This is called after we have completed<br/></li>
<li></span><span class="Comment"> * entering all the input <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> into the sort object.&nbsp; We complete the<br/></li>
<li></span><span class="Comment"> * sort, read out the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in sorted order, and run the transition<br/></li>
<li></span><span class="Comment"> * function on each value (applying DISTINCT if appropriate).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function handles only one grouping set (already set in<br/></li>
<li></span><span class="Comment"> * aggstate-&gt;current_set).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When called, <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> should be the per-query context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L949">&#x200c;</a></span><span class="linkable">process_ordered_aggregate_multi</span>(AggState *aggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerTrans pertrans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerGroup pergroupstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExprContext *tmpcontext = aggstate-&gt;tmpcontext;<br/></li>
<li>&nbsp; &nbsp; FunctionCallInfo fcinfo = pertrans-&gt;transfn_fcinfo;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot1 = pertrans-&gt;sortslot;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot2 = pertrans-&gt;uniqslot;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numTransInputs = pertrans-&gt;numTransInputs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numDistinctCols = pertrans-&gt;numDistinctCols;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; newAbbrevVal = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; oldAbbrevVal = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; haveOldValue = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *save = aggstate-&gt;tmpcontext-&gt;ecxt_outertuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>(pertrans-&gt;sortstates[aggstate-&gt;current_set]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(slot1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (slot2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(slot2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="../utils/sort/tuplesortvariants.c.html#L890" title="utils/sort/tuplesortvariants.c:890">tuplesort_gettupleslot</a>(pertrans-&gt;sortstates[aggstate-&gt;current_set],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">true</span>, slot1, &amp;newAbbrevVal))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmpcontext-&gt;ecxt_outertuple = slot1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmpcontext-&gt;ecxt_innertuple = slot2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (numDistinctCols == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !haveOldValue ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newAbbrevVal != oldAbbrevVal ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !ExecQual(pertrans-&gt;equalfnMulti, tmpcontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Extract the first numTransInputs columns as datums to pass to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the transfn.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot_getsomeattrs(slot1, numTransInputs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Load <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> into fcinfo */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Start from 1, since the 0th arg will be the transition value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numTransInputs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[i + <span class="Constant">1</span>].value = slot1-&gt;tts_values[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[i + <span class="Constant">1</span>].isnull = slot1-&gt;tts_isnull[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L706" title="executor/nodeAgg.c:706">advance_transition_function</a>(aggstate, pertrans, pergroupstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (numDistinctCols &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* swap the slot pointers to retain the current tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *tmpslot = slot2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot2 = slot1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot1 = tmpslot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* avoid ExecQual() calls by reusing abbreviated keys */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldAbbrevVal = newAbbrevVal;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; haveOldValue = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset context each time */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ResetExprContext(tmpcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(slot1);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (slot2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(slot2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L971" title="utils/sort/tuplesort.c:971">tuplesort_end</a>(pertrans-&gt;sortstates[aggstate-&gt;current_set]);<br/></li>
<li>&nbsp; &nbsp; pertrans-&gt;sortstates[aggstate-&gt;current_set] = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* restore previous slot, potentially in use for grouping sets */<br/></li>
<li></span>&nbsp; &nbsp; tmpcontext-&gt;ecxt_outertuple = save;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the final value of one aggregate.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function handles only one grouping set (already set in<br/></li>
<li></span><span class="Comment"> * aggstate-&gt;current_set).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The finalfn will be run, and the result delivered, in the<br/></li>
<li></span><span class="Comment"> * output-tuple context; caller's <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> does not matter.<br/></li>
<li></span><span class="Comment"> * (But note that in some cases, such as when there is no finalfn, the<br/></li>
<li></span><span class="Comment"> * result might be a pointer to or into the agg's transition value.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The finalfn uses the state as set in the transno.&nbsp; This also might be<br/></li>
<li></span><span class="Comment"> * being used by another aggregate function, so it's important that we do<br/></li>
<li></span><span class="Comment"> * nothing destructive here.&nbsp; Moreover, the aggregate's final value might<br/></li>
<li></span><span class="Comment"> * get used in multiple places, so we mustn't return a R/W expanded datum.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1046">&#x200c;</a></span><span class="linkable">finalize_aggregate</span>(AggState *aggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AggStatePerAgg peragg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AggStatePerGroup pergroupstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *resultVal, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *resultIsNull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, FUNC_MAX_ARGS);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; anynull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; AggStatePerTrans pertrans = &amp;aggstate-&gt;pertrans[peragg-&gt;transno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldContext = MemoryContextSwitchTo(aggstate-&gt;ss.ps.ps_ExprContext-&gt;ecxt_per_tuple_memory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Evaluate <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> direct arguments.&nbsp; We do this even if there's no finalfn<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (which is unlikely anyway), so that side-effects happen as expected.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The direct arguments go into arg positions 1 and up, leaving position 0<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the transition state value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; i = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, peragg-&gt;aggdirectargs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExprState&nbsp; *expr = (ExprState *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[i].value = ExecEvalExpr(expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggstate-&gt;ss.ps.ps_ExprContext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;fcinfo-&gt;args[i].isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; anynull |= fcinfo-&gt;args[i].isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Apply the agg's finalfn if one is provided, else return transValue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(peragg-&gt;finalfn_oid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numFinalArgs = peragg-&gt;numFinalArgs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set up aggstate-&gt;curperagg for <a href="#L4555" title="executor/nodeAgg.c:4555">AggGetAggref</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;curperagg = peragg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, &amp;peragg-&gt;finalfn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numFinalArgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pertrans-&gt;aggCollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) aggstate, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fill in the transition state value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MakeExpandedObjectReadOnly(pergroupstate-&gt;transValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pergroupstate-&gt;transValueIsNull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pertrans-&gt;transtypeLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = pergroupstate-&gt;transValueIsNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; anynull |= pergroupstate-&gt;transValueIsNull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fill <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining argument positions with nulls */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; i &lt; numFinalArgs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[i].value = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[i].isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; anynull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;flinfo-&gt;fn_strict &amp;&amp; anynull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't call a strict function with NULL inputs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *resultVal = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *resultIsNull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = FunctionCallInvoke(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *resultIsNull = fcinfo-&gt;isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *resultVal = MakeExpandedObjectReadOnly(result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peragg-&gt;resulttypeLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;curperagg = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *resultVal =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MakeExpandedObjectReadOnly(pergroupstate-&gt;transValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pergroupstate-&gt;transValueIsNull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pertrans-&gt;transtypeLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *resultIsNull = pergroupstate-&gt;transValueIsNull;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the output value of one partial aggregate.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The serialization function will be run, and the result delivered, in the<br/></li>
<li></span><span class="Comment"> * output-tuple context; caller's <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> does not matter.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1146">&#x200c;</a></span><span class="linkable">finalize_partialaggregate</span>(AggState *aggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerAgg peragg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerGroup pergroupstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *resultVal, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *resultIsNull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AggStatePerTrans pertrans = &amp;aggstate-&gt;pertrans[peragg-&gt;transno];<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldContext = MemoryContextSwitchTo(aggstate-&gt;ss.ps.ps_ExprContext-&gt;ecxt_per_tuple_memory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * serialfn_oid will be set if we must serialize the transvalue <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * returning it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(pertrans-&gt;serialfn_oid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't call a strict serialization function with NULL input. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pertrans-&gt;serialfn.fn_strict &amp;&amp; pergroupstate-&gt;transValueIsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *resultVal = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *resultIsNull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FunctionCallInfo fcinfo = pertrans-&gt;serialfn_fcinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MakeExpandedObjectReadOnly(pergroupstate-&gt;transValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pergroupstate-&gt;transValueIsNull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pertrans-&gt;transtypeLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = pergroupstate-&gt;transValueIsNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = FunctionCallInvoke(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *resultIsNull = fcinfo-&gt;isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *resultVal = MakeExpandedObjectReadOnly(result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peragg-&gt;resulttypeLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *resultVal =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MakeExpandedObjectReadOnly(pergroupstate-&gt;transValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pergroupstate-&gt;transValueIsNull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pertrans-&gt;transtypeLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *resultIsNull = pergroupstate-&gt;transValueIsNull;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extract the attributes that make up the grouping key into the<br/></li>
<li></span><span class="Comment"> * hashslot. This is necessary to compute the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> or perform a lookup.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L1204">&#x200c;</a></span><span class="linkable">prepare_hash_slot</span>(AggStatePerHash perhash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *inputslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *hashslot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transfer just the needed columns into hashslot */<br/></li>
<li></span>&nbsp; &nbsp; slot_getsomeattrs(inputslot, perhash-&gt;largestGrpColIdx);<br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(hashslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; perhash-&gt;numhashGrpCols; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varNumber = perhash-&gt;hashGrpColIdxInput[i] - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashslot-&gt;tts_values[i] = inputslot-&gt;tts_values[varNumber];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashslot-&gt;tts_isnull[i] = inputslot-&gt;tts_isnull[varNumber];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="execTuples.c.html#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a>(hashslot);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare to finalize and project based on the specified representative tuple<br/></li>
<li></span><span class="Comment"> * slot and grouping set.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the specified tuple slot, force to null all attributes that should be<br/></li>
<li></span><span class="Comment"> * read as null in the context of the current grouping set.&nbsp; Also stash the<br/></li>
<li></span><span class="Comment"> * current group bitmap where GroupingExpr can get at it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This relies on three conditions:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 1) Nothing is ever going to try and extract the whole tuple from this slot,<br/></li>
<li></span><span class="Comment"> * only reference it in evaluations, which will only access individual<br/></li>
<li></span><span class="Comment"> * attributes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 2) No system columns are going to need to be nulled. (If a system column is<br/></li>
<li></span><span class="Comment"> * referenced in a group clause, it is actually projected in the outer plan<br/></li>
<li></span><span class="Comment"> * tlist.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 3) Within a given phase, we never need to recover the value of an attribute<br/></li>
<li></span><span class="Comment"> * once it has been set to null.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Poking into the slot this way is a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> ugly, but the consensus is that the<br/></li>
<li></span><span class="Comment"> * alternative was worse.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1249">&#x200c;</a></span><span class="linkable">prepare_projection_slot</span>(AggState *aggstate, TupleTableSlot *slot, <span class="Type">int</span> currentSet)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;phase-&gt;grouped_cols)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *grouped_cols = aggstate-&gt;phase-&gt;grouped_cols[currentSet];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;grouped_cols = grouped_cols;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TTS_EMPTY(slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Force all <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to be NULL if working on an empty input tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (i.e. an empty grouping set for which no input rows were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * supplied).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L1663" title="executor/execTuples.c:1663">ExecStoreAllNullTuple</a>(slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (aggstate-&gt;all_grouped_cols)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* all_grouped_cols is arranged in desc order */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot_getsomeattrs(slot, linitial_int(aggstate-&gt;all_grouped_cols));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, aggstate-&gt;all_grouped_cols)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = lfirst_int(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(attnum, grouped_cols))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_isnull[attnum - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the final value of all aggregates for one group.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function handles only one grouping set at a time, which the caller must<br/></li>
<li></span><span class="Comment"> * have selected.&nbsp; It's also the caller's responsibility to adjust the supplied<br/></li>
<li></span><span class="Comment"> * pergroup parameter to point to the current set's transvalues.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Results are stored in the output econtext aggvalues/aggnulls.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1294">&#x200c;</a></span><span class="linkable">finalize_aggregates</span>(AggState *aggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerAgg peraggs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerGroup pergroup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext = aggstate-&gt;ss.ps.ps_ExprContext;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *aggvalues = econtext-&gt;ecxt_aggvalues;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *aggnulls = econtext-&gt;ecxt_aggnulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there were <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> DISTINCT and/or ORDER BY aggregates, sort their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inputs and run the transition <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> transno = <span class="Constant">0</span>; transno &lt; aggstate-&gt;numtrans; transno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggStatePerTrans pertrans = &amp;aggstate-&gt;pertrans[transno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggStatePerGroup pergroupstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pergroupstate = &amp;pergroup[transno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pertrans-&gt;aggsortrequired)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(aggstate-&gt;aggstrategy != AGG_HASHED &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggstate-&gt;aggstrategy != AGG_MIXED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pertrans-&gt;numInputs == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L848" title="executor/nodeAgg.c:848">process_ordered_aggregate_single</a>(aggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pertrans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pergroupstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L949" title="executor/nodeAgg.c:949">process_ordered_aggregate_multi</a>(aggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pergroupstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pertrans-&gt;numDistinctCols &gt; <span class="Constant">0</span> &amp;&amp; pertrans-&gt;haslast)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;haslast = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pertrans-&gt;numDistinctCols == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pertrans-&gt;inputtypeByVal &amp;&amp; !pertrans-&gt;lastisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(pertrans-&gt;lastdatum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;lastisnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;lastdatum = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(pertrans-&gt;uniqslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Run the final <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (aggno = <span class="Constant">0</span>; aggno &lt; aggstate-&gt;numaggs; aggno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggStatePerAgg peragg = &amp;peraggs[aggno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transno = peragg-&gt;transno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggStatePerGroup pergroupstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pergroupstate = &amp;pergroup[transno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DO_AGGSPLIT_SKIPFINAL(aggstate-&gt;aggsplit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1146" title="executor/nodeAgg.c:1146">finalize_partialaggregate</a>(aggstate, peragg, pergroupstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;aggvalues[aggno], &amp;aggnulls[aggno]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1046" title="executor/nodeAgg.c:1046">finalize_aggregate</a>(aggstate, peragg, pergroupstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;aggvalues[aggno], &amp;aggnulls[aggno]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Project the result of a group (whose aggs have already been calculated by<br/></li>
<li></span><span class="Comment"> * <a href="#L1294" title="executor/nodeAgg.c:1294">finalize_aggregates</a>). Returns the result slot, or NULL if no row is<br/></li>
<li></span><span class="Comment"> * projected (suppressed by qual).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TupleTableSlot *<br/></li>
<li><a id="L1371">&#x200c;</a><span class="linkable">project_aggregates</span>(AggState *aggstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext = aggstate-&gt;ss.ps.ps_ExprContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check the qual (HAVING clause); if the group does not match, ignore it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ExecQual(aggstate-&gt;ss.ps.qual, econtext))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Form and return projection tuple using the aggregate results and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the representative input tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ExecProject(aggstate-&gt;ss.ps.ps_ProjInfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; InstrCountFiltered1(aggstate, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find input-tuple columns that are needed, dividing them into<br/></li>
<li></span><span class="Comment"> * aggregated and unaggregated sets.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1397">&#x200c;</a></span><span class="linkable">find_cols</span>(AggState *aggstate, Bitmapset **aggregated, Bitmapset **unaggregated)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Agg&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *agg = (Agg *) aggstate-&gt;ss.ps.plan;<br/></li>
<li>&nbsp; &nbsp; <a href="#L360" title="executor/nodeAgg.c:360">FindColsContext</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.is_aggref = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; context.aggregated = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; context.unaggregated = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Examine tlist and quals */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1420" title="executor/nodeAgg.c:1420">find_cols_walker</a>((Node *) agg-&gt;plan.targetlist, &amp;context);<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1420" title="executor/nodeAgg.c:1420">find_cols_walker</a>((Node *) agg-&gt;plan.qual, &amp;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* In some cases, grouping columns will not appear in the tlist */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; agg-&gt;numCols; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context.unaggregated = <a href="../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(context.unaggregated,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; agg-&gt;grpColIdx[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *aggregated = context.aggregated;<br/></li>
<li>&nbsp; &nbsp; *unaggregated = context.unaggregated;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1420">&#x200c;</a></span><span class="linkable">find_cols_walker</span>(Node *node, <a href="#L360" title="executor/nodeAgg.c:360">FindColsContext</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* setrefs.c should have set the varno to OUTER_VAR */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(var-&gt;varno == OUTER_VAR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(var-&gt;varlevelsup == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;is_aggref)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;aggregated = <a href="../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(context-&gt;aggregated,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var-&gt;varattno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;unaggregated = <a href="../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(context-&gt;unaggregated,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var-&gt;varattno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Aggref))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!context-&gt;is_aggref);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;is_aggref = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expression_tree_walker(node, <a href="#L1420" title="executor/nodeAgg.c:1420">find_cols_walker</a>, (<span class="Type">void</span> *) context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;is_aggref = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L1420" title="executor/nodeAgg.c:1420">find_cols_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * (Re-)<a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table(s) to empty.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To implement hashed aggregation, we need a hashtable that stores a<br/></li>
<li></span><span class="Comment"> * representative tuple and an array of AggStatePerGroup structs for each<br/></li>
<li></span><span class="Comment"> * distinct set of GROUP BY column <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; We compute the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key from the<br/></li>
<li></span><span class="Comment"> * GROUP BY columns.&nbsp; The per-group data is allocated in lookup_hash_entry(),<br/></li>
<li></span><span class="Comment"> * for each entry.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We have a separate hashtable and associated perhash data structure for each<br/></li>
<li></span><span class="Comment"> * grouping set for which we're doing hashing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The contents of the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables always live in the hashcontext's per-tuple<br/></li>
<li></span><span class="Comment"> * memory context (there is only one of these for all tables together, since<br/></li>
<li></span><span class="Comment"> * they are all reset at the same time).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1468">&#x200c;</a></span><span class="linkable">build_hash_tables</span>(AggState *aggstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (setno = <span class="Constant">0</span>; setno &lt; aggstate-&gt;num_hashes; ++setno)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggStatePerHash perhash = &amp;aggstate-&gt;perhash[setno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; nbuckets;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; memory;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (perhash-&gt;hashtable != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execGrouping.c.html#L284" title="executor/execGrouping.c:284">ResetTupleHashTable</a>(perhash-&gt;hashtable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(perhash-&gt;aggnode-&gt;numGroups &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memory = aggstate-&gt;hash_mem_limit / aggstate-&gt;num_hashes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* choose reasonable number of buckets per hashtable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nbuckets = <a href="#L1966" title="executor/nodeAgg.c:1966">hash_choose_num_buckets</a>(aggstate-&gt;hashentrysize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; perhash-&gt;aggnode-&gt;numGroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; memory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeRecursiveunion.c.html#L32" title="executor/nodeRecursiveunion.c:32">build_hash_table</a>(aggstate, setno, nbuckets);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;hash_ngroups_current = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build a single hashtable for this grouping set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1503">&#x200c;</a></span><span class="linkable">build_hash_table</span>(AggState *aggstate, <span class="Type">int</span> setno, <span class="Type">long</span> nbuckets)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AggStatePerHash perhash = &amp;aggstate-&gt;perhash[setno];<br/></li>
<li>&nbsp; &nbsp; MemoryContext metacxt = aggstate-&gt;hash_metacxt;<br/></li>
<li>&nbsp; &nbsp; MemoryContext hashcxt = aggstate-&gt;hashcontext-&gt;ecxt_per_tuple_memory;<br/></li>
<li>&nbsp; &nbsp; MemoryContext tmpcxt = aggstate-&gt;tmpcontext-&gt;ecxt_per_tuple_memory;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; additionalsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(aggstate-&gt;aggstrategy == AGG_HASHED ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggstate-&gt;aggstrategy == AGG_MIXED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Used to make sure initial <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table allocation does not exceed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hash_mem. Note that the estimate does not include space for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pass-by-reference transition data <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nor for the representative<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple of each group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; additionalsize = aggstate-&gt;numtrans * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AggStatePerGroupData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; perhash-&gt;hashtable = <a href="execGrouping.c.html#L153" title="executor/execGrouping.c:153">BuildTupleHashTableExt</a>(&amp;aggstate-&gt;ss.ps,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perhash-&gt;hashslot-&gt;tts_tupleDescriptor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perhash-&gt;numCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perhash-&gt;hashGrpColIdxHash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perhash-&gt;eqfuncoids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perhash-&gt;hashfunctions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perhash-&gt;aggnode-&gt;grpCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbuckets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; additionalsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metacxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmpcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DO_AGGSPLIT_SKIPFINAL(aggstate-&gt;aggsplit));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute columns that actually need to be stored in hashtable entries.&nbsp; The<br/></li>
<li></span><span class="Comment"> * incoming tuples from the child plan node will contain grouping columns,<br/></li>
<li></span><span class="Comment"> * other columns referenced in our targetlist and qual, columns used to<br/></li>
<li></span><span class="Comment"> * compute the aggregate <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, and perhaps just junk columns we don't use<br/></li>
<li></span><span class="Comment"> * at all.&nbsp; Only columns of the first two types need to be stored in the<br/></li>
<li></span><span class="Comment"> * hashtable, and getting rid of the others can make the table entries<br/></li>
<li></span><span class="Comment"> * significantly smaller.&nbsp; The hashtable only contains the relevant columns,<br/></li>
<li></span><span class="Comment"> * and is packed/unpacked in lookup_hash_entry() / <a href="#L2746" title="executor/nodeAgg.c:2746">agg_retrieve_hash_table</a>()<br/></li>
<li></span><span class="Comment"> * into the format of the normal input descriptor.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Additional columns, in addition to the columns grouped by, come from two<br/></li>
<li></span><span class="Comment"> * sources: Firstly functionally dependent columns that we don't need to group<br/></li>
<li></span><span class="Comment"> * by themselves, and secondly ctids for row-marks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To eliminate duplicates, we build a bitmapset of the needed columns, and<br/></li>
<li></span><span class="Comment"> * then build an array of the columns included in the hashtable. We might<br/></li>
<li></span><span class="Comment"> * still have duplicates if the passed-in grpColIdx has them, which can happen<br/></li>
<li></span><span class="Comment"> * in edge cases from semijoins/distinct; these can't always be removed,<br/></li>
<li></span><span class="Comment"> * because it's not certain that the duplicate cols will be using the same<br/></li>
<li></span><span class="Comment"> * <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the array is preserved over <a href="#L4364" title="executor/nodeAgg.c:4364">ExecReScanAgg</a>, so we allocate it in<br/></li>
<li></span><span class="Comment"> * the per-query context (unlike the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table itself).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1563">&#x200c;</a></span><span class="linkable">find_hash_columns</span>(AggState *aggstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *base_colnos;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *aggregated_colnos;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; scanDesc = aggstate-&gt;ss.ss_ScanTupleSlot-&gt;tts_tupleDescriptor;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *outerTlist = outerPlanState(aggstate)-&gt;plan-&gt;targetlist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numHashes = aggstate-&gt;num_hashes;<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate = aggstate-&gt;ss.ps.state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find Vars that will be needed in tlist and qual */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1397" title="executor/nodeAgg.c:1397">find_cols</a>(aggstate, &amp;aggregated_colnos, &amp;base_colnos);<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;colnos_needed = <a href="../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(base_colnos, aggregated_colnos);<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;max_colno_needed = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;all_cols_needed = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; scanDesc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colno = i + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(colno, aggstate-&gt;colnos_needed))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;max_colno_needed = colno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;all_cols_needed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; numHashes; ++j)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggStatePerHash perhash = &amp;aggstate-&gt;perhash[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *colnos = <a href="../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(base_colnos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber *grpColIdx = perhash-&gt;aggnode-&gt;grpColIdx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *hashTlist = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; hashDesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxCols;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; perhash-&gt;largestGrpColIdx = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're doing grouping sets, then some Vars might be referenced in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tlist/qual for the benefit of other grouping sets, but not needed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when hashing; i.e. <a href="#L1249" title="executor/nodeAgg.c:1249">prepare_projection_slot</a> will null them out, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there'd be no point storing them.&nbsp; Use <a href="#L1249" title="executor/nodeAgg.c:1249">prepare_projection_slot</a>'s<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * logic to determine which.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;phases[<span class="Constant">0</span>].grouped_cols)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *grouped_cols = aggstate-&gt;phases[<span class="Constant">0</span>].grouped_cols[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, aggstate-&gt;all_grouped_cols)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = lfirst_int(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(attnum, grouped_cols))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colnos = <a href="../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(colnos, attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compute maximum number of input columns accounting for possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * duplications in the grpColIdx array, which can happen in some edge<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cases where HashAggregate was generated as part of a semijoin or a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * DISTINCT.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; maxCols = <a href="../nodes/bitmapset.c.html#L751" title="nodes/bitmapset.c:751">bms_num_members</a>(colnos) + perhash-&gt;numCols;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; perhash-&gt;hashGrpColIdxInput =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(maxCols * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; perhash-&gt;hashGrpColIdxHash =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(perhash-&gt;numCols * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add all the grouping columns to colnos */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; perhash-&gt;numCols; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colnos = <a href="../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(colnos, grpColIdx[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First build mapping for columns directly hashed. These are the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first, because they'll be accessed when computing <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comparing tuples for exact matches. We also build simple mapping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for execGrouping, so it knows where to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the to-be-hashed /<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * compared columns in the input.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; perhash-&gt;numCols; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perhash-&gt;hashGrpColIdxInput[i] = grpColIdx[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perhash-&gt;hashGrpColIdxHash[i] = i + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perhash-&gt;numhashGrpCols++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* delete already mapped columns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colnos = <a href="../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(colnos, grpColIdx[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and add the remaining columns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; i = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((i = <a href="../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(colnos, i)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perhash-&gt;hashGrpColIdxInput[perhash-&gt;numhashGrpCols] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perhash-&gt;numhashGrpCols++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and build a tuple descriptor for the hashtable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; perhash-&gt;numhashGrpCols; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varNumber = perhash-&gt;hashGrpColIdxInput[i] - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashTlist = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(hashTlist, list_nth(outerTlist, varNumber));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perhash-&gt;largestGrpColIdx =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Max(varNumber + <span class="Constant">1</span>, perhash-&gt;largestGrpColIdx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashDesc = <a href="execTuples.c.html#L2025" title="executor/execTuples.c:2025">ExecTypeFromTL</a>(hashTlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execGrouping.c.html#L95" title="executor/execGrouping.c:95">execTuplesHashPrepare</a>(perhash-&gt;numCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perhash-&gt;aggnode-&gt;grpOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;perhash-&gt;eqfuncoids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;perhash-&gt;hashfunctions);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; perhash-&gt;hashslot =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L1258" title="executor/execTuples.c:1258">ExecAllocTableSlot</a>(&amp;estate-&gt;es_tupleTable, hashDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(hashTlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(colnos);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(base_colnos);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Estimate per-<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>-table-entry overhead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L1694">&#x200c;</a><span class="linkable">hash_agg_entry_size</span>(<span class="Type">int</span> numTrans, Size tupleWidth, Size transitionSpace)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; tupleChunkSize;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; pergroupChunkSize;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; transitionChunkSize;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; tupleSize = (MAXALIGN(SizeofMinimalTupleHeader) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tupleWidth);<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; pergroupSize = numTrans * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AggStatePerGroupData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tupleChunkSize = <a href="#L320" title="executor/nodeAgg.c:320">CHUNKHDRSZ</a> + tupleSize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pergroupSize &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pergroupChunkSize = <a href="#L320" title="executor/nodeAgg.c:320">CHUNKHDRSZ</a> + pergroupSize;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pergroupChunkSize = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (transitionSpace &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transitionChunkSize = <a href="#L320" title="executor/nodeAgg.c:320">CHUNKHDRSZ</a> + transitionSpace;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; transitionChunkSize = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TupleHashEntryData) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupleChunkSize +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pergroupChunkSize +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; transitionChunkSize;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1741" title="executor/nodeAgg.c:1741">hashagg_recompile_expressions</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Identifies the right phase, compiles the right expression given the<br/></li>
<li></span><span class="Comment"> * arguments, and then sets phase-&gt;evalfunc to that expression.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Different versions of the compiled expression are needed depending on<br/></li>
<li></span><span class="Comment"> * whether <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> aggregation has spilled or not, and whether it's reading from<br/></li>
<li></span><span class="Comment"> * the outer plan or a tape. Before spilling to disk, the expression reads<br/></li>
<li></span><span class="Comment"> * from the outer plan and does not need to perform a NULL check. After<br/></li>
<li></span><span class="Comment"> * HashAgg begins to spill, new groups will not be created in the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table,<br/></li>
<li></span><span class="Comment"> * and the AggStatePerGroup array may be NULL; therefore we need to add a null<br/></li>
<li></span><span class="Comment"> * pointer check to the expression. Then, when reading spilled data from a<br/></li>
<li></span><span class="Comment"> * tape, we change the outer slot type to be a fixed minimal tuple slot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It would be wasteful to recompile every time, so cache the compiled<br/></li>
<li></span><span class="Comment"> * expressions in the AggStatePerPhase, and reuse when appropriate.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1741">&#x200c;</a></span><span class="linkable">hashagg_recompile_expressions</span>(AggState *aggstate, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> minslot, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nullcheck)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AggStatePerPhase phase;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = minslot ? <span class="Constant">1</span> : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j = nullcheck ? <span class="Constant">1</span> : <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(aggstate-&gt;aggstrategy == AGG_HASHED ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggstate-&gt;aggstrategy == AGG_MIXED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;aggstrategy == AGG_HASHED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phase = &amp;aggstate-&gt;phases[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* AGG_MIXED */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; phase = &amp;aggstate-&gt;phases[<span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (phase-&gt;evaltrans_cache[i][j] == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> TupleTableSlotOps *outerops = aggstate-&gt;ss.ps.outerops;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; outerfixed = aggstate-&gt;ss.ps.outeropsfixed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dohash = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dosort = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If minslot is true, that means we are processing a spilled batch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (inside <a href="#L2594" title="executor/nodeAgg.c:2594">agg_refill_hash_table</a>()), and we must not advance the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sorted grouping sets.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;aggstrategy == AGG_MIXED &amp;&amp; !minslot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dosort = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* temporarily change the outerops while compiling the expression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (minslot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;ss.ps.outerops = &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;ss.ps.outeropsfixed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phase-&gt;evaltrans_cache[i][j] = <a href="execExpr.c.html#L3490" title="executor/execExpr.c:3490">ExecBuildAggTrans</a>(aggstate, phase,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dosort, dohash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nullcheck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* change back */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;ss.ps.outerops = outerops;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;ss.ps.outeropsfixed = outerfixed;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; phase-&gt;evaltrans = phase-&gt;evaltrans_cache[i][j];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set limits that <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> spilling to avoid exceeding hash_mem. Consider the<br/></li>
<li></span><span class="Comment"> * number of partitions we expect to create (if we do spill).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There are two limits: a memory limit, and also an ngroups limit. The<br/></li>
<li></span><span class="Comment"> * ngroups limit becomes important when we expect transition <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to grow<br/></li>
<li></span><span class="Comment"> * substantially larger than the initial value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1798">&#x200c;</a></span><span class="linkable">hash_agg_set_limits</span>(<span class="Type">double</span> hashentrysize, <span class="Type">double</span> input_groups, <span class="Type">int</span> used_bits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size *mem_limit, uint64 *ngroups_limit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *num_partitions)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npartitions;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; partition_mem;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; hash_mem_limit = <a href="nodeHash.c.html#L3595" title="executor/nodeHash.c:3595">get_hash_memory_limit</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if not expected to spill, use all of hash_mem */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (input_groups * hashentrysize &lt;= hash_mem_limit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (num_partitions != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *num_partitions = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *mem_limit = hash_mem_limit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *ngroups_limit = hash_mem_limit / hashentrysize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate expected memory requirements for spilling, which is the size<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the buffers needed for all the tapes that need to be open at once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Then, subtract that from the memory available for holding <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; npartitions = <a href="#L1991" title="executor/nodeAgg.c:1991">hash_choose_num_partitions</a>(input_groups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hashentrysize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; used_bits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (num_partitions != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *num_partitions = npartitions;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; partition_mem =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L305" title="executor/nodeAgg.c:305">HASHAGG_READ_BUFFER_SIZE</a> +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L306" title="executor/nodeAgg.c:306">HASHAGG_WRITE_BUFFER_SIZE</a> * npartitions;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't set the limit below 3/4 of hash_mem. In that case, we are at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * minimum number of partitions, so we aren't going to dramatically exceed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * work mem anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (hash_mem_limit &gt; <span class="Constant">4</span> * partition_mem)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *mem_limit = hash_mem_limit - partition_mem;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *mem_limit = hash_mem_limit * <span class="Constant">0.75</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*mem_limit &gt; hashentrysize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *ngroups_limit = *mem_limit / hashentrysize;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *ngroups_limit = <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1856" title="executor/nodeAgg.c:1856">hash_agg_check_limits</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * After adding a new group to the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table, check whether we need to enter<br/></li>
<li></span><span class="Comment"> * spill mode. Allocations may happen without adding new groups (for instance,<br/></li>
<li></span><span class="Comment"> * if the transition state size grows), so this check is imperfect.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1856">&#x200c;</a></span><span class="linkable">hash_agg_check_limits</span>(AggState *aggstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; ngroups = aggstate-&gt;hash_ngroups_current;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; meta_mem = <a href="../utils/mmgr/mcxt.c.html#L762" title="utils/mmgr/mcxt.c:762">MemoryContextMemAllocated</a>(aggstate-&gt;hash_metacxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; hashkey_mem = <a href="../utils/mmgr/mcxt.c.html#L762" title="utils/mmgr/mcxt.c:762">MemoryContextMemAllocated</a>(aggstate-&gt;hashcontext-&gt;ecxt_per_tuple_memory,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't spill unless there's at least one group in the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can be sure to make progress even in edge cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;hash_ngroups_current &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (meta_mem + hashkey_mem &gt; aggstate-&gt;hash_mem_limit ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ngroups &gt; aggstate-&gt;hash_ngroups_limit))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1882" title="executor/nodeAgg.c:1882">hash_agg_enter_spill_mode</a>(aggstate);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Enter &quot;spill mode&quot;, meaning that no new groups are added to <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment"> * tables. Tuples that would create a new group are instead spilled, and<br/></li>
<li></span><span class="Comment"> * processed later.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1882">&#x200c;</a></span><span class="linkable">hash_agg_enter_spill_mode</span>(AggState *aggstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;hash_spill_mode = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1741" title="executor/nodeAgg.c:1741">hashagg_recompile_expressions</a>(aggstate, aggstate-&gt;table_filled, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!aggstate-&gt;hash_ever_spilled)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(aggstate-&gt;hash_tapeset == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(aggstate-&gt;hash_spills == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;hash_ever_spilled = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;hash_tapeset = <a href="../utils/sort/logtape.c.html#L556" title="utils/sort/logtape.c:556">LogicalTapeSetCreate</a>(<span class="Constant">true</span>, <span class="Constant">NULL</span>, -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;hash_spills = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L331" title="executor/nodeAgg.c:331">HashAggSpill</a>) * aggstate-&gt;num_hashes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> setno = <span class="Constant">0</span>; setno &lt; aggstate-&gt;num_hashes; setno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerHash perhash = &amp;aggstate-&gt;perhash[setno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="executor/nodeAgg.c:331">HashAggSpill</a> *spill = &amp;aggstate-&gt;hash_spills[setno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2894" title="executor/nodeAgg.c:2894">hashagg_spill_init</a>(spill, aggstate-&gt;hash_tapeset, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; perhash-&gt;aggnode-&gt;numGroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggstate-&gt;hashentrysize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update metrics after filling the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If reading from the outer plan, from_tape should be false; if reading from<br/></li>
<li></span><span class="Comment"> * another tape, from_tape should be true.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1917">&#x200c;</a></span><span class="linkable">hash_agg_update_metrics</span>(AggState *aggstate, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> from_tape, <span class="Type">int</span> npartitions)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; meta_mem;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; hashkey_mem;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; buffer_mem;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; total_mem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;aggstrategy != AGG_MIXED &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;aggstrategy != AGG_HASHED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* memory for the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table itself */<br/></li>
<li></span>&nbsp; &nbsp; meta_mem = <a href="../utils/mmgr/mcxt.c.html#L762" title="utils/mmgr/mcxt.c:762">MemoryContextMemAllocated</a>(aggstate-&gt;hash_metacxt, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* memory for the group keys and transition states */<br/></li>
<li></span>&nbsp; &nbsp; hashkey_mem = <a href="../utils/mmgr/mcxt.c.html#L762" title="utils/mmgr/mcxt.c:762">MemoryContextMemAllocated</a>(aggstate-&gt;hashcontext-&gt;ecxt_per_tuple_memory, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* memory for read/write tape buffers, if spilled */<br/></li>
<li></span>&nbsp; &nbsp; buffer_mem = npartitions * <a href="#L306" title="executor/nodeAgg.c:306">HASHAGG_WRITE_BUFFER_SIZE</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (from_tape)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer_mem += <a href="#L305" title="executor/nodeAgg.c:305">HASHAGG_READ_BUFFER_SIZE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update peak mem */<br/></li>
<li></span>&nbsp; &nbsp; total_mem = meta_mem + hashkey_mem + buffer_mem;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (total_mem &gt; aggstate-&gt;hash_mem_peak)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;hash_mem_peak = total_mem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update disk usage */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;hash_tapeset != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; disk_used = <a href="../utils/sort/logtape.c.html#L1181" title="utils/sort/logtape.c:1181">LogicalTapeSetBlocks</a>(aggstate-&gt;hash_tapeset) * (BLCKSZ / <span class="Constant">1024</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;hash_disk_used &lt; disk_used)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;hash_disk_used = disk_used;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update hashentrysize estimate based on contents */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;hash_ngroups_current &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;hashentrysize =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TupleHashEntryData) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (hashkey_mem / (<span class="Type">double</span>) aggstate-&gt;hash_ngroups_current);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Choose a reasonable number of buckets for the initial <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table size.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">long<br/></li>
<li><a id="L1966">&#x200c;</a></span><span class="linkable">hash_choose_num_buckets</span>(<span class="Type">double</span> hashentrysize, <span class="Type">long</span> ngroups, Size memory)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; max_nbuckets;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; nbuckets = ngroups;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; max_nbuckets = memory / hashentrysize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Underestimating is better than overestimating. Too many buckets crowd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * out space for group keys and transition state <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; max_nbuckets &gt;&gt;= <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nbuckets &gt; max_nbuckets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbuckets = max_nbuckets;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> Max(nbuckets, <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine the number of partitions to create when spilling, which will<br/></li>
<li></span><span class="Comment"> * always be a power of two. If log2_npartitions is non-NULL, set<br/></li>
<li></span><span class="Comment"> * *log2_npartitions to the log2() of the number of partitions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1991">&#x200c;</a></span><span class="linkable">hash_choose_num_partitions</span>(<span class="Type">double</span> input_groups, <span class="Type">double</span> hashentrysize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> used_bits, <span class="Type">int</span> *log2_npartitions)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; hash_mem_limit = <a href="nodeHash.c.html#L3595" title="executor/nodeHash.c:3595">get_hash_memory_limit</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; partition_limit;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; mem_wanted;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; dpartitions;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npartitions;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partition_bits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Avoid creating so many partitions that the memory requirements of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * open partition files are greater than 1/4 of hash_mem.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; partition_limit =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (hash_mem_limit * <span class="Constant">0.25</span> - <a href="#L305" title="executor/nodeAgg.c:305">HASHAGG_READ_BUFFER_SIZE</a>) /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L306" title="executor/nodeAgg.c:306">HASHAGG_WRITE_BUFFER_SIZE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mem_wanted = <a href="#L295" title="executor/nodeAgg.c:295">HASHAGG_PARTITION_FACTOR</a> * input_groups * hashentrysize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make enough partitions so that each one is likely to fit in memory */<br/></li>
<li></span>&nbsp; &nbsp; dpartitions = <span class="Constant">1</span> + (mem_wanted / hash_mem_limit);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dpartitions &gt; partition_limit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dpartitions = partition_limit;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dpartitions &lt; <a href="#L296" title="executor/nodeAgg.c:296">HASHAGG_MIN_PARTITIONS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dpartitions = <a href="#L296" title="executor/nodeAgg.c:296">HASHAGG_MIN_PARTITIONS</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dpartitions &gt; <a href="#L297" title="executor/nodeAgg.c:297">HASHAGG_MAX_PARTITIONS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dpartitions = <a href="#L297" title="executor/nodeAgg.c:297">HASHAGG_MAX_PARTITIONS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L297" title="executor/nodeAgg.c:297">HASHAGG_MAX_PARTITIONS</a> limit makes this safe */<br/></li>
<li></span>&nbsp; &nbsp; npartitions = (<span class="Type">int</span>) dpartitions;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ceil(log2(npartitions)) */<br/></li>
<li></span>&nbsp; &nbsp; partition_bits = <a href="../utils/hash/dynahash.c.html#L1751" title="utils/hash/dynahash.c:1751">my_log2</a>(npartitions);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure that we don't exhaust the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> bits */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (partition_bits + used_bits &gt;= <span class="Constant">32</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partition_bits = <span class="Constant">32</span> - used_bits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (log2_npartitions != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *log2_npartitions = partition_bits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* number of partitions will be a power of two */<br/></li>
<li></span>&nbsp; &nbsp; npartitions = <span class="Constant">1</span> &lt;&lt; partition_bits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> npartitions;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize a freshly-created TupleHashEntry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2045">&#x200c;</a></span><span class="linkable">initialize_hash_entry</span>(AggState *aggstate, TupleHashTable hashtable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleHashEntry entry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AggStatePerGroup pergroup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;hash_ngroups_current++;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1856" title="executor/nodeAgg.c:1856">hash_agg_check_limits</a>(aggstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no need to allocate or <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> per-group state */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;numtrans == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pergroup = (AggStatePerGroup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(hashtable-&gt;tablecxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AggStatePerGroupData) * aggstate-&gt;numtrans);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entry-&gt;additional = pergroup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize aggregates for new tuple group, <a href="#L2095" title="executor/nodeAgg.c:2095">lookup_hash_entries</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already has selected the relevant grouping set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (transno = <span class="Constant">0</span>; transno &lt; aggstate-&gt;numtrans; transno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggStatePerTrans pertrans = &amp;aggstate-&gt;pertrans[transno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggStatePerGroup pergroupstate = &amp;pergroup[transno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L578" title="executor/nodeAgg.c:578">initialize_aggregate</a>(aggstate, pertrans, pergroupstate);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Look up <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> entries for the current tuple in all hashed grouping sets.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Be aware that lookup_hash_entry can reset the tmpcontext.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Some entries may be left NULL if we are in &quot;spill mode&quot;. The same tuple<br/></li>
<li></span><span class="Comment"> * will belong to different groups for each grouping set, so may match a group<br/></li>
<li></span><span class="Comment"> * already in memory for one set and match a group not in memory for another<br/></li>
<li></span><span class="Comment"> * set. When in &quot;spill mode&quot;, the tuple will be spilled for each grouping set<br/></li>
<li></span><span class="Comment"> * where it doesn't match a group in memory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: It's possible to spill the same tuple for several different grouping<br/></li>
<li></span><span class="Comment"> * sets. This may seem wasteful, but it's actually a trade-off: if we spill<br/></li>
<li></span><span class="Comment"> * the tuple multiple times for multiple grouping sets, it can be partitioned<br/></li>
<li></span><span class="Comment"> * for each grouping set, making the refilling of the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table very<br/></li>
<li></span><span class="Comment"> * efficient.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2095">&#x200c;</a></span><span class="linkable">lookup_hash_entries</span>(AggState *aggstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AggStatePerGroup *pergroup = aggstate-&gt;hash_pergroup;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *outerslot = aggstate-&gt;tmpcontext-&gt;ecxt_outertuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (setno = <span class="Constant">0</span>; setno &lt; aggstate-&gt;num_hashes; setno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggStatePerHash perhash = &amp;aggstate-&gt;perhash[setno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleHashTable hashtable = perhash-&gt;hashtable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *hashslot = perhash-&gt;hashslot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleHashEntry entry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnew = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *p_isnew;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table already spilled, don't create new entries */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; p_isnew = aggstate-&gt;hash_spill_mode ? <span class="Constant">NULL</span> : &amp;isnew;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L455" title="executor/nodeAgg.c:455">select_current_set</a>(aggstate, setno, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1204" title="executor/nodeAgg.c:1204">prepare_hash_slot</a>(perhash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outerslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry = <a href="execGrouping.c.html#L305" title="executor/execGrouping.c:305">LookupTupleHashEntry</a>(hashtable, hashslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; p_isnew, &amp;<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnew)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2045" title="executor/nodeAgg.c:2045">initialize_hash_entry</a>(aggstate, hashtable, entry);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pergroup[setno] = entry-&gt;additional;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="executor/nodeAgg.c:331">HashAggSpill</a> *spill = &amp;aggstate-&gt;hash_spills[setno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *slot = aggstate-&gt;tmpcontext-&gt;ecxt_outertuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (spill-&gt;partitions == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2894" title="executor/nodeAgg.c:2894">hashagg_spill_init</a>(spill, aggstate-&gt;hash_tapeset, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; perhash-&gt;aggnode-&gt;numGroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggstate-&gt;hashentrysize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2925" title="executor/nodeAgg.c:2925">hashagg_spill_tuple</a>(aggstate, spill, slot, <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pergroup[setno] = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2158" title="executor/nodeAgg.c:2158">ExecAgg</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="#L2158" title="executor/nodeAgg.c:2158">ExecAgg</a> receives tuples from its outer subplan and aggregates over<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the appropriate attribute for each aggregate function use (Aggref<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; node) appearing in the targetlist or qual of the node.&nbsp; The number<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; of tuples to aggregate over depends on whether grouped or plain<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; aggregation is selected.&nbsp; In grouped aggregation, we produce a result<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; row for each group; in plain aggregation there's a single result row<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; for the whole query.&nbsp; In either case, the value of each aggregate is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; stored in the expression context to be used when ExecProject evaluates<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the result tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TupleTableSlot *<br/></li>
<li><a id="L2158">&#x200c;</a><span class="linkable">ExecAgg</span>(PlanState *pstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AggState&nbsp;&nbsp; *node = castNode(AggState, pstate);<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *result = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!node-&gt;agg_done)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Dispatch based on strategy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (node-&gt;phase-&gt;aggstrategy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AGG_HASHED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!node-&gt;table_filled)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2540" title="executor/nodeAgg.c:2540">agg_fill_hash_table</a>(node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALLTHROUGH */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AGG_MIXED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2746" title="executor/nodeAgg.c:2746">agg_retrieve_hash_table</a>(node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AGG_PLAIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AGG_SORTED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2194" title="executor/nodeAgg.c:2194">agg_retrieve_direct</a>(node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TupIsNull(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2158" title="executor/nodeAgg.c:2158">ExecAgg</a> for non-hashed case<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TupleTableSlot *<br/></li>
<li><a id="L2194">&#x200c;</a><span class="linkable">agg_retrieve_direct</span>(AggState *aggstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Agg&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *node = aggstate-&gt;phase-&gt;aggnode;<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li>&nbsp; &nbsp; ExprContext *tmpcontext;<br/></li>
<li>&nbsp; &nbsp; AggStatePerAgg peragg;<br/></li>
<li>&nbsp; &nbsp; AggStatePerGroup *pergroups;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *outerslot;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *firstSlot;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasGroupingSets = aggstate-&gt;phase-&gt;numsets &gt; <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numGroupingSets = Max(aggstate-&gt;phase-&gt;numsets, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currentSet;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextSetSize;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numReset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get state info from node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * econtext is the per-output-tuple expression context<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tmpcontext is the per-input-tuple expression context<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; econtext = aggstate-&gt;ss.ps.ps_ExprContext;<br/></li>
<li>&nbsp; &nbsp; tmpcontext = aggstate-&gt;tmpcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; peragg = aggstate-&gt;peragg;<br/></li>
<li>&nbsp; &nbsp; pergroups = aggstate-&gt;pergroups;<br/></li>
<li>&nbsp; &nbsp; firstSlot = aggstate-&gt;ss.ss_ScanTupleSlot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We loop retrieving groups until we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one matching<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggstate-&gt;ss.ps.qual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For grouping sets, we have the invariant that aggstate-&gt;projected_set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is either -1 (initial call) or the index (starting from 0) in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * gset_lengths for the group we just completed (either by projecting a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * row or by discarding it in the qual).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (!aggstate-&gt;agg_done)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Clear the per-output-tuple context for each group, as well as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aggcontext (which contains <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pass-by-ref transvalues of the old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * group).&nbsp; Some aggregate <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> store working state in child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contexts; those <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> get reset automatically without us needing to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do anything special.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We use <a href="execUtils.c.html#L441" title="executor/execUtils.c:441">ReScanExprContext</a> not just ResetExprContext because we want<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> registered shutdown callbacks to be called.&nbsp; That allows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aggregate <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to ensure they've cleaned up <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * resources.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execUtils.c.html#L441" title="executor/execUtils.c:441">ReScanExprContext</a>(econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine how many grouping sets need to be reset at this boundary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;projected_set &gt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;projected_set &lt; numGroupingSets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numReset = aggstate-&gt;projected_set + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numReset = numGroupingSets;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * numReset can change on a phase boundary, but that's OK; we want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reset the contexts used in _this_ phase, and later, after possibly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changing phase, <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the right number of aggregates for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * _new_ phase.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numReset; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execUtils.c.html#L441" title="executor/execUtils.c:441">ReScanExprContext</a>(aggstate-&gt;aggcontexts[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if input is complete and there are no more groups to project<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in this phase; move to <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> phase or mark as done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;input_done == <span class="Constant">true</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;projected_set &gt;= (numGroupingSets - <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;current_phase &lt; aggstate-&gt;numphases - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L477" title="executor/nodeAgg.c:477">initialize_phase</a>(aggstate, aggstate-&gt;current_phase + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;input_done = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;projected_set = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numGroupingSets = Max(aggstate-&gt;phase-&gt;numsets, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node = aggstate-&gt;phase-&gt;aggnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numReset = numGroupingSets;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (aggstate-&gt;aggstrategy == AGG_MIXED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Mixed mode; we've output all the grouped stuff and have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * full hashtables, so switch to outputting those.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L477" title="executor/nodeAgg.c:477">initialize_phase</a>(aggstate, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;table_filled = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResetTupleHashIterator(aggstate-&gt;perhash[<span class="Constant">0</span>].hashtable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;aggstate-&gt;perhash[<span class="Constant">0</span>].hashiter);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L455" title="executor/nodeAgg.c:455">select_current_set</a>(aggstate, <span class="Constant">0</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2746" title="executor/nodeAgg.c:2746">agg_retrieve_hash_table</a>(aggstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;agg_done = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get the number of columns in the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> grouping set after the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * projected one (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>). This is the number of columns to <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * see if we reached the boundary of that set too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;projected_set &gt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;projected_set &lt; (numGroupingSets - <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextSetSize = aggstate-&gt;phase-&gt;gset_lengths[aggstate-&gt;projected_set + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextSetSize = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If a subgroup for the current grouping set is present, project it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have a new group if:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; - we're out of input but haven't projected all grouping sets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; (checked above)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OR<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; - we already projected a row that wasn't from the last grouping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; AND<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; - the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> grouping set has at least one grouping column (since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; empty grouping sets project only once input is exhausted)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; AND<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; - the previous and pending rows differ on the grouping columns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; of the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> grouping set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tmpcontext-&gt;ecxt_innertuple = econtext-&gt;ecxt_outertuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;input_done ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (node-&gt;aggstrategy != AGG_PLAIN &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggstate-&gt;projected_set != -<span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggstate-&gt;projected_set &lt; (numGroupingSets - <span class="Constant">1</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nextSetSize &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !ExecQualAndReset(aggstate-&gt;phase-&gt;eqfunctions[nextSetSize - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tmpcontext)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;projected_set += <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(aggstate-&gt;projected_set &lt; numGroupingSets);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(nextSetSize &gt; <span class="Constant">0</span> || aggstate-&gt;input_done);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We no longer care what group we just projected, the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * projection will always be the first (or only) grouping set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (unless the input proves to be empty).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;projected_set = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we don't already have the first tuple of the new group,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fetch it from the outer plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;grp_firstTuple == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outerslot = <a href="#L547" title="executor/nodeAgg.c:547">fetch_input_tuple</a>(aggstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TupIsNull(outerslot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make a copy of the first input tuple; we will use this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for comparisons (in group mode) and for projection.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;grp_firstTuple = ExecCopySlotHeapTuple(outerslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* outer plan produced no tuples at all */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hasGroupingSets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there was no input at all, we need to project<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rows only if there are grouping sets of size 0.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that this implies that there can't be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * references to ungrouped Vars, which would otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cause issues with the empty output slot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: This is no longer true, we currently deal with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this in <a href="#L1294" title="executor/nodeAgg.c:1294">finalize_aggregates</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;input_done = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (aggstate-&gt;phase-&gt;gset_lengths[aggstate-&gt;projected_set] &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;projected_set += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;projected_set &gt;= numGroupingSets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't set agg_done here because we might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have more phases to do, even though the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * input is empty. So we need to restart the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whole outer loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;projected_set &gt;= numGroupingSets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;agg_done = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we are grouping, we should produce no tuples too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;aggstrategy != AGG_PLAIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Initialize working state for a new input tuple group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L665" title="executor/nodeAgg.c:665">initialize_aggregates</a>(aggstate, pergroups, numReset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;grp_firstTuple != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Store the copied first input tuple in the tuple table slot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reserved for it.&nbsp; The tuple will be deleted when it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cleared from the slot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L1556" title="executor/execTuples.c:1556">ExecForceStoreHeapTuple</a>(aggstate-&gt;grp_firstTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstSlot, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;grp_firstTuple = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* don't keep two pointers */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set up for first <a href="#L816" title="executor/nodeAgg.c:816">advance_aggregates</a> call */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmpcontext-&gt;ecxt_outertuple = firstSlot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Process each outer-plan tuple, and then fetch the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * until we exhaust the outer plan or cross a group boundary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * During phase 1 only of a mixed agg, we need to update<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hashtables as well in <a href="#L816" title="executor/nodeAgg.c:816">advance_aggregates</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;aggstrategy == AGG_MIXED &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;current_phase == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2095" title="executor/nodeAgg.c:2095">lookup_hash_entries</a>(aggstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance the aggregates (or <a href="../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L816" title="executor/nodeAgg.c:816">advance_aggregates</a>(aggstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset per-input-tuple context after each tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResetExprContext(tmpcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outerslot = <a href="#L547" title="executor/nodeAgg.c:547">fetch_input_tuple</a>(aggstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TupIsNull(outerslot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no more outer-plan tuples available */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if we built <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables, finalize <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> spills */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;aggstrategy == AGG_MIXED &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;current_phase == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3059" title="executor/nodeAgg.c:3059">hashagg_finish_initial_spills</a>(aggstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hasGroupingSets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;input_done = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;agg_done = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set up for <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="#L816" title="executor/nodeAgg.c:816">advance_aggregates</a> call */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmpcontext-&gt;ecxt_outertuple = outerslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are grouping, check whether we've crossed a group<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * boundary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;aggstrategy != AGG_PLAIN &amp;&amp; node-&gt;numCols &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmpcontext-&gt;ecxt_innertuple = firstSlot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ExecQual(aggstate-&gt;phase-&gt;eqfunctions[node-&gt;numCols - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmpcontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;grp_firstTuple = ExecCopySlotHeapTuple(outerslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use the representative input tuple for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> references to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-aggregated input columns in aggregate direct args, the node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * qual, and the tlist.&nbsp; (If we are not grouping, and there are no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * input rows at all, we will come here with an empty firstSlot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ... but if not grouping, there can't be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> references to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-aggregated input columns, so no problem.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_outertuple = firstSlot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(aggstate-&gt;projected_set &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; currentSet = aggstate-&gt;projected_set;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1249" title="executor/nodeAgg.c:1249">prepare_projection_slot</a>(aggstate, econtext-&gt;ecxt_outertuple, currentSet);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L455" title="executor/nodeAgg.c:455">select_current_set</a>(aggstate, currentSet, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1294" title="executor/nodeAgg.c:1294">finalize_aggregates</a>(aggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peragg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pergroups[currentSet]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there's no row to project right <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we must continue rather<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than returning a null since there might be more groups.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1371" title="executor/nodeAgg.c:1371">project_aggregates</a>(aggstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No more groups */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2158" title="executor/nodeAgg.c:2158">ExecAgg</a> for hashed case: read input and build <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2540">&#x200c;</a></span><span class="linkable">agg_fill_hash_table</span>(AggState *aggstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *outerslot;<br/></li>
<li>&nbsp; &nbsp; ExprContext *tmpcontext = aggstate-&gt;tmpcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Process each outer-plan tuple, and then fetch the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one, until we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exhaust the outer plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outerslot = <a href="#L547" title="executor/nodeAgg.c:547">fetch_input_tuple</a>(aggstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TupIsNull(outerslot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set up for <a href="#L2095" title="executor/nodeAgg.c:2095">lookup_hash_entries</a> and <a href="#L816" title="executor/nodeAgg.c:816">advance_aggregates</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tmpcontext-&gt;ecxt_outertuple = outerslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find or build hashtable entries */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2095" title="executor/nodeAgg.c:2095">lookup_hash_entries</a>(aggstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance the aggregates (or <a href="../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L816" title="executor/nodeAgg.c:816">advance_aggregates</a>(aggstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset per-input-tuple context after each tuple, but note that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> lookups do this too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ResetExprContext(aggstate-&gt;tmpcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* finalize spills, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3059" title="executor/nodeAgg.c:3059">hashagg_finish_initial_spills</a>(aggstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;table_filled = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize to walk the first <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L455" title="executor/nodeAgg.c:455">select_current_set</a>(aggstate, <span class="Constant">0</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; ResetTupleHashIterator(aggstate-&gt;perhash[<span class="Constant">0</span>].hashtable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;aggstate-&gt;perhash[<span class="Constant">0</span>].hashiter);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data was spilled during <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> aggregation, reset the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table and<br/></li>
<li></span><span class="Comment"> * reprocess one batch of spilled data. After reprocessing a batch, the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment"> * table will again contain data, ready to be consumed by<br/></li>
<li></span><span class="Comment"> * <a href="#L2771" title="executor/nodeAgg.c:2771">agg_retrieve_hash_table_in_memory</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Should only be called after all in memory <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table entries have been<br/></li>
<li></span><span class="Comment"> * finalized and emitted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return false when input is exhausted and there's no more work to be done;<br/></li>
<li></span><span class="Comment"> * otherwise return true.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2594">&#x200c;</a></span><span class="linkable">agg_refill_hash_table</span>(AggState *aggstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L350" title="executor/nodeAgg.c:350">HashAggBatch</a> *batch;<br/></li>
<li>&nbsp; &nbsp; AggStatePerHash perhash;<br/></li>
<li>&nbsp; &nbsp; <a href="#L331" title="executor/nodeAgg.c:331">HashAggSpill</a> spill;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/sort/logtape.c.html#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *tapeset = aggstate-&gt;hash_tapeset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; spill_initialized = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;hash_batches == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* hash_batches is a stack, with the top item at the end of the list */<br/></li>
<li></span>&nbsp; &nbsp; batch = llast(aggstate-&gt;hash_batches);<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;hash_batches = <a href="../nodes/list.c.html#L957" title="nodes/list.c:957">list_delete_last</a>(aggstate-&gt;hash_batches);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1798" title="executor/nodeAgg.c:1798">hash_agg_set_limits</a>(aggstate-&gt;hashentrysize, batch-&gt;input_card,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; batch-&gt;used_bits, &amp;aggstate-&gt;hash_mem_limit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;aggstate-&gt;hash_ngroups_limit, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Each batch only processes one grouping set; set the rest to NULL so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that <a href="#L816" title="executor/nodeAgg.c:816">advance_aggregates</a>() knows to ignore them. We don't touch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pergroups for sorted grouping sets here, because they will be needed if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we rescan later. The expressions for sorted grouping sets will not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * evaluated after we recompile anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(aggstate-&gt;hash_pergroup, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AggStatePerGroup) * aggstate-&gt;num_hashes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* free memory and reset <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execUtils.c.html#L441" title="executor/execUtils.c:441">ReScanExprContext</a>(aggstate-&gt;hashcontext);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> setno = <span class="Constant">0</span>; setno &lt; aggstate-&gt;num_hashes; setno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execGrouping.c.html#L284" title="executor/execGrouping.c:284">ResetTupleHashTable</a>(aggstate-&gt;perhash[setno].hashtable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;hash_ngroups_current = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In AGG_MIXED mode, <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> aggregation happens in phase 1 and the output<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happens in phase 0. So, we switch to phase 1 when processing a batch,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and back to phase 0 after the batch is done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(aggstate-&gt;current_phase == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;phase-&gt;aggstrategy == AGG_MIXED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;current_phase = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;phase = &amp;aggstate-&gt;phases[aggstate-&gt;current_phase];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L455" title="executor/nodeAgg.c:455">select_current_set</a>(aggstate, batch-&gt;setno, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; perhash = &amp;aggstate-&gt;perhash[aggstate-&gt;current_set];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Spilled tuples are always read back as MinimalTuples, which may be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * different from the outer plan, so recompile the aggregate expressions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We still need the NULL check, because we are only processing one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * grouping set at a time and the rest will be NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1741" title="executor/nodeAgg.c:1741">hashagg_recompile_expressions</a>(aggstate, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *spillslot = aggstate-&gt;hash_spill_rslot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *hashslot = perhash-&gt;hashslot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleHashEntry entry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MinimalTuple tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnew = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *p_isnew = aggstate-&gt;hash_spill_mode ? <span class="Constant">NULL</span> : &amp;isnew;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="#L3010" title="executor/nodeAgg.c:3010">hashagg_batch_read</a>(batch, &amp;<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tuple == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L1533" title="executor/execTuples.c:1533">ExecStoreMinimalTuple</a>(tuple, spillslot, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;tmpcontext-&gt;ecxt_outertuple = spillslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1204" title="executor/nodeAgg.c:1204">prepare_hash_slot</a>(perhash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;tmpcontext-&gt;ecxt_outertuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry = <a href="execGrouping.c.html#L360" title="executor/execGrouping.c:360">LookupTupleHashEntryHash</a>(perhash-&gt;hashtable, hashslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; p_isnew, <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnew)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2045" title="executor/nodeAgg.c:2045">initialize_hash_entry</a>(aggstate, perhash-&gt;hashtable, entry);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;hash_pergroup[batch-&gt;setno] = entry-&gt;additional;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L816" title="executor/nodeAgg.c:816">advance_aggregates</a>(aggstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!spill_initialized)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Avoid initializing the spill until we actually need it so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that we don't assign tapes that will never be used.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spill_initialized = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2894" title="executor/nodeAgg.c:2894">hashagg_spill_init</a>(&amp;spill, tapeset, batch-&gt;used_bits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; batch-&gt;input_card, aggstate-&gt;hashentrysize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no memory for a new group, spill */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2925" title="executor/nodeAgg.c:2925">hashagg_spill_tuple</a>(aggstate, &amp;spill, spillslot, <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;hash_pergroup[batch-&gt;setno] = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset per-input-tuple context after each tuple, but note that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> lookups do this too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ResetExprContext(aggstate-&gt;tmpcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/sort/logtape.c.html#L733" title="utils/sort/logtape.c:733">LogicalTapeClose</a>(batch-&gt;input_tape);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* change back to phase 0 */<br/></li>
<li></span>&nbsp; &nbsp; aggstate-&gt;current_phase = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;phase = &amp;aggstate-&gt;phases[aggstate-&gt;current_phase];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (spill_initialized)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3093" title="executor/nodeAgg.c:3093">hashagg_spill_finish</a>(aggstate, &amp;spill, batch-&gt;setno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1917" title="executor/nodeAgg.c:1917">hash_agg_update_metrics</a>(aggstate, <span class="Constant">true</span>, spill.npartitions);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1917" title="executor/nodeAgg.c:1917">hash_agg_update_metrics</a>(aggstate, <span class="Constant">true</span>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;hash_spill_mode = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prepare to walk the first <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L455" title="executor/nodeAgg.c:455">select_current_set</a>(aggstate, batch-&gt;setno, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; ResetTupleHashIterator(aggstate-&gt;perhash[batch-&gt;setno].hashtable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;aggstate-&gt;perhash[batch-&gt;setno].hashiter);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(batch);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2158" title="executor/nodeAgg.c:2158">ExecAgg</a> for hashed case: retrieving groups from <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * After exhausting in-memory tuples, also try refilling the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table using<br/></li>
<li></span><span class="Comment"> * previously-spilled tuples. Only returns NULL after all in-memory and<br/></li>
<li></span><span class="Comment"> * spilled tuples are exhausted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TupleTableSlot *<br/></li>
<li><a id="L2746">&#x200c;</a><span class="linkable">agg_retrieve_hash_table</span>(AggState *aggstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *result = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (result == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2771" title="executor/nodeAgg.c:2771">agg_retrieve_hash_table_in_memory</a>(aggstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2594" title="executor/nodeAgg.c:2594">agg_refill_hash_table</a>(aggstate))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;agg_done = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Retrieve the groups from the in-memory <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables without considering <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * spilled tuples.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TupleTableSlot *<br/></li>
<li><a id="L2771">&#x200c;</a><span class="linkable">agg_retrieve_hash_table_in_memory</span>(AggState *aggstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li>&nbsp; &nbsp; AggStatePerAgg peragg;<br/></li>
<li>&nbsp; &nbsp; AggStatePerGroup pergroup;<br/></li>
<li>&nbsp; &nbsp; TupleHashEntryData *entry;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *firstSlot;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *result;<br/></li>
<li>&nbsp; &nbsp; AggStatePerHash perhash;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get state info from node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * econtext is the per-output-tuple expression context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; econtext = aggstate-&gt;ss.ps.ps_ExprContext;<br/></li>
<li>&nbsp; &nbsp; peragg = aggstate-&gt;peragg;<br/></li>
<li>&nbsp; &nbsp; firstSlot = aggstate-&gt;ss.ss_ScanTupleSlot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that perhash (and therefore anything accessed through it) can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * change inside the loop, as we change between grouping sets.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; perhash = &amp;aggstate-&gt;perhash[aggstate-&gt;current_set];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We loop retrieving groups until we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one satisfying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggstate-&gt;ss.ps.qual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *hashslot = perhash-&gt;hashslot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> entry in the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; entry = ScanTupleHashTable(perhash-&gt;hashtable, &amp;perhash-&gt;hashiter);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextset = aggstate-&gt;current_set + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nextset &lt; aggstate-&gt;num_hashes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Switch to <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> grouping set, reinitialize, and restart the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L455" title="executor/nodeAgg.c:455">select_current_set</a>(aggstate, nextset, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perhash = &amp;aggstate-&gt;perhash[aggstate-&gt;current_set];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResetTupleHashIterator(perhash-&gt;hashtable, &amp;perhash-&gt;hashiter);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Clear the per-output-tuple context for each group<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We intentionally don't use <a href="execUtils.c.html#L441" title="executor/execUtils.c:441">ReScanExprContext</a> here; if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> aggs have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * registered shutdown callbacks, they mustn't be called yet, since we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might not be done with that agg.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ResetExprContext(econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Transform representative tuple back into one with the right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L1533" title="executor/execTuples.c:1533">ExecStoreMinimalTuple</a>(entry-&gt;firstTuple, hashslot, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot_getallattrs(hashslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(firstSlot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(firstSlot-&gt;tts_isnull, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; firstSlot-&gt;tts_tupleDescriptor-&gt;natts * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; perhash-&gt;numhashGrpCols; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varNumber = perhash-&gt;hashGrpColIdxInput[i] - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstSlot-&gt;tts_values[varNumber] = hashslot-&gt;tts_values[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstSlot-&gt;tts_isnull[varNumber] = hashslot-&gt;tts_isnull[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a>(firstSlot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pergroup = (AggStatePerGroup) entry-&gt;additional;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use the representative input tuple for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> references to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-aggregated input columns in the qual and tlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_outertuple = firstSlot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1249" title="executor/nodeAgg.c:1249">prepare_projection_slot</a>(aggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_outertuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;current_set);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1294" title="executor/nodeAgg.c:1294">finalize_aggregates</a>(aggstate, peragg, pergroup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1371" title="executor/nodeAgg.c:1371">project_aggregates</a>(aggstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No more groups */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2894" title="executor/nodeAgg.c:2894">hashagg_spill_init</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Called after we determined that spilling is necessary. Chooses the number<br/></li>
<li></span><span class="Comment"> * of partitions to create, and initializes them.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2894">&#x200c;</a></span><span class="linkable">hashagg_spill_init</span>(<a href="#L331" title="executor/nodeAgg.c:331">HashAggSpill</a> *spill, <a href="../utils/sort/logtape.c.html#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *tapeset, <span class="Type">int</span> used_bits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> input_groups, <span class="Type">double</span> hashentrysize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npartitions;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partition_bits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; npartitions = <a href="#L1991" title="executor/nodeAgg.c:1991">hash_choose_num_partitions</a>(input_groups, hashentrysize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; used_bits, &amp;partition_bits);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; spill-&gt;partitions = <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="../utils/sort/logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *) * npartitions);<br/></li>
<li>&nbsp; &nbsp; spill-&gt;ntuples = <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64) * npartitions);<br/></li>
<li>&nbsp; &nbsp; spill-&gt;hll_card = <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(hyperLogLogState) * npartitions);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; npartitions; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; spill-&gt;partitions[i] = <a href="../utils/sort/logtape.c.html#L680" title="utils/sort/logtape.c:680">LogicalTapeCreate</a>(tapeset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; spill-&gt;shift = <span class="Constant">32</span> - used_bits - partition_bits;<br/></li>
<li>&nbsp; &nbsp; spill-&gt;mask = (npartitions - <span class="Constant">1</span>) &lt;&lt; spill-&gt;shift;<br/></li>
<li>&nbsp; &nbsp; spill-&gt;npartitions = npartitions;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; npartitions; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lib/hyperloglog.c.html#L66" title="lib/hyperloglog.c:66">initHyperLogLog</a>(&amp;spill-&gt;hll_card[i], <a href="#L314" title="executor/nodeAgg.c:314">HASHAGG_HLL_BIT_WIDTH</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2925" title="executor/nodeAgg.c:2925">hashagg_spill_tuple</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * No room for new groups in the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table. Save for later in the appropriate<br/></li>
<li></span><span class="Comment"> * partition.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Size<br/></li>
<li><a id="L2925">&#x200c;</a><span class="linkable">hashagg_spill_tuple</span>(AggState *aggstate, <a href="#L331" title="executor/nodeAgg.c:331">HashAggSpill</a> *spill,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *inputslot, uint32 <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *spillslot;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partition;<br/></li>
<li>&nbsp; &nbsp; MinimalTuple tuple;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/sort/logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_written = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; shouldFree;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(spill-&gt;partitions != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* spill only attributes that we actually need */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!aggstate-&gt;all_cols_needed)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; spillslot = aggstate-&gt;hash_spill_wslot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot_getsomeattrs(inputslot, aggstate-&gt;max_colno_needed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(spillslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; spillslot-&gt;tts_tupleDescriptor-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(i + <span class="Constant">1</span>, aggstate-&gt;colnos_needed))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spillslot-&gt;tts_values[i] = inputslot-&gt;tts_values[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spillslot-&gt;tts_isnull[i] = inputslot-&gt;tts_isnull[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spillslot-&gt;tts_isnull[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a>(spillslot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; spillslot = inputslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="execTuples.c.html#L1779" title="executor/execTuples.c:1779">ExecFetchSlotMinimalTuple</a>(spillslot, &amp;shouldFree);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; partition = (<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> &amp; spill-&gt;mask) &gt;&gt; spill-&gt;shift;<br/></li>
<li>&nbsp; &nbsp; spill-&gt;ntuples[partition]++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> destined for a given partition have some bits in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * common, which causes bad HLL cardinality estimates. Hash the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get a more uniform distribution.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../lib/hyperloglog.c.html#L167" title="lib/hyperloglog.c:167">addHyperLogLog</a>(&amp;spill-&gt;hll_card[partition], hash_bytes_uint32(<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tape = spill-&gt;partitions[partition];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/sort/logtape.c.html#L761" title="utils/sort/logtape.c:761">LogicalTapeWrite</a>(tape, &amp;<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; total_written += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/sort/logtape.c.html#L761" title="utils/sort/logtape.c:761">LogicalTapeWrite</a>(tape, tuple, tuple-&gt;t_len);<br/></li>
<li>&nbsp; &nbsp; total_written += tuple-&gt;t_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (shouldFree)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> total_written;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2991" title="executor/nodeAgg.c:2991">hashagg_batch_new</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Construct a <a href="#L350" title="executor/nodeAgg.c:350">HashAggBatch</a> item, which represents one iteration of HashAgg to<br/></li>
<li></span><span class="Comment"> * be done.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L350" title="executor/nodeAgg.c:350">HashAggBatch</a> *<br/></li>
<li><a id="L2991">&#x200c;</a><span class="linkable">hashagg_batch_new</span>(<a href="../utils/sort/logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *input_tape, <span class="Type">int</span> setno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64 input_tuples, <span class="Type">double</span> input_card, <span class="Type">int</span> used_bits)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L350" title="executor/nodeAgg.c:350">HashAggBatch</a> *batch = <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L350" title="executor/nodeAgg.c:350">HashAggBatch</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; batch-&gt;setno = setno;<br/></li>
<li>&nbsp; &nbsp; batch-&gt;used_bits = used_bits;<br/></li>
<li>&nbsp; &nbsp; batch-&gt;input_tape = input_tape;<br/></li>
<li>&nbsp; &nbsp; batch-&gt;input_tuples = input_tuples;<br/></li>
<li>&nbsp; &nbsp; batch-&gt;input_card = input_card;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> batch;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3010" title="executor/nodeAgg.c:3010">hashagg_batch_read</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; read the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple from a batch's tape.&nbsp; Return NULL if no more.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> MinimalTuple<br/></li>
<li><a id="L3010">&#x200c;</a><span class="linkable">hashagg_batch_read</span>(<a href="#L350" title="executor/nodeAgg.c:350">HashAggBatch</a> *batch, uint32 *hashp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/sort/logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape = batch-&gt;input_tape;<br/></li>
<li>&nbsp; &nbsp; MinimalTuple tuple;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; t_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; nread;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nread = <a href="../utils/sort/logtape.c.html#L928" title="utils/sort/logtape.c:928">LogicalTapeRead</a>(tape, &amp;<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nread == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nread != <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;unexpected EOF for tape </span><span class="Special">%p</span><span class="Constant">: requested </span><span class="Special">%zu</span><span class="Constant"> bytes, read </span><span class="Special">%zu</span><span class="Constant"> bytes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tape, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32), nread)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hashp != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *hashp = <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nread = <a href="../utils/sort/logtape.c.html#L928" title="utils/sort/logtape.c:928">LogicalTapeRead</a>(tape, &amp;t_len, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(t_len));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nread != <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;unexpected EOF for tape </span><span class="Special">%p</span><span class="Constant">: requested </span><span class="Special">%zu</span><span class="Constant"> bytes, read </span><span class="Special">%zu</span><span class="Constant"> bytes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tape, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32), nread)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = (MinimalTuple) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(t_len);<br/></li>
<li>&nbsp; &nbsp; tuple-&gt;t_len = t_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nread = <a href="../utils/sort/logtape.c.html#L928" title="utils/sort/logtape.c:928">LogicalTapeRead</a>(tape,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">char</span> *) tuple + <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t_len - <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nread != t_len - <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;unexpected EOF for tape </span><span class="Special">%p</span><span class="Constant">: requested </span><span class="Special">%zu</span><span class="Constant"> bytes, read </span><span class="Special">%zu</span><span class="Constant"> bytes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tape, t_len - <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32), nread)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3059" title="executor/nodeAgg.c:3059">hashagg_finish_initial_spills</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * After a <a href="#L350" title="executor/nodeAgg.c:350">HashAggBatch</a> has been processed, it may have spilled tuples to<br/></li>
<li></span><span class="Comment"> * disk. If so, turn the spilled partitions into new batches that must later<br/></li>
<li></span><span class="Comment"> * be executed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3059">&#x200c;</a></span><span class="linkable">hashagg_finish_initial_spills</span>(AggState *aggstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_npartitions = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;hash_spills != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (setno = <span class="Constant">0</span>; setno &lt; aggstate-&gt;num_hashes; setno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="executor/nodeAgg.c:331">HashAggSpill</a> *spill = &amp;aggstate-&gt;hash_spills[setno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_npartitions += spill-&gt;npartitions;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3093" title="executor/nodeAgg.c:3093">hashagg_spill_finish</a>(aggstate, spill, setno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're not processing tuples from outer plan <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more; only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * processing batches of spilled tuples. The initial spill structures<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are no longer needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(aggstate-&gt;hash_spills);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;hash_spills = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1917" title="executor/nodeAgg.c:1917">hash_agg_update_metrics</a>(aggstate, <span class="Constant">false</span>, total_npartitions);<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;hash_spill_mode = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3093" title="executor/nodeAgg.c:3093">hashagg_spill_finish</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Transform spill partitions into new batches.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3093">&#x200c;</a></span><span class="linkable">hashagg_spill_finish</span>(AggState *aggstate, <a href="#L331" title="executor/nodeAgg.c:331">HashAggSpill</a> *spill, <span class="Type">int</span> setno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; used_bits = <span class="Constant">32</span> - spill-&gt;shift;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (spill-&gt;npartitions == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* didn't spill */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; spill-&gt;npartitions; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape = spill-&gt;partitions[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L350" title="executor/nodeAgg.c:350">HashAggBatch</a> *new_batch;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; cardinality;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if the partition is empty, don't create a new batch of work */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (spill-&gt;ntuples[i] == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cardinality = <a href="../lib/hyperloglog.c.html#L186" title="lib/hyperloglog.c:186">estimateHyperLogLog</a>(&amp;spill-&gt;hll_card[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../lib/hyperloglog.c.html#L151" title="lib/hyperloglog.c:151">freeHyperLogLog</a>(&amp;spill-&gt;hll_card[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rewinding frees the buffer while not in use */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/logtape.c.html#L846" title="utils/sort/logtape.c:846">LogicalTapeRewindForRead</a>(tape, <a href="#L305" title="executor/nodeAgg.c:305">HASHAGG_READ_BUFFER_SIZE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_batch = <a href="#L2991" title="executor/nodeAgg.c:2991">hashagg_batch_new</a>(tape, setno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spill-&gt;ntuples[i], cardinality,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; used_bits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;hash_batches = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(aggstate-&gt;hash_batches, new_batch);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;hash_batches_used++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(spill-&gt;ntuples);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(spill-&gt;hll_card);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(spill-&gt;partitions);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free resources related to a spilled HashAgg.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3133">&#x200c;</a></span><span class="linkable">hashagg_reset_spill_state</span>(AggState *aggstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* free spills from initial pass */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;hash_spills != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (setno = <span class="Constant">0</span>; setno &lt; aggstate-&gt;num_hashes; setno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="executor/nodeAgg.c:331">HashAggSpill</a> *spill = &amp;aggstate-&gt;hash_spills[setno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(spill-&gt;ntuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(spill-&gt;partitions);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(aggstate-&gt;hash_spills);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;hash_spills = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* free batches */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../nodes/list.c.html#L1560" title="nodes/list.c:1560">list_free_deep</a>(aggstate-&gt;hash_batches);<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;hash_batches = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* close tape set */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;hash_tapeset != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/logtape.c.html#L667" title="utils/sort/logtape.c:667">LogicalTapeSetClose</a>(aggstate-&gt;hash_tapeset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;hash_tapeset = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* -----------------<br/></li>
<li></span><span class="Comment"> * <a href="#L3173" title="executor/nodeAgg.c:3173">ExecInitAgg</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Creates the run-time information for the agg node produced by the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> and initializes its outer subtree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * -----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>AggState *<br/></li>
<li><a id="L3173">&#x200c;</a><span class="linkable">ExecInitAgg</span>(Agg *node, EState *estate, <span class="Type">int</span> eflags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AggState&nbsp;&nbsp; *aggstate;<br/></li>
<li>&nbsp; &nbsp; AggStatePerAgg peraggs;<br/></li>
<li>&nbsp; &nbsp; AggStatePerTrans pertransstates;<br/></li>
<li>&nbsp; &nbsp; AggStatePerGroup *pergroups;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *outerPlan;<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; scanDesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_aggno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_transno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numaggrefs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numaggs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numtrans;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phase;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phaseidx;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *all_grouped_cols = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numGroupingSets = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numPhases;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numHashes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; use_hashing = (node-&gt;aggstrategy == AGG_HASHED ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;aggstrategy == AGG_MIXED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for unsupported flags */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!(eflags &amp; (EXEC_FLAG_BACKWARD | EXEC_FLAG_MARK)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create state structure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; aggstate = makeNode(AggState);<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;ss.ps.plan = (Plan *) node;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;ss.ps.state = estate;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;ss.ps.ExecProcNode = <a href="#L2158" title="executor/nodeAgg.c:2158">ExecAgg</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;aggs = NIL;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;numaggs = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;numtrans = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;aggstrategy = node-&gt;aggstrategy;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;aggsplit = node-&gt;aggsplit;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;maxsets = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;projected_set = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;current_set = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;peragg = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;pertrans = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;curperagg = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;curpertrans = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;input_done = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;agg_done = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;pergroups = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;grp_firstTuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;sort_in = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;sort_out = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * phases[0] always exists, but is dummy in sorted/plain mode<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; numPhases = (use_hashing ? <span class="Constant">1</span> : <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; numHashes = (use_hashing ? <span class="Constant">1</span> : <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate the maximum number of grouping sets in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> phase; this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * determines the size of some allocations.&nbsp; Also calculate the number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * phases, since all hashed/mixed nodes contribute to only a single phase.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;groupingSets)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numGroupingSets = list_length(node-&gt;groupingSets);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, node-&gt;chain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Agg&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *agg = lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numGroupingSets = Max(numGroupingSets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(agg-&gt;groupingSets));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * additional AGG_HASHED aggs become part of phase 0, but all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * others add an extra phase.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (agg-&gt;aggstrategy != AGG_HASHED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++numPhases;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++numHashes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;maxsets = numGroupingSets;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;numphases = numPhases;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;aggcontexts = (ExprContext **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ExprContext *) * numGroupingSets);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create expression contexts.&nbsp; We need three or more, one for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * per-input-tuple processing, one for per-output-tuple processing, one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for all the hashtables, and one for each grouping set.&nbsp; The per-tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory context of the per-grouping-set ExprContexts (aggcontexts)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replaces the standalone memory context formerly used to hold transition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; We cheat a little by using <a href="execUtils.c.html#L483" title="executor/execUtils.c:483">ExecAssignExprContext</a>() to build<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all of them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: the details of what is stored in aggcontexts and what is stored<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the regular per-query memory context are driven by a simple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decision: we want to reset the aggcontext at group boundaries (if not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hashing) and in <a href="#L4364" title="executor/nodeAgg.c:4364">ExecReScanAgg</a> to recover no-longer-wanted space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execUtils.c.html#L483" title="executor/execUtils.c:483">ExecAssignExprContext</a>(estate, &amp;aggstate-&gt;ss.ps);<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;tmpcontext = aggstate-&gt;ss.ps.ps_ExprContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numGroupingSets; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execUtils.c.html#L483" title="executor/execUtils.c:483">ExecAssignExprContext</a>(estate, &amp;aggstate-&gt;ss.ps);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;aggcontexts[i] = aggstate-&gt;ss.ps.ps_ExprContext;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (use_hashing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;hashcontext = <a href="execUtils.c.html#L319" title="executor/execUtils.c:319">CreateWorkExprContext</a>(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="execUtils.c.html#L483" title="executor/execUtils.c:483">ExecAssignExprContext</a>(estate, &amp;aggstate-&gt;ss.ps);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize child nodes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are doing a hashed aggregation then the child plan does not need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to handle REWIND efficiently; see <a href="#L4364" title="executor/nodeAgg.c:4364">ExecReScanAgg</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;aggstrategy == AGG_HASHED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eflags &amp;= ~EXEC_FLAG_REWIND;<br/></li>
<li>&nbsp; &nbsp; outerPlan = outerPlan(node);<br/></li>
<li>&nbsp; &nbsp; outerPlanState(aggstate) = <a href="execProcnode.c.html#L142" title="executor/execProcnode.c:142">ExecInitNode</a>(outerPlan, estate, eflags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> source tuple type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; aggstate-&gt;ss.ps.outerops =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execUtils.c.html#L502" title="executor/execUtils.c:502">ExecGetResultSlotOps</a>(outerPlanState(&amp;aggstate-&gt;ss),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;aggstate-&gt;ss.ps.outeropsfixed);<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;ss.ps.outeropsset = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="execUtils.c.html#L659" title="executor/execUtils.c:659">ExecCreateScanSlotFromOuterPlan</a>(estate, &amp;aggstate-&gt;ss,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;ss.ps.outerops);<br/></li>
<li>&nbsp; &nbsp; scanDesc = aggstate-&gt;ss.ss_ScanTupleSlot-&gt;tts_tupleDescriptor;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are more than two phases (including a potential dummy phase<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 0), input will be resorted using tuplesort. Need a slot for that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (numPhases &gt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;sort_slot = <a href="execTuples.c.html#L1918" title="executor/execTuples.c:1918">ExecInitExtraTupleSlot</a>(estate, scanDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The output of the tuplesort, and the output from the outer child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might not use the same type of slot. In most cases the child will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be a Sort, and thus return a <a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a> type slot - but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * input can also be presorted due an index, in which case it could be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a different type of slot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: For efficiency it would be good to instead/additionally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * generate expressions with corresponding settings of outerops* for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the individual phases - deforming is often a bottleneck for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aggregations with lots of rows per group. If there's multiple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sorts, we know that all but the first use <a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a> (via<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the nodeAgg.c <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> tuplesort).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;ss.ps.outeropsfixed &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;ss.ps.outerops != &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;ss.ps.outeropsfixed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize result type, slot and projection.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execTuples.c.html#L1886" title="executor/execTuples.c:1886">ExecInitResultTupleSlotTL</a>(&amp;aggstate-&gt;ss.ps, &amp;<a href="execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="execUtils.c.html#L538" title="executor/execUtils.c:538">ExecAssignProjectionInfo</a>(&amp;aggstate-&gt;ss.ps, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> child expressions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We expect the parser to have checked that no aggs contain other agg<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calls in their arguments (and just to be sure, we verify it again while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initializing the plan node).&nbsp; This would make no sense under SQL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * semantics, and it's forbidden by the spec.&nbsp; Because it is true, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't need to worry about evaluating the aggs in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> particular order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: execExpr.c finds Aggrefs for us, and adds them to aggstate-&gt;aggs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Aggrefs in the qual are found here; Aggrefs in the targetlist are found<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during <a href="execUtils.c.html#L538" title="executor/execUtils.c:538">ExecAssignProjectionInfo</a>, above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; aggstate-&gt;ss.ps.qual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execExpr.c.html#L220" title="executor/execExpr.c:220">ExecInitQual</a>(node-&gt;plan.qual, (PlanState *) aggstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We should <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have found all Aggrefs in the targetlist and quals.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; numaggrefs = list_length(aggstate-&gt;aggs);<br/></li>
<li>&nbsp; &nbsp; max_aggno = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; max_transno = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(l, aggstate-&gt;aggs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Aggref&nbsp; &nbsp; &nbsp;&nbsp; *aggref = (Aggref *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; max_aggno = Max(max_aggno, aggref-&gt;aggno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; max_transno = Max(max_transno, aggref-&gt;aggtransno);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; numaggs = max_aggno + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; numtrans = max_transno + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For each phase, prepare grouping set data and fmgr lookup data for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; Accumulate all_grouped_cols in passing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; aggstate-&gt;phases = <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(numPhases * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AggStatePerPhaseData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;num_hashes = numHashes;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numHashes)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;perhash = <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AggStatePerHashData) * numHashes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;phases[<span class="Constant">0</span>].numsets = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;phases[<span class="Constant">0</span>].gset_lengths = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numHashes * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;phases[<span class="Constant">0</span>].grouped_cols = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numHashes * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Bitmapset *));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; phase = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (phaseidx = <span class="Constant">0</span>; phaseidx &lt;= list_length(node-&gt;chain); ++phaseidx)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Agg&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *aggnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Sort&nbsp; &nbsp; &nbsp;&nbsp; *sortnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (phaseidx &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggnode = list_nth_node(Agg, node-&gt;chain, phaseidx - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortnode = castNode(Sort, outerPlan(aggnode));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggnode = node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortnode = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(phase &lt;= <span class="Constant">1</span> || sortnode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggnode-&gt;aggstrategy == AGG_HASHED<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || aggnode-&gt;aggstrategy == AGG_MIXED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerPhase phasedata = &amp;aggstate-&gt;phases[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerHash perhash;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *cols = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(phase == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = phasedata-&gt;numsets++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perhash = &amp;aggstate-&gt;perhash[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* phase 0 always points to the &quot;real&quot; Agg in the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phasedata-&gt;aggnode = node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phasedata-&gt;aggstrategy = node-&gt;aggstrategy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* but the actual Agg node representing this <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> is saved here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perhash-&gt;aggnode = aggnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phasedata-&gt;gset_lengths[i] = perhash-&gt;numCols = aggnode-&gt;numCols;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; aggnode-&gt;numCols; ++j)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cols = <a href="../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(cols, aggnode-&gt;grpColIdx[j]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phasedata-&gt;grouped_cols[i] = cols;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_grouped_cols = <a href="../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(all_grouped_cols, cols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerPhase phasedata = &amp;aggstate-&gt;phases[++phase];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_sets;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phasedata-&gt;numsets = num_sets = list_length(aggnode-&gt;groupingSets);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (num_sets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phasedata-&gt;gset_lengths = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(num_sets * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phasedata-&gt;grouped_cols = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(num_sets * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Bitmapset *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, aggnode-&gt;groupingSets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_length = list_length(lfirst(l));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *cols = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> forces this to be correct */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; current_length; ++j)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cols = <a href="../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(cols, aggnode-&gt;grpColIdx[j]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phasedata-&gt;grouped_cols[i] = cols;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phasedata-&gt;gset_lengths[i] = current_length;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_grouped_cols = <a href="../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(all_grouped_cols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; phasedata-&gt;grouped_cols[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(phaseidx == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phasedata-&gt;gset_lengths = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phasedata-&gt;grouped_cols = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are grouping, precompute fmgr lookup data for inner loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggnode-&gt;aggstrategy == AGG_SORTED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Build a separate function for each <a href="../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of columns that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to be compared.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phasedata-&gt;eqfunctions =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ExprState **) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(aggnode-&gt;numCols * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ExprState *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for each grouping set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> k = <span class="Constant">0</span>; k &lt; phasedata-&gt;numsets; k++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; length = phasedata-&gt;gset_lengths[k];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do for empty grouping set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (length == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if we already had one of this length, it'll do */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (phasedata-&gt;eqfunctions[length - <span class="Constant">1</span>] != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phasedata-&gt;eqfunctions[length - <span class="Constant">1</span>] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execGrouping.c.html#L58" title="executor/execGrouping.c:58">execTuplesMatchPrepare</a>(scanDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggnode-&gt;grpColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggnode-&gt;grpOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggnode-&gt;grpCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (PlanState *) aggstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and for all grouped columns, unless already computed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggnode-&gt;numCols &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phasedata-&gt;eqfunctions[aggnode-&gt;numCols - <span class="Constant">1</span>] == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phasedata-&gt;eqfunctions[aggnode-&gt;numCols - <span class="Constant">1</span>] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execGrouping.c.html#L58" title="executor/execGrouping.c:58">execTuplesMatchPrepare</a>(scanDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggnode-&gt;numCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggnode-&gt;grpColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggnode-&gt;grpOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggnode-&gt;grpCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (PlanState *) aggstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phasedata-&gt;aggnode = aggnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phasedata-&gt;aggstrategy = aggnode-&gt;aggstrategy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phasedata-&gt;sortnode = sortnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Convert all_grouped_cols to a descending-order list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; i = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((i = <a href="../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(all_grouped_cols, i)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;all_grouped_cols = <a href="../nodes/list.c.html#L513" title="nodes/list.c:513">lcons_int</a>(i, aggstate-&gt;all_grouped_cols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up aggregate-result storage in the output expr context, and also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocate my private per-agg working storage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; econtext = aggstate-&gt;ss.ps.ps_ExprContext;<br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_aggvalues = (Datum *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * numaggs);<br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_aggnulls = (<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * numaggs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; peraggs = (AggStatePerAgg) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AggStatePerAggData) * numaggs);<br/></li>
<li>&nbsp; &nbsp; pertransstates = (AggStatePerTrans) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AggStatePerTransData) * numtrans);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;peragg = peraggs;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;pertrans = pertransstates;<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;all_pergroups =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (AggStatePerGroup *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AggStatePerGroup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (numGroupingSets + numHashes));<br/></li>
<li>&nbsp; &nbsp; pergroups = aggstate-&gt;all_pergroups;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;aggstrategy != AGG_HASHED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numGroupingSets; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pergroups[i] = (AggStatePerGroup) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AggStatePerGroupData)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * numaggs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;pergroups = pergroups;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pergroups += numGroupingSets;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Hashing can only appear in the initial phase.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (use_hashing)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *outerplan = outerPlan(node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; totalGroups = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;hash_metacxt = AllocSetContextCreate(aggstate-&gt;ss.ps.state-&gt;es_query_cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;HashAgg meta context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;hash_spill_rslot = <a href="execTuples.c.html#L1918" title="executor/execTuples.c:1918">ExecInitExtraTupleSlot</a>(estate, scanDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;hash_spill_wslot = <a href="execTuples.c.html#L1918" title="executor/execTuples.c:1918">ExecInitExtraTupleSlot</a>(estate, scanDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this is an array of pointers, not structures */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;hash_pergroup = pergroups;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;hashentrysize = <a href="#L1694" title="executor/nodeAgg.c:1694">hash_agg_entry_size</a>(aggstate-&gt;numtrans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outerplan-&gt;plan_width,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;transitionSpace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Consider all of the grouping sets together when setting the limits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and estimating the number of partitions. This can be inaccurate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when there is more than one grouping set, but should still be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reasonable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> k = <span class="Constant">0</span>; k &lt; aggstate-&gt;num_hashes; k++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totalGroups += aggstate-&gt;perhash[k].aggnode-&gt;numGroups;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1798" title="executor/nodeAgg.c:1798">hash_agg_set_limits</a>(aggstate-&gt;hashentrysize, totalGroups, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;aggstate-&gt;hash_mem_limit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;aggstate-&gt;hash_ngroups_limit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;aggstate-&gt;hash_planned_partitions);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1563" title="executor/nodeAgg.c:1563">find_hash_columns</a>(aggstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip massive memory allocation if we are just doing EXPLAIN */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1468" title="executor/nodeAgg.c:1468">build_hash_tables</a>(aggstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;table_filled = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize this to 1, meaning nothing spilled, yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;hash_batches_used = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize current phase-dependent <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to initial phase. The initial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * phase is 1 (first sort pass) for all strategies that use sorting (if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hashing is being done too, then phase 0 is processed last); but if only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hashing is being done, then phase 0 is all there is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;aggstrategy == AGG_HASHED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;current_phase = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L477" title="executor/nodeAgg.c:477">initialize_phase</a>(aggstate, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L455" title="executor/nodeAgg.c:455">select_current_set</a>(aggstate, <span class="Constant">0</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggstate-&gt;current_phase = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L477" title="executor/nodeAgg.c:477">initialize_phase</a>(aggstate, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L455" title="executor/nodeAgg.c:455">select_current_set</a>(aggstate, <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Perform lookups of aggregate function info, and <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unchanging fields of the per-agg and per-trans data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, aggstate-&gt;aggs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Aggref&nbsp; &nbsp; &nbsp;&nbsp; *aggref = lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggStatePerAgg peragg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggStatePerTrans pertrans;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggTransFnInputTypes[FUNC_MAX_ARGS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numAggTransFnArgs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numDirectArgs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; aggTuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_aggregate aggform;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AclResult&nbsp; &nbsp; aclresult;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finalfn_oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; serialfn_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deserialfn_oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggOwner;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *finalfnexpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggtranstype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Planner should have assigned aggregate to correct level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(aggref-&gt;agglevelsup == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and the split mode should match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(aggref-&gt;aggsplit == aggstate-&gt;aggsplit);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; peragg = &amp;peraggs[aggref-&gt;aggno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check if we initialized the state for this aggregate already. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (peragg-&gt;aggref != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; peragg-&gt;aggref = aggref;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; peragg-&gt;transno = aggref-&gt;aggtransno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch the pg_aggregate row */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; aggTuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(AGGFNOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(aggref-&gt;aggfnoid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(aggTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for aggregate </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggref-&gt;aggfnoid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggform = (Form_pg_aggregate) GETSTRUCT(aggTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check permission to call aggregate function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L3876" title="catalog/aclchk.c:3876">object_aclcheck</a>(ProcedureRelationId, aggref-&gt;aggfnoid, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_EXECUTE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(aclresult, OBJECT_AGGREGATE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L1608" title="utils/cache/lsyscache.c:1608">get_func_name</a>(aggref-&gt;aggfnoid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; InvokeFunctionExecuteHook(aggref-&gt;aggfnoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> recorded transition state type in the Aggref itself */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; aggtranstype = aggref-&gt;aggtranstype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(aggtranstype));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Final function only required if we're finalizing the aggregates */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DO_AGGSPLIT_SKIPFINAL(aggstate-&gt;aggsplit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peragg-&gt;finalfn_oid = finalfn_oid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peragg-&gt;finalfn_oid = finalfn_oid = aggform-&gt;aggfinalfn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; serialfn_oid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; deserialfn_oid = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if serialization/deserialization is required.&nbsp; We only do it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for aggregates that have transtype INTERNAL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggtranstype == INTERNALOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> should only have generated a serialize agg node if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * every aggregate with an INTERNAL state has a serialization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function.&nbsp; Verify that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DO_AGGSPLIT_SERIALIZE(aggstate-&gt;aggsplit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* serialization only valid when not running finalfn */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(DO_AGGSPLIT_SKIPFINAL(aggstate-&gt;aggsplit));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(aggform-&gt;aggserialfn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;serialfunc not provided for serialization aggregation&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; serialfn_oid = aggform-&gt;aggserialfn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Likewise for deserialization <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DO_AGGSPLIT_DESERIALIZE(aggstate-&gt;aggsplit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* deserialization only valid when combining states */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(DO_AGGSPLIT_COMBINE(aggstate-&gt;aggsplit));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(aggform-&gt;aggdeserialfn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;deserialfunc not provided for deserialization aggregation&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deserialfn_oid = aggform-&gt;aggdeserialfn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check that aggregate owner has permission to call component fns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; procTuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procTuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PROCOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(aggref-&gt;aggfnoid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(procTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for function </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggref-&gt;aggfnoid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggOwner = ((Form_pg_proc) GETSTRUCT(procTuple))-&gt;proowner;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(procTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(finalfn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L3876" title="catalog/aclchk.c:3876">object_aclcheck</a>(ProcedureRelationId, finalfn_oid, aggOwner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_EXECUTE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(aclresult, OBJECT_FUNCTION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L1608" title="utils/cache/lsyscache.c:1608">get_func_name</a>(finalfn_oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvokeFunctionExecuteHook(finalfn_oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(serialfn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L3876" title="catalog/aclchk.c:3876">object_aclcheck</a>(ProcedureRelationId, serialfn_oid, aggOwner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_EXECUTE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(aclresult, OBJECT_FUNCTION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L1608" title="utils/cache/lsyscache.c:1608">get_func_name</a>(serialfn_oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvokeFunctionExecuteHook(serialfn_oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(deserialfn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L3876" title="catalog/aclchk.c:3876">object_aclcheck</a>(ProcedureRelationId, deserialfn_oid, aggOwner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_EXECUTE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(aclresult, OBJECT_FUNCTION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L1608" title="utils/cache/lsyscache.c:1608">get_func_name</a>(deserialfn_oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvokeFunctionExecuteHook(deserialfn_oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get actual datatypes of the (nominal) aggregate inputs.&nbsp; These<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could be different from the agg's declared input types, when the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * agg accepts ANY or a polymorphic type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; numAggTransFnArgs = <a href="../parser/parse_agg.c.html#L1908" title="parser/parse_agg.c:1908">get_aggregate_argtypes</a>(aggref,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggTransFnInputTypes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Count the &quot;direct&quot; arguments, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; numDirectArgs = list_length(aggref-&gt;aggdirectargs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Detect how many arguments to pass to the finalfn */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggform-&gt;aggfinalextra)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peragg-&gt;numFinalArgs = numAggTransFnArgs + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peragg-&gt;numFinalArgs = numDirectArgs + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> direct-argument expressions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; peragg-&gt;aggdirectargs = <a href="execExpr.c.html#L326" title="executor/execExpr.c:326">ExecInitExprList</a>(aggref-&gt;aggdirectargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (PlanState *) aggstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * build expression trees using actual argument &amp; result types for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * finalfn, if it exists and is required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(finalfn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../parser/parse_agg.c.html#L2136" title="parser/parse_agg.c:2136">build_aggregate_finalfn_expr</a>(aggTransFnInputTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; peragg-&gt;numFinalArgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggtranstype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggref-&gt;aggtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggref-&gt;inputcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; finalfn_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;finalfnexpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(finalfn_oid, &amp;peragg-&gt;finalfn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fmgr_info_set_expr((Node *) finalfnexpr, &amp;peragg-&gt;finalfn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* get info about the output value's datatype */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L2251" title="utils/cache/lsyscache.c:2251">get_typlenbyval</a>(aggref-&gt;aggtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;peragg-&gt;resulttypeLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;peragg-&gt;resulttypeByVal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Build working state for invoking the transition function, if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * haven't done it already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pertrans = &amp;pertransstates[aggref-&gt;aggtransno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pertrans-&gt;aggref == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; textInitVal;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; initValue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; initValueIsNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transfn_oid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this aggregation is performing state combines, then instead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of using the transition function, we'll use the <a href="../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DO_AGGSPLIT_COMBINE(aggstate-&gt;aggsplit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transfn_oid = aggform-&gt;aggcombinefn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If not set then the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> messed up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(transfn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;combinefn not set for aggregate function&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transfn_oid = aggform-&gt;aggtransfn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L3876" title="catalog/aclchk.c:3876">object_aclcheck</a>(ProcedureRelationId, transfn_oid, aggOwner, ACL_EXECUTE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(aclresult, OBJECT_FUNCTION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L1608" title="utils/cache/lsyscache.c:1608">get_func_name</a>(transfn_oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvokeFunctionExecuteHook(transfn_oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * initval is potentially null, so don't try to access it as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * struct field. Must do it the hard way with <a href="../utils/cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; textInitVal = <a href="../utils/cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(AGGFNOID, aggTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_aggregate_agginitval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;initValueIsNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (initValueIsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initValue = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initValue = <a href="nodeWindowAgg.c.html#L3022" title="executor/nodeWindowAgg.c:3022">GetAggInitVal</a>(textInitVal, aggtranstype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DO_AGGSPLIT_COMBINE(aggstate-&gt;aggsplit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; combineFnInputTypes[] = {aggtranstype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggtranstype};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When combining there's only one input, the to-be-combined<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transition value.&nbsp; The transition value is not counted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;numTransInputs = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* aggcombinefn always has two arguments of aggtranstype */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4038" title="executor/nodeAgg.c:4038">build_pertrans_for_aggref</a>(pertrans, aggstate, estate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggref, transfn_oid, aggtranstype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; serialfn_oid, deserialfn_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initValue, initValueIsNull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; combineFnInputTypes, <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ensure that a <a href="../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> function to <a href="../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> INTERNAL states<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is not strict. This should have been checked during CREATE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * AGGREGATE, but the strict property could have been changed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since then.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pertrans-&gt;transfn.fn_strict &amp;&amp; aggtranstype == INTERNALOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FUNCTION_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> function with transition type </span><span class="Special">%s</span><span class="Constant"> must not be declared STRICT&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(aggtranstype))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Detect how many arguments to pass to the transfn */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (AGGKIND_IS_ORDERED_SET(aggref-&gt;aggkind))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;numTransInputs = list_length(aggref-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;numTransInputs = numAggTransFnArgs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4038" title="executor/nodeAgg.c:4038">build_pertrans_for_aggref</a>(pertrans, aggstate, estate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggref, transfn_oid, aggtranstype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; serialfn_oid, deserialfn_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initValue, initValueIsNull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggTransFnInputTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numAggTransFnArgs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the transfn is strict and the initval is NULL, make sure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * input type and transtype are the same (or at least<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * binary-compatible), so that it's OK to use the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aggregated input value as the initial transValue.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should have been checked at agg definition time, but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must check again in case the transfn's strictness property<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * has been changed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pertrans-&gt;transfn.fn_strict &amp;&amp; pertrans-&gt;initValueIsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (numAggTransFnArgs &lt;= numDirectArgs ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../parser/parse_coerce.c.html#L2995" title="parser/parse_coerce.c:2995">IsBinaryCoercible</a>(aggTransFnInputTypes[numDirectArgs],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggtranstype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FUNCTION_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;aggregate </span><span class="Special">%u</span><span class="Constant"> needs to have compatible input type and transition type&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggref-&gt;aggfnoid)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;aggshared = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(aggTuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update aggstate-&gt;numaggs to be the number of unique aggregates found.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also set numstates to the number of unique transition states found.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; aggstate-&gt;numaggs = numaggs;<br/></li>
<li>&nbsp; &nbsp; aggstate-&gt;numtrans = numtrans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Last, check whether <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more aggregates got added onto the node while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we processed the expressions for the aggregate arguments (including not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only the regular arguments and FILTER expressions handled immediately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * above, but <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> direct arguments we might've handled earlier).&nbsp; If so,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we have nested aggregate <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, which is semantically nonsensical,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so complain.&nbsp; (This should have been caught by the parser, so we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to work hard on a helpful error message; but we defend against it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here anyway, just to be sure.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (numaggrefs != list_length(aggstate-&gt;aggs))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_GROUPING_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;aggregate function calls cannot be nested&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build expressions doing all the transition work at once. We build a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * different one for each phase, as the number of transition function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * invocation can differ between phases. Note this'll work both for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transition and combination <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> (although there'll only be one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * phase in the latter case).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (phaseidx = <span class="Constant">0</span>; phaseidx &lt; aggstate-&gt;numphases; phaseidx++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggStatePerPhase phase = &amp;aggstate-&gt;phases[phaseidx];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dohash = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dosort = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* phase 0 doesn't necessarily exist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!phase-&gt;aggnode)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggstate-&gt;aggstrategy == AGG_MIXED &amp;&amp; phaseidx == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Phase one, and only phase one, in a mixed agg performs both<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sorting and aggregation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dohash = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dosort = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (aggstate-&gt;aggstrategy == AGG_MIXED &amp;&amp; phaseidx == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No need to compute a transition function for an AGG_MIXED phase<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 0 - the contents of the hashtables will have been computed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * during phase 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (phase-&gt;aggstrategy == AGG_PLAIN ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; phase-&gt;aggstrategy == AGG_SORTED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dohash = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dosort = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (phase-&gt;aggstrategy == AGG_HASHED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dohash = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dosort = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phase-&gt;evaltrans = <a href="execExpr.c.html#L3490" title="executor/execExpr.c:3490">ExecBuildAggTrans</a>(aggstate, phase, dosort, dohash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cache compiled expression for outer slot without NULL check */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; phase-&gt;evaltrans_cache[<span class="Constant">0</span>][<span class="Constant">0</span>] = phase-&gt;evaltrans;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> aggstate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build the state needed to calculate a state value for an aggregate.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This initializes all the fields in 'pertrans'. 'aggref' is the aggregate<br/></li>
<li></span><span class="Comment"> * to <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the state for. 'transfn_oid', 'aggtranstype', and the rest<br/></li>
<li></span><span class="Comment"> * of the arguments could be calculated from 'aggref', but the caller has<br/></li>
<li></span><span class="Comment"> * calculated them already, so might as well pass them.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'transfn_oid' may be either the Oid of the aggtransfn or the aggcombinefn.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4038">&#x200c;</a></span><span class="linkable">build_pertrans_for_aggref</span>(AggStatePerTrans pertrans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggState *aggstate, EState *estate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Aggref *aggref,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid transfn_oid, Oid aggtranstype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid aggserialfn, Oid aggdeserialfn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum initValue, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> initValueIsNull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid *inputTypes, <span class="Type">int</span> numArguments)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numGroupingSets = Max(aggstate-&gt;maxsets, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *transfnexpr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numTransArgs;<br/></li>
<li>&nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *serialfnexpr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *deserialfnexpr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numInputs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numDirectArgs;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sortlist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numSortCols;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numDistinctCols;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Begin filling in the pertrans data */<br/></li>
<li></span>&nbsp; &nbsp; pertrans-&gt;aggref = aggref;<br/></li>
<li>&nbsp; &nbsp; pertrans-&gt;aggshared = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pertrans-&gt;aggCollation = aggref-&gt;inputcollid;<br/></li>
<li>&nbsp; &nbsp; pertrans-&gt;transfn_oid = transfn_oid;<br/></li>
<li>&nbsp; &nbsp; pertrans-&gt;serialfn_oid = aggserialfn;<br/></li>
<li>&nbsp; &nbsp; pertrans-&gt;deserialfn_oid = aggdeserialfn;<br/></li>
<li>&nbsp; &nbsp; pertrans-&gt;initValue = initValue;<br/></li>
<li>&nbsp; &nbsp; pertrans-&gt;initValueIsNull = initValueIsNull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Count the &quot;direct&quot; arguments, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; numDirectArgs = list_length(aggref-&gt;aggdirectargs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Count the number of aggregated input columns */<br/></li>
<li></span>&nbsp; &nbsp; pertrans-&gt;numInputs = numInputs = list_length(aggref-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pertrans-&gt;aggtranstype = aggtranstype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* account for the current transition state */<br/></li>
<li></span>&nbsp; &nbsp; numTransArgs = pertrans-&gt;numTransInputs + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up infrastructure for calling the transfn.&nbsp; Note that invtransfn is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not needed here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../parser/parse_agg.c.html#L2028" title="parser/parse_agg.c:2028">build_aggregate_transfn_expr</a>(inputTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numArguments,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numDirectArgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggref-&gt;aggvariadic,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggtranstype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggref-&gt;inputcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; transfn_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;transfnexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(transfn_oid, &amp;pertrans-&gt;transfn);<br/></li>
<li>&nbsp; &nbsp; fmgr_info_set_expr((Node *) transfnexpr, &amp;pertrans-&gt;transfn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pertrans-&gt;transfn_fcinfo =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (FunctionCallInfo) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(SizeForFunctionCallInfo(numTransArgs));<br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*pertrans-&gt;transfn_fcinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;pertrans-&gt;transfn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numTransArgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pertrans-&gt;aggCollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) aggstate, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* get info about the state value's datatype */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L2251" title="utils/cache/lsyscache.c:2251">get_typlenbyval</a>(aggtranstype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;pertrans-&gt;transtypeLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;pertrans-&gt;transtypeByVal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(aggserialfn))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../parser/parse_agg.c.html#L2089" title="parser/parse_agg.c:2089">build_aggregate_serialfn_expr</a>(aggserialfn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;serialfnexpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(aggserialfn, &amp;pertrans-&gt;serialfn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fmgr_info_set_expr((Node *) serialfnexpr, &amp;pertrans-&gt;serialfn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;serialfn_fcinfo =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (FunctionCallInfo) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(SizeForFunctionCallInfo(<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; InitFunctionCallInfoData(*pertrans-&gt;serialfn_fcinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;pertrans-&gt;serialfn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) aggstate, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(aggdeserialfn))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../parser/parse_agg.c.html#L2112" title="parser/parse_agg.c:2112">build_aggregate_deserialfn_expr</a>(aggdeserialfn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;deserialfnexpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(aggdeserialfn, &amp;pertrans-&gt;deserialfn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fmgr_info_set_expr((Node *) deserialfnexpr, &amp;pertrans-&gt;deserialfn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;deserialfn_fcinfo =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (FunctionCallInfo) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(SizeForFunctionCallInfo(<span class="Constant">2</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; InitFunctionCallInfoData(*pertrans-&gt;deserialfn_fcinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;pertrans-&gt;deserialfn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) aggstate, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're doing either DISTINCT or ORDER BY for a plain agg, then we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have a list of SortGroupClause nodes; fish out the data in them and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stick them into arrays.&nbsp; We ignore ORDER BY for an ordered-set agg,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * however; the agg's transfn and finalfn are responsible for that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> has set the aggpresorted flag, the input to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggregate is already correctly sorted.&nbsp; For ORDER BY aggregates we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * simply treat these as normal aggregates.&nbsp; For presorted DISTINCT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggregates an extra step must be added to remove duplicate consecutive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inputs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that by construction, if there is a DISTINCT clause then the ORDER<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * BY clause is a prefix of it (see <a href="../parser/parse_clause.c.html#L2986" title="parser/parse_clause.c:2986">transformDistinctClause</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (AGGKIND_IS_ORDERED_SET(aggref-&gt;aggkind))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortlist = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numSortCols = numDistinctCols = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;aggsortrequired = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (aggref-&gt;aggpresorted &amp;&amp; aggref-&gt;aggdistinct == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortlist = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numSortCols = numDistinctCols = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;aggsortrequired = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (aggref-&gt;aggdistinct)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortlist = aggref-&gt;aggdistinct;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numSortCols = numDistinctCols = list_length(sortlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(numSortCols &gt;= list_length(aggref-&gt;aggorder));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;aggsortrequired = !aggref-&gt;aggpresorted;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortlist = aggref-&gt;aggorder;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numSortCols = list_length(sortlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numDistinctCols = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;aggsortrequired = (numSortCols &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pertrans-&gt;numSortCols = numSortCols;<br/></li>
<li>&nbsp; &nbsp; pertrans-&gt;numDistinctCols = numDistinctCols;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have either sorting or filtering to do, create a tupledesc and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slot corresponding to the aggregated inputs (including sort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expressions) of the agg.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (numSortCols &gt; <span class="Constant">0</span> || aggref-&gt;aggfilter)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;sortdesc = <a href="execTuples.c.html#L2025" title="executor/execTuples.c:2025">ExecTypeFromTL</a>(aggref-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;sortslot =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L1918" title="executor/execTuples.c:1918">ExecInitExtraTupleSlot</a>(estate, pertrans-&gt;sortdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numSortCols &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't implement DISTINCT or ORDER BY aggs in the HASHED case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (yet)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(aggstate-&gt;aggstrategy != AGG_HASHED &amp;&amp; aggstate-&gt;aggstrategy != AGG_MIXED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ORDER BY aggregates are not supported with partial aggregation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!DO_AGGSPLIT_COMBINE(aggstate-&gt;aggsplit));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we have only one input, we need its len/byval info. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (numInputs == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L2251" title="utils/cache/lsyscache.c:2251">get_typlenbyval</a>(inputTypes[numDirectArgs],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;pertrans-&gt;inputtypeLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;pertrans-&gt;inputtypeByVal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (numDistinctCols &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we will need an extra slot to store prior <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;uniqslot =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L1918" title="executor/execTuples.c:1918">ExecInitExtraTupleSlot</a>(estate, pertrans-&gt;sortdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Extract the sort information for use later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;sortColIdx =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (AttrNumber *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numSortCols * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;sortOperators =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Oid *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numSortCols * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;sortCollations =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Oid *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numSortCols * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;sortNullsFirst =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numSortCols * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, sortlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortGroupClause *sortcl = (SortGroupClause *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = <a href="../optimizer/util/tlist.c.html#L367" title="optimizer/util/tlist.c:367">get_sortgroupclause_tle</a>(sortcl, aggref-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the parser should have made sure of this */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(sortcl-&gt;sortop));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;sortColIdx[i] = tle-&gt;resno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;sortOperators[i] = sortcl-&gt;sortop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;sortCollations[i] = <a href="../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) tle-&gt;expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;sortNullsFirst[i] = sortcl-&gt;nulls_first;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(i == numSortCols);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aggref-&gt;aggdistinct)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *ops;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(numArguments &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(aggref-&gt;aggdistinct) == numDistinctCols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ops = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numDistinctCols * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, aggref-&gt;aggdistinct)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ops[i++] = ((SortGroupClause *) lfirst(lc))-&gt;eqop;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lookup / build the necessary comparators */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (numDistinctCols == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(<a href="../utils/cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(ops[<span class="Constant">0</span>]), &amp;pertrans-&gt;equalfnOne);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;equalfnMulti =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execGrouping.c.html#L58" title="executor/execGrouping.c:58">execTuplesMatchPrepare</a>(pertrans-&gt;sortdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numDistinctCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pertrans-&gt;sortColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ops,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pertrans-&gt;sortCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;aggstate-&gt;ss.ps);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ops);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pertrans-&gt;sortstates = (<a href="../utils/sort/tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="../utils/sort/tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *) * numGroupingSets);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> Datum<br/></li>
<li><a id="L4288">&#x200c;</a><span class="linkable">GetAggInitVal</span>(Datum textInitVal, Oid transtype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typinput,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typioparam;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *strInitVal;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; initVal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L2874" title="utils/cache/lsyscache.c:2874">getTypeInputInfo</a>(transtype, &amp;typinput, &amp;typioparam);<br/></li>
<li>&nbsp; &nbsp; strInitVal = TextDatumGetCString(textInitVal);<br/></li>
<li>&nbsp; &nbsp; initVal = <a href="../utils/fmgr/fmgr.c.html#L1754" title="utils/fmgr/fmgr.c:1754">OidInputFunctionCall</a>(typinput, strInitVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typioparam, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(strInitVal);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> initVal;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L4304">&#x200c;</a></span><span class="linkable">ExecEndAgg</span>(AggState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlanState&nbsp; *outerPlan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numGroupingSets = Max(node-&gt;maxsets, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When ending a parallel worker, copy the statistics gathered by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worker back into shared memory so that it can be picked up by the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process to report in EXPLAIN ANALYZE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;shared_info &amp;&amp; IsParallelWorker())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggregateInstrumentation *si;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../access/transam/parallel.c.html#L112" title="access/transam/parallel.c:112">ParallelWorkerNumber</a> &lt;= node-&gt;shared_info-&gt;num_workers);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; si = &amp;node-&gt;shared_info-&gt;sinstrument[<a href="../access/transam/parallel.c.html#L112" title="access/transam/parallel.c:112">ParallelWorkerNumber</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; si-&gt;hash_batches_used = node-&gt;hash_batches_used;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; si-&gt;hash_disk_used = node-&gt;hash_disk_used;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; si-&gt;hash_mem_peak = node-&gt;hash_mem_peak;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we have closed <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> open tuplesorts */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;sort_in)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L971" title="utils/sort/tuplesort.c:971">tuplesort_end</a>(node-&gt;sort_in);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;sort_out)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L971" title="utils/sort/tuplesort.c:971">tuplesort_end</a>(node-&gt;sort_out);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3133" title="executor/nodeAgg.c:3133">hashagg_reset_spill_state</a>(node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;hash_metacxt != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(node-&gt;hash_metacxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;hash_metacxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (transno = <span class="Constant">0</span>; transno &lt; node-&gt;numtrans; transno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggStatePerTrans pertrans = &amp;node-&gt;pertrans[transno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (setno = <span class="Constant">0</span>; setno &lt; numGroupingSets; setno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pertrans-&gt;sortstates[setno])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L971" title="utils/sort/tuplesort.c:971">tuplesort_end</a>(pertrans-&gt;sortstates[setno]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And ensure <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> agg shutdown callbacks have been called */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (setno = <span class="Constant">0</span>; setno &lt; numGroupingSets; setno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execUtils.c.html#L441" title="executor/execUtils.c:441">ReScanExprContext</a>(node-&gt;aggcontexts[setno]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;hashcontext)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execUtils.c.html#L441" title="executor/execUtils.c:441">ReScanExprContext</a>(node-&gt;hashcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; outerPlan = outerPlanState(node);<br/></li>
<li>&nbsp; &nbsp; <a href="execProcnode.c.html#L557" title="executor/execProcnode.c:557">ExecEndNode</a>(outerPlan);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L4364">&#x200c;</a></span><span class="linkable">ExecReScanAgg</span>(AggState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext = node-&gt;ss.ps.ps_ExprContext;<br/></li>
<li>&nbsp; &nbsp; PlanState&nbsp; *outerPlan = outerPlanState(node);<br/></li>
<li>&nbsp; &nbsp; Agg&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *aggnode = (Agg *) node-&gt;ss.ps.plan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numGroupingSets = Max(node-&gt;maxsets, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node-&gt;agg_done = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;aggstrategy == AGG_HASHED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the hashed case, if we haven't yet built the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table then we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can just return; nothing done yet, so nothing to undo. If subnode's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * chgParam is not NULL then it will be re-scanned by ExecProcNode,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * else no reason to re-scan it at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!node-&gt;table_filled)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we do have the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table, and it never spilled, and the subplan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * does not have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parameter changes, and <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of our own parameter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changes affect input expressions of the aggregated <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we can just rescan the existing <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table; no need to build it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (outerPlan-&gt;chgParam == <span class="Constant">NULL</span> &amp;&amp; !node-&gt;hash_ever_spilled &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(node-&gt;ss.ps.chgParam, aggnode-&gt;aggParams))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResetTupleHashIterator(node-&gt;perhash[<span class="Constant">0</span>].hashtable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;node-&gt;perhash[<span class="Constant">0</span>].hashiter);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L455" title="executor/nodeAgg.c:455">select_current_set</a>(node, <span class="Constant">0</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we have closed <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> open tuplesorts */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (transno = <span class="Constant">0</span>; transno &lt; node-&gt;numtrans; transno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (setno = <span class="Constant">0</span>; setno &lt; numGroupingSets; setno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggStatePerTrans pertrans = &amp;node-&gt;pertrans[transno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pertrans-&gt;sortstates[setno])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L971" title="utils/sort/tuplesort.c:971">tuplesort_end</a>(pertrans-&gt;sortstates[setno]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pertrans-&gt;sortstates[setno] = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't need to <a href="execUtils.c.html#L441" title="executor/execUtils.c:441">ReScanExprContext</a> the output tuple context here;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="execAmi.c.html#L76" title="executor/execAmi.c:76">ExecReScan</a> already did it. But we do need to reset our per-grouping-set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contexts, which may have transvalues stored in them. (We use rescan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rather than just reset because transfns may have registered callbacks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that need to be run <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.) For the AGG_HASHED case, see below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (setno = <span class="Constant">0</span>; setno &lt; numGroupingSets; setno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execUtils.c.html#L441" title="executor/execUtils.c:441">ReScanExprContext</a>(node-&gt;aggcontexts[setno]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release first tuple of group, if we have made a copy */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;grp_firstTuple != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(node-&gt;grp_firstTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;grp_firstTuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(node-&gt;ss.ss_ScanTupleSlot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Forget current agg <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(econtext-&gt;ecxt_aggvalues, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * node-&gt;numaggs);<br/></li>
<li>&nbsp; &nbsp; MemSet(econtext-&gt;ecxt_aggnulls, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * node-&gt;numaggs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * With AGG_HASHED/MIXED, the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table is allocated in a sub-context of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the hashcontext. This used to be an issue, but <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, resetting a context<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * automatically deletes sub-contexts too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;aggstrategy == AGG_HASHED || node-&gt;aggstrategy == AGG_MIXED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3133" title="executor/nodeAgg.c:3133">hashagg_reset_spill_state</a>(node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;hash_ever_spilled = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;hash_spill_mode = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;hash_ngroups_current = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execUtils.c.html#L441" title="executor/execUtils.c:441">ReScanExprContext</a>(node-&gt;hashcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Rebuild an empty <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1468" title="executor/nodeAgg.c:1468">build_hash_tables</a>(node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;table_filled = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* iterator will be reset when the table is filled */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1741" title="executor/nodeAgg.c:1741">hashagg_recompile_expressions</a>(node, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;aggstrategy != AGG_HASHED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset the per-group state (in particular, mark transvalues null)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (setno = <span class="Constant">0</span>; setno &lt; numGroupingSets; setno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemSet(node-&gt;pergroups[setno], <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AggStatePerGroupData) * node-&gt;numaggs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reset to phase 1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L477" title="executor/nodeAgg.c:477">initialize_phase</a>(node, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;input_done = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;projected_set = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (outerPlan-&gt;chgParam == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execAmi.c.html#L76" title="executor/execAmi.c:76">ExecReScan</a>(outerPlan);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/***********************************************************************<br/></li>
<li></span><span class="Comment"> * API exposed to aggregate <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> ***********************************************************************/<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a> - test if a SQL function is being called as an aggregate<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The transition and/or final <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> of an aggregate may want to verify<br/></li>
<li></span><span class="Comment"> * that they are being called as aggregates, rather than as plain SQL<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; They should use this function to do so.&nbsp; The return value<br/></li>
<li></span><span class="Comment"> * is nonzero if being called as an aggregate, or zero if not.&nbsp; (Specific<br/></li>
<li></span><span class="Comment"> * nonzero <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are AGG_CONTEXT_AGGREGATE or AGG_CONTEXT_WINDOW, but more<br/></li>
<li></span><span class="Comment"> * <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> could conceivably appear in future.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If aggcontext isn't NULL, the function also stores at *aggcontext the<br/></li>
<li></span><span class="Comment"> * identity of the memory context that aggregate transition <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are being<br/></li>
<li></span><span class="Comment"> * stored in.&nbsp; Note that the same aggregate call site (flinfo) may be called<br/></li>
<li></span><span class="Comment"> * interleaved on different transition <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in different contexts, so it's<br/></li>
<li></span><span class="Comment"> * not kosher to cache aggcontext under fn_extra.&nbsp; It is, however, kosher to<br/></li>
<li></span><span class="Comment"> * cache it in the transvalue itself (for <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>-type transvalues).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L4511">&#x200c;</a></span><span class="linkable">AggCheckCallContext</span>(FunctionCallInfo fcinfo, MemoryContext *aggcontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;context &amp;&amp; IsA(fcinfo-&gt;context, AggState))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggcontext)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AggState&nbsp;&nbsp; *aggstate = ((AggState *) fcinfo-&gt;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExprContext *cxt = aggstate-&gt;curaggcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *aggcontext = cxt-&gt;ecxt_per_tuple_memory;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> AGG_CONTEXT_AGGREGATE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;context &amp;&amp; IsA(fcinfo-&gt;context, WindowAggState))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aggcontext)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *aggcontext = ((WindowAggState *) fcinfo-&gt;context)-&gt;curaggcontext;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> AGG_CONTEXT_WINDOW;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* this is just to prevent &quot;uninitialized variable&quot; warnings */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (aggcontext)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *aggcontext = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4555" title="executor/nodeAgg.c:4555">AggGetAggref</a> - allow an aggregate support function to get its Aggref<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the function is being called as an aggregate support function,<br/></li>
<li></span><span class="Comment"> * return the Aggref node for the aggregate call.&nbsp; Otherwise, return NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Aggregates sharing the same inputs and transition <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> can get<br/></li>
<li></span><span class="Comment"> * merged into a single transition calculation.&nbsp; If the transition function<br/></li>
<li></span><span class="Comment"> * calls <a href="#L4555" title="executor/nodeAgg.c:4555">AggGetAggref</a>, it will get some one of the Aggrefs for which it is<br/></li>
<li></span><span class="Comment"> * executing.&nbsp; It must therefore not pay attention to the Aggref fields that<br/></li>
<li></span><span class="Comment"> * relate to the final function, as those are indeterminate.&nbsp; But if a final<br/></li>
<li></span><span class="Comment"> * function calls <a href="#L4555" title="executor/nodeAgg.c:4555">AggGetAggref</a>, it will get a precise result.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that if an aggregate is being used as a window function, this will<br/></li>
<li></span><span class="Comment"> * return NULL.&nbsp; We could provide a similar function to return the relevant<br/></li>
<li></span><span class="Comment"> * WindowFunc node in such cases, but it's not needed yet.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Aggref *<br/></li>
<li><a id="L4555">&#x200c;</a><span class="linkable">AggGetAggref</span>(FunctionCallInfo fcinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;context &amp;&amp; IsA(fcinfo-&gt;context, AggState))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggState&nbsp;&nbsp; *aggstate = (AggState *) fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggStatePerAgg curperagg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggStatePerTrans curpertrans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check curperagg (valid when in a final function) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; curperagg = aggstate-&gt;curperagg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curperagg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> curperagg-&gt;aggref;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check curpertrans (valid when in a transition function) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; curpertrans = aggstate-&gt;curpertrans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curpertrans)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> curpertrans-&gt;aggref;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4589" title="executor/nodeAgg.c:4589">AggGetTempMemoryContext</a> - fetch short-term memory context for aggregates<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is useful in agg final <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>; the context returned is one that<br/></li>
<li></span><span class="Comment"> * the final function can safely reset as desired.&nbsp; This isn't useful for<br/></li>
<li></span><span class="Comment"> * transition <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, since the context returned MAY (we don't promise)<br/></li>
<li></span><span class="Comment"> * be the same as the context those are called in.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As above, this is currently not useful for aggs called as window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MemoryContext<br/></li>
<li><a id="L4589">&#x200c;</a><span class="linkable">AggGetTempMemoryContext</span>(FunctionCallInfo fcinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;context &amp;&amp; IsA(fcinfo-&gt;context, AggState))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggState&nbsp;&nbsp; *aggstate = (AggState *) fcinfo-&gt;context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> aggstate-&gt;tmpcontext-&gt;ecxt_per_tuple_memory;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4615" title="executor/nodeAgg.c:4615">AggStateIsShared</a> - <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out whether transition state is shared<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the function is being called as an aggregate support function,<br/></li>
<li></span><span class="Comment"> * return true if the aggregate's transition state is shared across<br/></li>
<li></span><span class="Comment"> * multiple aggregates, false if it is not.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if not called as an aggregate support function.<br/></li>
<li></span><span class="Comment"> * This is intended as a conservative answer, ie &quot;no you'd better not<br/></li>
<li></span><span class="Comment"> * scribble on your input&quot;.&nbsp; In particular, will return true if the<br/></li>
<li></span><span class="Comment"> * aggregate is being used as a window function, which is a scenario<br/></li>
<li></span><span class="Comment"> * in which changing the transition state is a bad idea.&nbsp; We might<br/></li>
<li></span><span class="Comment"> * want to refine the behavior for the window case in future.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4615">&#x200c;</a></span><span class="linkable">AggStateIsShared</span>(FunctionCallInfo fcinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;context &amp;&amp; IsA(fcinfo-&gt;context, AggState))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggState&nbsp;&nbsp; *aggstate = (AggState *) fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggStatePerAgg curperagg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggStatePerTrans curpertrans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check curperagg (valid when in a final function) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; curperagg = aggstate-&gt;curperagg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curperagg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> aggstate-&gt;pertrans[curperagg-&gt;transno].aggshared;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check curpertrans (valid when in a transition function) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; curpertrans = aggstate-&gt;curpertrans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curpertrans)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> curpertrans-&gt;aggshared;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4654" title="executor/nodeAgg.c:4654">AggRegisterCallback</a> - register a <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> callback for an aggregate<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is useful for aggs to register shutdown callbacks, which will ensure<br/></li>
<li></span><span class="Comment"> * that non-memory resources are freed.&nbsp; The callback will occur just <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * the associated aggcontext (as returned by <a href="#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>) is reset,<br/></li>
<li></span><span class="Comment"> * either between groups or as a result of rescanning the query.&nbsp; The callback<br/></li>
<li></span><span class="Comment"> * will NOT be called on error paths.&nbsp; The typical use-case is for freeing of<br/></li>
<li></span><span class="Comment"> * tuplestores or tuplesorts maintained in aggcontext, or pins held by slots<br/></li>
<li></span><span class="Comment"> * created by the agg <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; (The callback will not be called until after<br/></li>
<li></span><span class="Comment"> * the result of the finalfn is no longer needed, so it's safe for the finalfn<br/></li>
<li></span><span class="Comment"> * to return data that will be freed by the callback.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As above, this is currently not useful for aggs called as window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4654">&#x200c;</a></span><span class="linkable">AggRegisterCallback</span>(FunctionCallInfo fcinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExprContextCallbackFunction func,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;context &amp;&amp; IsA(fcinfo-&gt;context, AggState))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AggState&nbsp;&nbsp; *aggstate = (AggState *) fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExprContext *cxt = aggstate-&gt;curaggcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execUtils.c.html#L897" title="executor/execUtils.c:897">RegisterExprContextCallback</a>(cxt, func, arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;aggregate function cannot register a callback in this context&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Parallel Query Support<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li> <span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment">&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4683" title="executor/nodeAgg.c:4683">ExecAggEstimate</a><br/></li>
<li></span><span class="Comment">&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; Estimate space required to propagate aggregate statistics.<br/></li>
<li></span><span class="Comment">&nbsp; * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment">&nbsp; */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4683">&#x200c;</a></span><span class="linkable">ExecAggEstimate</span>(AggState *node, ParallelContext *pcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't need this if not instrumenting or no workers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!node-&gt;ss.ps.instrument || pcxt-&gt;nworkers == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = <a href="../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(pcxt-&gt;nworkers, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AggregateInstrumentation));<br/></li>
<li>&nbsp; &nbsp; size = <a href="../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, offsetof(SharedAggInfo, sinstrument));<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, size);<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4704" title="executor/nodeAgg.c:4704">ExecAggInitializeDSM</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Initialize DSM space for aggregate statistics.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4704">&#x200c;</a></span><span class="linkable">ExecAggInitializeDSM</span>(AggState *node, ParallelContext *pcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't need this if not instrumenting or no workers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!node-&gt;ss.ps.instrument || pcxt-&gt;nworkers == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = offsetof(SharedAggInfo, sinstrument)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; + pcxt-&gt;nworkers * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AggregateInstrumentation);<br/></li>
<li>&nbsp; &nbsp; node-&gt;shared_info = <a href="../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, size);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ensure <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unfilled slots will contain zeroes */<br/></li>
<li></span>&nbsp; &nbsp; memset(node-&gt;shared_info, <span class="Constant">0</span>, size);<br/></li>
<li>&nbsp; &nbsp; node-&gt;shared_info-&gt;num_workers = pcxt-&gt;nworkers;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, node-&gt;ss.ps.plan-&gt;plan_node_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;shared_info);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4729" title="executor/nodeAgg.c:4729">ExecAggInitializeWorker</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Attach worker to DSM space for aggregate statistics.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4729">&#x200c;</a></span><span class="linkable">ExecAggInitializeWorker</span>(AggState *node, ParallelWorkerContext *pwcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; node-&gt;shared_info =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(pwcxt-&gt;toc, node-&gt;ss.ps.plan-&gt;plan_node_id, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4742" title="executor/nodeAgg.c:4742">ExecAggRetrieveInstrumentation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Transfer aggregate statistics from DSM to private memory.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4742">&#x200c;</a></span><span class="linkable">ExecAggRetrieveInstrumentation</span>(AggState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; SharedAggInfo *si;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;shared_info == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = offsetof(SharedAggInfo, sinstrument)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; + node-&gt;shared_info-&gt;num_workers * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AggregateInstrumentation);<br/></li>
<li>&nbsp; &nbsp; si = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(size);<br/></li>
<li>&nbsp; &nbsp; memcpy(si, node-&gt;shared_info, size);<br/></li>
<li>&nbsp; &nbsp; node-&gt;shared_info = si;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
