<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>executor/execParallel.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>executor/execParallel.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L111">ExecParallelEstimateContext</a></li>
<li><a href="#L115">ExecParallelEstimateContext</a></li>
<li><a href="#L118">ExecParallelInitializeDSMContext</a></li>
<li><a href="#L123">ExecParallelInitializeDSMContext</a></li>
<li><a href="#L73">FixedParallelExecutorState</a></li>
<li><a href="#L79">FixedParallelExecutorState</a></li>
<li><a href="#L97">SharedExecutorInstrumentation</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L310">EstimateParamExecSpace</a></li>
<li><a href="#L587">ExecInitParallelPlan</a></li>
<li><a href="#L1184">ExecParallelCleanup</a></li>
<li><a href="#L878">ExecParallelCreateReaders</a></li>
<li><a href="#L229">ExecParallelEstimate</a></li>
<li><a href="#L1131">ExecParallelFinish</a></li>
<li><a href="#L1236">ExecParallelGetQueryDesc</a></li>
<li><a href="#L1220">ExecParallelGetReceiver</a></li>
<li><a href="#L438">ExecParallelInitializeDSM</a></li>
<li><a href="#L1309">ExecParallelInitializeWorker</a></li>
<li><a href="#L953">ExecParallelReInitializeDSM</a></li>
<li><a href="#L904">ExecParallelReinitialize</a></li>
<li><a href="#L1268">ExecParallelReportInstrumentation</a></li>
<li><a href="#L1022">ExecParallelRetrieveInstrumentation</a></li>
<li><a href="#L1091">ExecParallelRetrieveJitInstrumentation</a></li>
<li><a href="#L535">ExecParallelSetupTupleQueues</a></li>
<li><a href="#L145">ExecSerializePlan</a></li>
<li><a href="#L1400">ParallelQueryMain</a></li>
<li><a href="#L409">RestoreParamExecParams</a></li>
<li><a href="#L354">SerializeParamExecParams</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L106">GetInstrumentationArray</a></li>
<li><a href="#L60">PARALLEL_KEY_BUFFER_USAGE</a></li>
<li><a href="#L63">PARALLEL_KEY_DSA</a></li>
<li><a href="#L57">PARALLEL_KEY_EXECUTOR_FIXED</a></li>
<li><a href="#L62">PARALLEL_KEY_INSTRUMENTATION</a></li>
<li><a href="#L65">PARALLEL_KEY_JIT_INSTRUMENTATION</a></li>
<li><a href="#L59">PARALLEL_KEY_PARAMLISTINFO</a></li>
<li><a href="#L58">PARALLEL_KEY_PLANNEDSTMT</a></li>
<li><a href="#L64">PARALLEL_KEY_QUERY_TEXT</a></li>
<li><a href="#L61">PARALLEL_KEY_TUPLE_QUEUE</a></li>
<li><a href="#L66">PARALLEL_KEY_WAL_USAGE</a></li>
<li><a href="#L68">PARALLEL_TUPLE_QUEUE_SIZE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * execParallel.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Support routines for parallel execution.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This file contains routines that are intended to support setting up,<br/></li>
<li></span><span class="Comment"> * using, and tearing down a ParallelContext from within the PostgreSQL<br/></li>
<li></span><span class="Comment"> * executor.&nbsp; The ParallelContext machinery will handle starting the<br/></li>
<li></span><span class="Comment"> * workers and ensuring that their state generally matches that of the<br/></li>
<li></span><span class="Comment"> * leader; see src/backend/access/transam/README.parallel for details.<br/></li>
<li></span><span class="Comment"> * However, we must save and restore relevant executor state, such as<br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> ParamListInfo associated with the query, buffer/WAL usage info, and<br/></li>
<li></span><span class="Comment"> * the actual plan to be passed down to the worker.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/executor/execParallel.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;executor/execParallel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeAgg.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeAppend.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeBitmapHeapscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeCustom.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeForeignscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeHash.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeHashjoin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeIncrementalSort.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeIndexonlyscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeIndexscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeMemoize.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeSeqscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeSort.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeSubplan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/tqueue.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;jit/jit.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/tcopprot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/dsa.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Magic numbers for parallel executor communication.&nbsp; We use constants<br/></li>
<li></span><span class="Comment"> * greater than <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> 32-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integer here so that <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> &lt; 2^32 can be used<br/></li>
<li></span><span class="Comment"> * by individual parallel nodes to store their own state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L57">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_EXECUTOR_FIXED</span>&nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xE000000000000001</span><span class="PreProc">)<br/></li>
<li><a id="L58">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_PLANNEDSTMT</span>&nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xE000000000000002</span><span class="PreProc">)<br/></li>
<li><a id="L59">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_PARAMLISTINFO</span>&nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xE000000000000003</span><span class="PreProc">)<br/></li>
<li><a id="L60">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_BUFFER_USAGE</span>&nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xE000000000000004</span><span class="PreProc">)<br/></li>
<li><a id="L61">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_TUPLE_QUEUE</span>&nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xE000000000000005</span><span class="PreProc">)<br/></li>
<li><a id="L62">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_INSTRUMENTATION</span>&nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xE000000000000006</span><span class="PreProc">)<br/></li>
<li><a id="L63">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_DSA</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xE000000000000007</span><span class="PreProc">)<br/></li>
<li><a id="L64">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_QUERY_TEXT</span>&nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xE000000000000008</span><span class="PreProc">)<br/></li>
<li><a id="L65">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_JIT_INSTRUMENTATION</span> UINT64CONST(</span><span class="Constant">0xE000000000000009</span><span class="PreProc">)<br/></li>
<li><a id="L66">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_WAL_USAGE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xE00000000000000A</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L68">&#x200c;</a><span class="PreProc">#define <span class="linkable">PARALLEL_TUPLE_QUEUE_SIZE</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">65536<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fixed-size random stuff that we need to pass to parallel workers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L73">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">FixedParallelExecutorState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; tuples_needed;&nbsp; &nbsp; <span class="Comment">/* tuple bound, see <a href="execProcnode.c.html#L843" title="executor/execProcnode.c:843">ExecSetTupleBound</a> */<br/></li>
<li></span>&nbsp; &nbsp; dsa_pointer param_exec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eflags;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jit_flags;<br/></li>
<li><a id="L79">&#x200c;</a>} <span class="linkable">FixedParallelExecutorState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * DSM structure for accumulating per-PlanState instrumentation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * instrument_options: Same meaning here as in instrument.c.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * instrument_offset: Offset, relative to the start of this structure,<br/></li>
<li></span><span class="Comment"> * of the first Instrumentation object.&nbsp; This will depend on the length of<br/></li>
<li></span><span class="Comment"> * the plan_node_id array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * num_workers: Number of workers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * num_plan_nodes: Number of plan nodes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * plan_node_id: Array of plan nodes for which we are gathering instrumentation<br/></li>
<li></span><span class="Comment"> * from parallel workers.&nbsp; The length of this array is given by num_plan_nodes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L97">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">SharedExecutorInstrumentation</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instrument_options;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instrument_offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_workers;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_plan_nodes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan_node_id[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* array of num_plan_nodes * num_workers Instrumentation objects follows */<br/></li>
<li></span>};<br/></li>
<li><a id="L106">&#x200c;</a><span class="PreProc">#define <span class="linkable">GetInstrumentationArray</span>(sei) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (AssertVariableIsOfTypeMacro(sei, <a href="#L97" title="executor/execParallel.c:97">SharedExecutorInstrumentation</a> *), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; (Instrumentation *) (((</span><span class="Type">char</span><span class="PreProc"> *) sei) + sei-&gt;instrument_offset))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Context object for <a href="#L229" title="executor/execParallel.c:229">ExecParallelEstimate</a>. */<br/></li>
<li><a id="L111">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ExecParallelEstimateContext</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParallelContext *pcxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nnodes;<br/></li>
<li><a id="L115">&#x200c;</a>} <span class="linkable">ExecParallelEstimateContext</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Context object for <a href="#L438" title="executor/execParallel.c:438">ExecParallelInitializeDSM</a>. */<br/></li>
<li><a id="L118">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ExecParallelInitializeDSMContext</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParallelContext *pcxt;<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="executor/execParallel.c:97">SharedExecutorInstrumentation</a> *instrumentation;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nnodes;<br/></li>
<li><a id="L123">&#x200c;</a>} <span class="linkable">ExecParallelInitializeDSMContext</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Helper <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that run in the parallel leader. */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<a href="#L145" title="executor/execParallel.c:145">ExecSerializePlan</a>(Plan *plan, EState *estate);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L229" title="executor/execParallel.c:229">ExecParallelEstimate</a>(PlanState *planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L111" title="executor/execParallel.c:111">ExecParallelEstimateContext</a> *e);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L438" title="executor/execParallel.c:438">ExecParallelInitializeDSM</a>(PlanState *planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execParallel.c:118">ExecParallelInitializeDSMContext</a> *d);<br/></li>
<li><span class="Type">static</span> <a href="../storage/ipc/shm_mq.c.html#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> **<a href="#L535" title="executor/execParallel.c:535">ExecParallelSetupTupleQueues</a>(ParallelContext *pcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> reinitialize);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L953" title="executor/execParallel.c:953">ExecParallelReInitializeDSM</a>(PlanState *planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParallelContext *pcxt);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1022" title="executor/execParallel.c:1022">ExecParallelRetrieveInstrumentation</a>(PlanState *planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="executor/execParallel.c:97">SharedExecutorInstrumentation</a> *instrumentation);<br/></li>
<li><br/></li>
<li><span class="Comment">/* Helper function that runs in the parallel worker. */<br/></li>
<li></span><span class="Type">static</span> DestReceiver *<a href="#L1220" title="executor/execParallel.c:1220">ExecParallelGetReceiver</a>(<a href="../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg, <a href="../storage/ipc/shm_toc.c.html#L26" title="storage/ipc/shm_toc.c:26">shm_toc</a> *toc);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a serialized representation of the plan to be sent to each worker.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L145">&#x200c;</a><span class="linkable">ExecSerializePlan</span>(Plan *plan, EState *estate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlannedStmt *pstmt;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can't scribble on the original plan, so make a copy. */<br/></li>
<li></span>&nbsp; &nbsp; plan = copyObject(plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The worker will start its own copy of the executor, and that copy will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * insert a junk filter if the toplevel node has <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> resjunk entries. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't want that to happen, because while resjunk columns shouldn't be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sent back to the user, here the tuples are coming back to another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backend which may very well need them.&nbsp; So mutate the target list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * accordingly.&nbsp; This is sort of a hack; there might be better ways to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, plan-&gt;targetlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = lfirst_node(TargetEntry, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle-&gt;resjunk = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a dummy PlannedStmt.&nbsp; Most of the fields don't need to be valid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for our purposes, but the worker will need at least a minimal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PlannedStmt to start the executor.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pstmt = makeNode(PlannedStmt);<br/></li>
<li>&nbsp; &nbsp; pstmt-&gt;commandType = CMD_SELECT;<br/></li>
<li>&nbsp; &nbsp; pstmt-&gt;queryId = <a href="../utils/activity/backend_status.c.html#L1027" title="utils/activity/backend_status.c:1027">pgstat_get_my_query_id</a>();<br/></li>
<li>&nbsp; &nbsp; pstmt-&gt;hasReturning = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pstmt-&gt;hasModifyingCTE = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pstmt-&gt;canSetTag = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; pstmt-&gt;transientPlan = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pstmt-&gt;dependsOnRole = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pstmt-&gt;parallelModeNeeded = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pstmt-&gt;planTree = plan;<br/></li>
<li>&nbsp; &nbsp; pstmt-&gt;rtable = estate-&gt;es_range_table;<br/></li>
<li>&nbsp; &nbsp; pstmt-&gt;permInfos = estate-&gt;es_rteperminfos;<br/></li>
<li>&nbsp; &nbsp; pstmt-&gt;resultRelations = NIL;<br/></li>
<li>&nbsp; &nbsp; pstmt-&gt;appendRelations = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Transfer only parallel-safe subplans, leaving a NULL &quot;hole&quot; in the list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for unsafe ones (so that the list indexes of the safe ones are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * preserved).&nbsp; This positively ensures that the worker won't try to run,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or even do <a href="execProcnode.c.html#L142" title="executor/execProcnode.c:142">ExecInitNode</a> on, an unsafe subplan.&nbsp; That's important to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * protect, eg, non-parallel-aware FDWs from getting into trouble.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pstmt-&gt;subplans = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, estate-&gt;es_plannedstmt-&gt;subplans)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *subplan = (Plan *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subplan &amp;&amp; !subplan-&gt;parallel_safe)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subplan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstmt-&gt;subplans = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(pstmt-&gt;subplans, subplan);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pstmt-&gt;rewindPlanIDs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pstmt-&gt;rowMarks = NIL;<br/></li>
<li>&nbsp; &nbsp; pstmt-&gt;relationOids = NIL;<br/></li>
<li>&nbsp; &nbsp; pstmt-&gt;invalItems = NIL;&nbsp; &nbsp; <span class="Comment">/* workers can't replan anyway... */<br/></li>
<li></span>&nbsp; &nbsp; pstmt-&gt;paramExecTypes = estate-&gt;es_plannedstmt-&gt;paramExecTypes;<br/></li>
<li>&nbsp; &nbsp; pstmt-&gt;utilityStmt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pstmt-&gt;stmt_location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; pstmt-&gt;stmt_len = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return serialized copy of our dummy PlannedStmt. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../nodes/outfuncs.c.html#L791" title="nodes/outfuncs.c:791">nodeToString</a>(pstmt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Parallel-aware plan nodes (and occasionally others) may need some state<br/></li>
<li></span><span class="Comment"> * which is shared across all parallel workers.&nbsp; Before we size the DSM, give<br/></li>
<li></span><span class="Comment"> * them a chance to call shm_toc_estimate_chunk or shm_toc_estimate_keys on<br/></li>
<li></span><span class="Comment"> * &amp;pcxt-&gt;estimator.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * While we're at it, count the number of PlanState nodes in the tree, so<br/></li>
<li></span><span class="Comment"> * we know how many Instrumentation structures we need.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L229">&#x200c;</a></span><span class="linkable">ExecParallelEstimate</span>(PlanState *planstate, <a href="#L111" title="executor/execParallel.c:111">ExecParallelEstimateContext</a> *e)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (planstate == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Count this node. */<br/></li>
<li></span>&nbsp; &nbsp; e-&gt;nnodes++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(planstate))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SeqScanState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeSeqscan.c.html#L238" title="executor/nodeSeqscan.c:238">ExecSeqScanEstimate</a>((SeqScanState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexScanState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeIndexscan.c.html#L1641" title="executor/nodeIndexscan.c:1641">ExecIndexScanEstimate</a>((IndexScanState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexOnlyScanState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeIndexonlyscan.c.html#L625" title="executor/nodeIndexonlyscan.c:625">ExecIndexOnlyScanEstimate</a>((IndexOnlyScanState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ForeignScanState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeForeignscan.c.html#L356" title="executor/nodeForeignscan.c:356">ExecForeignScanEstimate</a>((ForeignScanState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_AppendState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeAppend.c.html#L484" title="executor/nodeAppend.c:484">ExecAppendEstimate</a>((AppendState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; e-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CustomScanState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeCustom.c.html#L161" title="executor/nodeCustom.c:161">ExecCustomScanEstimate</a>((CustomScanState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; e-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitmapHeapScanState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeBitmapHeapscan.c.html#L803" title="executor/nodeBitmapHeapscan.c:803">ExecBitmapHeapEstimate</a>((BitmapHeapScanState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; e-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_HashJoinState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeHashjoin.c.html#L1543" title="executor/nodeHashjoin.c:1543">ExecHashJoinEstimate</a>((HashJoinState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; e-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_HashState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* even when not parallel-aware, for EXPLAIN ANALYZE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeHash.c.html#L2734" title="executor/nodeHash.c:2734">ExecHashEstimate</a>((HashState *) planstate, e-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SortState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* even when not parallel-aware, for EXPLAIN ANALYZE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeSort.c.html#L416" title="executor/nodeSort.c:416">ExecSortEstimate</a>((SortState *) planstate, e-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IncrementalSortState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* even when not parallel-aware, for EXPLAIN ANALYZE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeIncrementalSort.c.html#L1173" title="executor/nodeIncrementalSort.c:1173">ExecIncrementalSortEstimate</a>((IncrementalSortState *) planstate, e-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_AggState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* even when not parallel-aware, for EXPLAIN ANALYZE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeAgg.c.html#L4683" title="executor/nodeAgg.c:4683">ExecAggEstimate</a>((AggState *) planstate, e-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_MemoizeState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* even when not parallel-aware, for EXPLAIN ANALYZE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeMemoize.c.html#L1190" title="executor/nodeMemoize.c:1190">ExecMemoizeEstimate</a>((MemoizeState *) planstate, e-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> planstate_tree_walker(planstate, <a href="#L229" title="executor/execParallel.c:229">ExecParallelEstimate</a>, e);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Estimate the amount of space required to serialize the indicated parameters.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Size<br/></li>
<li><a id="L310">&#x200c;</a><span class="linkable">EstimateParamExecSpace</span>(EState *estate, Bitmapset *params)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramid;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; sz = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; paramid = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((paramid = <a href="../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(params, paramid)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; typLen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typByVal;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ParamExecData *prm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prm = &amp;(estate-&gt;es_param_exec_vals[paramid]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typeOid = list_nth_oid(estate-&gt;es_plannedstmt-&gt;paramExecTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; paramid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sz = <a href="../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(sz, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>)); <span class="Comment">/* space for paramid */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* space for datum/isnull */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(typeOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L2251" title="utils/cache/lsyscache.c:2251">get_typlenbyval</a>(typeOid, &amp;typLen, &amp;typByVal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If no type OID, assume by-value, like <a href="../nodes/params.c.html#L78" title="nodes/params.c:78">copyParamList</a> does. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typLen = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typByVal = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sz = <a href="../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(sz,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/datum.c.html#L412" title="utils/adt/datum.c:412">datumEstimateSpace</a>(prm-&gt;value, prm-&gt;isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typByVal, typLen));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> sz;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Serialize specified PARAM_EXEC parameters.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We write the number of parameters first, as a 4-byte integer, and then<br/></li>
<li></span><span class="Comment"> * write details for each parameter in turn.&nbsp; The details for each parameter<br/></li>
<li></span><span class="Comment"> * consist of a 4-byte paramid (location of param in execution time <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a><br/></li>
<li></span><span class="Comment"> * parameter array) and then the datum as serialized by <a href="../utils/adt/datum.c.html#L459" title="utils/adt/datum.c:459">datumSerialize</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> dsa_pointer<br/></li>
<li><a id="L354">&#x200c;</a><span class="linkable">SerializeParamExecParams</span>(EState *estate, Bitmapset *params, <a href="../utils/mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nparams;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramid;<br/></li>
<li>&nbsp; &nbsp; ParamExecData *prm;<br/></li>
<li>&nbsp; &nbsp; dsa_pointer handle;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *start_address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate enough space for the current parameter <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="#L310" title="executor/execParallel.c:310">EstimateParamExecSpace</a>(estate, params);<br/></li>
<li>&nbsp; &nbsp; handle = dsa_allocate(area, size);<br/></li>
<li>&nbsp; &nbsp; start_address = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, handle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First write the number of parameters as a 4-byte integer. */<br/></li>
<li></span>&nbsp; &nbsp; nparams = <a href="../nodes/bitmapset.c.html#L751" title="nodes/bitmapset.c:751">bms_num_members</a>(params);<br/></li>
<li>&nbsp; &nbsp; memcpy(start_address, &amp;nparams, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; start_address += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Write details for each parameter in turn. */<br/></li>
<li></span>&nbsp; &nbsp; paramid = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((paramid = <a href="../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(params, paramid)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; typLen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typByVal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prm = &amp;(estate-&gt;es_param_exec_vals[paramid]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typeOid = list_nth_oid(estate-&gt;es_plannedstmt-&gt;paramExecTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; paramid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Write paramid. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(start_address, &amp;paramid, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; start_address += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Write datum/isnull */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(typeOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L2251" title="utils/cache/lsyscache.c:2251">get_typlenbyval</a>(typeOid, &amp;typLen, &amp;typByVal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If no type OID, assume by-value, like <a href="../nodes/params.c.html#L78" title="nodes/params.c:78">copyParamList</a> does. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typLen = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typByVal = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/datum.c.html#L459" title="utils/adt/datum.c:459">datumSerialize</a>(prm-&gt;value, prm-&gt;isnull, typByVal, typLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;start_address);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> handle;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Restore specified PARAM_EXEC parameters.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L409">&#x200c;</a></span><span class="linkable">RestoreParamExecParams</span>(<span class="Type">char</span> *start_address, EState *estate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nparams;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(&amp;nparams, start_address, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; start_address += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nparams; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ParamExecData *prm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Read paramid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;paramid, start_address, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; start_address += <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prm = &amp;(estate-&gt;es_param_exec_vals[paramid]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Read datum/isnull. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; prm-&gt;value = <a href="../utils/adt/datum.c.html#L521" title="utils/adt/datum.c:521">datumRestore</a>(&amp;start_address, &amp;prm-&gt;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prm-&gt;execPlan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize the dynamic shared memory segment that will be used to control<br/></li>
<li></span><span class="Comment"> * parallel execution.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L438">&#x200c;</a></span><span class="linkable">ExecParallelInitializeDSM</span>(PlanState *planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="executor/execParallel.c:118">ExecParallelInitializeDSMContext</a> *d)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (planstate == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If instrumentation is enabled, <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> slot for this node. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (d-&gt;instrumentation != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; d-&gt;instrumentation-&gt;plan_node_id[d-&gt;nnodes] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; planstate-&gt;plan-&gt;plan_node_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Count this node. */<br/></li>
<li></span>&nbsp; &nbsp; d-&gt;nnodes++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call initializers for DSM-using plan nodes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Most plan nodes won't do anything here, but plan nodes that allocated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * DSM may need to <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> shared state in the DSM <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * workers are launched.&nbsp; They can allocate the space they previously<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimated using <a href="../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>, and add the keys they previously<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimated using <a href="../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>, in each case targeting pcxt-&gt;toc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(planstate))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SeqScanState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeSeqscan.c.html#L256" title="executor/nodeSeqscan.c:256">ExecSeqScanInitializeDSM</a>((SeqScanState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; d-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexScanState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeIndexscan.c.html#L1661" title="executor/nodeIndexscan.c:1661">ExecIndexScanInitializeDSM</a>((IndexScanState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; d-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexOnlyScanState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeIndexonlyscan.c.html#L645" title="executor/nodeIndexonlyscan.c:645">ExecIndexOnlyScanInitializeDSM</a>((IndexOnlyScanState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; d-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ForeignScanState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeForeignscan.c.html#L375" title="executor/nodeForeignscan.c:375">ExecForeignScanInitializeDSM</a>((ForeignScanState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; d-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_AppendState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeAppend.c.html#L503" title="executor/nodeAppend.c:503">ExecAppendInitializeDSM</a>((AppendState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CustomScanState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeCustom.c.html#L174" title="executor/nodeCustom.c:174">ExecCustomScanInitializeDSM</a>((CustomScanState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitmapHeapScanState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeBitmapHeapscan.c.html#L817" title="executor/nodeBitmapHeapscan.c:817">ExecBitmapHeapInitializeDSM</a>((BitmapHeapScanState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_HashJoinState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeHashjoin.c.html#L1550" title="executor/nodeHashjoin.c:1550">ExecHashJoinInitializeDSM</a>((HashJoinState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_HashState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* even when not parallel-aware, for EXPLAIN ANALYZE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeHash.c.html#L2753" title="executor/nodeHash.c:2753">ExecHashInitializeDSM</a>((HashState *) planstate, d-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SortState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* even when not parallel-aware, for EXPLAIN ANALYZE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeSort.c.html#L437" title="executor/nodeSort.c:437">ExecSortInitializeDSM</a>((SortState *) planstate, d-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IncrementalSortState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* even when not parallel-aware, for EXPLAIN ANALYZE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeIncrementalSort.c.html#L1194" title="executor/nodeIncrementalSort.c:1194">ExecIncrementalSortInitializeDSM</a>((IncrementalSortState *) planstate, d-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_AggState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* even when not parallel-aware, for EXPLAIN ANALYZE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeAgg.c.html#L4704" title="executor/nodeAgg.c:4704">ExecAggInitializeDSM</a>((AggState *) planstate, d-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_MemoizeState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* even when not parallel-aware, for EXPLAIN ANALYZE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeMemoize.c.html#L1211" title="executor/nodeMemoize.c:1211">ExecMemoizeInitializeDSM</a>((MemoizeState *) planstate, d-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> planstate_tree_walker(planstate, <a href="#L438" title="executor/execParallel.c:438">ExecParallelInitializeDSM</a>, d);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * It sets up the response queues for backend workers to return tuples<br/></li>
<li></span><span class="Comment"> * to the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> backend and start the workers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="../storage/ipc/shm_mq.c.html#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> **<br/></li>
<li><a id="L535">&#x200c;</a><span class="linkable">ExecParallelSetupTupleQueues</span>(ParallelContext *pcxt, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> reinitialize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/shm_mq.c.html#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> **responseq;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tqueuespace;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Skip this if no workers. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;nworkers == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate memory for shared memory queue handles. */<br/></li>
<li></span>&nbsp; &nbsp; responseq = (<a href="../storage/ipc/shm_mq.c.html#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(pcxt-&gt;nworkers * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="../storage/ipc/shm_mq.c.html#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If not reinitializing, allocate space from the DSM for the queues;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise, <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the already allocated space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!reinitialize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tqueuespace =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<a href="#L68" title="executor/execParallel.c:68">PARALLEL_TUPLE_QUEUE_SIZE</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;nworkers));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tqueuespace = <a href="../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(pcxt-&gt;toc, <a href="#L61" title="executor/execParallel.c:61">PARALLEL_KEY_TUPLE_QUEUE</a>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the queues, and become the receiver for each. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; pcxt-&gt;nworkers; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/shm_mq.c.html#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>&nbsp; &nbsp; &nbsp;&nbsp; *mq;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mq = <a href="../storage/ipc/shm_mq.c.html#L177" title="storage/ipc/shm_mq.c:177">shm_mq_create</a>(tqueuespace +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((Size) i) * <a href="#L68" title="executor/execParallel.c:68">PARALLEL_TUPLE_QUEUE_SIZE</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Size) <a href="#L68" title="executor/execParallel.c:68">PARALLEL_TUPLE_QUEUE_SIZE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/shm_mq.c.html#L206" title="storage/ipc/shm_mq.c:206">shm_mq_set_receiver</a>(mq, <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; responseq[i] = <a href="../storage/ipc/shm_mq.c.html#L290" title="storage/ipc/shm_mq.c:290">shm_mq_attach</a>(mq, pcxt-&gt;seg, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add array of queues to <a href="../storage/ipc/shm_toc.c.html#L26" title="storage/ipc/shm_toc.c:26">shm_toc</a>, so others can <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!reinitialize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L61" title="executor/execParallel.c:61">PARALLEL_KEY_TUPLE_QUEUE</a>, tqueuespace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return array of handles. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> responseq;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sets up the required infrastructure for backend workers to perform<br/></li>
<li></span><span class="Comment"> * execution and return results to the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> backend.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ParallelExecutorInfo *<br/></li>
<li><a id="L587">&#x200c;</a><span class="linkable">ExecInitParallelPlan</span>(PlanState *planstate, EState *estate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Bitmapset *sendParams, <span class="Type">int</span> nworkers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int64 tuples_needed)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParallelExecutorInfo *pei;<br/></li>
<li>&nbsp; &nbsp; ParallelContext *pcxt;<br/></li>
<li>&nbsp; &nbsp; <a href="#L111" title="executor/execParallel.c:111">ExecParallelEstimateContext</a> e;<br/></li>
<li>&nbsp; &nbsp; <a href="#L118" title="executor/execParallel.c:118">ExecParallelInitializeDSMContext</a> d;<br/></li>
<li>&nbsp; &nbsp; <a href="#L73" title="executor/execParallel.c:73">FixedParallelExecutorState</a> *fpes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *pstmt_data;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *pstmt_space;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *paramlistinfo_space;<br/></li>
<li>&nbsp; &nbsp; BufferUsage *bufusage_space;<br/></li>
<li>&nbsp; &nbsp; WalUsage&nbsp;&nbsp; *walusage_space;<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="executor/execParallel.c:97">SharedExecutorInstrumentation</a> *instrumentation = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; SharedJitInstrumentation *jit_instrumentation = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstmt_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramlistinfo_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instrumentation_len = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jit_instrumentation_len = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instrument_offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; dsa_minsize = <a href="../utils/mmgr/dsa.c.html#L1196" title="utils/mmgr/dsa.c:1196">dsa_minimum_size</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *query_string;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Force <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> initplan outputs that we're going to pass to workers to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * evaluated, if they weren't already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For simplicity, we use the EState's per-output-tuple ExprContext here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * That risks intra-query memory leakage, since we might pass through here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * many times <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> that ExprContext gets reset; but <a href="nodeSubplan.c.html#L1092" title="executor/nodeSubplan.c:1092">ExecSetParamPlan</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't normally leak <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> memory in the context (see its comments), so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it doesn't seem worth complicating this function's API to pass it a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shorter-lived ExprContext.&nbsp; This might need to change someday.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="nodeSubplan.c.html#L1268" title="executor/nodeSubplan.c:1268">ExecSetParamPlanMulti</a>(sendParams, GetPerTupleExprContext(estate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate object for return value. */<br/></li>
<li></span>&nbsp; &nbsp; pei = <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ParallelExecutorInfo));<br/></li>
<li>&nbsp; &nbsp; pei-&gt;finished = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pei-&gt;planstate = planstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fix up and serialize plan to be sent to workers. */<br/></li>
<li></span>&nbsp; &nbsp; pstmt_data = <a href="#L145" title="executor/execParallel.c:145">ExecSerializePlan</a>(planstate-&gt;plan, estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create a parallel context. */<br/></li>
<li></span>&nbsp; &nbsp; pcxt = <a href="../access/transam/parallel.c.html#L167" title="access/transam/parallel.c:167">CreateParallelContext</a>(<span class="Constant">&quot;postgres&quot;</span>, <span class="Constant">&quot;<a href="#L1400" title="executor/execParallel.c:1400">ParallelQueryMain</a>&quot;</span>, nworkers);<br/></li>
<li>&nbsp; &nbsp; pei-&gt;pcxt = pcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Before telling the parallel context to create a dynamic shared memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * segment, we need to figure out how big it should be.&nbsp; Estimate space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the various things we need to store.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Estimate space for fixed-size state. */<br/></li>
<li></span>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L73" title="executor/execParallel.c:73">FixedParallelExecutorState</a>));<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Estimate space for query text. */<br/></li>
<li></span>&nbsp; &nbsp; query_len = strlen(estate-&gt;es_sourceText);<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, query_len + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Estimate space for serialized PlannedStmt. */<br/></li>
<li></span>&nbsp; &nbsp; pstmt_len = strlen(pstmt_data) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, pstmt_len);<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Estimate space for serialized ParamListInfo. */<br/></li>
<li></span>&nbsp; &nbsp; paramlistinfo_len = <a href="../nodes/params.c.html#L167" title="nodes/params.c:167">EstimateParamListSpace</a>(estate-&gt;es_param_list_info);<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, paramlistinfo_len);<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate space for BufferUsage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If EXPLAIN is not in use and there are no extensions loaded that care,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we could <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this.&nbsp; But we have no way of knowing whether anyone's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * looking at <a href="instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>, so do it unconditionally.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BufferUsage), pcxt-&gt;nworkers));<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Same thing for WalUsage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(WalUsage), pcxt-&gt;nworkers));<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Estimate space for tuple queues. */<br/></li>
<li></span>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<a href="#L68" title="executor/execParallel.c:68">PARALLEL_TUPLE_QUEUE_SIZE</a>, pcxt-&gt;nworkers));<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Give parallel-aware nodes a chance to add to the estimates, and get a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * count of how many PlanState nodes there are.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; e.pcxt = pcxt;<br/></li>
<li>&nbsp; &nbsp; e.nnodes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L229" title="executor/execParallel.c:229">ExecParallelEstimate</a>(planstate, &amp;e);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Estimate space for instrumentation, if required. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (estate-&gt;es_instrument)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instrumentation_len =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offsetof(<a href="#L97" title="executor/execParallel.c:97">SharedExecutorInstrumentation</a>, plan_node_id) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * e.nnodes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instrumentation_len = MAXALIGN(instrumentation_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instrument_offset = instrumentation_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instrumentation_len +=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Instrumentation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(e.nnodes, nworkers));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, instrumentation_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Estimate space for JIT instrumentation, if required. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (estate-&gt;es_jit_flags != PGJIT_NONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jit_instrumentation_len =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offsetof(SharedJitInstrumentation, jit_instr) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JitInstrumentation) * nworkers;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, jit_instrumentation_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Estimate space for DSA area. */<br/></li>
<li></span>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, dsa_minsize);<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../access/transam/parallel.c.html#L205" title="access/transam/parallel.c:205">InitializeParallelDSM</a>() passes the active snapshot to the parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worker, which uses it to set es_snapshot.&nbsp; Make sure we don't set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * es_snapshot differently in the child.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../utils/time/snapmgr.c.html#L770" title="utils/time/snapmgr.c:770">GetActiveSnapshot</a>() == estate-&gt;es_snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Everyone's had a chance to ask for space, so <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> create the DSM. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/parallel.c.html#L205" title="access/transam/parallel.c:205">InitializeParallelDSM</a>(pcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK, <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we have a dynamic shared memory segment, and it should be big<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enough to store all of the data we estimated we would want to put into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it, plus whatever general stuff (not specifically executor-related) the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ParallelContext itself needs to store there.&nbsp; None of the space we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * asked for has been allocated or initialized yet, though, so do that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store fixed-size state. */<br/></li>
<li></span>&nbsp; &nbsp; fpes = <a href="../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L73" title="executor/execParallel.c:73">FixedParallelExecutorState</a>));<br/></li>
<li>&nbsp; &nbsp; fpes-&gt;tuples_needed = tuples_needed;<br/></li>
<li>&nbsp; &nbsp; fpes-&gt;param_exec = InvalidDsaPointer;<br/></li>
<li>&nbsp; &nbsp; fpes-&gt;eflags = estate-&gt;es_top_eflags;<br/></li>
<li>&nbsp; &nbsp; fpes-&gt;jit_flags = estate-&gt;es_jit_flags;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L57" title="executor/execParallel.c:57">PARALLEL_KEY_EXECUTOR_FIXED</a>, fpes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store query string */<br/></li>
<li></span>&nbsp; &nbsp; query_string = <a href="../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, query_len + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; memcpy(query_string, estate-&gt;es_sourceText, query_len + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L64" title="executor/execParallel.c:64">PARALLEL_KEY_QUERY_TEXT</a>, query_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store serialized PlannedStmt. */<br/></li>
<li></span>&nbsp; &nbsp; pstmt_space = <a href="../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, pstmt_len);<br/></li>
<li>&nbsp; &nbsp; memcpy(pstmt_space, pstmt_data, pstmt_len);<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L58" title="executor/execParallel.c:58">PARALLEL_KEY_PLANNEDSTMT</a>, pstmt_space);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store serialized ParamListInfo. */<br/></li>
<li></span>&nbsp; &nbsp; paramlistinfo_space = <a href="../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, paramlistinfo_len);<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L59" title="executor/execParallel.c:59">PARALLEL_KEY_PARAMLISTINFO</a>, paramlistinfo_space);<br/></li>
<li>&nbsp; &nbsp; <a href="../nodes/params.c.html#L229" title="nodes/params.c:229">SerializeParamList</a>(estate-&gt;es_param_list_info, &amp;paramlistinfo_space);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate space for each worker's BufferUsage; no need to <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a>. */<br/></li>
<li></span>&nbsp; &nbsp; bufusage_space = <a href="../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BufferUsage), pcxt-&gt;nworkers));<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L60" title="executor/execParallel.c:60">PARALLEL_KEY_BUFFER_USAGE</a>, bufusage_space);<br/></li>
<li>&nbsp; &nbsp; pei-&gt;buffer_usage = bufusage_space;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Same for WalUsage. */<br/></li>
<li></span>&nbsp; &nbsp; walusage_space = <a href="../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(WalUsage), pcxt-&gt;nworkers));<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L66" title="executor/execParallel.c:66">PARALLEL_KEY_WAL_USAGE</a>, walusage_space);<br/></li>
<li>&nbsp; &nbsp; pei-&gt;wal_usage = walusage_space;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up the tuple queues that the workers will write into. */<br/></li>
<li></span>&nbsp; &nbsp; pei-&gt;tqueue = <a href="#L535" title="executor/execParallel.c:535">ExecParallelSetupTupleQueues</a>(pcxt, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We don't need the TupleQueueReaders yet, though. */<br/></li>
<li></span>&nbsp; &nbsp; pei-&gt;reader = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If instrumentation options were supplied, allocate space for the data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It only gets partially initialized here; the rest happens during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L438" title="executor/execParallel.c:438">ExecParallelInitializeDSM</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (estate-&gt;es_instrument)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Instrumentation *instrument;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instrumentation = <a href="../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, instrumentation_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instrumentation-&gt;instrument_options = estate-&gt;es_instrument;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instrumentation-&gt;instrument_offset = instrument_offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instrumentation-&gt;num_workers = nworkers;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instrumentation-&gt;num_plan_nodes = e.nnodes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instrument = <a href="#L106" title="executor/execParallel.c:106">GetInstrumentationArray</a>(instrumentation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nworkers * e.nnodes; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="instrument.c.html#L58" title="executor/instrument.c:58">InstrInit</a>(&amp;instrument[i], estate-&gt;es_instrument);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L62" title="executor/execParallel.c:62">PARALLEL_KEY_INSTRUMENTATION</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; instrumentation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pei-&gt;instrumentation = instrumentation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (estate-&gt;es_jit_flags != PGJIT_NONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jit_instrumentation = <a href="../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jit_instrumentation_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jit_instrumentation-&gt;num_workers = nworkers;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(jit_instrumentation-&gt;jit_instr, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JitInstrumentation) * nworkers);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L65" title="executor/execParallel.c:65">PARALLEL_KEY_JIT_INSTRUMENTATION</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; jit_instrumentation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pei-&gt;jit_instrumentation = jit_instrumentation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a DSA area that can be used by the leader and all workers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (However, if we failed to create a DSM and are using private memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * instead, then <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;seg != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *area_space;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; area_space = <a href="../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, dsa_minsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L63" title="executor/execParallel.c:63">PARALLEL_KEY_DSA</a>, area_space);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pei-&gt;area = dsa_create_in_place(area_space, dsa_minsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LWTRANCHE_PARALLEL_QUERY_DSA,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;seg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Serialize parameters, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, using DSA storage.&nbsp; We don't dare use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> parallel query DSM for this because we might relaunch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * workers after the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> have changed (and thus the amount of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * storage required has changed).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!bms_is_empty(sendParams))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pei-&gt;param_exec = <a href="#L354" title="executor/execParallel.c:354">SerializeParamExecParams</a>(estate, sendParams,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pei-&gt;area);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fpes-&gt;param_exec = pei-&gt;param_exec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Give parallel-aware nodes a chance to <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> their shared data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This also initializes the elements of instrumentation-&gt;ps_instrument,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if it exists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; d.pcxt = pcxt;<br/></li>
<li>&nbsp; &nbsp; d.instrumentation = instrumentation;<br/></li>
<li>&nbsp; &nbsp; d.nnodes = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Install our DSA area while initializing the plan. */<br/></li>
<li></span>&nbsp; &nbsp; estate-&gt;es_query_dsa = pei-&gt;area;<br/></li>
<li>&nbsp; &nbsp; <a href="#L438" title="executor/execParallel.c:438">ExecParallelInitializeDSM</a>(planstate, &amp;d);<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_query_dsa = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure that the world hasn't shifted under our feet.&nbsp; This could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * probably just be an Assert(), but let's be conservative for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (e.nnodes != d.nnodes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;inconsistent count of PlanState nodes&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, we're ready to rock and roll. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> pei;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set up tuple queue readers to read the results of a parallel subplan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is separate from <a href="#L587" title="executor/execParallel.c:587">ExecInitParallelPlan</a>() because we can launch the<br/></li>
<li></span><span class="Comment"> * worker processes and let them start doing something <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we do this.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L878">&#x200c;</a></span><span class="linkable">ExecParallelCreateReaders</span>(ParallelExecutorInfo *pei)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nworkers = pei-&gt;pcxt-&gt;nworkers_launched;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(pei-&gt;reader == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nworkers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pei-&gt;reader = (<a href="tqueue.c.html#L43" title="executor/tqueue.c:43">TupleQueueReader</a> **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nworkers * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="tqueue.c.html#L43" title="executor/tqueue.c:43">TupleQueueReader</a> *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nworkers; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/shm_mq.c.html#L319" title="storage/ipc/shm_mq.c:319">shm_mq_set_handle</a>(pei-&gt;tqueue[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pei-&gt;pcxt-&gt;worker[i].bgwhandle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pei-&gt;reader[i] = <a href="tqueue.c.html#L139" title="executor/tqueue.c:139">CreateTupleQueueReader</a>(pei-&gt;tqueue[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Re-<a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the parallel executor shared memory state <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> launching<br/></li>
<li></span><span class="Comment"> * a fresh batch of workers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L904">&#x200c;</a></span><span class="linkable">ExecParallelReinitialize</span>(PlanState *planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ParallelExecutorInfo *pei,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Bitmapset *sendParams)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate = planstate-&gt;state;<br/></li>
<li>&nbsp; &nbsp; <a href="#L73" title="executor/execParallel.c:73">FixedParallelExecutorState</a> *fpes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Old workers must already be shut down */<br/></li>
<li></span>&nbsp; &nbsp; Assert(pei-&gt;finished);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Force <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> initplan outputs that we're going to pass to workers to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * evaluated, if they weren't already (see comments in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L587" title="executor/execParallel.c:587">ExecInitParallelPlan</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="nodeSubplan.c.html#L1268" title="executor/nodeSubplan.c:1268">ExecSetParamPlanMulti</a>(sendParams, GetPerTupleExprContext(estate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/transam/parallel.c.html#L488" title="access/transam/parallel.c:488">ReinitializeParallelDSM</a>(pei-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; pei-&gt;tqueue = <a href="#L535" title="executor/execParallel.c:535">ExecParallelSetupTupleQueues</a>(pei-&gt;pcxt, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; pei-&gt;reader = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pei-&gt;finished = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fpes = <a href="../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(pei-&gt;pcxt-&gt;toc, <a href="#L57" title="executor/execParallel.c:57">PARALLEL_KEY_EXECUTOR_FIXED</a>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Free <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> serialized parameters from the last round. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (DsaPointerIsValid(fpes-&gt;param_exec))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/dsa.c.html#L826" title="utils/mmgr/dsa.c:826">dsa_free</a>(pei-&gt;area, fpes-&gt;param_exec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fpes-&gt;param_exec = InvalidDsaPointer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Serialize current parameter <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> if required. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!bms_is_empty(sendParams))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pei-&gt;param_exec = <a href="#L354" title="executor/execParallel.c:354">SerializeParamExecParams</a>(estate, sendParams,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pei-&gt;area);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fpes-&gt;param_exec = pei-&gt;param_exec;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Traverse plan tree and let each child node reset associated state. */<br/></li>
<li></span>&nbsp; &nbsp; estate-&gt;es_query_dsa = pei-&gt;area;<br/></li>
<li>&nbsp; &nbsp; <a href="#L953" title="executor/execParallel.c:953">ExecParallelReInitializeDSM</a>(planstate, pei-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_query_dsa = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Traverse plan tree to reinitialize per-node dynamic shared memory state<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L953">&#x200c;</a></span><span class="linkable">ExecParallelReInitializeDSM</span>(PlanState *planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParallelContext *pcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (planstate == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call reinitializers for DSM-using plan nodes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(planstate))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SeqScanState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeSeqscan.c.html#L278" title="executor/nodeSeqscan.c:278">ExecSeqScanReInitializeDSM</a>((SeqScanState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexScanState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeIndexscan.c.html#L1697" title="executor/nodeIndexscan.c:1697">ExecIndexScanReInitializeDSM</a>((IndexScanState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexOnlyScanState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeIndexonlyscan.c.html#L683" title="executor/nodeIndexonlyscan.c:683">ExecIndexOnlyScanReInitializeDSM</a>((IndexOnlyScanState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ForeignScanState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeForeignscan.c.html#L397" title="executor/nodeForeignscan.c:397">ExecForeignScanReInitializeDSM</a>((ForeignScanState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_AppendState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeAppend.c.html#L524" title="executor/nodeAppend.c:524">ExecAppendReInitializeDSM</a>((AppendState *) planstate, pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CustomScanState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeCustom.c.html#L190" title="executor/nodeCustom.c:190">ExecCustomScanReInitializeDSM</a>((CustomScanState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitmapHeapScanState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeBitmapHeapscan.c.html#L851" title="executor/nodeBitmapHeapscan.c:851">ExecBitmapHeapReInitializeDSM</a>((BitmapHeapScanState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_HashJoinState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeHashjoin.c.html#L1608" title="executor/nodeHashjoin.c:1608">ExecHashJoinReInitializeDSM</a>((HashJoinState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_HashState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SortState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IncrementalSortState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_MemoizeState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* these nodes have DSM state, but no reinitialization is required */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> planstate_tree_walker(planstate, <a href="#L953" title="executor/execParallel.c:953">ExecParallelReInitializeDSM</a>, pcxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copy instrumentation information about this node and its descendants from<br/></li>
<li></span><span class="Comment"> * dynamic shared memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1022">&#x200c;</a></span><span class="linkable">ExecParallelRetrieveInstrumentation</span>(PlanState *planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="executor/execParallel.c:97">SharedExecutorInstrumentation</a> *instrumentation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Instrumentation *instrument;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ibytes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan_node_id = planstate-&gt;plan-&gt;plan_node_id;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the instrumentation for this node. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; instrumentation-&gt;num_plan_nodes; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (instrumentation-&gt;plan_node_id[i] == plan_node_id)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= instrumentation-&gt;num_plan_nodes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;plan node </span><span class="Special">%d</span><span class="Constant"> not found&quot;</span>, plan_node_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Accumulate the statistics from all workers. */<br/></li>
<li></span>&nbsp; &nbsp; instrument = <a href="#L106" title="executor/execParallel.c:106">GetInstrumentationArray</a>(instrumentation);<br/></li>
<li>&nbsp; &nbsp; instrument += i * instrumentation-&gt;num_workers;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (n = <span class="Constant">0</span>; n &lt; instrumentation-&gt;num_workers; ++n)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="instrument.c.html#L169" title="executor/instrument.c:169">InstrAggNode</a>(planstate-&gt;instrument, &amp;instrument[n]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also store the per-worker detail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Worker instrumentation should be allocated in the same context as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * regular instrumentation information, which is the per-query context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Switch into per-query memory context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(planstate-&gt;state-&gt;es_query_cxt);<br/></li>
<li>&nbsp; &nbsp; ibytes = <a href="../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(instrumentation-&gt;num_workers, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Instrumentation));<br/></li>
<li>&nbsp; &nbsp; planstate-&gt;worker_instrument =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ibytes + offsetof(WorkerInstrumentation, instrument));<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; planstate-&gt;worker_instrument-&gt;num_workers = instrumentation-&gt;num_workers;<br/></li>
<li>&nbsp; &nbsp; memcpy(&amp;planstate-&gt;worker_instrument-&gt;instrument, instrument, ibytes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Perform <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> node-type-specific work that needs to be done. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(planstate))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SortState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeSort.c.html#L476" title="executor/nodeSort.c:476">ExecSortRetrieveInstrumentation</a>((SortState *) planstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IncrementalSortState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeIncrementalSort.c.html#L1233" title="executor/nodeIncrementalSort.c:1233">ExecIncrementalSortRetrieveInstrumentation</a>((IncrementalSortState *) planstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_HashState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeHash.c.html#L2819" title="executor/nodeHash.c:2819">ExecHashRetrieveInstrumentation</a>((HashState *) planstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_AggState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeAgg.c.html#L4742" title="executor/nodeAgg.c:4742">ExecAggRetrieveInstrumentation</a>((AggState *) planstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_MemoizeState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeMemoize.c.html#L1249" title="executor/nodeMemoize.c:1249">ExecMemoizeRetrieveInstrumentation</a>((MemoizeState *) planstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> planstate_tree_walker(planstate, <a href="#L1022" title="executor/execParallel.c:1022">ExecParallelRetrieveInstrumentation</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; instrumentation);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add up the workers' JIT instrumentation from dynamic shared memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1091">&#x200c;</a></span><span class="linkable">ExecParallelRetrieveJitInstrumentation</span>(PlanState *planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SharedJitInstrumentation *shared_jit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; JitInstrumentation *combined;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ibytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Accumulate worker JIT instrumentation into the combined JIT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * instrumentation, allocating it if required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!planstate-&gt;state-&gt;es_jit_worker_instr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; planstate-&gt;state-&gt;es_jit_worker_instr =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(planstate-&gt;state-&gt;es_query_cxt, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JitInstrumentation));<br/></li>
<li>&nbsp; &nbsp; combined = planstate-&gt;state-&gt;es_jit_worker_instr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Accumulate all the workers' instrumentations. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (n = <span class="Constant">0</span>; n &lt; shared_jit-&gt;num_workers; ++n)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../jit/jit.c.html#L182" title="jit/jit.c:182">InstrJitAgg</a>(combined, &amp;shared_jit-&gt;jit_instr[n]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Store the per-worker detail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Similar to <a href="#L1022" title="executor/execParallel.c:1022">ExecParallelRetrieveInstrumentation</a>(), allocate the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * instrumentation in per-query context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ibytes = offsetof(SharedJitInstrumentation, jit_instr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; + <a href="../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(shared_jit-&gt;num_workers, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JitInstrumentation));<br/></li>
<li>&nbsp; &nbsp; planstate-&gt;worker_jit_instrument =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(planstate-&gt;state-&gt;es_query_cxt, ibytes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(planstate-&gt;worker_jit_instrument, shared_jit, ibytes);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Finish parallel execution.&nbsp; We wait for parallel workers to finish, and<br/></li>
<li></span><span class="Comment"> * accumulate their buffer/WAL usage.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1131">&#x200c;</a></span><span class="linkable">ExecParallelFinish</span>(ParallelExecutorInfo *pei)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nworkers = pei-&gt;pcxt-&gt;nworkers_launched;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make this be a no-op if called twice in a row. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pei-&gt;finished)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Detach from tuple queues ASAP, so that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> still-active workers will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * notice that no further results are wanted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pei-&gt;tqueue != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nworkers; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/shm_mq.c.html#L843" title="storage/ipc/shm_mq.c:843">shm_mq_detach</a>(pei-&gt;tqueue[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pei-&gt;tqueue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pei-&gt;tqueue = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * While we're <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the workers to finish, let's get rid of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple queue readers.&nbsp; (Any other local <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> could be done here too.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pei-&gt;reader != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nworkers; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tqueue.c.html#L155" title="executor/tqueue.c:155">DestroyTupleQueueReader</a>(pei-&gt;reader[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pei-&gt;reader);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pei-&gt;reader = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now wait for the workers to finish. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/parallel.c.html#L775" title="access/transam/parallel.c:775">WaitForParallelWorkersToFinish</a>(pei-&gt;pcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Next, accumulate buffer/WAL usage.&nbsp; (This must wait for the workers to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * finish, or we might get incomplete data.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nworkers; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="instrument.c.html#L218" title="executor/instrument.c:218">InstrAccumParallelQuery</a>(&amp;pei-&gt;buffer_usage[i], &amp;pei-&gt;wal_usage[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pei-&gt;finished = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Accumulate instrumentation, and then clean up whatever ParallelExecutorInfo<br/></li>
<li></span><span class="Comment"> * resources still exist after <a href="#L1131" title="executor/execParallel.c:1131">ExecParallelFinish</a>.&nbsp; We separate these<br/></li>
<li></span><span class="Comment"> * routines because someone might want to examine the contents of the DSM<br/></li>
<li></span><span class="Comment"> * after <a href="#L1131" title="executor/execParallel.c:1131">ExecParallelFinish</a> and <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling this routine.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1184">&#x200c;</a></span><span class="linkable">ExecParallelCleanup</span>(ParallelExecutorInfo *pei)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Accumulate instrumentation, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pei-&gt;instrumentation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1022" title="executor/execParallel.c:1022">ExecParallelRetrieveInstrumentation</a>(pei-&gt;planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pei-&gt;instrumentation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Accumulate JIT instrumentation, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pei-&gt;jit_instrumentation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1091" title="executor/execParallel.c:1091">ExecParallelRetrieveJitInstrumentation</a>(pei-&gt;planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pei-&gt;jit_instrumentation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Free <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> serialized parameters. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (DsaPointerIsValid(pei-&gt;param_exec))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/dsa.c.html#L826" title="utils/mmgr/dsa.c:826">dsa_free</a>(pei-&gt;area, pei-&gt;param_exec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pei-&gt;param_exec = InvalidDsaPointer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pei-&gt;area != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/dsa.c.html#L1952" title="utils/mmgr/dsa.c:1952">dsa_detach</a>(pei-&gt;area);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pei-&gt;area = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pei-&gt;pcxt != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/parallel.c.html#L929" title="access/transam/parallel.c:929">DestroyParallelContext</a>(pei-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pei-&gt;pcxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pei);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a DestReceiver to write tuples we produce to the <a href="../storage/ipc/shm_mq.c.html#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> designated<br/></li>
<li></span><span class="Comment"> * for that purpose.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> DestReceiver *<br/></li>
<li><a id="L1220">&#x200c;</a><span class="linkable">ExecParallelGetReceiver</span>(<a href="../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg, <a href="../storage/ipc/shm_toc.c.html#L26" title="storage/ipc/shm_toc.c:26">shm_toc</a> *toc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *mqspace;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/shm_mq.c.html#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>&nbsp; &nbsp; &nbsp;&nbsp; *mq;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mqspace = <a href="../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L61" title="executor/execParallel.c:61">PARALLEL_KEY_TUPLE_QUEUE</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; mqspace += <a href="../access/transam/parallel.c.html#L112" title="access/transam/parallel.c:112">ParallelWorkerNumber</a> * <a href="#L68" title="executor/execParallel.c:68">PARALLEL_TUPLE_QUEUE_SIZE</a>;<br/></li>
<li>&nbsp; &nbsp; mq = (<a href="../storage/ipc/shm_mq.c.html#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> *) mqspace;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/shm_mq.c.html#L224" title="storage/ipc/shm_mq.c:224">shm_mq_set_sender</a>(mq, <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="tqueue.c.html#L119" title="executor/tqueue.c:119">CreateTupleQueueDestReceiver</a>(<a href="../storage/ipc/shm_mq.c.html#L290" title="storage/ipc/shm_mq.c:290">shm_mq_attach</a>(mq, seg, <span class="Constant">NULL</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a QueryDesc for the PlannedStmt we are to execute, and return it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> QueryDesc *<br/></li>
<li><a id="L1236">&#x200c;</a><span class="linkable">ExecParallelGetQueryDesc</span>(<a href="../storage/ipc/shm_toc.c.html#L26" title="storage/ipc/shm_toc.c:26">shm_toc</a> *toc, DestReceiver *receiver,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> instrument_options)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *pstmtspace;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *paramspace;<br/></li>
<li>&nbsp; &nbsp; PlannedStmt *pstmt;<br/></li>
<li>&nbsp; &nbsp; ParamListInfo paramLI;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *queryString;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the query string from shared memory */<br/></li>
<li></span>&nbsp; &nbsp; queryString = <a href="../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L64" title="executor/execParallel.c:64">PARALLEL_KEY_QUERY_TEXT</a>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reconstruct leader-supplied PlannedStmt. */<br/></li>
<li></span>&nbsp; &nbsp; pstmtspace = <a href="../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L58" title="executor/execParallel.c:58">PARALLEL_KEY_PLANNEDSTMT</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; pstmt = (PlannedStmt *) <a href="../nodes/read.c.html#L90" title="nodes/read.c:90">stringToNode</a>(pstmtspace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reconstruct ParamListInfo. */<br/></li>
<li></span>&nbsp; &nbsp; paramspace = <a href="../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L59" title="executor/execParallel.c:59">PARALLEL_KEY_PARAMLISTINFO</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; paramLI = <a href="../nodes/params.c.html#L292" title="nodes/params.c:292">RestoreParamList</a>(&amp;paramspace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create a QueryDesc for the query. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../tcop/pquery.c.html#L67" title="tcop/pquery.c:67">CreateQueryDesc</a>(pstmt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; queryString,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/time/snapmgr.c.html#L770" title="utils/time/snapmgr.c:770">GetActiveSnapshot</a>(), InvalidSnapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; receiver, paramLI, <span class="Constant">NULL</span>, instrument_options);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copy instrumentation information from this node and its descendants into<br/></li>
<li></span><span class="Comment"> * dynamic shared memory, so that the parallel leader can retrieve it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1268">&#x200c;</a></span><span class="linkable">ExecParallelReportInstrumentation</span>(PlanState *planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="executor/execParallel.c:97">SharedExecutorInstrumentation</a> *instrumentation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan_node_id = planstate-&gt;plan-&gt;plan_node_id;<br/></li>
<li>&nbsp; &nbsp; Instrumentation *instrument;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="instrument.c.html#L140" title="executor/instrument.c:140">InstrEndLoop</a>(planstate-&gt;instrument);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we shuffled the plan_node_id <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in ps_instrument into sorted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * order, we could use binary search here.&nbsp; This might matter someday if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're pushing down sufficiently large plan trees.&nbsp; For <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, do it the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slow, dumb way.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; instrumentation-&gt;num_plan_nodes; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (instrumentation-&gt;plan_node_id[i] == plan_node_id)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= instrumentation-&gt;num_plan_nodes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;plan node </span><span class="Special">%d</span><span class="Constant"> not found&quot;</span>, plan_node_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add our statistics to the per-node, per-worker totals.&nbsp; It's possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that this could happen more than once if we relaunched workers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; instrument = <a href="#L106" title="executor/execParallel.c:106">GetInstrumentationArray</a>(instrumentation);<br/></li>
<li>&nbsp; &nbsp; instrument += i * instrumentation-&gt;num_workers;<br/></li>
<li>&nbsp; &nbsp; Assert(IsParallelWorker());<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../access/transam/parallel.c.html#L112" title="access/transam/parallel.c:112">ParallelWorkerNumber</a> &lt; instrumentation-&gt;num_workers);<br/></li>
<li>&nbsp; &nbsp; <a href="instrument.c.html#L169" title="executor/instrument.c:169">InstrAggNode</a>(&amp;instrument[<a href="../access/transam/parallel.c.html#L112" title="access/transam/parallel.c:112">ParallelWorkerNumber</a>], planstate-&gt;instrument);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> planstate_tree_walker(planstate, <a href="#L1268" title="executor/execParallel.c:1268">ExecParallelReportInstrumentation</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; instrumentation);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize the PlanState and its descendants with the information<br/></li>
<li></span><span class="Comment"> * retrieved from shared memory.&nbsp; This has to be done once the PlanState<br/></li>
<li></span><span class="Comment"> * is allocated and initialized by executor; that is, after <a href="execMain.c.html#L124" title="executor/execMain.c:124">ExecutorStart</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1309">&#x200c;</a></span><span class="linkable">ExecParallelInitializeWorker</span>(PlanState *planstate, ParallelWorkerContext *pwcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (planstate == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(planstate))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SeqScanState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeSeqscan.c.html#L294" title="executor/nodeSeqscan.c:294">ExecSeqScanInitializeWorker</a>((SeqScanState *) planstate, pwcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexScanState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeIndexscan.c.html#L1710" title="executor/nodeIndexscan.c:1710">ExecIndexScanInitializeWorker</a>((IndexScanState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pwcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexOnlyScanState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeIndexonlyscan.c.html#L696" title="executor/nodeIndexonlyscan.c:696">ExecIndexOnlyScanInitializeWorker</a>((IndexOnlyScanState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pwcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ForeignScanState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeForeignscan.c.html#L418" title="executor/nodeForeignscan.c:418">ExecForeignScanInitializeWorker</a>((ForeignScanState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pwcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_AppendState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeAppend.c.html#L540" title="executor/nodeAppend.c:540">ExecAppendInitializeWorker</a>((AppendState *) planstate, pwcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CustomScanState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeCustom.c.html#L205" title="executor/nodeCustom.c:205">ExecCustomScanInitializeWorker</a>((CustomScanState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pwcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitmapHeapScanState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeBitmapHeapscan.c.html#L880" title="executor/nodeBitmapHeapscan.c:880">ExecBitmapHeapInitializeWorker</a>((BitmapHeapScanState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pwcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_HashJoinState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (planstate-&gt;plan-&gt;parallel_aware)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeHashjoin.c.html#L1641" title="executor/nodeHashjoin.c:1641">ExecHashJoinInitializeWorker</a>((HashJoinState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pwcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_HashState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* even when not parallel-aware, for EXPLAIN ANALYZE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeHash.c.html#L2778" title="executor/nodeHash.c:2778">ExecHashInitializeWorker</a>((HashState *) planstate, pwcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SortState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* even when not parallel-aware, for EXPLAIN ANALYZE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeSort.c.html#L462" title="executor/nodeSort.c:462">ExecSortInitializeWorker</a>((SortState *) planstate, pwcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IncrementalSortState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* even when not parallel-aware, for EXPLAIN ANALYZE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeIncrementalSort.c.html#L1219" title="executor/nodeIncrementalSort.c:1219">ExecIncrementalSortInitializeWorker</a>((IncrementalSortState *) planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pwcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_AggState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* even when not parallel-aware, for EXPLAIN ANALYZE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeAgg.c.html#L4729" title="executor/nodeAgg.c:4729">ExecAggInitializeWorker</a>((AggState *) planstate, pwcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_MemoizeState:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* even when not parallel-aware, for EXPLAIN ANALYZE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeMemoize.c.html#L1236" title="executor/nodeMemoize.c:1236">ExecMemoizeInitializeWorker</a>((MemoizeState *) planstate, pwcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> planstate_tree_walker(planstate, <a href="#L1309" title="executor/execParallel.c:1309">ExecParallelInitializeWorker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pwcxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Main entrypoint for parallel query worker processes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We reach this function from <a href="../access/transam/parallel.c.html#L1271" title="access/transam/parallel.c:1271">ParallelWorkerMain</a>, so the setup necessary to<br/></li>
<li></span><span class="Comment"> * create a sensible parallel environment has already been done;<br/></li>
<li></span><span class="Comment"> * <a href="../access/transam/parallel.c.html#L1271" title="access/transam/parallel.c:1271">ParallelWorkerMain</a> worries about stuff like the transaction state, combo<br/></li>
<li></span><span class="Comment"> * CID mappings, and GUC <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, so we don't need to deal with <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of that<br/></li>
<li></span><span class="Comment"> * here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Our job is to deal with concerns specific to the executor.&nbsp; The parallel<br/></li>
<li></span><span class="Comment"> * group leader will have stored a serialized PlannedStmt, and it's our job<br/></li>
<li></span><span class="Comment"> * to execute that plan and write the resulting tuples to the appropriate<br/></li>
<li></span><span class="Comment"> * tuple queue.&nbsp; Various bits of supporting information that we need in order<br/></li>
<li></span><span class="Comment"> * to do this are also stored in the <a href="../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> and can be accessed through<br/></li>
<li></span><span class="Comment"> * the <a href="../storage/ipc/shm_toc.c.html#L26" title="storage/ipc/shm_toc.c:26">shm_toc</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1400">&#x200c;</a></span><span class="linkable">ParallelQueryMain</span>(<a href="../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg, <a href="../storage/ipc/shm_toc.c.html#L26" title="storage/ipc/shm_toc.c:26">shm_toc</a> *toc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L73" title="executor/execParallel.c:73">FixedParallelExecutorState</a> *fpes;<br/></li>
<li>&nbsp; &nbsp; BufferUsage *buffer_usage;<br/></li>
<li>&nbsp; &nbsp; WalUsage&nbsp;&nbsp; *wal_usage;<br/></li>
<li>&nbsp; &nbsp; DestReceiver *receiver;<br/></li>
<li>&nbsp; &nbsp; QueryDesc&nbsp; *queryDesc;<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="executor/execParallel.c:97">SharedExecutorInstrumentation</a> *instrumentation;<br/></li>
<li>&nbsp; &nbsp; SharedJitInstrumentation *jit_instrumentation;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instrument_options = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *area_space;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a>&nbsp;&nbsp; *area;<br/></li>
<li>&nbsp; &nbsp; ParallelWorkerContext pwcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get fixed-size state. */<br/></li>
<li></span>&nbsp; &nbsp; fpes = <a href="../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L57" title="executor/execParallel.c:57">PARALLEL_KEY_EXECUTOR_FIXED</a>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up DestReceiver, <a href="#L97" title="executor/execParallel.c:97">SharedExecutorInstrumentation</a>, and QueryDesc. */<br/></li>
<li></span>&nbsp; &nbsp; receiver = <a href="#L1220" title="executor/execParallel.c:1220">ExecParallelGetReceiver</a>(seg, toc);<br/></li>
<li>&nbsp; &nbsp; instrumentation = <a href="../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L62" title="executor/execParallel.c:62">PARALLEL_KEY_INSTRUMENTATION</a>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (instrumentation != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instrument_options = instrumentation-&gt;instrument_options;<br/></li>
<li>&nbsp; &nbsp; jit_instrumentation = <a href="../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L65" title="executor/execParallel.c:65">PARALLEL_KEY_JIT_INSTRUMENTATION</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; queryDesc = <a href="#L1236" title="executor/execParallel.c:1236">ExecParallelGetQueryDesc</a>(toc, receiver, instrument_options);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Setting <a href="../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a> for individual workers */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a> = queryDesc-&gt;sourceText;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report workers' query for monitoring purposes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_RUNNING, <a href="../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Attach to the dynamic shared memory area. */<br/></li>
<li></span>&nbsp; &nbsp; area_space = <a href="../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L63" title="executor/execParallel.c:63">PARALLEL_KEY_DSA</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; area = <a href="../utils/mmgr/dsa.c.html#L545" title="utils/mmgr/dsa.c:545">dsa_attach_in_place</a>(area_space, seg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Start up the executor */<br/></li>
<li></span>&nbsp; &nbsp; queryDesc-&gt;plannedstmt-&gt;jitFlags = fpes-&gt;jit_flags;<br/></li>
<li>&nbsp; &nbsp; <a href="execMain.c.html#L124" title="executor/execMain.c:124">ExecutorStart</a>(queryDesc, fpes-&gt;eflags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Special executor initialization steps for parallel workers */<br/></li>
<li></span>&nbsp; &nbsp; queryDesc-&gt;planstate-&gt;state-&gt;es_query_dsa = area;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DsaPointerIsValid(fpes-&gt;param_exec))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *paramexec_space;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; paramexec_space = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, fpes-&gt;param_exec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L409" title="executor/execParallel.c:409">RestoreParamExecParams</a>(paramexec_space, queryDesc-&gt;estate);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pwcxt.toc = toc;<br/></li>
<li>&nbsp; &nbsp; pwcxt.seg = seg;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1309" title="executor/execParallel.c:1309">ExecParallelInitializeWorker</a>(queryDesc-&gt;planstate, &amp;pwcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pass down <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuple bound */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execProcnode.c.html#L843" title="executor/execProcnode.c:843">ExecSetTupleBound</a>(fpes-&gt;tuples_needed, queryDesc-&gt;planstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare to track buffer/WAL usage during query execution.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do this after starting up the executor to match what happens in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leader, which also doesn't count buffer accesses and WAL activity that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * occur during executor startup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="instrument.c.html#L200" title="executor/instrument.c:200">InstrStartParallelQuery</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Run the plan.&nbsp; If we specified a tuple bound, be careful not to demand<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more tuples than that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execMain.c.html#L297" title="executor/execMain.c:297">ExecutorRun</a>(queryDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForwardScanDirection,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fpes-&gt;tuples_needed &lt; <span class="Constant">0</span> ? (int64) <span class="Constant">0</span> : fpes-&gt;tuples_needed,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shut down the executor */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execMain.c.html#L407" title="executor/execMain.c:407">ExecutorFinish</a>(queryDesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report buffer/WAL usage during parallel execution. */<br/></li>
<li></span>&nbsp; &nbsp; buffer_usage = <a href="../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L60" title="executor/execParallel.c:60">PARALLEL_KEY_BUFFER_USAGE</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; wal_usage = <a href="../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L66" title="executor/execParallel.c:66">PARALLEL_KEY_WAL_USAGE</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="instrument.c.html#L208" title="executor/instrument.c:208">InstrEndParallelQuery</a>(&amp;buffer_usage[<a href="../access/transam/parallel.c.html#L112" title="access/transam/parallel.c:112">ParallelWorkerNumber</a>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;wal_usage[<a href="../access/transam/parallel.c.html#L112" title="access/transam/parallel.c:112">ParallelWorkerNumber</a>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report instrumentation data if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> instrumentation options are set. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (instrumentation != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1268" title="executor/execParallel.c:1268">ExecParallelReportInstrumentation</a>(queryDesc-&gt;planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instrumentation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report JIT instrumentation data if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (queryDesc-&gt;estate-&gt;es_jit &amp;&amp; jit_instrumentation != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../access/transam/parallel.c.html#L112" title="access/transam/parallel.c:112">ParallelWorkerNumber</a> &lt; jit_instrumentation-&gt;num_workers);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jit_instrumentation-&gt;jit_instr[<a href="../access/transam/parallel.c.html#L112" title="access/transam/parallel.c:112">ParallelWorkerNumber</a>] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryDesc-&gt;estate-&gt;es_jit-&gt;instr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must do this after capturing instrumentation. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execMain.c.html#L467" title="executor/execMain.c:467">ExecutorEnd</a>(queryDesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cleanup. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/dsa.c.html#L1952" title="utils/mmgr/dsa.c:1952">dsa_detach</a>(area);<br/></li>
<li>&nbsp; &nbsp; <a href="../tcop/pquery.c.html#L105" title="tcop/pquery.c:105">FreeQueryDesc</a>(queryDesc);<br/></li>
<li>&nbsp; &nbsp; receiver-&gt;rDestroy(receiver);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
