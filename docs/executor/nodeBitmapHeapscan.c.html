<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>executor/nodeBitmapHeapscan.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>executor/nodeBitmapHeapscan.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L344">BitmapAdjustPrefetchIterator</a></li>
<li><a href="#L409">BitmapAdjustPrefetchTarget</a></li>
<li><a href="#L332">BitmapDoneInitializingSharedState</a></li>
<li><a href="#L69">BitmapHeapNext</a></li>
<li><a href="#L548">BitmapHeapRecheck</a></li>
<li><a href="#L448">BitmapPrefetch</a></li>
<li><a href="#L770">BitmapShouldInitializeSharedState</a></li>
<li><a href="#L803">ExecBitmapHeapEstimate</a></li>
<li><a href="#L817">ExecBitmapHeapInitializeDSM</a></li>
<li><a href="#L880">ExecBitmapHeapInitializeWorker</a></li>
<li><a href="#L851">ExecBitmapHeapReInitializeDSM</a></li>
<li><a href="#L567">ExecBitmapHeapScan</a></li>
<li><a href="#L626">ExecEndBitmapHeapScan</a></li>
<li><a href="#L671">ExecInitBitmapHeapScan</a></li>
<li><a href="#L581">ExecReScanBitmapHeapScan</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * nodeBitmapHeapscan.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines to support bitmapped scans of relations<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: it is critical that this plan type only be used with MVCC-compliant<br/></li>
<li></span><span class="Comment"> * snapshots (ie, regular snapshots, not SnapshotAny or one of the other<br/></li>
<li></span><span class="Comment"> * special snapshots).&nbsp; The reason is that since index and heap scans are<br/></li>
<li></span><span class="Comment"> * decoupled, there can be no assurance that the index tuple prompting a<br/></li>
<li></span><span class="Comment"> * visit to a particular heap TID still exists when the visit is made.<br/></li>
<li></span><span class="Comment"> * Therefore the tuple might not exist anymore either (which is OK because<br/></li>
<li></span><span class="Comment"> * <a href="../access/heap/heapam.c.html#L1507" title="access/heap/heapam.c:1507">heap_fetch</a> will cope) --- but worse, the tuple slot could have been<br/></li>
<li></span><span class="Comment"> * re-used for a newer tuple.&nbsp; With an MVCC snapshot the newer tuple is<br/></li>
<li></span><span class="Comment"> * certain to fail the time qual and so it will not be mistakenly returned,<br/></li>
<li></span><span class="Comment"> * but with anything else we might return a tuple that doesn't meet the<br/></li>
<li></span><span class="Comment"> * required index qual conditions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/executor/nodeBitmapHeapscan.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * INTERFACE ROUTINES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L567" title="executor/nodeBitmapHeapscan.c:567">ExecBitmapHeapScan</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scans a relation using bitmap info<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ExecBitmapHeapNext&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workhorse for above<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L671" title="executor/nodeBitmapHeapscan.c:671">ExecInitBitmapHeapScan</a>&nbsp; &nbsp; &nbsp; &nbsp; creates and initializes state info.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L581" title="executor/nodeBitmapHeapscan.c:581">ExecReScanBitmapHeapScan</a>&nbsp; &nbsp; prepares to rescan the plan.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L626" title="executor/nodeBitmapHeapscan.c:626">ExecEndBitmapHeapScan</a>&nbsp; &nbsp; &nbsp; &nbsp; releases all storage.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/relscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tableam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/visibilitymap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeBitmapHeapscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/spccache.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> TupleTableSlot *<a href="#L69" title="executor/nodeBitmapHeapscan.c:69">BitmapHeapNext</a>(BitmapHeapScanState *node);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L332" title="executor/nodeBitmapHeapscan.c:332">BitmapDoneInitializingSharedState</a>(ParallelBitmapHeapState *pstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L344" title="executor/nodeBitmapHeapscan.c:344">BitmapAdjustPrefetchIterator</a>(BitmapHeapScanState *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blockno);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L409" title="executor/nodeBitmapHeapscan.c:409">BitmapAdjustPrefetchTarget</a>(BitmapHeapScanState *node);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L448" title="executor/nodeBitmapHeapscan.c:448">BitmapPrefetch</a>(BitmapHeapScanState *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TableScanDesc scan);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L770" title="executor/nodeBitmapHeapscan.c:770">BitmapShouldInitializeSharedState</a>(ParallelBitmapHeapState *pstate);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L69" title="executor/nodeBitmapHeapscan.c:69">BitmapHeapNext</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Retrieve <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple from the BitmapHeapScan node's currentRelation<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TupleTableSlot *<br/></li>
<li><a id="L69">&#x200c;</a><span class="linkable">BitmapHeapNext</span>(BitmapHeapScanState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li>&nbsp; &nbsp; TableScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a>&nbsp; *tbm;<br/></li>
<li>&nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L178" title="nodes/tidbitmap.c:178">TBMIterator</a> *tbmiterator = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L219" title="nodes/tidbitmap.c:219">TBMSharedIterator</a> *shared_tbmiterator = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; TBMIterateResult *tbmres;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li>&nbsp; &nbsp; ParallelBitmapHeapState *pstate = node-&gt;pstate;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a>&nbsp;&nbsp; *dsa = node-&gt;ss.ps.state-&gt;es_query_dsa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extract necessary information from index scan node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; econtext = node-&gt;ss.ps.ps_ExprContext;<br/></li>
<li>&nbsp; &nbsp; slot = node-&gt;ss.ss_ScanTupleSlot;<br/></li>
<li>&nbsp; &nbsp; scan = node-&gt;ss.ss_currentScanDesc;<br/></li>
<li>&nbsp; &nbsp; tbm = node-&gt;tbm;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pstate == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tbmiterator = node-&gt;tbmiterator;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; shared_tbmiterator = node-&gt;shared_tbmiterator;<br/></li>
<li>&nbsp; &nbsp; tbmres = node-&gt;tbmres;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we haven't yet performed the underlying index scan, do it, and begin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the iteration over the bitmap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For prefetching, we use *two* iterators, one for the pages we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * actually scanning and another that runs ahead of the first for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prefetching.&nbsp; node-&gt;prefetch_pages tracks exactly how many pages ahead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the prefetch iterator is.&nbsp; Also, node-&gt;prefetch_target tracks the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * desired prefetch distance, which starts small and increases up to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * node-&gt;prefetch_maximum.&nbsp; This is to avoid doing a lot of prefetching in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a scan that stops after a few tuples because of a LIMIT.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!node-&gt;initialized)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pstate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tbm = (<a href="../nodes/tidbitmap.c.html#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *) <a href="execProcnode.c.html#L502" title="executor/execProcnode.c:502">MultiExecProcNode</a>(outerPlanState(node));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tbm || !IsA(tbm, <a href="../nodes/tidbitmap.c.html#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized result from subplan&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;tbm = tbm;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;tbmiterator = tbmiterator = <a href="../nodes/tidbitmap.c.html#L689" title="nodes/tidbitmap.c:689">tbm_begin_iterate</a>(tbm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;tbmres = tbmres = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_PREFETCH<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;prefetch_maximum &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;prefetch_iterator = <a href="../nodes/tidbitmap.c.html#L689" title="nodes/tidbitmap.c:689">tbm_begin_iterate</a>(tbm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;prefetch_pages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;prefetch_target = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_PREFETCH */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The leader will immediately come out of the function, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * others will be blocked until leader populates the TBM and wakes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L770" title="executor/nodeBitmapHeapscan.c:770">BitmapShouldInitializeSharedState</a>(pstate))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tbm = (<a href="../nodes/tidbitmap.c.html#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *) <a href="execProcnode.c.html#L502" title="executor/execProcnode.c:502">MultiExecProcNode</a>(outerPlanState(node));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tbm || !IsA(tbm, <a href="../nodes/tidbitmap.c.html#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized result from subplan&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;tbm = tbm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Prepare to iterate over the TBM. This will return the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dsa_pointer of the iterator state which will be used by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multiple processes to iterate jointly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;tbmiterator = <a href="../nodes/tidbitmap.c.html#L766" title="nodes/tidbitmap.c:766">tbm_prepare_shared_iterate</a>(tbm);<br/></li>
<li><span class="PreProc">#ifdef USE_PREFETCH<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;prefetch_maximum &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;prefetch_iterator =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L766" title="nodes/tidbitmap.c:766">tbm_prepare_shared_iterate</a>(tbm);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't need the mutex here as we haven't yet woke up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * others.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;prefetch_pages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;prefetch_target = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have initialized the shared state so wake up others. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L332" title="executor/nodeBitmapHeapscan.c:332">BitmapDoneInitializingSharedState</a>(pstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allocate a private iterator and attach the shared state to it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;shared_tbmiterator = shared_tbmiterator =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L1461" title="nodes/tidbitmap.c:1461">tbm_attach_shared_iterate</a>(dsa, pstate-&gt;tbmiterator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;tbmres = tbmres = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_PREFETCH<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;prefetch_maximum &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;shared_prefetch_iterator =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L1461" title="nodes/tidbitmap.c:1461">tbm_attach_shared_iterate</a>(dsa, pstate-&gt;prefetch_iterator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_PREFETCH */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is the first scan of the underlying table, create the table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan descriptor and begin the scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!scan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; need_tuples = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can potentially <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> fetching heap pages if we do not need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> columns of the table, either for checking non-indexable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * quals or for returning data.&nbsp; This test is a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> simplistic, as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it checks the stronger condition that there's no qual or return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tlist at all. But in most cases it's probably not worth working<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * harder than that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; need_tuples = (node-&gt;ss.ps.plan-&gt;qual != NIL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ss.ps.plan-&gt;targetlist != NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan = table_beginscan_bm(node-&gt;ss.ss_currentRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;ss.ps.state-&gt;es_snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; need_tuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;ss.ss_currentScanDesc = scan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;initialized = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; valid_block;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page of results if needed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tbmres == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pstate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;tbmres = tbmres = <a href="../nodes/tidbitmap.c.html#L971" title="nodes/tidbitmap.c:971">tbm_iterate</a>(tbmiterator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;tbmres = tbmres = <a href="../nodes/tidbitmap.c.html#L1052" title="nodes/tidbitmap.c:1052">tbm_shared_iterate</a>(shared_tbmiterator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tbmres == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no more entries in the bitmap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L344" title="executor/nodeBitmapHeapscan.c:344">BitmapAdjustPrefetchIterator</a>(node, tbmres-&gt;blockno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valid_block = table_scan_bitmap_next_block(scan, tbmres);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tbmres-&gt;ntuples &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;exact_pages++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;lossy_pages++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!valid_block)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* AM doesn't think this block is valid, <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust the prefetch target */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L409" title="executor/nodeBitmapHeapscan.c:409">BitmapAdjustPrefetchTarget</a>(node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Continuing in previously obtained page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef USE_PREFETCH<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to prefetch at least a few pages even <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we get to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * second page if we don't stop reading after the first tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pstate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;prefetch_target &lt; node-&gt;prefetch_maximum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;prefetch_target++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pstate-&gt;prefetch_target &lt; node-&gt;prefetch_maximum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* take spinlock while updating shared state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;pstate-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstate-&gt;prefetch_target &lt; node-&gt;prefetch_maximum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;prefetch_target++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;pstate-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_PREFETCH */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We issue prefetch requests *after* fetching the current page to try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to avoid having prefetching interfere with the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> I/O. Also, this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should happen only when we have determined there is still something<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to do on the current page, else we may uselessly prefetch the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page we are just about to request for real.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L448" title="executor/nodeBitmapHeapscan.c:448">BitmapPrefetch</a>(node, scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Attempt to fetch tuple from AM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!table_scan_bitmap_next_tuple(scan, tbmres, slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing more to look at on this page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;tbmres = tbmres = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are using lossy info, we have to recheck the qual conditions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at every tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tbmres-&gt;recheck)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_scantuple = slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ExecQualAndReset(node-&gt;bitmapqualorig, econtext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fails recheck, so drop it and loop back for another */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InstrCountFiltered2(node, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK to return this tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> slot;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we get here it means we are at the end of the scan..<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> ExecClearTuple(slot);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L332" title="executor/nodeBitmapHeapscan.c:332">BitmapDoneInitializingSharedState</a> - Shared state is initialized<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; By this time the leader has already populated the TBM and initialized the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; shared state so wake up other processes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L332">&#x200c;</a></span><span class="linkable">BitmapDoneInitializingSharedState</span>(ParallelBitmapHeapState *pstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;pstate-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; pstate-&gt;state = BM_FINISHED;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;pstate-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L282" title="storage/lmgr/condition_variable.c:282">ConditionVariableBroadcast</a>(&amp;pstate-&gt;cv);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L344" title="executor/nodeBitmapHeapscan.c:344">BitmapAdjustPrefetchIterator</a> - Adjust the prefetch iterator<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L344">&#x200c;</a></span><span class="linkable">BitmapAdjustPrefetchIterator</span>(BitmapHeapScanState *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber blockno)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_PREFETCH<br/></li>
<li></span>&nbsp; &nbsp; ParallelBitmapHeapState *pstate = node-&gt;pstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pstate == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L178" title="nodes/tidbitmap.c:178">TBMIterator</a> *prefetch_iterator = node-&gt;prefetch_iterator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;prefetch_pages &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> iterator has closed the distance by one page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;prefetch_pages--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (prefetch_iterator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do not let the prefetch iterator get behind the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TBMIterateResult *tbmpre = <a href="../nodes/tidbitmap.c.html#L971" title="nodes/tidbitmap.c:971">tbm_iterate</a>(prefetch_iterator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tbmpre == <span class="Constant">NULL</span> || tbmpre-&gt;blockno != blockno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;prefetch and <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> iterators are out of sync&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;prefetch_maximum &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L219" title="nodes/tidbitmap.c:219">TBMSharedIterator</a> *prefetch_iterator = node-&gt;shared_prefetch_iterator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;pstate-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstate-&gt;prefetch_pages &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;prefetch_pages--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;pstate-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release the mutex <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> iterating */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;pstate-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In case of shared mode, we can not ensure that the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * blockno of the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> iterator and that of the prefetch iterator<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are same.&nbsp; It's possible that whatever blockno we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prefetching will be processed by another process.&nbsp; Therefore,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we don't validate the blockno here as we do in non-parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prefetch_iterator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L1052" title="nodes/tidbitmap.c:1052">tbm_shared_iterate</a>(prefetch_iterator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_PREFETCH */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L409" title="executor/nodeBitmapHeapscan.c:409">BitmapAdjustPrefetchTarget</a> - Adjust the prefetch target<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Increase prefetch target if it's not yet at the max.&nbsp; Note that<br/></li>
<li></span><span class="Comment"> * we will increase it to zero after fetching the very first<br/></li>
<li></span><span class="Comment"> * page/tuple, then to one after the second tuple is fetched, then<br/></li>
<li></span><span class="Comment"> * it doubles as later pages are fetched.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L409">&#x200c;</a></span><span class="linkable">BitmapAdjustPrefetchTarget</span>(BitmapHeapScanState *node)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_PREFETCH<br/></li>
<li></span>&nbsp; &nbsp; ParallelBitmapHeapState *pstate = node-&gt;pstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pstate == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;prefetch_target &gt;= node-&gt;prefetch_maximum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* don't increase <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> further */</span> ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (node-&gt;prefetch_target &gt;= node-&gt;prefetch_maximum / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;prefetch_target = node-&gt;prefetch_maximum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (node-&gt;prefetch_target &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;prefetch_target *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;prefetch_target++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do an unlocked check first to save spinlock acquisitions. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pstate-&gt;prefetch_target &lt; node-&gt;prefetch_maximum)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;pstate-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstate-&gt;prefetch_target &gt;= node-&gt;prefetch_maximum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* don't increase <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> further */</span> ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pstate-&gt;prefetch_target &gt;= node-&gt;prefetch_maximum / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;prefetch_target = node-&gt;prefetch_maximum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pstate-&gt;prefetch_target &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;prefetch_target *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;prefetch_target++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;pstate-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_PREFETCH */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L448" title="executor/nodeBitmapHeapscan.c:448">BitmapPrefetch</a> - Prefetch, if prefetch_pages are behind prefetch_target<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L448">&#x200c;</a></span><span class="linkable">BitmapPrefetch</span>(BitmapHeapScanState *node, TableScanDesc scan)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_PREFETCH<br/></li>
<li></span>&nbsp; &nbsp; ParallelBitmapHeapState *pstate = node-&gt;pstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pstate == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L178" title="nodes/tidbitmap.c:178">TBMIterator</a> *prefetch_iterator = node-&gt;prefetch_iterator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prefetch_iterator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (node-&gt;prefetch_pages &lt; node-&gt;prefetch_target)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TBMIterateResult *tbmpre = <a href="../nodes/tidbitmap.c.html#L971" title="nodes/tidbitmap.c:971">tbm_iterate</a>(prefetch_iterator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; skip_fetch;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tbmpre == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No more pages to prefetch */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L1146" title="nodes/tidbitmap.c:1146">tbm_end_iterate</a>(prefetch_iterator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;prefetch_iterator = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;prefetch_pages++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we expect not to have to actually read this heap page,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this prefetch call, but continue to run the prefetch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * logic normally.&nbsp; (Would it be better not to increment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prefetch_pages?)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skip_fetch = (!(scan-&gt;rs_flags &amp; SO_NEED_TUPLES) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !tbmpre-&gt;recheck &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VM_ALL_VISIBLE(node-&gt;ss.ss_currentRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tbmpre-&gt;blockno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;node-&gt;pvmbuffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!skip_fetch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L638" title="storage/buffer/bufmgr.c:638">PrefetchBuffer</a>(scan-&gt;rs_rd, MAIN_FORKNUM, tbmpre-&gt;blockno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pstate-&gt;prefetch_pages &lt; pstate-&gt;prefetch_target)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L219" title="nodes/tidbitmap.c:219">TBMSharedIterator</a> *prefetch_iterator = node-&gt;shared_prefetch_iterator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prefetch_iterator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TBMIterateResult *tbmpre;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; do_prefetch = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; skip_fetch;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Recheck under the mutex. If some other process has already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * done enough prefetching then we need not to do anything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;pstate-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstate-&gt;prefetch_pages &lt; pstate-&gt;prefetch_target)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;prefetch_pages++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do_prefetch = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;pstate-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!do_prefetch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tbmpre = <a href="../nodes/tidbitmap.c.html#L1052" title="nodes/tidbitmap.c:1052">tbm_shared_iterate</a>(prefetch_iterator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tbmpre == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No more pages to prefetch */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L1158" title="nodes/tidbitmap.c:1158">tbm_end_shared_iterate</a>(prefetch_iterator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;shared_prefetch_iterator = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* As above, <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> prefetch if we expect not to need page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skip_fetch = (!(scan-&gt;rs_flags &amp; SO_NEED_TUPLES) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !tbmpre-&gt;recheck &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VM_ALL_VISIBLE(node-&gt;ss.ss_currentRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tbmpre-&gt;blockno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;node-&gt;pvmbuffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!skip_fetch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L638" title="storage/buffer/bufmgr.c:638">PrefetchBuffer</a>(scan-&gt;rs_rd, MAIN_FORKNUM, tbmpre-&gt;blockno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_PREFETCH */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L548" title="executor/nodeBitmapHeapscan.c:548">BitmapHeapRecheck</a> -- access method routine to recheck a tuple in <a href="execMain.c.html#L2470" title="executor/execMain.c:2470">EvalPlanQual</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L548">&#x200c;</a></span><span class="linkable">BitmapHeapRecheck</span>(BitmapHeapScanState *node, TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extract necessary information from index scan node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; econtext = node-&gt;ss.ps.ps_ExprContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Does the tuple meet the original qual conditions? */<br/></li>
<li></span>&nbsp; &nbsp; econtext-&gt;ecxt_scantuple = slot;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ExecQualAndReset(node-&gt;bitmapqualorig, econtext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L567" title="executor/nodeBitmapHeapscan.c:567">ExecBitmapHeapScan</a>(node)<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TupleTableSlot *<br/></li>
<li><a id="L567">&#x200c;</a><span class="linkable">ExecBitmapHeapScan</span>(PlanState *pstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BitmapHeapScanState *node = castNode(BitmapHeapScanState, pstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="execScan.c.html#L156" title="executor/execScan.c:156">ExecScan</a>(&amp;node-&gt;ss,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ExecScanAccessMtd) <a href="#L69" title="executor/nodeBitmapHeapscan.c:69">BitmapHeapNext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ExecScanRecheckMtd) <a href="#L548" title="executor/nodeBitmapHeapscan.c:548">BitmapHeapRecheck</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L581" title="executor/nodeBitmapHeapscan.c:581">ExecReScanBitmapHeapScan</a>(node)<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L581">&#x200c;</a></span><span class="linkable">ExecReScanBitmapHeapScan</span>(BitmapHeapScanState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlanState&nbsp; *outerPlan = outerPlanState(node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* rescan to release <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> page pin */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;ss.ss_currentScanDesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; table_rescan(node-&gt;ss.ss_currentScanDesc, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* release bitmaps and buffers if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;tbmiterator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L1146" title="nodes/tidbitmap.c:1146">tbm_end_iterate</a>(node-&gt;tbmiterator);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;prefetch_iterator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L1146" title="nodes/tidbitmap.c:1146">tbm_end_iterate</a>(node-&gt;prefetch_iterator);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;shared_tbmiterator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L1158" title="nodes/tidbitmap.c:1158">tbm_end_shared_iterate</a>(node-&gt;shared_tbmiterator);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;shared_prefetch_iterator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L1158" title="nodes/tidbitmap.c:1158">tbm_end_shared_iterate</a>(node-&gt;shared_prefetch_iterator);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;tbm)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L322" title="nodes/tidbitmap.c:322">tbm_free</a>(node-&gt;tbm);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;pvmbuffer != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(node-&gt;pvmbuffer);<br/></li>
<li>&nbsp; &nbsp; node-&gt;tbm = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;tbmiterator = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;tbmres = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;prefetch_iterator = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;initialized = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;shared_tbmiterator = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;shared_prefetch_iterator = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;pvmbuffer = InvalidBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="execScan.c.html#L297" title="executor/execScan.c:297">ExecScanReScan</a>(&amp;node-&gt;ss);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if chgParam of subnode is not null then plan will be re-scanned by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first ExecProcNode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (outerPlan-&gt;chgParam == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execAmi.c.html#L76" title="executor/execAmi.c:76">ExecReScan</a>(outerPlan);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L626" title="executor/nodeBitmapHeapscan.c:626">ExecEndBitmapHeapScan</a><br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L626">&#x200c;</a></span><span class="linkable">ExecEndBitmapHeapScan</span>(BitmapHeapScanState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TableScanDesc scanDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extract information from the node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; scanDesc = node-&gt;ss.ss_currentScanDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * close down subplans<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execProcnode.c.html#L557" title="executor/execProcnode.c:557">ExecEndNode</a>(outerPlanState(node));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * release bitmaps and buffers if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;tbmiterator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L1146" title="nodes/tidbitmap.c:1146">tbm_end_iterate</a>(node-&gt;tbmiterator);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;prefetch_iterator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L1146" title="nodes/tidbitmap.c:1146">tbm_end_iterate</a>(node-&gt;prefetch_iterator);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;tbm)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L322" title="nodes/tidbitmap.c:322">tbm_free</a>(node-&gt;tbm);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;shared_tbmiterator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L1158" title="nodes/tidbitmap.c:1158">tbm_end_shared_iterate</a>(node-&gt;shared_tbmiterator);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;shared_prefetch_iterator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L1158" title="nodes/tidbitmap.c:1158">tbm_end_shared_iterate</a>(node-&gt;shared_prefetch_iterator);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;pvmbuffer != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(node-&gt;pvmbuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * close heap scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scanDesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; table_endscan(scanDesc);<br/></li>
<li><br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L671" title="executor/nodeBitmapHeapscan.c:671">ExecInitBitmapHeapScan</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Initializes the scan's state information.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BitmapHeapScanState *<br/></li>
<li><a id="L671">&#x200c;</a><span class="linkable">ExecInitBitmapHeapScan</span>(BitmapHeapScan *node, EState *estate, <span class="Type">int</span> eflags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BitmapHeapScanState *scanstate;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; currentRelation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for unsupported flags */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!(eflags &amp; (EXEC_FLAG_BACKWARD | EXEC_FLAG_MARK)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Assert caller didn't ask for an unsafe snapshot --- see comments at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * head of file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(IsMVCCSnapshot(estate-&gt;es_snapshot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create state structure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; scanstate = makeNode(BitmapHeapScanState);<br/></li>
<li>&nbsp; &nbsp; scanstate-&gt;ss.ps.plan = (Plan *) node;<br/></li>
<li>&nbsp; &nbsp; scanstate-&gt;ss.ps.state = estate;<br/></li>
<li>&nbsp; &nbsp; scanstate-&gt;ss.ps.ExecProcNode = <a href="#L567" title="executor/nodeBitmapHeapscan.c:567">ExecBitmapHeapScan</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scanstate-&gt;tbm = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; scanstate-&gt;tbmiterator = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; scanstate-&gt;tbmres = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; scanstate-&gt;pvmbuffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; scanstate-&gt;exact_pages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; scanstate-&gt;lossy_pages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; scanstate-&gt;prefetch_iterator = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; scanstate-&gt;prefetch_pages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; scanstate-&gt;prefetch_target = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; scanstate-&gt;initialized = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; scanstate-&gt;shared_tbmiterator = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; scanstate-&gt;shared_prefetch_iterator = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; scanstate-&gt;pstate = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Miscellaneous initialization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create expression context for node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execUtils.c.html#L483" title="executor/execUtils.c:483">ExecAssignExprContext</a>(estate, &amp;scanstate-&gt;ss.ps);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * open the scan relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; currentRelation = <a href="execUtils.c.html#L697" title="executor/execUtils.c:697">ExecOpenScanRelation</a>(estate, node-&gt;scan.scanrelid, eflags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> child nodes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; outerPlanState(scanstate) = <a href="execProcnode.c.html#L142" title="executor/execProcnode.c:142">ExecInitNode</a>(outerPlan(node), estate, eflags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get the scan type from the relation descriptor.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execTuples.c.html#L1898" title="executor/execTuples.c:1898">ExecInitScanTupleSlot</a>(estate, &amp;scanstate-&gt;ss,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetDescr(currentRelation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/tableam.c.html#L58" title="access/table/tableam.c:58">table_slot_callbacks</a>(currentRelation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize result type and projection.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execTuples.c.html#L1842" title="executor/execTuples.c:1842">ExecInitResultTypeTL</a>(&amp;scanstate-&gt;ss.ps);<br/></li>
<li>&nbsp; &nbsp; <a href="execScan.c.html#L270" title="executor/execScan.c:270">ExecAssignScanProjectionInfo</a>(&amp;scanstate-&gt;ss);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> child expressions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; scanstate-&gt;ss.ps.qual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execExpr.c.html#L220" title="executor/execExpr.c:220">ExecInitQual</a>(node-&gt;scan.plan.qual, (PlanState *) scanstate);<br/></li>
<li>&nbsp; &nbsp; scanstate-&gt;bitmapqualorig =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execExpr.c.html#L220" title="executor/execExpr.c:220">ExecInitQual</a>(node-&gt;bitmapqualorig, (PlanState *) scanstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Maximum number of prefetches for the tablespace if configured,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise the current value of the <a href="../storage/buffer/bufmgr.c.html#L150" title="storage/buffer/bufmgr.c:150">effective_io_concurrency</a> GUC.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; scanstate-&gt;prefetch_maximum =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/spccache.c.html#L215" title="utils/cache/spccache.c:215">get_tablespace_io_concurrency</a>(currentRelation-&gt;rd_rel-&gt;reltablespace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scanstate-&gt;ss.ss_currentRelation = currentRelation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> scanstate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L770" title="executor/nodeBitmapHeapscan.c:770">BitmapShouldInitializeSharedState</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The first process to come here and see the state to the BM_INITIAL<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; will become the leader for the parallel bitmap scan and will be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; responsible for populating the <a href="../nodes/tidbitmap.c.html#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a>.&nbsp; The other processes will<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; be blocked by the condition variable until the leader wakes them up.<br/></li>
<li></span><span class="Comment"> * ---------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L770">&#x200c;</a></span><span class="linkable">BitmapShouldInitializeSharedState</span>(ParallelBitmapHeapState *pstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SharedBitmapState state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;pstate-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state = pstate-&gt;state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstate-&gt;state == BM_INITIAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;state = BM_INPROGRESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;pstate-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Exit if bitmap is done, or if we're the leader. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state != BM_INPROGRESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wait for the leader to wake us up. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L96" title="storage/lmgr/condition_variable.c:96">ConditionVariableSleep</a>(&amp;pstate-&gt;cv, WAIT_EVENT_PARALLEL_BITMAP_SCAN);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (state == BM_INITIAL);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L803" title="executor/nodeBitmapHeapscan.c:803">ExecBitmapHeapEstimate</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Compute the amount of space we'll need in the parallel<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; query DSM, and inform pcxt-&gt;estimator about our needs.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L803">&#x200c;</a></span><span class="linkable">ExecBitmapHeapEstimate</span>(BitmapHeapScanState *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ParallelContext *pcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ParallelBitmapHeapState));<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L817" title="executor/nodeBitmapHeapscan.c:817">ExecBitmapHeapInitializeDSM</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set up a parallel bitmap heap scan descriptor.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L817">&#x200c;</a></span><span class="linkable">ExecBitmapHeapInitializeDSM</span>(BitmapHeapScanState *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParallelContext *pcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParallelBitmapHeapState *pstate;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a>&nbsp;&nbsp; *dsa = node-&gt;ss.ps.state-&gt;es_query_dsa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there's no DSA, there are no workers; <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> nothing. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dsa == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pstate = <a href="../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ParallelBitmapHeapState));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pstate-&gt;tbmiterator = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pstate-&gt;prefetch_iterator = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the mutex */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockInit(&amp;pstate-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; pstate-&gt;prefetch_pages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pstate-&gt;prefetch_target = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pstate-&gt;state = BM_INITIAL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L35" title="storage/lmgr/condition_variable.c:35">ConditionVariableInit</a>(&amp;pstate-&gt;cv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, node-&gt;ss.ps.plan-&gt;plan_node_id, pstate);<br/></li>
<li>&nbsp; &nbsp; node-&gt;pstate = pstate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L851" title="executor/nodeBitmapHeapscan.c:851">ExecBitmapHeapReInitializeDSM</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Reset shared state <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> beginning a fresh scan.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L851">&#x200c;</a></span><span class="linkable">ExecBitmapHeapReInitializeDSM</span>(BitmapHeapScanState *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParallelContext *pcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParallelBitmapHeapState *pstate = node-&gt;pstate;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a>&nbsp;&nbsp; *dsa = node-&gt;ss.ps.state-&gt;es_query_dsa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there's no DSA, there are no workers; do nothing. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dsa == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pstate-&gt;state = BM_INITIAL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DsaPointerIsValid(pstate-&gt;tbmiterator))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L341" title="nodes/tidbitmap.c:341">tbm_free_shared_area</a>(dsa, pstate-&gt;tbmiterator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DsaPointerIsValid(pstate-&gt;prefetch_iterator))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/tidbitmap.c.html#L341" title="nodes/tidbitmap.c:341">tbm_free_shared_area</a>(dsa, pstate-&gt;prefetch_iterator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pstate-&gt;tbmiterator = InvalidDsaPointer;<br/></li>
<li>&nbsp; &nbsp; pstate-&gt;prefetch_iterator = InvalidDsaPointer;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L880" title="executor/nodeBitmapHeapscan.c:880">ExecBitmapHeapInitializeWorker</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Copy relevant information from TOC into planstate.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L880">&#x200c;</a></span><span class="linkable">ExecBitmapHeapInitializeWorker</span>(BitmapHeapScanState *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ParallelWorkerContext *pwcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParallelBitmapHeapState *pstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(node-&gt;ss.ps.state-&gt;es_query_dsa != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pstate = <a href="../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(pwcxt-&gt;toc, node-&gt;ss.ps.plan-&gt;plan_node_id, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; node-&gt;pstate = pstate;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
