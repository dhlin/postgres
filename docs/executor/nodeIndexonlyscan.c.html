<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>executor/nodeIndexonlyscan.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>executor/nodeIndexonlyscan.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L364">ExecEndIndexOnlyScan</a></li>
<li><a href="#L399">ExecIndexOnlyMarkPos</a></li>
<li><a href="#L436">ExecIndexOnlyRestrPos</a></li>
<li><a href="#L302">ExecIndexOnlyScan</a></li>
<li><a href="#L625">ExecIndexOnlyScanEstimate</a></li>
<li><a href="#L645">ExecIndexOnlyScanInitializeDSM</a></li>
<li><a href="#L696">ExecIndexOnlyScanInitializeWorker</a></li>
<li><a href="#L683">ExecIndexOnlyScanReInitializeDSM</a></li>
<li><a href="#L472">ExecInitIndexOnlyScan</a></li>
<li><a href="#L329">ExecReScanIndexOnlyScan</a></li>
<li><a href="#L59">IndexOnlyNext</a></li>
<li><a href="#L291">IndexOnlyRecheck</a></li>
<li><a href="#L266">StoreIndexTuple</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * nodeIndexonlyscan.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines to support index-only scans<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/executor/nodeIndexonlyscan.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * INTERFACE ROUTINES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L302" title="executor/nodeIndexonlyscan.c:302">ExecIndexOnlyScan</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scans an index<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L59" title="executor/nodeIndexonlyscan.c:59">IndexOnlyNext</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retrieve <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L472" title="executor/nodeIndexonlyscan.c:472">ExecInitIndexOnlyScan</a>&nbsp; &nbsp; &nbsp; &nbsp; creates and initializes state info.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L329" title="executor/nodeIndexonlyscan.c:329">ExecReScanIndexOnlyScan</a>&nbsp; &nbsp; &nbsp; &nbsp; rescans the indexed relation.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L364" title="executor/nodeIndexonlyscan.c:364">ExecEndIndexOnlyScan</a>&nbsp; &nbsp; &nbsp; &nbsp; releases all storage.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L399" title="executor/nodeIndexonlyscan.c:399">ExecIndexOnlyMarkPos</a>&nbsp; &nbsp; &nbsp; &nbsp; marks scan position.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L436" title="executor/nodeIndexonlyscan.c:436">ExecIndexOnlyRestrPos</a>&nbsp; &nbsp; &nbsp; &nbsp; restores scan position.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L625" title="executor/nodeIndexonlyscan.c:625">ExecIndexOnlyScanEstimate</a>&nbsp; &nbsp; estimates DSM space needed for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parallel index-only scan<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L645" title="executor/nodeIndexonlyscan.c:645">ExecIndexOnlyScanInitializeDSM</a>&nbsp; &nbsp; <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> DSM for parallel<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-only scan<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L683" title="executor/nodeIndexonlyscan.c:683">ExecIndexOnlyScanReInitializeDSM</a>&nbsp; &nbsp; reinitialize DSM for fresh scan<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L696" title="executor/nodeIndexonlyscan.c:696">ExecIndexOnlyScanInitializeWorker</a> attach to DSM info in parallel worker<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/genam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/relscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tableam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tupdesc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/visibilitymap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeIndexonlyscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeIndexscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/predicate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> TupleTableSlot *<a href="#L59" title="executor/nodeIndexonlyscan.c:59">IndexOnlyNext</a>(IndexOnlyScanState *node);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L266" title="executor/nodeIndexonlyscan.c:266">StoreIndexTuple</a>(TupleTableSlot *slot, IndexTuple itup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDesc itupdesc);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L59" title="executor/nodeIndexonlyscan.c:59">IndexOnlyNext</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Retrieve a tuple from the IndexOnlyScan node's index.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TupleTableSlot *<br/></li>
<li><a id="L59">&#x200c;</a><span class="linkable">IndexOnlyNext</span>(IndexOnlyScanState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate;<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li>&nbsp; &nbsp; ScanDirection direction;<br/></li>
<li>&nbsp; &nbsp; IndexScanDesc scandesc;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li>&nbsp; &nbsp; ItemPointer tid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extract necessary information from index scan node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; estate = node-&gt;ss.ps.state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine which direction to scan the index in based on the plan's scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * direction and the current direction of execution.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; direction = ScanDirectionCombine(estate-&gt;es_direction,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((IndexOnlyScan *) node-&gt;ss.ps.plan)-&gt;indexorderdir);<br/></li>
<li>&nbsp; &nbsp; scandesc = node-&gt;ioss_ScanDesc;<br/></li>
<li>&nbsp; &nbsp; econtext = node-&gt;ss.ps.ps_ExprContext;<br/></li>
<li>&nbsp; &nbsp; slot = node-&gt;ss.ss_ScanTupleSlot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (scandesc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We reach here if the index only scan is not parallel, or if we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * serially executing an index only scan that was planned to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parallel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; scandesc = <a href="../access/index/indexam.c.html#L256" title="access/index/indexam.c:256">index_beginscan</a>(node-&gt;ss.ss_currentRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ioss_RelationDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; estate-&gt;es_snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ioss_NumScanKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ioss_NumOrderByKeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;ioss_ScanDesc = scandesc;<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set it up for index-only scan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;ioss_ScanDesc-&gt;xs_want_itup = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;ioss_VMBuffer = InvalidBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If no run-time keys to calculate or they are ready, go ahead and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pass the scankeys to the index AM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;ioss_NumRuntimeKeys == <span class="Constant">0</span> || node-&gt;ioss_RuntimeKeysReady)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L352" title="access/index/indexam.c:352">index_rescan</a>(scandesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ioss_ScanKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ioss_NumScanKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ioss_OrderByKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ioss_NumOrderByKeys);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK, <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that we have what we need, fetch the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> ((tid = <a href="../access/index/indexam.c.html#L574" title="access/index/indexam.c:574">index_getnext_tid</a>(scandesc, direction)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; tuple_from_heap = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the heap fetch if the TID references a heap page on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which all tuples are known visible to everybody.&nbsp; In <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll use the index tuple not the heap tuple as the data source.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note on Memory Ordering Effects: <a href="../access/heap/visibilitymap.c.html#L336" title="access/heap/visibilitymap.c:336">visibilitymap_get_status</a> does not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock the visibility map buffer, and therefore the result we read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here could be slightly stale.&nbsp; However, it can't be stale enough to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to detect clearing a VM <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> due to an insert right away,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because the tuple is present in the index page but not visible. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reading of the TID by this scan (using a shared lock on the index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffer) is serialized with the insert of the TID into the index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (using an exclusive lock on the index buffer). Because the VM <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is cleared <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> updating the index, and locking/unlocking of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index page acts as a full memory barrier, we are sure to see the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cleared <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> if we see a recently-inserted TID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Deletes do not update the index page (only VACUUM will clear out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the TID), so the clearing of the VM <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> by a delete is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * serialized with this test below, and we may see a value that is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * significantly stale. However, we don't care about the delete right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * away, because the tuple is still visible until the deleting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction commits or the statement ends (if it's our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction). In either case, the lock on the VM buffer will have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * been released (acting as a write barrier) after clearing the <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * And for us to have a snapshot that includes the deleting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction (making the tuple invisible), we must have acquired<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ProcArrayLock after that time, acting as a read barrier.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's worth going through this complexity to avoid needing to lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the VM buffer, which could cause significant contention.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!VM_ALL_VISIBLE(scandesc-&gt;heapRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerGetBlockNumber(tid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;node-&gt;ioss_VMBuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Rats, we have to visit the heap to check visibility.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InstrCountTuples2(node, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../access/index/indexam.c.html#L632" title="access/index/indexam.c:632">index_fetch_heap</a>(scandesc, node-&gt;ioss_TableSlot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no visible tuple, try <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> index entry */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(node-&gt;ioss_TableSlot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Only MVCC snapshots are supported here, so there should be no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to keep following the HOT chain once a visible entry has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * been found.&nbsp; If we did want to allow that, we'd need to keep<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more state to remember not to call <a href="../access/index/indexam.c.html#L574" title="access/index/indexam.c:574">index_getnext_tid</a> <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scandesc-&gt;xs_heap_continue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;non-MVCC snapshots are not supported in index-only scans&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: at this point we are holding a pin on the heap page, as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recorded in scandesc-&gt;xs_cbuf.&nbsp; We could release that pin <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but it's not clear whether it's a win to do so.&nbsp; The <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry might require a visit to the same heap page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_from_heap = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fill the scan tuple slot with data from the index.&nbsp; This might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * provided in either HeapTuple or IndexTuple format.&nbsp; Conceivably an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index AM might fill both fields, in which case we prefer the heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * format, since it's probably a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> cheaper to fill a slot from.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scandesc-&gt;xs_hitup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't take the trouble to verify that the provided tuple has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exactly the slot's format, but it seems worth doing a quick<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check on the number of fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(slot-&gt;tts_tupleDescriptor-&gt;natts ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scandesc-&gt;xs_hitupdesc-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L1556" title="executor/execTuples.c:1556">ExecForceStoreHeapTuple</a>(scandesc-&gt;xs_hitup, slot, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (scandesc-&gt;xs_itup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L266" title="executor/nodeIndexonlyscan.c:266">StoreIndexTuple</a>(slot, scandesc-&gt;xs_itup, scandesc-&gt;xs_itupdesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no data returned for index-only scan&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the index was lossy, we have to recheck the index quals.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scandesc-&gt;xs_recheck)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_scantuple = slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ExecQualAndReset(node-&gt;recheckqual, econtext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fails recheck, so drop it and loop back for another */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InstrCountFiltered2(node, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't currently support rechecking ORDER BY distances.&nbsp; (In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * principle, if the index can support retrieval of the originally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indexed value, it should be able to produce an exact distance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * calculation too.&nbsp; So it's not clear that adding code here for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recheck/re-sort would be worth the trouble.&nbsp; But we should at least<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * throw an error if someone tries it.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scandesc-&gt;numberOfOrderBys &gt; <span class="Constant">0</span> &amp;&amp; scandesc-&gt;xs_recheckorderby)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;lossy distance <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are not supported in index-only scans&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we didn't access the heap, then we'll need to take a predicate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock explicitly, as if we had.&nbsp; For <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we do that at page level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tuple_from_heap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/predicate.c.html#L2584" title="storage/lmgr/predicate.c:2584">PredicateLockPage</a>(scandesc-&gt;heapRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerGetBlockNumber(tid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> slot;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we get here it means the index scan failed so we are at the end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the scan..<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> ExecClearTuple(slot);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L266" title="executor/nodeIndexonlyscan.c:266">StoreIndexTuple</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Fill the slot with data from the index tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At some point this might be generally-useful functionality, but<br/></li>
<li></span><span class="Comment"> * right <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we don't need it elsewhere.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L266">&#x200c;</a></span><span class="linkable">StoreIndexTuple</span>(TupleTableSlot *slot, IndexTuple itup, TupleDesc itupdesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we must use the tupdesc supplied by the AM in <a href="../access/common/indextuple.c.html#L456" title="access/common/indextuple.c:456">index_deform_tuple</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not the slot's tupdesc, in case the latter has different datatypes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (this happens for btree name_ops in particular).&nbsp; They'd better have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same number of columns though, as well as being datatype-compatible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which is something we can't so easily check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(slot-&gt;tts_tupleDescriptor-&gt;natts == itupdesc-&gt;natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/indextuple.c.html#L456" title="access/common/indextuple.c:456">index_deform_tuple</a>(itup, itupdesc, slot-&gt;tts_values, slot-&gt;tts_isnull);<br/></li>
<li>&nbsp; &nbsp; <a href="execTuples.c.html#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a>(slot);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L291" title="executor/nodeIndexonlyscan.c:291">IndexOnlyRecheck</a> -- access method routine to recheck a tuple in <a href="execMain.c.html#L2470" title="executor/execMain.c:2470">EvalPlanQual</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This can't really happen, since an index can't supply CTID which would<br/></li>
<li></span><span class="Comment"> * be necessary data for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> potential <a href="execMain.c.html#L2470" title="executor/execMain.c:2470">EvalPlanQual</a> target relation.&nbsp; If it<br/></li>
<li></span><span class="Comment"> * did happen, the EPQ code would pass us the wrong data, namely a heap<br/></li>
<li></span><span class="Comment"> * tuple not an index tuple.&nbsp; So throw an error.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L291">&#x200c;</a></span><span class="linkable">IndexOnlyRecheck</span>(IndexOnlyScanState *node, TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="execMain.c.html#L2470" title="executor/execMain.c:2470">EvalPlanQual</a> recheck is not supported in index-only scans&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L302" title="executor/nodeIndexonlyscan.c:302">ExecIndexOnlyScan</a>(node)<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TupleTableSlot *<br/></li>
<li><a id="L302">&#x200c;</a><span class="linkable">ExecIndexOnlyScan</span>(PlanState *pstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexOnlyScanState *node = castNode(IndexOnlyScanState, pstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have runtime keys and they've not already been set up, do it <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;ioss_NumRuntimeKeys != <span class="Constant">0</span> &amp;&amp; !node-&gt;ioss_RuntimeKeysReady)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execAmi.c.html#L76" title="executor/execAmi.c:76">ExecReScan</a>((PlanState *) node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="execScan.c.html#L156" title="executor/execScan.c:156">ExecScan</a>(&amp;node-&gt;ss,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ExecScanAccessMtd) <a href="#L59" title="executor/nodeIndexonlyscan.c:59">IndexOnlyNext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ExecScanRecheckMtd) <a href="#L291" title="executor/nodeIndexonlyscan.c:291">IndexOnlyRecheck</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L329" title="executor/nodeIndexonlyscan.c:329">ExecReScanIndexOnlyScan</a>(node)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Recalculates the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> scan keys whose value depends on<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; information known at runtime, then rescans the indexed relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Updating the scan key was formerly done separately in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ExecUpdateIndexScanKeys. Integrating it into ReScan makes<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; rescans of indices and relations/general streams more uniform.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L329">&#x200c;</a></span><span class="linkable">ExecReScanIndexOnlyScan</span>(IndexOnlyScanState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are doing runtime key calculations (ie, <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the index key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> weren't simple Consts), compute the new key <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; But first,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reset the context so we don't leak memory as each outer tuple is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scanned.&nbsp; Note this assumes that we will recalculate *all* runtime keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on each call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;ioss_NumRuntimeKeys != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExprContext *econtext = node-&gt;ioss_RuntimeContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ResetExprContext(econtext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeIndexscan.c.html#L599" title="executor/nodeIndexscan.c:599">ExecIndexEvalRuntimeKeys</a>(econtext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ioss_RuntimeKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ioss_NumRuntimeKeys);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; node-&gt;ioss_RuntimeKeysReady = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* reset index scan */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;ioss_ScanDesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L352" title="access/index/indexam.c:352">index_rescan</a>(node-&gt;ioss_ScanDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ioss_ScanKeys, node-&gt;ioss_NumScanKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ioss_OrderByKeys, node-&gt;ioss_NumOrderByKeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="execScan.c.html#L297" title="executor/execScan.c:297">ExecScanReScan</a>(&amp;node-&gt;ss);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L364" title="executor/nodeIndexonlyscan.c:364">ExecEndIndexOnlyScan</a><br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L364">&#x200c;</a></span><span class="linkable">ExecEndIndexOnlyScan</span>(IndexOnlyScanState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; indexRelationDesc;<br/></li>
<li>&nbsp; &nbsp; IndexScanDesc indexScanDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extract information from the node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexRelationDesc = node-&gt;ioss_RelationDesc;<br/></li>
<li>&nbsp; &nbsp; indexScanDesc = node-&gt;ioss_ScanDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release VM buffer pin, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;ioss_VMBuffer != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(node-&gt;ioss_VMBuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;ioss_VMBuffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * close the index relation (no-op if we didn't open it)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexScanDesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L378" title="access/index/indexam.c:378">index_endscan</a>(indexScanDesc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (indexRelationDesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(indexRelationDesc, NoLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L399" title="executor/nodeIndexonlyscan.c:399">ExecIndexOnlyMarkPos</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we assume that no caller attempts to set a mark <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> having read<br/></li>
<li></span><span class="Comment"> * at least one tuple.&nbsp; Otherwise, ioss_ScanDesc might still be NULL.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L399">&#x200c;</a></span><span class="linkable">ExecIndexOnlyMarkPos</span>(IndexOnlyScanState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate = node-&gt;ss.ps.state;<br/></li>
<li>&nbsp; &nbsp; EPQState&nbsp;&nbsp; *epqstate = estate-&gt;es_epq_active;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (epqstate != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are inside an <a href="execMain.c.html#L2470" title="executor/execMain.c:2470">EvalPlanQual</a> recheck.&nbsp; If a test tuple exists for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this relation, then we shouldn't access the index at all.&nbsp; We would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * instead need to save, and later restore, the state of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relsubs_done flag, so that re-fetching the test tuple is possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, given the assumption that no caller sets a mark at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * start of the scan, we can only get here with relsubs_done[i]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already set, and so no state need be saved.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; scanrelid = ((Scan *) node-&gt;ss.ps.plan)-&gt;scanrelid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(scanrelid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (epqstate-&gt;relsubs_slot[scanrelid - <span class="Constant">1</span>] != <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; epqstate-&gt;relsubs_rowmark[scanrelid - <span class="Constant">1</span>] != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Verify the claim above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!epqstate-&gt;relsubs_done[scanrelid - <span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected <a href="#L399" title="executor/nodeIndexonlyscan.c:399">ExecIndexOnlyMarkPos</a> call in EPQ recheck&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/indexam.c.html#L408" title="access/index/indexam.c:408">index_markpos</a>(node-&gt;ioss_ScanDesc);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L436" title="executor/nodeIndexonlyscan.c:436">ExecIndexOnlyRestrPos</a><br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L436">&#x200c;</a></span><span class="linkable">ExecIndexOnlyRestrPos</span>(IndexOnlyScanState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate = node-&gt;ss.ps.state;<br/></li>
<li>&nbsp; &nbsp; EPQState&nbsp;&nbsp; *epqstate = estate-&gt;es_epq_active;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (estate-&gt;es_epq_active != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See comments in <a href="nodeIndexscan.c.html#L813" title="executor/nodeIndexscan.c:813">ExecIndexMarkPos</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; scanrelid = ((Scan *) node-&gt;ss.ps.plan)-&gt;scanrelid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(scanrelid &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (epqstate-&gt;relsubs_slot[scanrelid - <span class="Constant">1</span>] != <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; epqstate-&gt;relsubs_rowmark[scanrelid - <span class="Constant">1</span>] != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Verify the claim above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!epqstate-&gt;relsubs_done[scanrelid - <span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected <a href="#L436" title="executor/nodeIndexonlyscan.c:436">ExecIndexOnlyRestrPos</a> call in EPQ recheck&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/indexam.c.html#L432" title="access/index/indexam.c:432">index_restrpos</a>(node-&gt;ioss_ScanDesc);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L472" title="executor/nodeIndexonlyscan.c:472">ExecInitIndexOnlyScan</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Initializes the index scan's state information, creates<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; scan keys, and opens the base and index relations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Note: index scans have 2 sets of state information because<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; we have to keep track of the base relation and the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index relation.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexOnlyScanState *<br/></li>
<li><a id="L472">&#x200c;</a><span class="linkable">ExecInitIndexOnlyScan</span>(IndexOnlyScan *node, EState *estate, <span class="Type">int</span> eflags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexOnlyScanState *indexstate;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; currentRelation;<br/></li>
<li>&nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; lockmode;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create state structure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexstate = makeNode(IndexOnlyScanState);<br/></li>
<li>&nbsp; &nbsp; indexstate-&gt;ss.ps.plan = (Plan *) node;<br/></li>
<li>&nbsp; &nbsp; indexstate-&gt;ss.ps.state = estate;<br/></li>
<li>&nbsp; &nbsp; indexstate-&gt;ss.ps.ExecProcNode = <a href="#L302" title="executor/nodeIndexonlyscan.c:302">ExecIndexOnlyScan</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Miscellaneous initialization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create expression context for node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execUtils.c.html#L483" title="executor/execUtils.c:483">ExecAssignExprContext</a>(estate, &amp;indexstate-&gt;ss.ps);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * open the scan relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; currentRelation = <a href="execUtils.c.html#L697" title="executor/execUtils.c:697">ExecOpenScanRelation</a>(estate, node-&gt;scan.scanrelid, eflags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indexstate-&gt;ss.ss_currentRelation = currentRelation;<br/></li>
<li>&nbsp; &nbsp; indexstate-&gt;ss.ss_currentScanDesc = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* no heap scan here */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build the scan tuple type using the indextlist generated by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>.&nbsp; We use this, rather than the index's physical tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * descriptor, because the latter contains storage column types not the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * types of the original datums.&nbsp; (It's the AM's responsibility to return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * suitable data anyway.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tupDesc = <a href="execTuples.c.html#L2025" title="executor/execTuples.c:2025">ExecTypeFromTL</a>(node-&gt;indextlist);<br/></li>
<li>&nbsp; &nbsp; <a href="execTuples.c.html#L1898" title="executor/execTuples.c:1898">ExecInitScanTupleSlot</a>(estate, &amp;indexstate-&gt;ss, tupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need another slot, in a format that's suitable for the table AM, for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when we need to fetch a tuple from the table for rechecking visibility.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexstate-&gt;ioss_TableSlot =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L1258" title="executor/execTuples.c:1258">ExecAllocTableSlot</a>(&amp;estate-&gt;es_tupleTable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetDescr(currentRelation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../access/table/tableam.c.html#L58" title="access/table/tableam.c:58">table_slot_callbacks</a>(currentRelation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize result type and projection info.&nbsp; The node's targetlist will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contain Vars with varno = INDEX_VAR, referencing the scan tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execTuples.c.html#L1842" title="executor/execTuples.c:1842">ExecInitResultTypeTL</a>(&amp;indexstate-&gt;ss.ps);<br/></li>
<li>&nbsp; &nbsp; <a href="execScan.c.html#L283" title="executor/execScan.c:283">ExecAssignScanProjectionInfoWithVarno</a>(&amp;indexstate-&gt;ss, INDEX_VAR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> child expressions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we don't <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> all of the indexorderby expression, only the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sub-parts corresponding to runtime keys (see below).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexstate-&gt;ss.ps.qual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execExpr.c.html#L220" title="executor/execExpr.c:220">ExecInitQual</a>(node-&gt;scan.plan.qual, (PlanState *) indexstate);<br/></li>
<li>&nbsp; &nbsp; indexstate-&gt;recheckqual =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execExpr.c.html#L220" title="executor/execExpr.c:220">ExecInitQual</a>(node-&gt;recheckqual, (PlanState *) indexstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are just doing EXPLAIN (ie, aren't going to run the plan), stop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here.&nbsp; This allows an index-advisor plugin to EXPLAIN a plan containing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * references to nonexistent indexes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> indexstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Open the index relation. */<br/></li>
<li></span>&nbsp; &nbsp; lockmode = exec_rt_fetch(node-&gt;scan.scanrelid, estate)-&gt;rellockmode;<br/></li>
<li>&nbsp; &nbsp; indexstate-&gt;ioss_RelationDesc = <a href="../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(node-&gt;indexid, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize index-specific scan state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexstate-&gt;ioss_RuntimeKeysReady = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; indexstate-&gt;ioss_RuntimeKeys = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; indexstate-&gt;ioss_NumRuntimeKeys = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * build the index scan keys from the index qualification<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="nodeIndexscan.c.html#L1135" title="executor/nodeIndexscan.c:1135">ExecIndexBuildScanKeys</a>((PlanState *) indexstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexstate-&gt;ioss_RelationDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;indexqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;indexstate-&gt;ioss_ScanKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;indexstate-&gt;ioss_NumScanKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;indexstate-&gt;ioss_RuntimeKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;indexstate-&gt;ioss_NumRuntimeKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,&nbsp; &nbsp; <span class="Comment">/* no ArrayKeys */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> ORDER BY exprs have to be turned into scankeys in the same way<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="nodeIndexscan.c.html#L1135" title="executor/nodeIndexscan.c:1135">ExecIndexBuildScanKeys</a>((PlanState *) indexstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexstate-&gt;ioss_RelationDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;indexorderby,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;indexstate-&gt;ioss_OrderByKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;indexstate-&gt;ioss_NumOrderByKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;indexstate-&gt;ioss_RuntimeKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;indexstate-&gt;ioss_NumRuntimeKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,&nbsp; &nbsp; <span class="Comment">/* no ArrayKeys */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have runtime keys, we need an ExprContext to evaluate them. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * node's standard context won't do because we want to reset that context<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for every tuple.&nbsp; So, build another context just like the other one...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * -tgl 7/11/00<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexstate-&gt;ioss_NumRuntimeKeys != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExprContext *stdecontext = indexstate-&gt;ss.ps.ps_ExprContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execUtils.c.html#L483" title="executor/execUtils.c:483">ExecAssignExprContext</a>(estate, &amp;indexstate-&gt;ss.ps);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexstate-&gt;ioss_RuntimeContext = indexstate-&gt;ss.ps.ps_ExprContext;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexstate-&gt;ss.ps.ps_ExprContext = stdecontext;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexstate-&gt;ioss_RuntimeContext = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> indexstate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Parallel Index-only Scan Support<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L625" title="executor/nodeIndexonlyscan.c:625">ExecIndexOnlyScanEstimate</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Compute the amount of space we'll need in the parallel<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; query DSM, and inform pcxt-&gt;estimator about our needs.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L625">&#x200c;</a></span><span class="linkable">ExecIndexOnlyScanEstimate</span>(IndexOnlyScanState *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParallelContext *pcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate = node-&gt;ss.ps.state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node-&gt;ioss_PscanLen = <a href="../access/index/indexam.c.html#L453" title="access/index/indexam.c:453">index_parallelscan_estimate</a>(node-&gt;ioss_RelationDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;ioss_NumScanKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;ioss_NumOrderByKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_snapshot);<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, node-&gt;ioss_PscanLen);<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L645" title="executor/nodeIndexonlyscan.c:645">ExecIndexOnlyScanInitializeDSM</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set up a parallel index-only scan descriptor.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L645">&#x200c;</a></span><span class="linkable">ExecIndexOnlyScanInitializeDSM</span>(IndexOnlyScanState *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ParallelContext *pcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate = node-&gt;ss.ps.state;<br/></li>
<li>&nbsp; &nbsp; ParallelIndexScanDesc piscan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; piscan = <a href="../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, node-&gt;ioss_PscanLen);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/indexam.c.html#L490" title="access/index/indexam.c:490">index_parallelscan_initialize</a>(node-&gt;ss.ss_currentRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;ioss_RelationDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; estate-&gt;es_snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; piscan);<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, node-&gt;ss.ps.plan-&gt;plan_node_id, piscan);<br/></li>
<li>&nbsp; &nbsp; node-&gt;ioss_ScanDesc =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L541" title="access/index/indexam.c:541">index_beginscan_parallel</a>(node-&gt;ss.ss_currentRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ioss_RelationDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ioss_NumScanKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ioss_NumOrderByKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; piscan);<br/></li>
<li>&nbsp; &nbsp; node-&gt;ioss_ScanDesc-&gt;xs_want_itup = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;ioss_VMBuffer = InvalidBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If no run-time keys to calculate or they are ready, go ahead and pass<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the scankeys to the index AM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;ioss_NumRuntimeKeys == <span class="Constant">0</span> || node-&gt;ioss_RuntimeKeysReady)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L352" title="access/index/indexam.c:352">index_rescan</a>(node-&gt;ioss_ScanDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ioss_ScanKeys, node-&gt;ioss_NumScanKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ioss_OrderByKeys, node-&gt;ioss_NumOrderByKeys);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L683" title="executor/nodeIndexonlyscan.c:683">ExecIndexOnlyScanReInitializeDSM</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Reset shared state <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> beginning a fresh scan.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L683">&#x200c;</a></span><span class="linkable">ExecIndexOnlyScanReInitializeDSM</span>(IndexOnlyScanState *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ParallelContext *pcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/indexam.c.html#L523" title="access/index/indexam.c:523">index_parallelrescan</a>(node-&gt;ioss_ScanDesc);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L696" title="executor/nodeIndexonlyscan.c:696">ExecIndexOnlyScanInitializeWorker</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Copy relevant information from TOC into planstate.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L696">&#x200c;</a></span><span class="linkable">ExecIndexOnlyScanInitializeWorker</span>(IndexOnlyScanState *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParallelWorkerContext *pwcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParallelIndexScanDesc piscan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; piscan = <a href="../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(pwcxt-&gt;toc, node-&gt;ss.ps.plan-&gt;plan_node_id, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; node-&gt;ioss_ScanDesc =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L541" title="access/index/indexam.c:541">index_beginscan_parallel</a>(node-&gt;ss.ss_currentRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ioss_RelationDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ioss_NumScanKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ioss_NumOrderByKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; piscan);<br/></li>
<li>&nbsp; &nbsp; node-&gt;ioss_ScanDesc-&gt;xs_want_itup = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If no run-time keys to calculate or they are ready, go ahead and pass<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the scankeys to the index AM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;ioss_NumRuntimeKeys == <span class="Constant">0</span> || node-&gt;ioss_RuntimeKeysReady)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L352" title="access/index/indexam.c:352">index_rescan</a>(node-&gt;ioss_ScanDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ioss_ScanKeys, node-&gt;ioss_NumScanKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ioss_OrderByKeys, node-&gt;ioss_NumOrderByKeys);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
