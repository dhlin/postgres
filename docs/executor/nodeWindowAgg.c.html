<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>executor/nodeWindowAgg.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>executor/nodeWindowAgg.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L62">WindowObjectData</a></li>
<li><a href="#L72">WindowObjectData</a></li>
<li><a href="#L106">WindowStatePerAggData</a></li>
<li><a href="#L160">WindowStatePerAggData</a></li>
<li><a href="#L78">WindowStatePerFuncData</a></li>
<li><a href="#L101">WindowStatePerFuncData</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L2682">ExecEndWindowAgg</a></li>
<li><a href="#L2375">ExecInitWindowAgg</a></li>
<li><a href="#L2709">ExecReScanWindowAgg</a></li>
<li><a href="#L2046">ExecWindowAgg</a></li>
<li><a href="#L3022">GetAggInitVal</a></li>
<li><a href="#L3186">WinGetCurrentPosition</a></li>
<li><a href="#L3594">WinGetFuncArgCurrent</a></li>
<li><a href="#L3399">WinGetFuncArgInFrame</a></li>
<li><a href="#L3311">WinGetFuncArgInPartition</a></li>
<li><a href="#L3171">WinGetPartitionLocalMemory</a></li>
<li><a href="#L3201">WinGetPartitionRowCount</a></li>
<li><a href="#L3254">WinRowsArePeers</a></li>
<li><a href="#L3219">WinSetMarkPosition</a></li>
<li><a href="#L242">advance_windowaggregate</a></li>
<li><a href="#L419">advance_windowaggregate_base</a></li>
<li><a href="#L3044">are_peers</a></li>
<li><a href="#L1081">begin_partition</a></li>
<li><a href="#L663">eval_windowaggregates</a></li>
<li><a href="#L1033">eval_windowfunction</a></li>
<li><a href="#L582">finalize_windowaggregate</a></li>
<li><a href="#L2749">initialize_peragg</a></li>
<li><a href="#L207">initialize_windowaggregate</a></li>
<li><a href="#L1335">release_partition</a></li>
<li><a href="#L1385">row_is_in_frame</a></li>
<li><a href="#L1241">spool_tuples</a></li>
<li><a href="#L1485">update_frameheadpos</a></li>
<li><a href="#L1735">update_frametailpos</a></li>
<li><a href="#L1985">update_grouptailpos</a></li>
<li><a href="#L3067">window_gettupleslot</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * nodeWindowAgg.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; routines to handle WindowAgg nodes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A WindowAgg node evaluates &quot;window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>&quot; across suitable partitions<br/></li>
<li></span><span class="Comment"> * of the input tuple set.&nbsp; Any one WindowAgg works for just a single window<br/></li>
<li></span><span class="Comment"> * specification, though it can evaluate multiple window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> sharing<br/></li>
<li></span><span class="Comment"> * identical window specifications.&nbsp; The input tuples are required to be<br/></li>
<li></span><span class="Comment"> * delivered in sorted order, with the PARTITION BY columns (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) as<br/></li>
<li></span><span class="Comment"> * major sort keys and the ORDER BY columns (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) as minor sort keys.<br/></li>
<li></span><span class="Comment"> * (The <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> generates a stack of WindowAggs with intervening Sort nodes<br/></li>
<li></span><span class="Comment"> * as needed, if a query involves more than one window specification.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> can require access to <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> or all of the rows in<br/></li>
<li></span><span class="Comment"> * the current partition, we accumulate rows of the partition into a<br/></li>
<li></span><span class="Comment"> * tuplestore.&nbsp; The window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are called using the WindowObject API<br/></li>
<li></span><span class="Comment"> * so that they can access those rows as needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also support using plain aggregate <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> as window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> * For these, the regular Agg-node environment is emulated for each partition.<br/></li>
<li></span><span class="Comment"> * As required by the SQL spec, the output represents the value of the<br/></li>
<li></span><span class="Comment"> * aggregate function over all rows in the current row's window frame.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/executor/nodeWindowAgg.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/objectaccess.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_aggregate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeWindowAgg.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/clauses.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_agg.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_coerce.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/acl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/expandeddatum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/regproc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;windowapi.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * All the window function APIs are called with this object, which is passed<br/></li>
<li></span><span class="Comment"> * to window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> as fcinfo-&gt;context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L62">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">WindowObjectData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; NodeTag&nbsp; &nbsp; &nbsp; &nbsp; type;<br/></li>
<li>&nbsp; &nbsp; WindowAggState *winstate;&nbsp; &nbsp; <span class="Comment">/* parent WindowAggState */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *argstates;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ExprState trees for fn's arguments */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *localmem;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L3171" title="executor/nodeWindowAgg.c:3171">WinGetPartitionLocalMemory</a>'s chunk */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; markptr;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tuplestore mark pointer for this fn */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tuplestore read pointer for this fn */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; markpos;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* row that markptr is positioned on */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; seekpos;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* row that readptr is positioned on */<br/></li>
<li><a id="L72">&#x200c;</a></span>} <span class="linkable">WindowObjectData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We have one WindowStatePerFunc struct for each window function and<br/></li>
<li></span><span class="Comment"> * window aggregate handled by this node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L78">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">WindowStatePerFuncData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Links to WindowFunc expr and state nodes this working state is for */<br/></li>
<li></span>&nbsp; &nbsp; WindowFuncExprState *wfuncstate;<br/></li>
<li>&nbsp; &nbsp; WindowFunc *wfunc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numArguments;&nbsp; &nbsp; <span class="Comment">/* number of arguments */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; flinfo;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fmgr lookup data for window function */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winCollation;&nbsp; &nbsp; <span class="Comment">/* collation derived for window function */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need the len and byval info for the result of each function in order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to know how to copy/delete <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; resulttypeLen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; resulttypeByVal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; plain_agg;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* is it just a plain aggregate function? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggno;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if so, index of its <a href="#L106" title="executor/nodeWindowAgg.c:106">WindowStatePerAggData</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; WindowObject winobj;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* object used in window function API */<br/></li>
<li><a id="L101">&#x200c;</a></span>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">WindowStatePerFuncData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * For plain aggregate window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, we also have one of these.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L106">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">WindowStatePerAggData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Oids of transition <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transfn_oid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invtransfn_oid; <span class="Comment">/* may be InvalidOid */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finalfn_oid;&nbsp; &nbsp; <span class="Comment">/* may be InvalidOid */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fmgr lookup data for transition <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> --- only valid when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corresponding oid is not InvalidOid.&nbsp; Note in particular that fn_strict<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * flags are kept here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; transfn;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; invtransfn;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; finalfn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numFinalArgs;&nbsp; &nbsp; <span class="Comment">/* number of arguments to pass to finalfn */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initial value from pg_aggregate entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; initValue;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; initValueIsNull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cached value for current frame boundaries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; resultValue;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; resultValueIsNull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need the len and byval info for the agg's input, result, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transition data types in order to know how to copy/delete <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; inputtypeLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resulttypeLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transtypeLen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; inputtypeByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resulttypeByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transtypeByVal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wfuncno;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* index of associated <a href="#L78" title="executor/nodeWindowAgg.c:78">WindowStatePerFuncData</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Context holding transition value and possibly other subsidiary data */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext aggcontext;&nbsp; &nbsp; <span class="Comment">/* may be private, or winstate-&gt;aggcontext */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Current transition value */<br/></li>
<li></span>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; transValue;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* current transition value */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; transValueIsNull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; transValueCount;&nbsp; &nbsp; <span class="Comment">/* number of currently-aggregated rows */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Data local to <a href="#L663" title="executor/nodeWindowAgg.c:663">eval_windowaggregates</a>() */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; restart;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* need to restart this agg in this cycle? */<br/></li>
<li><a id="L160">&#x200c;</a></span>} <span class="linkable">WindowStatePerAggData</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L207" title="executor/nodeWindowAgg.c:207">initialize_windowaggregate</a>(WindowAggState *winstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WindowStatePerFunc perfuncstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WindowStatePerAgg peraggstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L242" title="executor/nodeWindowAgg.c:242">advance_windowaggregate</a>(WindowAggState *winstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WindowStatePerFunc perfuncstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WindowStatePerAgg peraggstate);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L419" title="executor/nodeWindowAgg.c:419">advance_windowaggregate_base</a>(WindowAggState *winstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WindowStatePerFunc perfuncstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WindowStatePerAgg peraggstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L582" title="executor/nodeWindowAgg.c:582">finalize_windowaggregate</a>(WindowAggState *winstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WindowStatePerFunc perfuncstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WindowStatePerAgg peraggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *result, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L663" title="executor/nodeWindowAgg.c:663">eval_windowaggregates</a>(WindowAggState *winstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1033" title="executor/nodeWindowAgg.c:1033">eval_windowfunction</a>(WindowAggState *winstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WindowStatePerFunc perfuncstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *result, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1081" title="executor/nodeWindowAgg.c:1081">begin_partition</a>(WindowAggState *winstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1241" title="executor/nodeWindowAgg.c:1241">spool_tuples</a>(WindowAggState *winstate, int64 pos);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1335" title="executor/nodeWindowAgg.c:1335">release_partition</a>(WindowAggState *winstate);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1385" title="executor/nodeWindowAgg.c:1385">row_is_in_frame</a>(WindowAggState *winstate, int64 pos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *slot);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1485" title="executor/nodeWindowAgg.c:1485">update_frameheadpos</a>(WindowAggState *winstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1735" title="executor/nodeWindowAgg.c:1735">update_frametailpos</a>(WindowAggState *winstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1985" title="executor/nodeWindowAgg.c:1985">update_grouptailpos</a>(WindowAggState *winstate);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L106" title="executor/nodeWindowAgg.c:106">WindowStatePerAggData</a> *<a href="#L2749" title="executor/nodeWindowAgg.c:2749">initialize_peragg</a>(WindowAggState *winstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WindowFunc *wfunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WindowStatePerAgg peraggstate);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L3022" title="executor/nodeWindowAgg.c:3022">GetAggInitVal</a>(Datum textInitVal, Oid transtype);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3044" title="executor/nodeWindowAgg.c:3044">are_peers</a>(WindowAggState *winstate, TupleTableSlot *slot1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *slot2);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3067" title="executor/nodeWindowAgg.c:3067">window_gettupleslot</a>(WindowObject winobj, int64 pos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *slot);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L207" title="executor/nodeWindowAgg.c:207">initialize_windowaggregate</a><br/></li>
<li></span><span class="Comment"> * parallel to <a href="nodeAgg.c.html#L665" title="executor/nodeAgg.c:665">initialize_aggregates</a> in nodeAgg.c<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L207">&#x200c;</a></span><span class="linkable">initialize_windowaggregate</span>(WindowAggState *winstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WindowStatePerFunc perfuncstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WindowStatePerAgg peraggstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're using a private aggcontext, we may reset it here.&nbsp; But if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * context is shared, we don't know which other aggregates may still need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it, so we must leave it to the caller to reset at an appropriate time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (peraggstate-&gt;aggcontext != winstate-&gt;aggcontext)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(peraggstate-&gt;aggcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (peraggstate-&gt;initValueIsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;transValue = peraggstate-&gt;initValue;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldContext = MemoryContextSwitchTo(peraggstate-&gt;aggcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;transValue = <a href="../utils/adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(peraggstate-&gt;initValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;transtypeByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;transtypeLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; peraggstate-&gt;transValueIsNull = peraggstate-&gt;initValueIsNull;<br/></li>
<li>&nbsp; &nbsp; peraggstate-&gt;transValueCount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; peraggstate-&gt;resultValue = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; peraggstate-&gt;resultValueIsNull = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L242" title="executor/nodeWindowAgg.c:242">advance_windowaggregate</a><br/></li>
<li></span><span class="Comment"> * parallel to <a href="nodeAgg.c.html#L816" title="executor/nodeAgg.c:816">advance_aggregates</a> in nodeAgg.c<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L242">&#x200c;</a></span><span class="linkable">advance_windowaggregate</span>(WindowAggState *winstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WindowStatePerFunc perfuncstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WindowStatePerAgg peraggstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, FUNC_MAX_ARGS);<br/></li>
<li>&nbsp; &nbsp; WindowFuncExprState *wfuncstate = perfuncstate-&gt;wfuncstate;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numArguments = perfuncstate-&gt;numArguments;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; newVal;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *arg;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext = winstate-&gt;tmpcontext;<br/></li>
<li>&nbsp; &nbsp; ExprState&nbsp; *filter = wfuncstate-&gt;aggfilter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldContext = MemoryContextSwitchTo(econtext-&gt;ecxt_per_tuple_memory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Skip anything FILTERed out */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (filter)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; res = ExecEvalExpr(filter, econtext, &amp;isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull || !DatumGetBool(res))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We start from 1, since the 0th arg will be the transition value */<br/></li>
<li></span>&nbsp; &nbsp; i = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(arg, wfuncstate-&gt;args)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExprState&nbsp; *argstate = (ExprState *) lfirst(arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[i].value = ExecEvalExpr(argstate, econtext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;fcinfo-&gt;args[i].isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (peraggstate-&gt;transfn.fn_strict)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For a strict transfn, nothing happens when there's a NULL input; we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just keep the prior transValue.&nbsp; Note transValueCount doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * change either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= numArguments; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;args[i].isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For strict transition <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> with initial value NULL we use the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first non-NULL input as the initial state.&nbsp; (We already checked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that the agg's input type is binary-compatible with its transtype,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so straight copy here is OK.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must copy the datum into aggcontext if it is pass-by-ref.&nbsp; We do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not need to <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> the old transValue, since it's NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (peraggstate-&gt;transValueCount == <span class="Constant">0</span> &amp;&amp; peraggstate-&gt;transValueIsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(peraggstate-&gt;aggcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;transValue = <a href="../utils/adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(fcinfo-&gt;args[<span class="Constant">1</span>].value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;transtypeByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;transtypeLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;transValueIsNull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;transValueCount = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (peraggstate-&gt;transValueIsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't call a strict function with NULL inputs.&nbsp; Note it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible to get here despite the above tests, if the transfn is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * strict *and* returned a NULL on a prior cycle.&nbsp; If that happens<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we will propagate the NULL all the way to the end.&nbsp; That can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only happen if there's no inverse transition function, though,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since we disallow transitions back to NULL when there is one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!OidIsValid(peraggstate-&gt;invtransfn_oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK to call the transition function.&nbsp; Set winstate-&gt;curaggcontext while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calling it, for possible use by <a href="nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, &amp;(peraggstate-&gt;transfn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numArguments + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; perfuncstate-&gt;winCollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) winstate, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = peraggstate-&gt;transValue;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = peraggstate-&gt;transValueIsNull;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;curaggcontext = peraggstate-&gt;aggcontext;<br/></li>
<li>&nbsp; &nbsp; newVal = FunctionCallInvoke(fcinfo);<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;curaggcontext = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Moving-aggregate transition <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> must not return null, see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L419" title="executor/nodeWindowAgg.c:419">advance_windowaggregate_base</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull &amp;&amp; OidIsValid(peraggstate-&gt;invtransfn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NULL_VALUE_NOT_ALLOWED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;moving-aggregate transition function must not return null&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must track the number of rows included in transValue, since to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remove the last input, <a href="#L419" title="executor/nodeWindowAgg.c:419">advance_windowaggregate_base</a>() mustn't call the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inverse transition function, but simply reset transValue back to its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initial value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; peraggstate-&gt;transValueCount++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If pass-by-ref datatype, must copy the new value into aggcontext and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * free the prior transValue.&nbsp; But if transfn returned a pointer to its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first input, we don't need to do anything.&nbsp; Also, if transfn returned a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pointer to a R/W expanded object that is already a child of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggcontext, assume we can adopt that value without copying it.&nbsp; (See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comments for <a href="execExprInterp.c.html#L4960" title="executor/execExprInterp.c:4960">ExecAggCopyTransValue</a>, which this code duplicates.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!peraggstate-&gt;transtypeByVal &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DatumGetPointer(newVal) != DatumGetPointer(peraggstate-&gt;transValue))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(peraggstate-&gt;aggcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumIsReadWriteExpandedObject(newVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; peraggstate-&gt;transtypeLen) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L731" title="utils/mmgr/mcxt.c:731">MemoryContextGetParent</a>(<a href="../utils/adt/expandeddatum.c.html#L29" title="utils/adt/expandeddatum.c:29">DatumGetEOHP</a>(newVal)-&gt;eoh_context) == <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* do nothing */</span> ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newVal = <a href="../utils/adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(newVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; peraggstate-&gt;transtypeByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; peraggstate-&gt;transtypeLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!peraggstate-&gt;transValueIsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumIsReadWriteExpandedObject(peraggstate-&gt;transValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; peraggstate-&gt;transtypeLen))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/expandeddatum.c.html#L136" title="utils/adt/expandeddatum.c:136">DeleteExpandedObject</a>(peraggstate-&gt;transValue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(peraggstate-&gt;transValue));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>&nbsp; &nbsp; peraggstate-&gt;transValue = newVal;<br/></li>
<li>&nbsp; &nbsp; peraggstate-&gt;transValueIsNull = fcinfo-&gt;isnull;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L419" title="executor/nodeWindowAgg.c:419">advance_windowaggregate_base</a><br/></li>
<li></span><span class="Comment"> * Remove the oldest tuple from an aggregation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is very much like <a href="#L242" title="executor/nodeWindowAgg.c:242">advance_windowaggregate</a>, except that we will call<br/></li>
<li></span><span class="Comment"> * the inverse transition function (which caller must have checked is<br/></li>
<li></span><span class="Comment"> * available).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if we successfully removed the current row from this<br/></li>
<li></span><span class="Comment"> * aggregate, false if not (in the latter case, caller is responsible<br/></li>
<li></span><span class="Comment"> * for cleaning up by restarting the aggregation).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L419">&#x200c;</a></span><span class="linkable">advance_windowaggregate_base</span>(WindowAggState *winstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WindowStatePerFunc perfuncstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WindowStatePerAgg peraggstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, FUNC_MAX_ARGS);<br/></li>
<li>&nbsp; &nbsp; WindowFuncExprState *wfuncstate = perfuncstate-&gt;wfuncstate;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numArguments = perfuncstate-&gt;numArguments;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; newVal;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *arg;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext = winstate-&gt;tmpcontext;<br/></li>
<li>&nbsp; &nbsp; ExprState&nbsp; *filter = wfuncstate-&gt;aggfilter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldContext = MemoryContextSwitchTo(econtext-&gt;ecxt_per_tuple_memory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Skip anything FILTERed out */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (filter)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; res = ExecEvalExpr(filter, econtext, &amp;isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull || !DatumGetBool(res))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We start from 1, since the 0th arg will be the transition value */<br/></li>
<li></span>&nbsp; &nbsp; i = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(arg, wfuncstate-&gt;args)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExprState&nbsp; *argstate = (ExprState *) lfirst(arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[i].value = ExecEvalExpr(argstate, econtext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;fcinfo-&gt;args[i].isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (peraggstate-&gt;invtransfn.fn_strict)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For a strict (inv)transfn, nothing happens when there's a NULL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * input; we just keep the prior transValue.&nbsp; Note transValueCount<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doesn't change either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= numArguments; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;args[i].isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* There should still be an added but not yet removed value */<br/></li>
<li></span>&nbsp; &nbsp; Assert(peraggstate-&gt;transValueCount &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In moving-aggregate mode, the state must never be NULL, except possibly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> rows have been aggregated (which is surely not the case at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this point).&nbsp; This restriction allows us to interpret a NULL result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the inverse function as meaning &quot;sorry, can't do an inverse<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transition in this case&quot;.&nbsp; We already checked this in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L242" title="executor/nodeWindowAgg.c:242">advance_windowaggregate</a>, but just for safety, check again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (peraggstate-&gt;transValueIsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;aggregate transition value is NULL <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> inverse transition&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We mustn't use the inverse transition function to remove the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * input.&nbsp; Doing so would yield a non-NULL state, whereas we should be in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the initial state afterwards which may very well be NULL.&nbsp; So instead,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we simply re-<a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the aggregate in this case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (peraggstate-&gt;transValueCount == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L207" title="executor/nodeWindowAgg.c:207">initialize_windowaggregate</a>(winstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;winstate-&gt;perfunc[peraggstate-&gt;wfuncno],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; peraggstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK to call the inverse transition function.&nbsp; Set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * winstate-&gt;curaggcontext while calling it, for possible use by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, &amp;(peraggstate-&gt;invtransfn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numArguments + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; perfuncstate-&gt;winCollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) winstate, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = peraggstate-&gt;transValue;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = peraggstate-&gt;transValueIsNull;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;curaggcontext = peraggstate-&gt;aggcontext;<br/></li>
<li>&nbsp; &nbsp; newVal = FunctionCallInvoke(fcinfo);<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;curaggcontext = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the function returns NULL, report failure, forcing a restart.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update number of rows included in transValue */<br/></li>
<li></span>&nbsp; &nbsp; peraggstate-&gt;transValueCount--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If pass-by-ref datatype, must copy the new value into aggcontext and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * free the prior transValue.&nbsp; But if invtransfn returned a pointer to its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first input, we don't need to do anything.&nbsp; Also, if invtransfn<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * returned a pointer to a R/W expanded object that is already a child of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the aggcontext, assume we can adopt that value without copying it. (See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comments for <a href="execExprInterp.c.html#L4960" title="executor/execExprInterp.c:4960">ExecAggCopyTransValue</a>, which this code duplicates.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: the checks for null <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> here will never fire, but it seems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * best to have this stanza look just like <a href="#L242" title="executor/nodeWindowAgg.c:242">advance_windowaggregate</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!peraggstate-&gt;transtypeByVal &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DatumGetPointer(newVal) != DatumGetPointer(peraggstate-&gt;transValue))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(peraggstate-&gt;aggcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumIsReadWriteExpandedObject(newVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; peraggstate-&gt;transtypeLen) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L731" title="utils/mmgr/mcxt.c:731">MemoryContextGetParent</a>(<a href="../utils/adt/expandeddatum.c.html#L29" title="utils/adt/expandeddatum.c:29">DatumGetEOHP</a>(newVal)-&gt;eoh_context) == <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* do nothing */</span> ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newVal = <a href="../utils/adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(newVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; peraggstate-&gt;transtypeByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; peraggstate-&gt;transtypeLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!peraggstate-&gt;transValueIsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumIsReadWriteExpandedObject(peraggstate-&gt;transValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; peraggstate-&gt;transtypeLen))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/expandeddatum.c.html#L136" title="utils/adt/expandeddatum.c:136">DeleteExpandedObject</a>(peraggstate-&gt;transValue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(peraggstate-&gt;transValue));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>&nbsp; &nbsp; peraggstate-&gt;transValue = newVal;<br/></li>
<li>&nbsp; &nbsp; peraggstate-&gt;transValueIsNull = fcinfo-&gt;isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L582" title="executor/nodeWindowAgg.c:582">finalize_windowaggregate</a><br/></li>
<li></span><span class="Comment"> * parallel to <a href="nodeAgg.c.html#L1046" title="executor/nodeAgg.c:1046">finalize_aggregate</a> in nodeAgg.c<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L582">&#x200c;</a></span><span class="linkable">finalize_windowaggregate</span>(WindowAggState *winstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WindowStatePerFunc perfuncstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WindowStatePerAgg peraggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *result, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldContext = MemoryContextSwitchTo(winstate-&gt;ss.ps.ps_ExprContext-&gt;ecxt_per_tuple_memory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Apply the agg's finalfn if one is provided, else return transValue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(peraggstate-&gt;finalfn_oid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCAL_FCINFO(fcinfo, FUNC_MAX_ARGS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numFinalArgs = peraggstate-&gt;numFinalArgs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; anynull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; InitFunctionCallInfoData(fcinfodata.fcinfo, &amp;(peraggstate-&gt;finalfn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numFinalArgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; perfuncstate-&gt;winCollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) winstate, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MakeExpandedObjectReadOnly(peraggstate-&gt;transValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; peraggstate-&gt;transValueIsNull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; peraggstate-&gt;transtypeLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = peraggstate-&gt;transValueIsNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; anynull = peraggstate-&gt;transValueIsNull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fill <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining argument positions with nulls */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; numFinalArgs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[i].value = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[i].isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; anynull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;flinfo-&gt;fn_strict &amp;&amp; anynull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't call a strict function with NULL inputs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;curaggcontext = peraggstate-&gt;aggcontext;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = FunctionCallInvoke(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;curaggcontext = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isnull = fcinfo-&gt;isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = MakeExpandedObjectReadOnly(res,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fcinfo-&gt;isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; peraggstate-&gt;resulttypeLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *result =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MakeExpandedObjectReadOnly(peraggstate-&gt;transValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; peraggstate-&gt;transValueIsNull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; peraggstate-&gt;transtypeLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *isnull = peraggstate-&gt;transValueIsNull;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L663" title="executor/nodeWindowAgg.c:663">eval_windowaggregates</a><br/></li>
<li></span><span class="Comment"> * evaluate plain aggregates being used as window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This differs from nodeAgg.c in two ways.&nbsp; First, if the window's frame<br/></li>
<li></span><span class="Comment"> * start position moves, we use the inverse transition function (if it exists)<br/></li>
<li></span><span class="Comment"> * to remove rows from the transition value.&nbsp; And second, we expect to be<br/></li>
<li></span><span class="Comment"> * able to call aggregate final <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> repeatedly after aggregating more<br/></li>
<li></span><span class="Comment"> * data onto the same transition value.&nbsp; This is not a behavior required by<br/></li>
<li></span><span class="Comment"> * nodeAgg.c.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L663">&#x200c;</a></span><span class="linkable">eval_windowaggregates</span>(WindowAggState *winstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WindowStatePerAgg peraggstate;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wfuncno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numaggs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numaggs_restart,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; aggregatedupto_nonrestarted;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li>&nbsp; &nbsp; WindowObject agg_winobj;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *agg_row_slot;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *temp_slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; numaggs = winstate-&gt;numaggs;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numaggs == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* final output execution is in ps_ExprContext */<br/></li>
<li></span>&nbsp; &nbsp; econtext = winstate-&gt;ss.ps.ps_ExprContext;<br/></li>
<li>&nbsp; &nbsp; agg_winobj = winstate-&gt;agg_winobj;<br/></li>
<li>&nbsp; &nbsp; agg_row_slot = winstate-&gt;agg_row_slot;<br/></li>
<li>&nbsp; &nbsp; temp_slot = winstate-&gt;temp_slot_1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the window's frame start clause is UNBOUNDED_PRECEDING and no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exclusion clause is specified, then the window frame consists of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contiguous group of rows extending forward from the start of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partition, and rows only enter the frame, never exit it, as the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * row advances forward.&nbsp; This makes it possible to use an incremental<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * strategy for evaluating aggregates: we run the transition function for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * each row added to the frame, and run the final function whenever we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need the current aggregate value.&nbsp; This is considerably more efficient<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than the naive approach of re-running the entire aggregate calculation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for each current row.&nbsp; It does assume that the final function doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * damage the running transition value, but we have the same assumption in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nodeAgg.c too (when it rescans an existing <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the frame start does sometimes move, we can still <a href="../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> as above<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whenever successive rows share the same frame head, but if the frame<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * head moves beyond the previous head we try to remove those rows using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the aggregate's inverse transition function.&nbsp; This function restores<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the aggregate's current state to what it would be if the removed row<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * had never been aggregated in the first place.&nbsp; Inverse transition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> may optionally return NULL, indicating that the function was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unable to remove the tuple from aggregation.&nbsp; If this happens, or if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the aggregate doesn't have an inverse transition function at all, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must perform the aggregation all over again for all tuples within the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new frame boundaries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there's <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> exclusion clause, then we may have to aggregate over a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-contiguous set of rows, so we punt and recalculate for every row.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (For some frame end choices, it might be that the frame is always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contiguous anyway, but that's an optimization to investigate later.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In many common cases, multiple rows share the same frame and hence the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same aggregate value. (In particular, if there's no ORDER BY in a <a href="../regex/regcomp.c.html#L339" title="regex/regcomp.c:339">RANGE</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * window, then all rows are peers and so they all have window frame <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the whole partition.)&nbsp; We <a href="../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> such cases by calculating the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggregate value once when we reach the first row of a peer group, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then returning the saved value for all subsequent rows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'aggregatedupto' keeps track of the first row that has not yet been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * accumulated into the aggregate transition <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; Whenever we start a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new peer group, we accumulate forward to the end of the peer group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, update the frame head position.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The frame head should never move backwards, and the code below wouldn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cope if it did, so for safety we complain if it does.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1485" title="executor/nodeWindowAgg.c:1485">update_frameheadpos</a>(winstate);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;frameheadpos &lt; winstate-&gt;aggregatedbase)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;window frame head moved backward&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the frame didn't change compared to the previous row, we can re-use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the result <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that were previously saved at the bottom of this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function.&nbsp; Since we don't know the current frame's end yet, this is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible to check for fully.&nbsp; But if the frame end mode is UNBOUNDED<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * FOLLOWING or CURRENT ROW, no exclusion clause is specified, and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current row lies within the previous row's frame, then the two frames'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ends must coincide.&nbsp; Note that on the first row aggregatedbase ==<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggregatedupto, meaning this test must fail, so we don't need to check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the &quot;there was no previous row&quot; case explicitly here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;aggregatedbase == winstate-&gt;frameheadpos &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (winstate-&gt;frameOptions &amp; (FRAMEOPTION_END_UNBOUNDED_FOLLOWING |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FRAMEOPTION_END_CURRENT_ROW)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !(winstate-&gt;frameOptions &amp; FRAMEOPTION_EXCLUSION) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;aggregatedbase &lt;= winstate-&gt;currentpos &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;aggregatedupto &gt; winstate-&gt;currentpos)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numaggs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peraggstate = &amp;winstate-&gt;peragg[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wfuncno = peraggstate-&gt;wfuncno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_aggvalues[wfuncno] = peraggstate-&gt;resultValue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_aggnulls[wfuncno] = peraggstate-&gt;resultValueIsNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize restart flags.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We restart the aggregation:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp;&nbsp; - if we're processing the first row in the partition, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp;&nbsp; - if the frame's head moved and we cannot use an inverse<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp;&nbsp; transition function, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp;&nbsp; - we have an EXCLUSION clause, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp;&nbsp; - if the new frame doesn't overlap the old one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we don't strictly need to restart in the last case, but if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're going to remove all rows from the aggregation anyway, a restart<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * surely is faster.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; numaggs_restart = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numaggs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; peraggstate = &amp;winstate-&gt;peragg[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;currentpos == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (winstate-&gt;aggregatedbase != winstate-&gt;frameheadpos &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !OidIsValid(peraggstate-&gt;invtransfn_oid)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (winstate-&gt;frameOptions &amp; FRAMEOPTION_EXCLUSION) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;aggregatedupto &lt;= winstate-&gt;frameheadpos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;restart = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numaggs_restart++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;restart = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> possibly-moving aggregates, attempt to advance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggregatedbase to match the frame's head by removing input rows that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fell off the top of the frame from the aggregations.&nbsp; This can fail,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * i.e. <a href="#L419" title="executor/nodeWindowAgg.c:419">advance_windowaggregate_base</a>() can return false, in which case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we'll restart that aggregate below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (numaggs_restart &lt; numaggs &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;aggregatedbase &lt; winstate-&gt;frameheadpos)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fetch the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple of those being removed. This should never fail<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as we should have been here <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3067" title="executor/nodeWindowAgg.c:3067">window_gettupleslot</a>(agg_winobj, winstate-&gt;aggregatedbase,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; temp_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not re-fetch previously fetched frame row&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set tuple context for evaluation of aggregate arguments */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;tmpcontext-&gt;ecxt_outertuple = temp_slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Perform the inverse transition for each aggregate function in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * window, unless it has already been marked as needing a restart.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numaggs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ok;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peraggstate = &amp;winstate-&gt;peragg[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (peraggstate-&gt;restart)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wfuncno = peraggstate-&gt;wfuncno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ok = <a href="#L419" title="executor/nodeWindowAgg.c:419">advance_windowaggregate_base</a>(winstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;winstate-&gt;perfunc[wfuncno],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peraggstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Inverse transition function has failed, must restart */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;restart = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numaggs_restart++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset per-input-tuple context after each tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ResetExprContext(winstate-&gt;tmpcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And advance the aggregated-row state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;aggregatedbase++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(temp_slot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we successfully advanced the base rows of all the aggregates,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggregatedbase <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> equals frameheadpos; but if we failed for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must forcibly update aggregatedbase.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; winstate-&gt;aggregatedbase = winstate-&gt;frameheadpos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we created a mark pointer for aggregates, keep it pushed up to frame<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * head, so that tuplestore can discard unnecessary rows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (agg_winobj-&gt;markptr &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3219" title="executor/nodeWindowAgg.c:3219">WinSetMarkPosition</a>(agg_winobj, winstate-&gt;frameheadpos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now restart the aggregates that require it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We assume that aggregates using the shared context always restart if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * *<a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>* aggregate restarts, and we may thus clean up the shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggcontext if that is the case.&nbsp; Private aggcontexts are reset by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L207" title="executor/nodeWindowAgg.c:207">initialize_windowaggregate</a>() if their owning aggregate restarts. If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aren't restarting an aggregate, we need to free <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> previously saved<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * result for it, else we'll leak memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (numaggs_restart &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(winstate-&gt;aggcontext);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numaggs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; peraggstate = &amp;winstate-&gt;peragg[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Aggregates using the shared ctx must restart if *<a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>* agg does */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(peraggstate-&gt;aggcontext != winstate-&gt;aggcontext ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numaggs_restart == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; peraggstate-&gt;restart);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (peraggstate-&gt;restart)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wfuncno = peraggstate-&gt;wfuncno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L207" title="executor/nodeWindowAgg.c:207">initialize_windowaggregate</a>(winstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;winstate-&gt;perfunc[wfuncno],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; peraggstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!peraggstate-&gt;resultValueIsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!peraggstate-&gt;resulttypeByVal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(peraggstate-&gt;resultValue));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;resultValue = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;resultValueIsNull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Non-restarted aggregates <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> contain the rows between aggregatedbase<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (i.e., frameheadpos) and aggregatedupto, while restarted aggregates<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contain no rows.&nbsp; If there are <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> restarted aggregates, we must thus<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * begin aggregating anew at frameheadpos, otherwise we may simply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * continue at aggregatedupto.&nbsp; We must remember the old value of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggregatedupto to know how long to <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> advancing non-restarted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggregates.&nbsp; If we modify aggregatedupto, we must also clear<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * agg_row_slot, per the loop invariant below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; aggregatedupto_nonrestarted = winstate-&gt;aggregatedupto;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numaggs_restart &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;aggregatedupto != winstate-&gt;frameheadpos)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;aggregatedupto = winstate-&gt;frameheadpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(agg_row_slot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advance until we reach a row not in frame (or end of partition).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note the loop invariant: agg_row_slot is either empty or holds the row<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at position aggregatedupto.&nbsp; We advance aggregatedupto after processing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a row.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> row if we didn't already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TupIsNull(agg_row_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3067" title="executor/nodeWindowAgg.c:3067">window_gettupleslot</a>(agg_winobj, winstate-&gt;aggregatedupto,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; agg_row_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must be end of partition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Exit loop if no more rows can be in frame.&nbsp; Skip aggregation if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current row is not in frame but there might be more in the frame.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="#L1385" title="executor/nodeWindowAgg.c:1385">row_is_in_frame</a>(winstate, winstate-&gt;aggregatedupto, agg_row_slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ret &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ret == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> next_tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set tuple context for evaluation of aggregate arguments */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;tmpcontext-&gt;ecxt_outertuple = agg_row_slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Accumulate row into the aggregates */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numaggs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peraggstate = &amp;winstate-&gt;peragg[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Non-restarted aggs <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> until aggregatedupto_nonrestarted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!peraggstate-&gt;restart &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;aggregatedupto &lt; aggregatedupto_nonrestarted)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wfuncno = peraggstate-&gt;wfuncno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L242" title="executor/nodeWindowAgg.c:242">advance_windowaggregate</a>(winstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;winstate-&gt;perfunc[wfuncno],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peraggstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="Statement">next_tuple</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset per-input-tuple context after each tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ResetExprContext(winstate-&gt;tmpcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And advance the aggregated-row state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;aggregatedupto++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(agg_row_slot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The frame's end is not supposed to move backwards, ever */<br/></li>
<li></span>&nbsp; &nbsp; Assert(aggregatedupto_nonrestarted &lt;= winstate-&gt;aggregatedupto);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * finalize aggregates and fill result/isnull fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numaggs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; peraggstate = &amp;winstate-&gt;peragg[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wfuncno = peraggstate-&gt;wfuncno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = &amp;econtext-&gt;ecxt_aggvalues[wfuncno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isnull = &amp;econtext-&gt;ecxt_aggnulls[wfuncno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L582" title="executor/nodeWindowAgg.c:582">finalize_windowaggregate</a>(winstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;winstate-&gt;perfunc[wfuncno],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; peraggstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result, isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * save the result in case <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> row shares the same frame.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> in some framing modes, eg ROWS/END_CURRENT_ROW, we can know in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * advance that the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> row can't possibly share the same frame. Is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it worth detecting that and skipping this code?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!peraggstate-&gt;resulttypeByVal &amp;&amp; !*isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldContext = MemoryContextSwitchTo(peraggstate-&gt;aggcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;resultValue =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(*result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;resulttypeByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;resulttypeLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;resultValue = *result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;resultValueIsNull = *isnull;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1033" title="executor/nodeWindowAgg.c:1033">eval_windowfunction</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Arguments of window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are not evaluated here, because a window<br/></li>
<li></span><span class="Comment"> * function can need random access to arbitrary rows in the partition.<br/></li>
<li></span><span class="Comment"> * The window function uses the special <a href="#L3311" title="executor/nodeWindowAgg.c:3311">WinGetFuncArgInPartition</a> and<br/></li>
<li></span><span class="Comment"> * <a href="#L3399" title="executor/nodeWindowAgg.c:3399">WinGetFuncArgInFrame</a> <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to evaluate the arguments for the rows<br/></li>
<li></span><span class="Comment"> * it wants.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1033">&#x200c;</a></span><span class="linkable">eval_windowfunction</span>(WindowAggState *winstate, WindowStatePerFunc perfuncstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *result, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, FUNC_MAX_ARGS);<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldContext = MemoryContextSwitchTo(winstate-&gt;ss.ps.ps_ExprContext-&gt;ecxt_per_tuple_memory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't pass <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> normal arguments to a window function, but we do pass<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it the number of arguments, in order to permit window function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * implementations to support varying numbers of arguments.&nbsp; The real info<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * goes through the WindowObject, which is passed via fcinfo-&gt;context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, &amp;(perfuncstate-&gt;flinfo),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; perfuncstate-&gt;numArguments,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; perfuncstate-&gt;winCollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) perfuncstate-&gt;winobj, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Just in case, make all the regular argument slots be null */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> argno = <span class="Constant">0</span>; argno &lt; perfuncstate-&gt;numArguments; argno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;args[argno].isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> don't have a current aggregate context, either */<br/></li>
<li></span>&nbsp; &nbsp; winstate-&gt;curaggcontext = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *result = FunctionCallInvoke(fcinfo);<br/></li>
<li>&nbsp; &nbsp; *isnull = fcinfo-&gt;isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The window function might have returned a pass-by-ref result that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just a pointer into one of the WindowObject's temporary slots.&nbsp; That's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not a problem if it's the only window function using the WindowObject;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but if there's more than one function, we'd better copy the result to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensure it's not clobbered by later window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!perfuncstate-&gt;resulttypeByVal &amp;&amp; !fcinfo-&gt;isnull &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;numfuncs &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *result = <a href="../utils/adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(*result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perfuncstate-&gt;resulttypeByVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perfuncstate-&gt;resulttypeLen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1081" title="executor/nodeWindowAgg.c:1081">begin_partition</a><br/></li>
<li></span><span class="Comment"> * Start buffering rows of the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> partition.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1081">&#x200c;</a></span><span class="linkable">begin_partition</span>(WindowAggState *winstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WindowAgg&nbsp; *node = (WindowAgg *) winstate-&gt;ss.ps.plan;<br/></li>
<li>&nbsp; &nbsp; PlanState&nbsp; *outerPlan = outerPlanState(winstate);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frameOptions = winstate-&gt;frameOptions;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfuncs = winstate-&gt;numfuncs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; winstate-&gt;partition_spooled = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;framehead_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;frametail_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;grouptail_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;spooled_rows = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;currentpos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;frameheadpos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;frametailpos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;currentgroup = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;frameheadgroup = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;frametailgroup = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;groupheadpos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;grouptailpos = -<span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* see <a href="#L1985" title="executor/nodeWindowAgg.c:1985">update_grouptailpos</a> */<br/></li>
<li></span>&nbsp; &nbsp; ExecClearTuple(winstate-&gt;agg_row_slot);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;framehead_slot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(winstate-&gt;framehead_slot);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;frametail_slot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(winstate-&gt;frametail_slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is the very first partition, we need to fetch the first input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * row to store in first_part_slot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TupIsNull(winstate-&gt;first_part_slot))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *outerslot = ExecProcNode(outerPlan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TupIsNull(outerslot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecCopySlot(winstate-&gt;first_part_slot, outerslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* outer plan is empty, so we have nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;partition_spooled = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;more_partitions = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create new tuplestore for this partition */<br/></li>
<li></span>&nbsp; &nbsp; winstate-&gt;buffer = <a href="../utils/sort/tuplestore.c.html#L318" title="utils/sort/tuplestore.c:318">tuplestore_begin_heap</a>(<span class="Constant">false</span>, <span class="Constant">false</span>, <a href="../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up read pointers for the tuplestore.&nbsp; The current pointer doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need BACKWARD capability, but the per-window-function read pointers do,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and the aggregate pointer does if we might need to restart aggregation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; winstate-&gt;current_ptr = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* read pointer 0 is pre-allocated */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* reset default REWIND capability <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> for current ptr */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L359" title="utils/sort/tuplestore.c:359">tuplestore_set_eflags</a>(winstate-&gt;buffer, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* create read pointers for aggregates, if needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;numaggs &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WindowObject agg_winobj = winstate-&gt;agg_winobj;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr_flags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the frame head is potentially movable, or we have an EXCLUSION<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clause, we might need to restart aggregation ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(frameOptions &amp; FRAMEOPTION_START_UNBOUNDED_PRECEDING) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (frameOptions &amp; FRAMEOPTION_EXCLUSION))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... so create a mark pointer to track the frame head */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; agg_winobj-&gt;markptr = <a href="../utils/sort/tuplestore.c.html#L383" title="utils/sort/tuplestore.c:383">tuplestore_alloc_read_pointer</a>(winstate-&gt;buffer, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and the read pointer will need BACKWARD capability */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr_flags |= EXEC_FLAG_BACKWARD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; agg_winobj-&gt;readptr = <a href="../utils/sort/tuplestore.c.html#L383" title="utils/sort/tuplestore.c:383">tuplestore_alloc_read_pointer</a>(winstate-&gt;buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr_flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; agg_winobj-&gt;markpos = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; agg_winobj-&gt;seekpos = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Also reset the row counters for aggregates */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;aggregatedbase = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;aggregatedupto = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* create mark and read pointers for each real window function */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numfuncs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WindowStatePerFunc perfuncstate = &amp;(winstate-&gt;perfunc[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!perfuncstate-&gt;plain_agg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WindowObject winobj = perfuncstate-&gt;winobj;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winobj-&gt;markptr = <a href="../utils/sort/tuplestore.c.html#L383" title="utils/sort/tuplestore.c:383">tuplestore_alloc_read_pointer</a>(winstate-&gt;buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winobj-&gt;readptr = <a href="../utils/sort/tuplestore.c.html#L383" title="utils/sort/tuplestore.c:383">tuplestore_alloc_read_pointer</a>(winstate-&gt;buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXEC_FLAG_BACKWARD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winobj-&gt;markpos = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winobj-&gt;seekpos = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are in <a href="../regex/regcomp.c.html#L339" title="regex/regcomp.c:339">RANGE</a> or GROUPS mode, then determining frame boundaries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requires physical access to the frame endpoint rows, except in certain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * degenerate cases.&nbsp; We create read pointers to point to those rows, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * simplify access and ensure that the tuplestore doesn't discard the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * endpoint rows prematurely.&nbsp; (Must create pointers in exactly the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases that <a href="#L1485" title="executor/nodeWindowAgg.c:1485">update_frameheadpos</a> and <a href="#L1735" title="executor/nodeWindowAgg.c:1735">update_frametailpos</a> need them.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; winstate-&gt;framehead_ptr = winstate-&gt;frametail_ptr = -<span class="Constant">1</span>; <span class="Comment">/* if not used */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; (FRAMEOPTION_RANGE | FRAMEOPTION_GROUPS))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((frameOptions &amp; FRAMEOPTION_START_CURRENT_ROW) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ordNumCols != <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (frameOptions &amp; FRAMEOPTION_START_OFFSET))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;framehead_ptr =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L383" title="utils/sort/tuplestore.c:383">tuplestore_alloc_read_pointer</a>(winstate-&gt;buffer, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((frameOptions &amp; FRAMEOPTION_END_CURRENT_ROW) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ordNumCols != <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (frameOptions &amp; FRAMEOPTION_END_OFFSET))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frametail_ptr =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L383" title="utils/sort/tuplestore.c:383">tuplestore_alloc_read_pointer</a>(winstate-&gt;buffer, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have an exclusion clause that requires knowing the boundaries of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the current row's peer group, we create a read pointer to track the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tail position of the peer group (i.e., first row of the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> peer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * group).&nbsp; The head position does not require its own pointer because we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * maintain that as a side effect of advancing the current row.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; winstate-&gt;grouptail_ptr = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((frameOptions &amp; (FRAMEOPTION_EXCLUDE_GROUP |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FRAMEOPTION_EXCLUDE_TIES)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;ordNumCols != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;grouptail_ptr =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L383" title="utils/sort/tuplestore.c:383">tuplestore_alloc_read_pointer</a>(winstate-&gt;buffer, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Store the first tuple into the tuplestore (it's always available <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we either read it above, or saved it at the end of previous partition)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L708" title="utils/sort/tuplestore.c:708">tuplestore_puttupleslot</a>(winstate-&gt;buffer, winstate-&gt;first_part_slot);<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;spooled_rows++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read tuples from the outer node, up to and including position 'pos', and<br/></li>
<li></span><span class="Comment"> * store them into the tuplestore. If pos is -1, reads the whole partition.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1241">&#x200c;</a></span><span class="linkable">spool_tuples</span>(WindowAggState *winstate, int64 pos)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WindowAgg&nbsp; *node = (WindowAgg *) winstate-&gt;ss.ps.plan;<br/></li>
<li>&nbsp; &nbsp; PlanState&nbsp; *outerPlan;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *outerslot;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!winstate-&gt;buffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just a safety check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;partition_spooled)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* whole partition done already */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When in pass-through mode we can just exhaust all tuples in the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partition.&nbsp; We don't need these tuples for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> further window function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * evaluation, however, we do need to keep them around if we're not the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * top-level window as another WindowAgg node above must see these.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;status != WINDOWAGG_RUN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(winstate-&gt;status == WINDOWAGG_PASSTHROUGH ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;status == WINDOWAGG_PASSTHROUGH_STRICT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pos = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the tuplestore has spilled to disk, alternate reading and writing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * becomes quite expensive due to frequent buffer flushes.&nbsp; It's cheaper<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to force the entire partition to get spooled in one go.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> this is a horrid kluge --- it'd be better to fix the performance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * problem inside tuplestore.&nbsp; </span><span class="Todo">FIXME<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="../utils/sort/tuplestore.c.html#L1455" title="utils/sort/tuplestore.c:1455">tuplestore_in_memory</a>(winstate-&gt;buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pos = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; outerPlan = outerPlanState(winstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must be in query context to call outerplan */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(winstate-&gt;ss.ps.ps_ExprContext-&gt;ecxt_per_query_memory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (winstate-&gt;spooled_rows &lt;= pos || pos == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outerslot = ExecProcNode(outerPlan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TupIsNull(outerslot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reached the end of the last partition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;partition_spooled = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;more_partitions = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;partNumCols &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExprContext *econtext = winstate-&gt;tmpcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_innertuple = winstate-&gt;first_part_slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_outertuple = outerslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check if this tuple still belongs to the current partition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ExecQualAndReset(winstate-&gt;partEqfunction, econtext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end of partition; copy the tuple for the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> cycle.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecCopySlot(winstate-&gt;first_part_slot, outerslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;partition_spooled = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;more_partitions = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember the tuple unless we're the top-level window and we're in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pass-through mode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;status != WINDOWAGG_PASSTHROUGH_STRICT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Still in partition, so save it into the tuplestore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L708" title="utils/sort/tuplestore.c:708">tuplestore_puttupleslot</a>(winstate-&gt;buffer, outerslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;spooled_rows++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1335" title="executor/nodeWindowAgg.c:1335">release_partition</a><br/></li>
<li></span><span class="Comment"> * clear information kept within a partition, including<br/></li>
<li></span><span class="Comment"> * tuplestore and aggregate results.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1335">&#x200c;</a></span><span class="linkable">release_partition</span>(WindowAggState *winstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; winstate-&gt;numfuncs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WindowStatePerFunc perfuncstate = &amp;(winstate-&gt;perfunc[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> partition-local state of this window function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (perfuncstate-&gt;winobj)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perfuncstate-&gt;winobj-&gt;localmem = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release all partition-local memory (in particular, <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> partition-local<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state that we might have trashed our pointers to in the above loop, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> aggregate temp data).&nbsp; We don't rely on retail <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> because some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggregates might have allocated data we don't have direct pointers to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(winstate-&gt;partcontext);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(winstate-&gt;aggcontext);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; winstate-&gt;numaggs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;peragg[i].aggcontext != winstate-&gt;aggcontext)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(winstate-&gt;peragg[i].aggcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;buffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L453" title="utils/sort/tuplestore.c:453">tuplestore_end</a>(winstate-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;buffer = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;partition_spooled = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1385" title="executor/nodeWindowAgg.c:1385">row_is_in_frame</a><br/></li>
<li></span><span class="Comment"> * Determine whether a row is in the current row's window frame according<br/></li>
<li></span><span class="Comment"> * to our window framing rule<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must have already determined that the row is in the partition<br/></li>
<li></span><span class="Comment"> * and fetched it into a slot.&nbsp; This function just encapsulates the framing<br/></li>
<li></span><span class="Comment"> * rules.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns:<br/></li>
<li></span><span class="Comment"> * -1, if the row is out of frame and no succeeding rows can be in frame<br/></li>
<li></span><span class="Comment"> * 0, if the row is out of frame but succeeding rows might be in frame<br/></li>
<li></span><span class="Comment"> * 1, if the row is in frame<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * May clobber winstate-&gt;temp_slot_2.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1385">&#x200c;</a></span><span class="linkable">row_is_in_frame</span>(WindowAggState *winstate, int64 pos, TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frameOptions = winstate-&gt;frameOptions;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(pos &gt;= <span class="Constant">0</span>);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else caller error */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, check frame starting conditions.&nbsp; We might as well delegate this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to <a href="#L1485" title="executor/nodeWindowAgg.c:1485">update_frameheadpos</a> always; it doesn't add <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> notable cost.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1485" title="executor/nodeWindowAgg.c:1485">update_frameheadpos</a>(winstate);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pos &lt; winstate-&gt;frameheadpos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Okay so far, <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> check frame ending conditions.&nbsp; Here, we avoid calling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1735" title="executor/nodeWindowAgg.c:1735">update_frametailpos</a> in simple cases, so as not to spool tuples further<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ahead than necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_END_CURRENT_ROW)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_ROWS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rows after current row are out of frame */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pos &gt; winstate-&gt;currentpos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (frameOptions &amp; (FRAMEOPTION_RANGE | FRAMEOPTION_GROUPS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* following row that is not peer is out of frame */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pos &gt; winstate-&gt;currentpos &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L3044" title="executor/nodeWindowAgg.c:3044">are_peers</a>(winstate, slot, winstate-&gt;ss.ss_ScanTupleSlot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_END_OFFSET)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_ROWS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; offset = DatumGetInt64(winstate-&gt;endOffsetValue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rows after current row + offset are out of frame */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_END_OFFSET_PRECEDING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset = -offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pos &gt; winstate-&gt;currentpos + offset)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (frameOptions &amp; (FRAMEOPTION_RANGE | FRAMEOPTION_GROUPS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* hard cases, so delegate to <a href="#L1735" title="executor/nodeWindowAgg.c:1735">update_frametailpos</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1735" title="executor/nodeWindowAgg.c:1735">update_frametailpos</a>(winstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pos &gt;= winstate-&gt;frametailpos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check exclusion clause */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_EXCLUDE_CURRENT_ROW)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pos == winstate-&gt;currentpos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((frameOptions &amp; FRAMEOPTION_EXCLUDE_GROUP) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((frameOptions &amp; FRAMEOPTION_EXCLUDE_TIES) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos != winstate-&gt;currentpos))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WindowAgg&nbsp; *node = (WindowAgg *) winstate-&gt;ss.ps.plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If no ORDER BY, all rows are peers with each other */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;ordNumCols == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise, check the group boundaries */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pos &gt;= winstate-&gt;groupheadpos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1985" title="executor/nodeWindowAgg.c:1985">update_grouptailpos</a>(winstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pos &lt; winstate-&gt;grouptailpos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we get here, it's in frame */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1485" title="executor/nodeWindowAgg.c:1485">update_frameheadpos</a><br/></li>
<li></span><span class="Comment"> * make frameheadpos valid for the current row<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that frameheadpos is computed without regard for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> window exclusion<br/></li>
<li></span><span class="Comment"> * clause; the current row and/or its peers are considered part of the frame<br/></li>
<li></span><span class="Comment"> * for this purpose even if they must be excluded later.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * May clobber winstate-&gt;temp_slot_2.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1485">&#x200c;</a></span><span class="linkable">update_frameheadpos</span>(WindowAggState *winstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WindowAgg&nbsp; *node = (WindowAgg *) winstate-&gt;ss.ps.plan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frameOptions = winstate-&gt;frameOptions;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;framehead_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* already known for current row */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We may be called in a short-lived context */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(winstate-&gt;ss.ps.ps_ExprContext-&gt;ecxt_per_query_memory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_START_UNBOUNDED_PRECEDING)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In UNBOUNDED PRECEDING mode, frame head is always row 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frameheadpos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;framehead_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_START_CURRENT_ROW)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_ROWS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In ROWS mode, frame head is the same as current */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frameheadpos = winstate-&gt;currentpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;framehead_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (frameOptions &amp; (FRAMEOPTION_RANGE | FRAMEOPTION_GROUPS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If no ORDER BY, all rows are peers with each other */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;ordNumCols == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frameheadpos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;framehead_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In <a href="../regex/regcomp.c.html#L339" title="regex/regcomp.c:339">RANGE</a> or GROUPS START_CURRENT_ROW mode, frame head is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first row that is a peer of current row.&nbsp; We keep a copy of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * last-known frame head row in framehead_slot, and advance as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * necessary.&nbsp; Note that if we reach end of partition, we will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leave frameheadpos = end+1 and framehead_slot empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L473" title="utils/sort/tuplestore.c:473">tuplestore_select_read_pointer</a>(winstate-&gt;buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;framehead_ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;frameheadpos == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupIsNull(winstate-&gt;framehead_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fetch first row into framehead_slot, if we didn't already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/sort/tuplestore.c.html#L1078" title="utils/sort/tuplestore.c:1078">tuplestore_gettupleslot</a>(winstate-&gt;buffer, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;framehead_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected end of tuplestore&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (!TupIsNull(winstate-&gt;framehead_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3044" title="executor/nodeWindowAgg.c:3044">are_peers</a>(winstate, winstate-&gt;framehead_slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;ss.ss_ScanTupleSlot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this row is the correct frame head */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Note we advance frameheadpos even if the fetch fails */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frameheadpos++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1241" title="executor/nodeWindowAgg.c:1241">spool_tuples</a>(winstate, winstate-&gt;frameheadpos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/sort/tuplestore.c.html#L1078" title="utils/sort/tuplestore.c:1078">tuplestore_gettupleslot</a>(winstate-&gt;buffer, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;framehead_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of partition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;framehead_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_START_OFFSET)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_ROWS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In ROWS mode, bound is physically n <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>/after current */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; offset = DatumGetInt64(winstate-&gt;startOffsetValue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_START_OFFSET_PRECEDING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset = -offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frameheadpos = winstate-&gt;currentpos + offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* frame head can't go <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> first row */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;frameheadpos &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frameheadpos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (winstate-&gt;frameheadpos &gt; winstate-&gt;currentpos + <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure frameheadpos is not past end of partition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1241" title="executor/nodeWindowAgg.c:1241">spool_tuples</a>(winstate, winstate-&gt;frameheadpos - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;frameheadpos &gt; winstate-&gt;spooled_rows)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frameheadpos = winstate-&gt;spooled_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;framehead_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_RANGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In <a href="../regex/regcomp.c.html#L339" title="regex/regcomp.c:339">RANGE</a> START_OFFSET mode, frame head is the first row that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * satisfies the in_range constraint relative to the current row.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We keep a copy of the last-known frame head row in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * framehead_slot, and advance as necessary.&nbsp; Note that if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reach end of partition, we will leave frameheadpos = end+1 and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * framehead_slot empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortCol = node-&gt;ordColIdx[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sub,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; less;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We must have an ordering column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(node-&gt;ordNumCols == <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Precompute flags for in_range checks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_START_OFFSET_PRECEDING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* subtract startOffset from current row */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* add it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; less = <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* normally, we want frame head &gt;= sum */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If sort order is descending, flip both flags */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!winstate-&gt;inRangeAsc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub = !sub;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; less = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L473" title="utils/sort/tuplestore.c:473">tuplestore_select_read_pointer</a>(winstate-&gt;buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;framehead_ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;frameheadpos == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupIsNull(winstate-&gt;framehead_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fetch first row into framehead_slot, if we didn't already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/sort/tuplestore.c.html#L1078" title="utils/sort/tuplestore.c:1078">tuplestore_gettupleslot</a>(winstate-&gt;buffer, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;framehead_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected end of tuplestore&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (!TupIsNull(winstate-&gt;framehead_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; headval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; headisnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currisnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; headval = slot_getattr(winstate-&gt;framehead_slot, sortCol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;headisnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currval = slot_getattr(winstate-&gt;ss.ss_ScanTupleSlot, sortCol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;currisnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (headisnull || currisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* order of the rows depends only on nulls_first */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;inRangeNullsFirst)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* advance head if head is null and curr is not */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!headisnull || currisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* advance head if head is not null and curr is null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (headisnull || !currisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(<a href="../utils/fmgr/fmgr.c.html#L1223" title="utils/fmgr/fmgr.c:1223">FunctionCall5Coll</a>(&amp;winstate-&gt;startInRangeFunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;inRangeColl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; headval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; currval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;startOffsetValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BoolGetDatum(sub),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BoolGetDatum(less))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; <span class="Comment">/* this row is the correct frame head */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Note we advance frameheadpos even if the fetch fails */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frameheadpos++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1241" title="executor/nodeWindowAgg.c:1241">spool_tuples</a>(winstate, winstate-&gt;frameheadpos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/sort/tuplestore.c.html#L1078" title="utils/sort/tuplestore.c:1078">tuplestore_gettupleslot</a>(winstate-&gt;buffer, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;framehead_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of partition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;framehead_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_GROUPS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In GROUPS START_OFFSET mode, frame head is the first row of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first peer group whose number satisfies the offset constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We keep a copy of the last-known frame head row in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * framehead_slot, and advance as necessary.&nbsp; Note that if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reach end of partition, we will leave frameheadpos = end+1 and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * framehead_slot empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; offset = DatumGetInt64(winstate-&gt;startOffsetValue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; minheadgroup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_START_OFFSET_PRECEDING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minheadgroup = winstate-&gt;currentgroup - offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minheadgroup = winstate-&gt;currentgroup + offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L473" title="utils/sort/tuplestore.c:473">tuplestore_select_read_pointer</a>(winstate-&gt;buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;framehead_ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;frameheadpos == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupIsNull(winstate-&gt;framehead_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fetch first row into framehead_slot, if we didn't already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/sort/tuplestore.c.html#L1078" title="utils/sort/tuplestore.c:1078">tuplestore_gettupleslot</a>(winstate-&gt;buffer, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;framehead_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected end of tuplestore&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (!TupIsNull(winstate-&gt;framehead_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;frameheadgroup &gt;= minheadgroup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this row is the correct frame head */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecCopySlot(winstate-&gt;temp_slot_2, winstate-&gt;framehead_slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Note we advance frameheadpos even if the fetch fails */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frameheadpos++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1241" title="executor/nodeWindowAgg.c:1241">spool_tuples</a>(winstate, winstate-&gt;frameheadpos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/sort/tuplestore.c.html#L1078" title="utils/sort/tuplestore.c:1078">tuplestore_gettupleslot</a>(winstate-&gt;buffer, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;framehead_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of partition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3044" title="executor/nodeWindowAgg.c:3044">are_peers</a>(winstate, winstate-&gt;temp_slot_2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;framehead_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frameheadgroup++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(winstate-&gt;temp_slot_2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;framehead_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1735" title="executor/nodeWindowAgg.c:1735">update_frametailpos</a><br/></li>
<li></span><span class="Comment"> * make frametailpos valid for the current row<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that frametailpos is computed without regard for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> window exclusion<br/></li>
<li></span><span class="Comment"> * clause; the current row and/or its peers are considered part of the frame<br/></li>
<li></span><span class="Comment"> * for this purpose even if they must be excluded later.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * May clobber winstate-&gt;temp_slot_2.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1735">&#x200c;</a></span><span class="linkable">update_frametailpos</span>(WindowAggState *winstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WindowAgg&nbsp; *node = (WindowAgg *) winstate-&gt;ss.ps.plan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frameOptions = winstate-&gt;frameOptions;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;frametail_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* already known for current row */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We may be called in a short-lived context */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(winstate-&gt;ss.ps.ps_ExprContext-&gt;ecxt_per_query_memory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_END_UNBOUNDED_FOLLOWING)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In UNBOUNDED FOLLOWING mode, all partition rows are in frame */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1241" title="executor/nodeWindowAgg.c:1241">spool_tuples</a>(winstate, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frametailpos = winstate-&gt;spooled_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frametail_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_END_CURRENT_ROW)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_ROWS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In ROWS mode, exactly the rows up to current are in frame */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frametailpos = winstate-&gt;currentpos + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frametail_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (frameOptions &amp; (FRAMEOPTION_RANGE | FRAMEOPTION_GROUPS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If no ORDER BY, all rows are peers with each other */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;ordNumCols == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1241" title="executor/nodeWindowAgg.c:1241">spool_tuples</a>(winstate, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frametailpos = winstate-&gt;spooled_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frametail_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In <a href="../regex/regcomp.c.html#L339" title="regex/regcomp.c:339">RANGE</a> or GROUPS END_CURRENT_ROW mode, frame end is the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * row that is a peer of current row, frame tail is the row after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>).&nbsp; We keep a copy of the last-known frame tail row<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in frametail_slot, and advance as necessary.&nbsp; Note that if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reach end of partition, we will leave frametailpos = end+1 and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * frametail_slot empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L473" title="utils/sort/tuplestore.c:473">tuplestore_select_read_pointer</a>(winstate-&gt;buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;frametail_ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;frametailpos == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupIsNull(winstate-&gt;frametail_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fetch first row into frametail_slot, if we didn't already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/sort/tuplestore.c.html#L1078" title="utils/sort/tuplestore.c:1078">tuplestore_gettupleslot</a>(winstate-&gt;buffer, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;frametail_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected end of tuplestore&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (!TupIsNull(winstate-&gt;frametail_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;frametailpos &gt; winstate-&gt;currentpos &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L3044" title="executor/nodeWindowAgg.c:3044">are_peers</a>(winstate, winstate-&gt;frametail_slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;ss.ss_ScanTupleSlot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this row is the frame tail */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Note we advance frametailpos even if the fetch fails */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frametailpos++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1241" title="executor/nodeWindowAgg.c:1241">spool_tuples</a>(winstate, winstate-&gt;frametailpos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/sort/tuplestore.c.html#L1078" title="utils/sort/tuplestore.c:1078">tuplestore_gettupleslot</a>(winstate-&gt;buffer, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;frametail_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of partition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frametail_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_END_OFFSET)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_ROWS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In ROWS mode, bound is physically n <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>/after current */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; offset = DatumGetInt64(winstate-&gt;endOffsetValue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_END_OFFSET_PRECEDING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset = -offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frametailpos = winstate-&gt;currentpos + offset + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* smallest allowable value of frametailpos is 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;frametailpos &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frametailpos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (winstate-&gt;frametailpos &gt; winstate-&gt;currentpos + <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure frametailpos is not past end of partition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1241" title="executor/nodeWindowAgg.c:1241">spool_tuples</a>(winstate, winstate-&gt;frametailpos - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;frametailpos &gt; winstate-&gt;spooled_rows)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frametailpos = winstate-&gt;spooled_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frametail_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_RANGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In <a href="../regex/regcomp.c.html#L339" title="regex/regcomp.c:339">RANGE</a> END_OFFSET mode, frame end is the last row that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * satisfies the in_range constraint relative to the current row,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * frame tail is the row after that (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>).&nbsp; We keep a copy of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the last-known frame tail row in frametail_slot, and advance as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * necessary.&nbsp; Note that if we reach end of partition, we will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leave frametailpos = end+1 and frametail_slot empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortCol = node-&gt;ordColIdx[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sub,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; less;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We must have an ordering column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(node-&gt;ordNumCols == <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Precompute flags for in_range checks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_END_OFFSET_PRECEDING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* subtract endOffset from current row */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* add it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; less = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* normally, we want frame tail &lt;= sum */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If sort order is descending, flip both flags */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!winstate-&gt;inRangeAsc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub = !sub;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; less = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L473" title="utils/sort/tuplestore.c:473">tuplestore_select_read_pointer</a>(winstate-&gt;buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;frametail_ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;frametailpos == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupIsNull(winstate-&gt;frametail_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fetch first row into frametail_slot, if we didn't already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/sort/tuplestore.c.html#L1078" title="utils/sort/tuplestore.c:1078">tuplestore_gettupleslot</a>(winstate-&gt;buffer, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;frametail_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected end of tuplestore&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (!TupIsNull(winstate-&gt;frametail_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; tailval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; tailisnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currisnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tailval = slot_getattr(winstate-&gt;frametail_slot, sortCol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;tailisnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currval = slot_getattr(winstate-&gt;ss.ss_ScanTupleSlot, sortCol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;currisnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tailisnull || currisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* order of the rows depends only on nulls_first */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;inRangeNullsFirst)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* advance tail if tail is null or curr is not */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tailisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* advance tail if tail is not null or curr is null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!currisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!DatumGetBool(<a href="../utils/fmgr/fmgr.c.html#L1223" title="utils/fmgr/fmgr.c:1223">FunctionCall5Coll</a>(&amp;winstate-&gt;endInRangeFunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;inRangeColl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tailval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;endOffsetValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BoolGetDatum(sub),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BoolGetDatum(less))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; <span class="Comment">/* this row is the correct frame tail */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Note we advance frametailpos even if the fetch fails */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frametailpos++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1241" title="executor/nodeWindowAgg.c:1241">spool_tuples</a>(winstate, winstate-&gt;frametailpos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/sort/tuplestore.c.html#L1078" title="utils/sort/tuplestore.c:1078">tuplestore_gettupleslot</a>(winstate-&gt;buffer, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;frametail_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of partition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frametail_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_GROUPS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In GROUPS END_OFFSET mode, frame end is the last row of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * last peer group whose number satisfies the offset constraint,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and frame tail is the row after that (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>).&nbsp; We keep a copy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the last-known frame tail row in frametail_slot, and advance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as necessary.&nbsp; Note that if we reach end of partition, we will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leave frametailpos = end+1 and frametail_slot empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; offset = DatumGetInt64(winstate-&gt;endOffsetValue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; maxtailgroup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_END_OFFSET_PRECEDING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxtailgroup = winstate-&gt;currentgroup - offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxtailgroup = winstate-&gt;currentgroup + offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L473" title="utils/sort/tuplestore.c:473">tuplestore_select_read_pointer</a>(winstate-&gt;buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;frametail_ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;frametailpos == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupIsNull(winstate-&gt;frametail_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fetch first row into frametail_slot, if we didn't already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/sort/tuplestore.c.html#L1078" title="utils/sort/tuplestore.c:1078">tuplestore_gettupleslot</a>(winstate-&gt;buffer, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;frametail_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected end of tuplestore&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (!TupIsNull(winstate-&gt;frametail_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;frametailgroup &gt; maxtailgroup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this row is the correct frame tail */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecCopySlot(winstate-&gt;temp_slot_2, winstate-&gt;frametail_slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Note we advance frametailpos even if the fetch fails */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frametailpos++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1241" title="executor/nodeWindowAgg.c:1241">spool_tuples</a>(winstate, winstate-&gt;frametailpos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/sort/tuplestore.c.html#L1078" title="utils/sort/tuplestore.c:1078">tuplestore_gettupleslot</a>(winstate-&gt;buffer, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;frametail_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of partition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3044" title="executor/nodeWindowAgg.c:3044">are_peers</a>(winstate, winstate-&gt;temp_slot_2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;frametail_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frametailgroup++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(winstate-&gt;temp_slot_2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frametail_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1985" title="executor/nodeWindowAgg.c:1985">update_grouptailpos</a><br/></li>
<li></span><span class="Comment"> * make grouptailpos valid for the current row<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * May clobber winstate-&gt;temp_slot_2.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1985">&#x200c;</a></span><span class="linkable">update_grouptailpos</span>(WindowAggState *winstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WindowAgg&nbsp; *node = (WindowAgg *) winstate-&gt;ss.ps.plan;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;grouptail_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* already known for current row */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We may be called in a short-lived context */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(winstate-&gt;ss.ps.ps_ExprContext-&gt;ecxt_per_query_memory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If no ORDER BY, all rows are peers with each other */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;ordNumCols == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1241" title="executor/nodeWindowAgg.c:1241">spool_tuples</a>(winstate, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;grouptailpos = winstate-&gt;spooled_rows;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;grouptail_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because grouptail_valid is reset only when current row advances into a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new peer group, we always reach here knowing that grouptailpos needs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be advanced by at least one row.&nbsp; Hence, unlike the otherwise similar<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case for frame tail tracking, we do not need persistent storage of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * group tail row.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(winstate-&gt;grouptailpos &lt;= winstate-&gt;currentpos);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L473" title="utils/sort/tuplestore.c:473">tuplestore_select_read_pointer</a>(winstate-&gt;buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;grouptail_ptr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Note we advance grouptailpos even if the fetch fails */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;grouptailpos++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1241" title="executor/nodeWindowAgg.c:1241">spool_tuples</a>(winstate, winstate-&gt;grouptailpos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/sort/tuplestore.c.html#L1078" title="utils/sort/tuplestore.c:1078">tuplestore_gettupleslot</a>(winstate-&gt;buffer, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;temp_slot_2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of partition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;grouptailpos &gt; winstate-&gt;currentpos &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L3044" title="executor/nodeWindowAgg.c:3044">are_peers</a>(winstate, winstate-&gt;temp_slot_2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;ss.ss_ScanTupleSlot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this row is the group tail */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(winstate-&gt;temp_slot_2);<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;grouptail_valid = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* -----------------<br/></li>
<li></span><span class="Comment"> * <a href="#L2046" title="executor/nodeWindowAgg.c:2046">ExecWindowAgg</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2046" title="executor/nodeWindowAgg.c:2046">ExecWindowAgg</a> receives tuples from its outer subplan and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; stores them into a tuplestore, then processes window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This node doesn't reduce nor qualify <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> row so the number of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; returned rows is exactly the same as its outer subplan's result.<br/></li>
<li></span><span class="Comment"> * -----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TupleTableSlot *<br/></li>
<li><a id="L2046">&#x200c;</a><span class="linkable">ExecWindowAgg</span>(PlanState *pstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WindowAggState *winstate = castNode(WindowAggState, pstate);<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfuncs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;status == WINDOWAGG_DONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute frame offset <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, during first call (or after a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rescan).&nbsp; These are assumed to hold constant throughout the scan; if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * user gives us a volatile expression, we'll only use its initial value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;all_first)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frameOptions = winstate-&gt;frameOptions;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; byval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; econtext = winstate-&gt;ss.ps.ps_ExprContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_START_OFFSET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(winstate-&gt;startOffset != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = ExecEvalExprSwitchContext(winstate-&gt;startOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NULL_VALUE_NOT_ALLOWED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;frame starting offset must not be null&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy value into query-lifespan context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L2251" title="utils/cache/lsyscache.c:2251">get_typlenbyval</a>(<a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) winstate-&gt;startOffset-&gt;expr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;len, &amp;byval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;startOffsetValue = <a href="../utils/adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(value, byval, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; (FRAMEOPTION_ROWS | FRAMEOPTION_GROUPS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* value is known to be int8 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; offset = DatumGetInt64(value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offset &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;frame starting offset must not be negative&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; FRAMEOPTION_END_OFFSET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(winstate-&gt;endOffset != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = ExecEvalExprSwitchContext(winstate-&gt;endOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NULL_VALUE_NOT_ALLOWED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;frame ending offset must not be null&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy value into query-lifespan context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L2251" title="utils/cache/lsyscache.c:2251">get_typlenbyval</a>(<a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) winstate-&gt;endOffset-&gt;expr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;len, &amp;byval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;endOffsetValue = <a href="../utils/adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(value, byval, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; (FRAMEOPTION_ROWS | FRAMEOPTION_GROUPS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* value is known to be int8 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; offset = DatumGetInt64(value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offset &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;frame ending offset must not be negative&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;all_first = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We need to loop as the runCondition or qual may filter out tuples */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;buffer == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize for first partition and set current row = 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1081" title="executor/nodeWindowAgg.c:1081">begin_partition</a>(winstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If there are no input rows, we'll detect that and exit below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance current row within partition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;currentpos++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This might mean that the frame moves, too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;framehead_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frametail_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we don't need to invalidate grouptail here; see below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Spool all tuples up to and including the current row, if we haven't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1241" title="executor/nodeWindowAgg.c:1241">spool_tuples</a>(winstate, winstate-&gt;currentpos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Move to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> partition if we reached the end of this partition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;partition_spooled &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;currentpos &gt;= winstate-&gt;spooled_rows)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1335" title="executor/nodeWindowAgg.c:1335">release_partition</a>(winstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;more_partitions)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1081" title="executor/nodeWindowAgg.c:1081">begin_partition</a>(winstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(winstate-&gt;spooled_rows &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Come out of pass-through mode when changing partition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;status = WINDOWAGG_RUN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No further partitions?&nbsp; We're done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;status = WINDOWAGG_DONE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* final output execution is in ps_ExprContext */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; econtext = winstate-&gt;ss.ps.ps_ExprContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Clear the per-output-tuple context for current row */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ResetExprContext(econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Read the current row from the tuplestore, and save in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ScanTupleSlot. (We can't rely on the outerplan's output slot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because we may have to read beyond the current row.&nbsp; Also, we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to actually copy the row out of the tuplestore, since window<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function evaluation might cause the tuplestore to <a href="../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> its state to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * disk.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In GROUPS mode, or when tracking a group-oriented exclusion clause,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we must also detect entering a new peer group and update associated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * state when that happens.&nbsp; We use temp_slot_2 to temporarily hold<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the previous row for this purpose.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Current row must be in the tuplestore, since we spooled it above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L473" title="utils/sort/tuplestore.c:473">tuplestore_select_read_pointer</a>(winstate-&gt;buffer, winstate-&gt;current_ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((winstate-&gt;frameOptions &amp; (FRAMEOPTION_GROUPS |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FRAMEOPTION_EXCLUDE_GROUP |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FRAMEOPTION_EXCLUDE_TIES)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;currentpos &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecCopySlot(winstate-&gt;temp_slot_2, winstate-&gt;ss.ss_ScanTupleSlot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/sort/tuplestore.c.html#L1078" title="utils/sort/tuplestore.c:1078">tuplestore_gettupleslot</a>(winstate-&gt;buffer, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;ss.ss_ScanTupleSlot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected end of tuplestore&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3044" title="executor/nodeWindowAgg.c:3044">are_peers</a>(winstate, winstate-&gt;temp_slot_2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;ss.ss_ScanTupleSlot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;currentgroup++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;groupheadpos = winstate-&gt;currentpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;grouptail_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(winstate-&gt;temp_slot_2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/sort/tuplestore.c.html#L1078" title="utils/sort/tuplestore.c:1078">tuplestore_gettupleslot</a>(winstate-&gt;buffer, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;ss.ss_ScanTupleSlot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected end of tuplestore&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't evaluate the window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> when we're in pass-through mode */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;status == WINDOWAGG_RUN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Evaluate true window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfuncs = winstate-&gt;numfuncs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numfuncs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WindowStatePerFunc perfuncstate = &amp;(winstate-&gt;perfunc[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (perfuncstate-&gt;plain_agg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1033" title="executor/nodeWindowAgg.c:1033">eval_windowfunction</a>(winstate, perfuncstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;(econtext-&gt;ecxt_aggvalues[perfuncstate-&gt;wfuncstate-&gt;wfuncno]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;(econtext-&gt;ecxt_aggnulls[perfuncstate-&gt;wfuncstate-&gt;wfuncno]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Evaluate aggregates<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;numaggs &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L663" title="executor/nodeWindowAgg.c:663">eval_windowaggregates</a>(winstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have created auxiliary read pointers for the frame or group<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * boundaries, force them to be kept up-to-date, because we don't know<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whether the window function(s) will do anything that requires that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Failing to advance the pointers would result in being unable to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * trim data from the tuplestore, which is bad.&nbsp; (If we could know in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * advance whether the window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> will use frame boundary info,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we could <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> creating these pointers in the first place ... but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unfortunately the window function API doesn't require that.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;framehead_ptr &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1485" title="executor/nodeWindowAgg.c:1485">update_frameheadpos</a>(winstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;frametail_ptr &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1735" title="executor/nodeWindowAgg.c:1735">update_frametailpos</a>(winstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;grouptail_ptr &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1985" title="executor/nodeWindowAgg.c:1985">update_grouptailpos</a>(winstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Truncate <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> no-longer-needed rows from the tuplestore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L1360" title="utils/sort/tuplestore.c:1360">tuplestore_trim</a>(winstate-&gt;buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Form and return a projection tuple using the windowfunc results and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the current row.&nbsp; Setting ecxt_outertuple arranges that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Vars<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will be evaluated with respect to that row.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_outertuple = winstate-&gt;ss.ss_ScanTupleSlot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot = ExecProject(winstate-&gt;ss.ps.ps_ProjInfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;status == WINDOWAGG_RUN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_scantuple = slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now evaluate the run condition to see if we need to go into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pass-through mode, or maybe stop completely.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ExecQual(winstate-&gt;runcondition, econtext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine which mode to move into.&nbsp; If there is no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PARTITION BY clause and we're the top-level WindowAgg then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we're done.&nbsp; This tuple and <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> future tuples cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possibly match the runcondition.&nbsp; However, when there is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PARTITION BY clause or we're not the top-level window we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can't just stop as we need to either process other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partitions or ensure WindowAgg nodes above us receive all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the tuples they need to process their WindowFuncs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;use_pass_through)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * STRICT pass-through mode is required for the top window<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when there is a PARTITION BY clause.&nbsp; Otherwise we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ensure we store tuples that don't match the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * runcondition so they're available to WindowAggs above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;top_window)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;status = WINDOWAGG_PASSTHROUGH_STRICT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;status = WINDOWAGG_PASSTHROUGH;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're not the top-window, we'd better NULLify<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the aggregate results.&nbsp; In pass-through mode we no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * longer update these and this avoids the old stale<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * results lingering.&nbsp; Some of these might be byref<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * types so we can't have them pointing to free'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memory.&nbsp; The <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> insisted that quals used in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the runcondition are strict, so the top-level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WindowAgg will filter these NULLs out in the filter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfuncs = winstate-&gt;numfuncs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numfuncs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_aggvalues[i] = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_aggnulls[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pass-through not required.&nbsp; We can just return NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Nothing else will match the runcondition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;status = WINDOWAGG_DONE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Filter out <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples we don't need in the top-level WindowAgg.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ExecQual(winstate-&gt;ss.ps.qual, econtext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InstrCountFiltered1(winstate, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When not in WINDOWAGG_RUN mode, we must still return this tuple if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we're anything apart from the top window.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!winstate-&gt;top_window)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> slot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* -----------------<br/></li>
<li></span><span class="Comment"> * <a href="#L2375" title="executor/nodeWindowAgg.c:2375">ExecInitWindowAgg</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Creates the run-time information for the WindowAgg node produced by the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> and initializes its outer subtree<br/></li>
<li></span><span class="Comment"> * -----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>WindowAggState *<br/></li>
<li><a id="L2375">&#x200c;</a><span class="linkable">ExecInitWindowAgg</span>(WindowAgg *node, EState *estate, <span class="Type">int</span> eflags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WindowAggState *winstate;<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *outerPlan;<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li>&nbsp; &nbsp; ExprContext *tmpcontext;<br/></li>
<li>&nbsp; &nbsp; WindowStatePerFunc perfunc;<br/></li>
<li>&nbsp; &nbsp; WindowStatePerAgg peragg;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frameOptions = node-&gt;frameOptions;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfuncs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wfuncno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numaggs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggno;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; scanDesc;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for unsupported flags */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!(eflags &amp; (EXEC_FLAG_BACKWARD | EXEC_FLAG_MARK)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create state structure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; winstate = makeNode(WindowAggState);<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;ss.ps.plan = (Plan *) node;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;ss.ps.state = estate;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;ss.ps.ExecProcNode = <a href="#L2046" title="executor/nodeWindowAgg.c:2046">ExecWindowAgg</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy frame options to state node for easy access */<br/></li>
<li></span>&nbsp; &nbsp; winstate-&gt;frameOptions = frameOptions;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create expression contexts.&nbsp; We need two, one for per-input-tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processing and one for per-output-tuple processing.&nbsp; We cheat a little<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by using <a href="execUtils.c.html#L483" title="executor/execUtils.c:483">ExecAssignExprContext</a>() to build both.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execUtils.c.html#L483" title="executor/execUtils.c:483">ExecAssignExprContext</a>(estate, &amp;winstate-&gt;ss.ps);<br/></li>
<li>&nbsp; &nbsp; tmpcontext = winstate-&gt;ss.ps.ps_ExprContext;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;tmpcontext = tmpcontext;<br/></li>
<li>&nbsp; &nbsp; <a href="execUtils.c.html#L483" title="executor/execUtils.c:483">ExecAssignExprContext</a>(estate, &amp;winstate-&gt;ss.ps);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create long-lived context for storage of partition-local memory etc */<br/></li>
<li></span>&nbsp; &nbsp; winstate-&gt;partcontext =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;WindowAgg Partition&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create mid-lived context for aggregate trans <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> etc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that moving aggregates each use their own private context, not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; winstate-&gt;aggcontext =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;WindowAgg Aggregates&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Only the top-level WindowAgg may have a qual */<br/></li>
<li></span>&nbsp; &nbsp; Assert(node-&gt;plan.qual == NIL || node-&gt;topWindow);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the qual */<br/></li>
<li></span>&nbsp; &nbsp; winstate-&gt;ss.ps.qual = <a href="execExpr.c.html#L220" title="executor/execExpr.c:220">ExecInitQual</a>(node-&gt;plan.qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (PlanState *) winstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Setup the run condition, if we received one from the query <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When set, this may allow us to move into pass-through mode so that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't have to perform <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> further evaluation of WindowFuncs in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current partition or possibly stop returning tuples altogether when all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuples are in the same partition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; winstate-&gt;runcondition = <a href="execExpr.c.html#L220" title="executor/execExpr.c:220">ExecInitQual</a>(node-&gt;runCondition,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (PlanState *) winstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When we're not the top-level WindowAgg node or we are but have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PARTITION BY clause we must move into one of the WINDOWAGG_PASSTHROUGH*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * modes when the runCondition becomes false.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; winstate-&gt;use_pass_through = !node-&gt;topWindow || node-&gt;partNumCols &gt; <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remember if we're the top-window or we are below the top-window */<br/></li>
<li></span>&nbsp; &nbsp; winstate-&gt;top_window = node-&gt;topWindow;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> child nodes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; outerPlan = outerPlan(node);<br/></li>
<li>&nbsp; &nbsp; outerPlanState(winstate) = <a href="execProcnode.c.html#L142" title="executor/execProcnode.c:142">ExecInitNode</a>(outerPlan, estate, eflags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> source tuple type (which is also the tuple type that we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * store in the tuplestore and use in all our working slots).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execUtils.c.html#L659" title="executor/execUtils.c:659">ExecCreateScanSlotFromOuterPlan</a>(estate, &amp;winstate-&gt;ss, &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li>&nbsp; &nbsp; scanDesc = winstate-&gt;ss.ss_ScanTupleSlot-&gt;tts_tupleDescriptor;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the outer tuple isn't the child's tuple, but always a minimal tuple */<br/></li>
<li></span>&nbsp; &nbsp; winstate-&gt;ss.ps.outeropsset = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;ss.ps.outerops = &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;ss.ps.outeropsfixed = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple table initialization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; winstate-&gt;first_part_slot = <a href="execTuples.c.html#L1918" title="executor/execTuples.c:1918">ExecInitExtraTupleSlot</a>(estate, scanDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;agg_row_slot = <a href="execTuples.c.html#L1918" title="executor/execTuples.c:1918">ExecInitExtraTupleSlot</a>(estate, scanDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;temp_slot_1 = <a href="execTuples.c.html#L1918" title="executor/execTuples.c:1918">ExecInitExtraTupleSlot</a>(estate, scanDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;temp_slot_2 = <a href="execTuples.c.html#L1918" title="executor/execTuples.c:1918">ExecInitExtraTupleSlot</a>(estate, scanDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create frame head and tail slots only if needed (must create slots in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exactly the same cases that <a href="#L1485" title="executor/nodeWindowAgg.c:1485">update_frameheadpos</a> and <a href="#L1735" title="executor/nodeWindowAgg.c:1735">update_frametailpos</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need them)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; winstate-&gt;framehead_slot = winstate-&gt;frametail_slot = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (frameOptions &amp; (FRAMEOPTION_RANGE | FRAMEOPTION_GROUPS))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((frameOptions &amp; FRAMEOPTION_START_CURRENT_ROW) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ordNumCols != <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (frameOptions &amp; FRAMEOPTION_START_OFFSET))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;framehead_slot = <a href="execTuples.c.html#L1918" title="executor/execTuples.c:1918">ExecInitExtraTupleSlot</a>(estate, scanDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((frameOptions &amp; FRAMEOPTION_END_CURRENT_ROW) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ordNumCols != <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (frameOptions &amp; FRAMEOPTION_END_OFFSET))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;frametail_slot = <a href="execTuples.c.html#L1918" title="executor/execTuples.c:1918">ExecInitExtraTupleSlot</a>(estate, scanDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize result slot, type and projection.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execTuples.c.html#L1886" title="executor/execTuples.c:1886">ExecInitResultTupleSlotTL</a>(&amp;winstate-&gt;ss.ps, &amp;<a href="execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="execUtils.c.html#L538" title="executor/execUtils.c:538">ExecAssignProjectionInfo</a>(&amp;winstate-&gt;ss.ps, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up data for comparing tuples */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;partNumCols &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;partEqfunction =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execGrouping.c.html#L58" title="executor/execGrouping.c:58">execTuplesMatchPrepare</a>(scanDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;partNumCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;partColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;partOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;partCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;winstate-&gt;ss.ps);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;ordNumCols &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;ordEqfunction =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execGrouping.c.html#L58" title="executor/execGrouping.c:58">execTuplesMatchPrepare</a>(scanDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ordNumCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ordColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ordOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;ordCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;winstate-&gt;ss.ps);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WindowAgg nodes use aggvalues and aggnulls as well as Agg nodes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; numfuncs = winstate-&gt;numfuncs;<br/></li>
<li>&nbsp; &nbsp; numaggs = winstate-&gt;numaggs;<br/></li>
<li>&nbsp; &nbsp; econtext = winstate-&gt;ss.ps.ps_ExprContext;<br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_aggvalues = (Datum *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * numfuncs);<br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_aggnulls = (<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * numfuncs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocate per-wfunc/per-agg state information.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; perfunc = (WindowStatePerFunc) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L78" title="executor/nodeWindowAgg.c:78">WindowStatePerFuncData</a>) * numfuncs);<br/></li>
<li>&nbsp; &nbsp; peragg = (WindowStatePerAgg) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L106" title="executor/nodeWindowAgg.c:106">WindowStatePerAggData</a>) * numaggs);<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;perfunc = perfunc;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;peragg = peragg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; wfuncno = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; aggno = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(l, winstate-&gt;funcs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WindowFuncExprState *wfuncstate = (WindowFuncExprState *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WindowFunc *wfunc = wfuncstate-&gt;wfunc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WindowStatePerFunc perfuncstate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AclResult&nbsp; &nbsp; aclresult;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wfunc-&gt;winref != node-&gt;winref)&nbsp; &nbsp; <span class="Comment">/* <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> screwed up? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;WindowFunc with winref </span><span class="Special">%u</span><span class="Constant"> assigned to WindowAgg with winref </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wfunc-&gt;winref, node-&gt;winref);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Look for a previous duplicate window function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt;= wfuncno; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(wfunc, perfunc[i].wfunc) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../optimizer/util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>((Node *) wfunc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt;= wfuncno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found a match to an existing entry, so just mark it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wfuncstate-&gt;wfuncno = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nope, so assign a new PerAgg record */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; perfuncstate = &amp;perfunc[++wfuncno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark WindowFunc state node with assigned index in the result array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; wfuncstate-&gt;wfuncno = wfuncno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check permission to call window function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L3876" title="catalog/aclchk.c:3876">object_aclcheck</a>(ProcedureRelationId, wfunc-&gt;winfnoid, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_EXECUTE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(aclresult, OBJECT_FUNCTION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L1608" title="utils/cache/lsyscache.c:1608">get_func_name</a>(wfunc-&gt;winfnoid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; InvokeFunctionExecuteHook(wfunc-&gt;winfnoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fill in the perfuncstate data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; perfuncstate-&gt;wfuncstate = wfuncstate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; perfuncstate-&gt;wfunc = wfunc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; perfuncstate-&gt;numArguments = list_length(wfuncstate-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; perfuncstate-&gt;winCollation = wfunc-&gt;inputcollid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L2251" title="utils/cache/lsyscache.c:2251">get_typlenbyval</a>(wfunc-&gt;wintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;perfuncstate-&gt;resulttypeLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;perfuncstate-&gt;resulttypeByVal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's really just a plain aggregate function, we'll emulate the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Agg environment for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; perfuncstate-&gt;plain_agg = wfunc-&gt;winagg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wfunc-&gt;winagg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WindowStatePerAgg peraggstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perfuncstate-&gt;aggno = ++aggno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peraggstate = &amp;winstate-&gt;peragg[aggno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2749" title="executor/nodeWindowAgg.c:2749">initialize_peragg</a>(winstate, wfunc, peraggstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;wfuncno = wfuncno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WindowObject winobj = makeNode(<a href="#L62" title="executor/nodeWindowAgg.c:62">WindowObjectData</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winobj-&gt;winstate = winstate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winobj-&gt;argstates = wfuncstate-&gt;args;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winobj-&gt;localmem = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perfuncstate-&gt;winobj = winobj;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It's a real window function, so set up to call it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(wfunc-&gt;winfnoid, &amp;perfuncstate-&gt;flinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_per_query_memory);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fmgr_info_set_expr((Node *) wfunc, &amp;perfuncstate-&gt;flinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update numfuncs, numaggs to match number of unique <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> found */<br/></li>
<li></span>&nbsp; &nbsp; winstate-&gt;numfuncs = wfuncno + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;numaggs = aggno + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up WindowObject for aggregates, if needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (winstate-&gt;numaggs &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WindowObject agg_winobj = makeNode(<a href="#L62" title="executor/nodeWindowAgg.c:62">WindowObjectData</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; agg_winobj-&gt;winstate = winstate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; agg_winobj-&gt;argstates = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; agg_winobj-&gt;localmem = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure markptr = -1 to invalidate. It may not get used */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; agg_winobj-&gt;markptr = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; agg_winobj-&gt;readptr = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;agg_winobj = agg_winobj;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set the status to running */<br/></li>
<li></span>&nbsp; &nbsp; winstate-&gt;status = WINDOWAGG_RUN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> frame bound offset expressions */<br/></li>
<li></span>&nbsp; &nbsp; winstate-&gt;startOffset = <a href="execExpr.c.html#L134" title="executor/execExpr.c:134">ExecInitExpr</a>((Expr *) node-&gt;startOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (PlanState *) winstate);<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;endOffset = <a href="execExpr.c.html#L134" title="executor/execExpr.c:134">ExecInitExpr</a>((Expr *) node-&gt;endOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (PlanState *) winstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Lookup in_range support <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> if needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(node-&gt;startInRangeFunc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(node-&gt;startInRangeFunc, &amp;winstate-&gt;startInRangeFunc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(node-&gt;endInRangeFunc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(node-&gt;endInRangeFunc, &amp;winstate-&gt;endInRangeFunc);<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;inRangeColl = node-&gt;inRangeColl;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;inRangeAsc = node-&gt;inRangeAsc;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;inRangeNullsFirst = node-&gt;inRangeNullsFirst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; winstate-&gt;all_first = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;partition_spooled = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; winstate-&gt;more_partitions = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> winstate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* -----------------<br/></li>
<li></span><span class="Comment"> * <a href="#L2682" title="executor/nodeWindowAgg.c:2682">ExecEndWindowAgg</a><br/></li>
<li></span><span class="Comment"> * -----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2682">&#x200c;</a></span><span class="linkable">ExecEndWindowAgg</span>(WindowAggState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlanState&nbsp; *outerPlan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1335" title="executor/nodeWindowAgg.c:1335">release_partition</a>(node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; node-&gt;numaggs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;peragg[i].aggcontext != node-&gt;aggcontext)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(node-&gt;peragg[i].aggcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(node-&gt;partcontext);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(node-&gt;aggcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(node-&gt;perfunc);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(node-&gt;peragg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; outerPlan = outerPlanState(node);<br/></li>
<li>&nbsp; &nbsp; <a href="execProcnode.c.html#L557" title="executor/execProcnode.c:557">ExecEndNode</a>(outerPlan);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* -----------------<br/></li>
<li></span><span class="Comment"> * <a href="#L2709" title="executor/nodeWindowAgg.c:2709">ExecReScanWindowAgg</a><br/></li>
<li></span><span class="Comment"> * -----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2709">&#x200c;</a></span><span class="linkable">ExecReScanWindowAgg</span>(WindowAggState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlanState&nbsp; *outerPlan = outerPlanState(node);<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext = node-&gt;ss.ps.ps_ExprContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node-&gt;status = WINDOWAGG_RUN;<br/></li>
<li>&nbsp; &nbsp; node-&gt;all_first = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* release tuplestore et al */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1335" title="executor/nodeWindowAgg.c:1335">release_partition</a>(node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* release all temp tuples, but especially first_part_slot */<br/></li>
<li></span>&nbsp; &nbsp; ExecClearTuple(node-&gt;ss.ss_ScanTupleSlot);<br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(node-&gt;first_part_slot);<br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(node-&gt;agg_row_slot);<br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(node-&gt;temp_slot_1);<br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(node-&gt;temp_slot_2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;framehead_slot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(node-&gt;framehead_slot);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;frametail_slot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(node-&gt;frametail_slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Forget current wfunc <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(econtext-&gt;ecxt_aggvalues, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * node-&gt;numfuncs);<br/></li>
<li>&nbsp; &nbsp; MemSet(econtext-&gt;ecxt_aggnulls, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * node-&gt;numfuncs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if chgParam of subnode is not null then plan will be re-scanned by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first ExecProcNode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (outerPlan-&gt;chgParam == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execAmi.c.html#L76" title="executor/execAmi.c:76">ExecReScan</a>(outerPlan);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2749" title="executor/nodeWindowAgg.c:2749">initialize_peragg</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Almost same as in nodeAgg.c, except we don't support DISTINCT currently.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L106" title="executor/nodeWindowAgg.c:106">WindowStatePerAggData</a> *<br/></li>
<li><a id="L2749">&#x200c;</a><span class="linkable">initialize_peragg</span>(WindowAggState *winstate, WindowFunc *wfunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WindowStatePerAgg peraggstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inputTypes[FUNC_MAX_ARGS];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numArguments;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; aggTuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_aggregate aggform;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggtranstype;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; initvalAttNo;<br/></li>
<li>&nbsp; &nbsp; AclResult&nbsp; &nbsp; aclresult;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; use_ma_code;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transfn_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invtransfn_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finalfn_oid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; finalextra;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; finalmodify;<br/></li>
<li>&nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *transfnexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *invtransfnexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *finalfnexpr;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; textInitVal;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; numArguments = list_length(wfunc-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, wfunc-&gt;args)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inputTypes[i++] = <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) lfirst(lc));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; aggTuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(AGGFNOID, ObjectIdGetDatum(wfunc-&gt;winfnoid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(aggTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for aggregate </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wfunc-&gt;winfnoid);<br/></li>
<li>&nbsp; &nbsp; aggform = (Form_pg_aggregate) GETSTRUCT(aggTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Figure out whether we want to use the moving-aggregate implementation,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and collect the right set of fields from the pg_aggregate entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's possible that an aggregate would supply a safe moving-aggregate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * implementation and an unsafe normal one, in which case our hand is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * forced.&nbsp; Otherwise, if the frame head can't move, we don't need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * moving-aggregate code.&nbsp; Even if we'd like to use it, don't do so if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggregate's arguments (and FILTER clause if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) contain <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> calls to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * volatile <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; Otherwise, the difference between restarting and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not restarting the aggregation would be user-visible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We also don't risk using moving aggregates when there are subplans in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the arguments or FILTER clause.&nbsp; This is partly because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../optimizer/util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>() doesn't look inside subplans; but there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are other reasons why a subplan's output might be volatile.&nbsp; For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * example, syncscan mode can render the results nonrepeatable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(aggform-&gt;aggminvtransfn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; use_ma_code = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* sine qua non */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (aggform-&gt;aggmfinalmodify == AGGMODIFY_READ_ONLY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggform-&gt;aggfinalmodify != AGGMODIFY_READ_ONLY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; use_ma_code = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* decision forced by safety */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (winstate-&gt;frameOptions &amp; FRAMEOPTION_START_UNBOUNDED_PRECEDING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; use_ma_code = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* non-moving frame head */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../optimizer/util/clauses.c.html#L538" title="optimizer/util/clauses.c:538">contain_volatile_functions</a>((Node *) wfunc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; use_ma_code = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* avoid possible behavioral change */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../optimizer/util/clauses.c.html#L330" title="optimizer/util/clauses.c:330">contain_subplans</a>((Node *) wfunc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; use_ma_code = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* subplans might contain volatile <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; use_ma_code = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* yes, let's use it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (use_ma_code)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;transfn_oid = transfn_oid = aggform-&gt;aggmtransfn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;invtransfn_oid = invtransfn_oid = aggform-&gt;aggminvtransfn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;finalfn_oid = finalfn_oid = aggform-&gt;aggmfinalfn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; finalextra = aggform-&gt;aggmfinalextra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; finalmodify = aggform-&gt;aggmfinalmodify;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggtranstype = aggform-&gt;aggmtranstype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initvalAttNo = Anum_pg_aggregate_aggminitval;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;transfn_oid = transfn_oid = aggform-&gt;aggtransfn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;invtransfn_oid = invtransfn_oid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;finalfn_oid = finalfn_oid = aggform-&gt;aggfinalfn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; finalextra = aggform-&gt;aggfinalextra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; finalmodify = aggform-&gt;aggfinalmodify;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggtranstype = aggform-&gt;aggtranstype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initvalAttNo = Anum_pg_aggregate_agginitval;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2375" title="executor/nodeWindowAgg.c:2375">ExecInitWindowAgg</a> already checked permission to call aggregate function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ... but we still need to check the component <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that aggregate owner has permission to call component fns */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; procTuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aggOwner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; procTuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PROCOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(wfunc-&gt;winfnoid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(procTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for function </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wfunc-&gt;winfnoid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aggOwner = ((Form_pg_proc) GETSTRUCT(procTuple))-&gt;proowner;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(procTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L3876" title="catalog/aclchk.c:3876">object_aclcheck</a>(ProcedureRelationId, transfn_oid, aggOwner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_EXECUTE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(aclresult, OBJECT_FUNCTION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L1608" title="utils/cache/lsyscache.c:1608">get_func_name</a>(transfn_oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; InvokeFunctionExecuteHook(transfn_oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(invtransfn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L3876" title="catalog/aclchk.c:3876">object_aclcheck</a>(ProcedureRelationId, invtransfn_oid, aggOwner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_EXECUTE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(aclresult, OBJECT_FUNCTION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L1608" title="utils/cache/lsyscache.c:1608">get_func_name</a>(invtransfn_oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvokeFunctionExecuteHook(invtransfn_oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(finalfn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L3876" title="catalog/aclchk.c:3876">object_aclcheck</a>(ProcedureRelationId, finalfn_oid, aggOwner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_EXECUTE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(aclresult, OBJECT_FUNCTION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L1608" title="utils/cache/lsyscache.c:1608">get_func_name</a>(finalfn_oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvokeFunctionExecuteHook(finalfn_oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the selected finalfn isn't read-only, we can't run this aggregate as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a window function.&nbsp; This is a user-facing error, so we take a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * care with the error message than elsewhere in this function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (finalmodify != AGGMODIFY_READ_ONLY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;aggregate function </span><span class="Special">%s</span><span class="Constant"> does not support use as a window function&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/regproc.c.html#L299" title="utils/adt/regproc.c:299">format_procedure</a>(wfunc-&gt;winfnoid))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Detect how many arguments to pass to the finalfn */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (finalextra)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;numFinalArgs = numArguments + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;numFinalArgs = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* resolve actual type of transition state, if polymorphic */<br/></li>
<li></span>&nbsp; &nbsp; aggtranstype = <a href="../parser/parse_agg.c.html#L1934" title="parser/parse_agg.c:1934">resolve_aggregate_transtype</a>(wfunc-&gt;winfnoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggtranstype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inputTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numArguments);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build expression trees using actual argument &amp; result types */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../parser/parse_agg.c.html#L2028" title="parser/parse_agg.c:2028">build_aggregate_transfn_expr</a>(inputTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numArguments,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>, <span class="Comment">/* no ordered-set window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Comment">/* no variadic window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggtranstype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wfunc-&gt;inputcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; transfn_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; invtransfn_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;transfnexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;invtransfnexpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set up infrastructure for calling the transfn(s) and finalfn */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(transfn_oid, &amp;peraggstate-&gt;transfn);<br/></li>
<li>&nbsp; &nbsp; fmgr_info_set_expr((Node *) transfnexpr, &amp;peraggstate-&gt;transfn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(invtransfn_oid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(invtransfn_oid, &amp;peraggstate-&gt;invtransfn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fmgr_info_set_expr((Node *) invtransfnexpr, &amp;peraggstate-&gt;invtransfn);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(finalfn_oid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../parser/parse_agg.c.html#L2136" title="parser/parse_agg.c:2136">build_aggregate_finalfn_expr</a>(inputTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; peraggstate-&gt;numFinalArgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggtranstype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wfunc-&gt;wintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wfunc-&gt;inputcollid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; finalfn_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;finalfnexpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(finalfn_oid, &amp;peraggstate-&gt;finalfn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fmgr_info_set_expr((Node *) finalfnexpr, &amp;peraggstate-&gt;finalfn);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* get info about relevant datatypes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L2251" title="utils/cache/lsyscache.c:2251">get_typlenbyval</a>(wfunc-&gt;wintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;peraggstate-&gt;resulttypeLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;peraggstate-&gt;resulttypeByVal);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L2251" title="utils/cache/lsyscache.c:2251">get_typlenbyval</a>(aggtranstype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;peraggstate-&gt;transtypeLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;peraggstate-&gt;transtypeByVal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initval is potentially null, so don't try to access it as a struct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * field. Must do it the hard way with <a href="../utils/cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; textInitVal = <a href="../utils/cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(AGGFNOID, aggTuple, initvalAttNo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;peraggstate-&gt;initValueIsNull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (peraggstate-&gt;initValueIsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;initValue = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;initValue = <a href="#L3022" title="executor/nodeWindowAgg.c:3022">GetAggInitVal</a>(textInitVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aggtranstype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the transfn is strict and the initval is NULL, make sure input type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and transtype are the same (or at least binary-compatible), so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's OK to use the first input value as the initial transValue.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should have been checked at agg definition time, but we must check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * again in case the transfn's strictness property has been changed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (peraggstate-&gt;transfn.fn_strict &amp;&amp; peraggstate-&gt;initValueIsNull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (numArguments &lt; <span class="Constant">1</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../parser/parse_coerce.c.html#L2995" title="parser/parse_coerce.c:2995">IsBinaryCoercible</a>(inputTypes[<span class="Constant">0</span>], aggtranstype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FUNCTION_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;aggregate </span><span class="Special">%u</span><span class="Constant"> needs to have compatible input type and transition type&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wfunc-&gt;winfnoid)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Insist that forward and inverse transition <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> have the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * strictness setting.&nbsp; Allowing them to differ would require handling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more special cases in <a href="#L242" title="executor/nodeWindowAgg.c:242">advance_windowaggregate</a> and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L419" title="executor/nodeWindowAgg.c:419">advance_windowaggregate_base</a>, for no discernible benefit.&nbsp; This should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have been checked at agg definition time, but we must check again in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case either function's strictness property has been changed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(invtransfn_oid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;transfn.fn_strict != peraggstate-&gt;invtransfn.fn_strict)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FUNCTION_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;strictness of aggregate's forward and inverse transition <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> must match&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Moving aggregates use their own aggcontext.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is necessary because they might restart at different times, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might never be able to reset the shared context otherwise.&nbsp; We can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * make it the aggregates' responsibility to clean up after themselves,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because strict aggregates must be restarted whenever we remove their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * last non-NULL input, which the aggregate won't be aware is happening.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, just <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>()ing the transValue upon restarting wouldn't <a href="../main/main.c.html#L320" title="main/main.c:320">help</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since we'd <a href="../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> indirectly referenced data.&nbsp; We could, in theory,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * make the memory allocation rules for moving aggregates different than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they have historically been for plain aggregates, but that seems grotty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and likely to lead to memory leaks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(invtransfn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;aggcontext =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;WindowAgg Per Aggregate&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; peraggstate-&gt;aggcontext = winstate-&gt;aggcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(aggTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> peraggstate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Datum<br/></li>
<li><a id="L3022">&#x200c;</a><span class="linkable">GetAggInitVal</span>(Datum textInitVal, Oid transtype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typinput,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typioparam;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *strInitVal;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; initVal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L2874" title="utils/cache/lsyscache.c:2874">getTypeInputInfo</a>(transtype, &amp;typinput, &amp;typioparam);<br/></li>
<li>&nbsp; &nbsp; strInitVal = TextDatumGetCString(textInitVal);<br/></li>
<li>&nbsp; &nbsp; initVal = <a href="../utils/fmgr/fmgr.c.html#L1754" title="utils/fmgr/fmgr.c:1754">OidInputFunctionCall</a>(typinput, strInitVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typioparam, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(strInitVal);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> initVal;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3044" title="executor/nodeWindowAgg.c:3044">are_peers</a><br/></li>
<li></span><span class="Comment"> * <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> two rows to see if they are <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> according to the ORDER BY clause<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: this does not consider the window frame mode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3044">&#x200c;</a></span><span class="linkable">are_peers</span>(WindowAggState *winstate, TupleTableSlot *slot1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *slot2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WindowAgg&nbsp; *node = (WindowAgg *) winstate-&gt;ss.ps.plan;<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext = winstate-&gt;tmpcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If no ORDER BY, all rows are peers with each other */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;ordNumCols == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_outertuple = slot1;<br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_innertuple = slot2;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ExecQualAndReset(winstate-&gt;ordEqfunction, econtext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3067" title="executor/nodeWindowAgg.c:3067">window_gettupleslot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Fetch the pos'th tuple of the current partition into the slot,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; using the winobj's read pointer<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if no such row<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3067">&#x200c;</a></span><span class="linkable">window_gettupleslot</span>(WindowObject winobj, int64 pos, TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WindowAggState *winstate = winobj-&gt;winstate;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* often called repeatedly in a row */<br/></li>
<li></span>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't allow passing -1 to <a href="#L1241" title="executor/nodeWindowAgg.c:1241">spool_tuples</a> here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pos &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If necessary, fetch the tuple into the spool */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1241" title="executor/nodeWindowAgg.c:1241">spool_tuples</a>(winstate, pos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pos &gt;= winstate-&gt;spooled_rows)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pos &lt; winobj-&gt;markpos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot fetch row <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> WindowObject's mark position&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(winstate-&gt;ss.ps.ps_ExprContext-&gt;ecxt_per_query_memory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L473" title="utils/sort/tuplestore.c:473">tuplestore_select_read_pointer</a>(winstate-&gt;buffer, winobj-&gt;readptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advance or rewind until we are within one tuple of the one we want.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (winobj-&gt;seekpos &lt; pos - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/sort/tuplestore.c.html#L1135" title="utils/sort/tuplestore.c:1135">tuplestore_skiptuples</a>(winstate-&gt;buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pos - <span class="Constant">1</span> - winobj-&gt;seekpos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected end of tuplestore&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winobj-&gt;seekpos = pos - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (winobj-&gt;seekpos &gt; pos + <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/sort/tuplestore.c.html#L1135" title="utils/sort/tuplestore.c:1135">tuplestore_skiptuples</a>(winstate-&gt;buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winobj-&gt;seekpos - (pos + <span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected end of tuplestore&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winobj-&gt;seekpos = pos + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (winobj-&gt;seekpos == pos)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There's no API to refetch the tuple at the current position.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have to move one tuple forward, and then one backward.&nbsp; (We don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do it the other way because we might try to fetch the row <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * our mark, which isn't allowed.)&nbsp; </span><span class="Todo">XXX</span><span class="Comment"> this case could stand to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * optimized.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L1110" title="utils/sort/tuplestore.c:1110">tuplestore_advance</a>(winstate-&gt;buffer, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winobj-&gt;seekpos++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we should be on the tuple immediately <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> or after the one we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * want, so just fetch forwards or backwards as appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Notice that we tell <a href="../utils/sort/tuplestore.c.html#L1078" title="utils/sort/tuplestore.c:1078">tuplestore_gettupleslot</a> to make a physical copy of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the fetched tuple.&nbsp; This ensures that the slot's contents remain valid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * through manipulations of the tuplestore, which some callers depend on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (winobj-&gt;seekpos &gt; pos)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/sort/tuplestore.c.html#L1078" title="utils/sort/tuplestore.c:1078">tuplestore_gettupleslot</a>(winstate-&gt;buffer, <span class="Constant">false</span>, <span class="Constant">true</span>, slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected end of tuplestore&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winobj-&gt;seekpos--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/sort/tuplestore.c.html#L1078" title="utils/sort/tuplestore.c:1078">tuplestore_gettupleslot</a>(winstate-&gt;buffer, <span class="Constant">true</span>, <span class="Constant">true</span>, slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected end of tuplestore&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winobj-&gt;seekpos++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(winobj-&gt;seekpos == pos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/***********************************************************************<br/></li>
<li></span><span class="Comment"> * API exposed to window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> ***********************************************************************/<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3171" title="executor/nodeWindowAgg.c:3171">WinGetPartitionLocalMemory</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get working memory that lives till end of partition processing<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On first call within a given partition, this allocates and zeroes the<br/></li>
<li></span><span class="Comment"> * requested amount of space.&nbsp; Subsequent calls just return the same chunk.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Memory obtained this way is normally used to hold state that should be<br/></li>
<li></span><span class="Comment"> * automatically reset for each new partition.&nbsp; If a window function wants<br/></li>
<li></span><span class="Comment"> * to hold state across the whole query, fcinfo-&gt;fn_extra can be used in the<br/></li>
<li></span><span class="Comment"> * usual way for that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L3171">&#x200c;</a><span class="linkable">WinGetPartitionLocalMemory</span>(WindowObject winobj, Size sz)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(WindowObjectIsValid(winobj));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (winobj-&gt;localmem == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winobj-&gt;localmem =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(winobj-&gt;winstate-&gt;partcontext, sz);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> winobj-&gt;localmem;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3186" title="executor/nodeWindowAgg.c:3186">WinGetCurrentPosition</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return the current row's position (counting from 0) within the current<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; partition.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>int64<br/></li>
<li><a id="L3186">&#x200c;</a><span class="linkable">WinGetCurrentPosition</span>(WindowObject winobj)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(WindowObjectIsValid(winobj));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> winobj-&gt;winstate-&gt;currentpos;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3201" title="executor/nodeWindowAgg.c:3201">WinGetPartitionRowCount</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return total number of rows contained in the current partition.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this is a relatively expensive operation because it forces the<br/></li>
<li></span><span class="Comment"> * whole partition to be &quot;spooled&quot; into the tuplestore at once.&nbsp; Once<br/></li>
<li></span><span class="Comment"> * executed, however, additional calls within the same partition are cheap.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>int64<br/></li>
<li><a id="L3201">&#x200c;</a><span class="linkable">WinGetPartitionRowCount</span>(WindowObject winobj)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(WindowObjectIsValid(winobj));<br/></li>
<li>&nbsp; &nbsp; <a href="#L1241" title="executor/nodeWindowAgg.c:1241">spool_tuples</a>(winobj-&gt;winstate, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> winobj-&gt;winstate-&gt;spooled_rows;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3219" title="executor/nodeWindowAgg.c:3219">WinSetMarkPosition</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set the &quot;mark&quot; position for the window object, which is the oldest row<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; number (counting from 0) it is allowed to fetch during all subsequent<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; operations within the current partition.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> do not have to call this, but are encouraged to move the<br/></li>
<li></span><span class="Comment"> * mark forward when possible to keep the tuplestore size down and prevent<br/></li>
<li></span><span class="Comment"> * having to spill rows to disk.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3219">&#x200c;</a></span><span class="linkable">WinSetMarkPosition</span>(WindowObject winobj, int64 markpos)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WindowAggState *winstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(WindowObjectIsValid(winobj));<br/></li>
<li>&nbsp; &nbsp; winstate = winobj-&gt;winstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (markpos &lt; winobj-&gt;markpos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot move WindowObject's mark position backward&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L473" title="utils/sort/tuplestore.c:473">tuplestore_select_read_pointer</a>(winstate-&gt;buffer, winobj-&gt;markptr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (markpos &gt; winobj-&gt;markpos)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L1135" title="utils/sort/tuplestore.c:1135">tuplestore_skiptuples</a>(winstate-&gt;buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; markpos - winobj-&gt;markpos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winobj-&gt;markpos = markpos;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L473" title="utils/sort/tuplestore.c:473">tuplestore_select_read_pointer</a>(winstate-&gt;buffer, winobj-&gt;readptr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (markpos &gt; winobj-&gt;seekpos)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L1135" title="utils/sort/tuplestore.c:1135">tuplestore_skiptuples</a>(winstate-&gt;buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; markpos - winobj-&gt;seekpos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winobj-&gt;seekpos = markpos;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3254" title="executor/nodeWindowAgg.c:3254">WinRowsArePeers</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Compare two rows (specified by absolute position in partition) to see<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; if they are <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> according to the ORDER BY clause.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: this does not consider the window frame mode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3254">&#x200c;</a></span><span class="linkable">WinRowsArePeers</span>(WindowObject winobj, int64 pos1, int64 pos2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WindowAggState *winstate;<br/></li>
<li>&nbsp; &nbsp; WindowAgg&nbsp; *node;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot1;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(WindowObjectIsValid(winobj));<br/></li>
<li>&nbsp; &nbsp; winstate = winobj-&gt;winstate;<br/></li>
<li>&nbsp; &nbsp; node = (WindowAgg *) winstate-&gt;ss.ps.plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If no ORDER BY, all rows are peers; don't bother to fetch them */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;ordNumCols == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: OK to use temp_slot_2 here because we aren't calling <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * frame-related <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> (those tend to clobber temp_slot_2).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; slot1 = winstate-&gt;temp_slot_1;<br/></li>
<li>&nbsp; &nbsp; slot2 = winstate-&gt;temp_slot_2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3067" title="executor/nodeWindowAgg.c:3067">window_gettupleslot</a>(winobj, pos1, slot1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;specified position is out of window: &quot;</span> INT64_FORMAT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pos1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3067" title="executor/nodeWindowAgg.c:3067">window_gettupleslot</a>(winobj, pos2, slot2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;specified position is out of window: &quot;</span> INT64_FORMAT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pos2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L3044" title="executor/nodeWindowAgg.c:3044">are_peers</a>(winstate, slot1, slot2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(slot1);<br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(slot2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3311" title="executor/nodeWindowAgg.c:3311">WinGetFuncArgInPartition</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Evaluate a window function's argument expression on a specified<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; row of the partition.&nbsp; The row is identified in lseek(2) style,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; i.e. relative to the current, first, or last row.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * argno: argument number to evaluate (counted from 0)<br/></li>
<li></span><span class="Comment"> * relpos: signed rowcount offset from the seek position<br/></li>
<li></span><span class="Comment"> * seektype: WINDOW_SEEK_CURRENT, WINDOW_SEEK_HEAD, or WINDOW_SEEK_TAIL<br/></li>
<li></span><span class="Comment"> * set_mark: If the row is found and set_mark is true, the mark is moved to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the row as a side-effect.<br/></li>
<li></span><span class="Comment"> * isnull: output argument, receives isnull status of result<br/></li>
<li></span><span class="Comment"> * isout: output argument, set to indicate whether target row position<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; is out of partition (can pass NULL if caller doesn't care about this)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Specifying a nonexistent row is not an error, it just causes a null result<br/></li>
<li></span><span class="Comment"> * (plus setting *isout true, if isout isn't NULL).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3311">&#x200c;</a><span class="linkable">WinGetFuncArgInPartition</span>(WindowObject winobj, <span class="Type">int</span> argno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> relpos, <span class="Type">int</span> seektype, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> set_mark,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isout)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WindowAggState *winstate;<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; gottuple;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; abs_pos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(WindowObjectIsValid(winobj));<br/></li>
<li>&nbsp; &nbsp; winstate = winobj-&gt;winstate;<br/></li>
<li>&nbsp; &nbsp; econtext = winstate-&gt;ss.ps.ps_ExprContext;<br/></li>
<li>&nbsp; &nbsp; slot = winstate-&gt;temp_slot_1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (seektype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WINDOW_SEEK_CURRENT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abs_pos = winstate-&gt;currentpos + relpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WINDOW_SEEK_HEAD:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abs_pos = relpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WINDOW_SEEK_TAIL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1241" title="executor/nodeWindowAgg.c:1241">spool_tuples</a>(winstate, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abs_pos = winstate-&gt;spooled_rows - <span class="Constant">1</span> + relpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized window seek type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, seektype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abs_pos = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; gottuple = <a href="#L3067" title="executor/nodeWindowAgg.c:3067">window_gettupleslot</a>(winobj, abs_pos, slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!gottuple)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isout)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isout = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isout)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isout = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (set_mark)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3219" title="executor/nodeWindowAgg.c:3219">WinSetMarkPosition</a>(winobj, abs_pos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_outertuple = slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ExecEvalExpr((ExprState *) list_nth(winobj-&gt;argstates, argno),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext, isnull);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3399" title="executor/nodeWindowAgg.c:3399">WinGetFuncArgInFrame</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Evaluate a window function's argument expression on a specified<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; row of the window frame.&nbsp; The row is identified in lseek(2) style,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; i.e. relative to the first or last row of the frame.&nbsp; (We do not<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; support WINDOW_SEEK_CURRENT here, because it's not very clear what<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; that should mean if the current row isn't part of the frame.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * argno: argument number to evaluate (counted from 0)<br/></li>
<li></span><span class="Comment"> * relpos: signed rowcount offset from the seek position<br/></li>
<li></span><span class="Comment"> * seektype: WINDOW_SEEK_HEAD or WINDOW_SEEK_TAIL<br/></li>
<li></span><span class="Comment"> * set_mark: If the row is found/in frame and set_mark is true, the mark is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; moved to the row as a side-effect.<br/></li>
<li></span><span class="Comment"> * isnull: output argument, receives isnull status of result<br/></li>
<li></span><span class="Comment"> * isout: output argument, set to indicate whether target row position<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; is out of frame (can pass NULL if caller doesn't care about this)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Specifying a nonexistent or not-in-frame row is not an error, it just<br/></li>
<li></span><span class="Comment"> * causes a null result (plus setting *isout true, if isout isn't NULL).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that some exclusion-clause options lead to situations where the<br/></li>
<li></span><span class="Comment"> * rows that are in-frame are not consecutive in the partition.&nbsp; But we<br/></li>
<li></span><span class="Comment"> * count only in-frame rows when measuring relpos.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The set_mark flag is interpreted as meaning that the caller will specify<br/></li>
<li></span><span class="Comment"> * a constant (or, perhaps, monotonically increasing) relpos in successive<br/></li>
<li></span><span class="Comment"> * calls, so that *if there is no exclusion clause* there will be no need<br/></li>
<li></span><span class="Comment"> * to fetch a row <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the previously fetched row.&nbsp; But we do not expect<br/></li>
<li></span><span class="Comment"> * the caller to know how to account for exclusion clauses.&nbsp; Therefore,<br/></li>
<li></span><span class="Comment"> * if there is an exclusion clause we take responsibility for adjusting the<br/></li>
<li></span><span class="Comment"> * mark request to something that will be safe given the above assumption<br/></li>
<li></span><span class="Comment"> * about relpos.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3399">&#x200c;</a><span class="linkable">WinGetFuncArgInFrame</span>(WindowObject winobj, <span class="Type">int</span> argno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> relpos, <span class="Type">int</span> seektype, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> set_mark,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isout)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WindowAggState *winstate;<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; abs_pos;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; mark_pos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(WindowObjectIsValid(winobj));<br/></li>
<li>&nbsp; &nbsp; winstate = winobj-&gt;winstate;<br/></li>
<li>&nbsp; &nbsp; econtext = winstate-&gt;ss.ps.ps_ExprContext;<br/></li>
<li>&nbsp; &nbsp; slot = winstate-&gt;temp_slot_1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (seektype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WINDOW_SEEK_CURRENT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;WINDOW_SEEK_CURRENT is not supported for <a href="#L3399" title="executor/nodeWindowAgg.c:3399">WinGetFuncArgInFrame</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abs_pos = mark_pos = <span class="Constant">0</span>; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WINDOW_SEEK_HEAD:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rejecting relpos &lt; 0 is easy and simplifies code below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relpos &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_frame;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1485" title="executor/nodeWindowAgg.c:1485">update_frameheadpos</a>(winstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abs_pos = winstate-&gt;frameheadpos + relpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mark_pos = abs_pos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Account for exclusion option if one is active, but advance only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * abs_pos not mark_pos.&nbsp; This prevents changes of the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * row's peer group from resulting in trying to fetch a row <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * some previous mark position.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that in some corner cases such as current row being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * outside frame, these calculations are theoretically too simple,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but it doesn't matter because we'll end up deciding the row is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * out of frame.&nbsp; We do not attempt to avoid fetching rows past<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end of frame; that would happen in some cases anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (winstate-&gt;frameOptions &amp; FRAMEOPTION_EXCLUSION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no adjustment needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FRAMEOPTION_EXCLUDE_CURRENT_ROW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (abs_pos &gt;= winstate-&gt;currentpos &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;currentpos &gt;= winstate-&gt;frameheadpos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abs_pos++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FRAMEOPTION_EXCLUDE_GROUP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1985" title="executor/nodeWindowAgg.c:1985">update_grouptailpos</a>(winstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (abs_pos &gt;= winstate-&gt;groupheadpos &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;grouptailpos &gt; winstate-&gt;frameheadpos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; overlapstart = Max(winstate-&gt;groupheadpos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;frameheadpos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abs_pos += winstate-&gt;grouptailpos - overlapstart;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FRAMEOPTION_EXCLUDE_TIES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1985" title="executor/nodeWindowAgg.c:1985">update_grouptailpos</a>(winstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (abs_pos &gt;= winstate-&gt;groupheadpos &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;grouptailpos &gt; winstate-&gt;frameheadpos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; overlapstart = Max(winstate-&gt;groupheadpos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;frameheadpos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (abs_pos == overlapstart)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abs_pos = winstate-&gt;currentpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abs_pos += winstate-&gt;grouptailpos - overlapstart - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized frame option state: 0x</span><span class="Special">%x</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;frameOptions);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WINDOW_SEEK_TAIL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rejecting relpos &gt; 0 is easy and simplifies code below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relpos &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_frame;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1735" title="executor/nodeWindowAgg.c:1735">update_frametailpos</a>(winstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abs_pos = winstate-&gt;frametailpos - <span class="Constant">1</span> + relpos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Account for exclusion option if one is active.&nbsp; If there is no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exclusion, we can safely set the mark at the accessed row.&nbsp; But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if there is, we can only mark the frame start, because we can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be sure how far back in the frame the exclusion might cause us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to fetch in future.&nbsp; Furthermore, we have to actually check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * against frameheadpos here, since it's unsafe to try to fetch a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * row <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> frame start if the mark might be there already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (winstate-&gt;frameOptions &amp; FRAMEOPTION_EXCLUSION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no adjustment needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mark_pos = abs_pos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FRAMEOPTION_EXCLUDE_CURRENT_ROW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (abs_pos &lt;= winstate-&gt;currentpos &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;currentpos &lt; winstate-&gt;frametailpos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abs_pos--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1485" title="executor/nodeWindowAgg.c:1485">update_frameheadpos</a>(winstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (abs_pos &lt; winstate-&gt;frameheadpos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_frame;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mark_pos = winstate-&gt;frameheadpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FRAMEOPTION_EXCLUDE_GROUP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1985" title="executor/nodeWindowAgg.c:1985">update_grouptailpos</a>(winstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (abs_pos &lt; winstate-&gt;grouptailpos &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;groupheadpos &lt; winstate-&gt;frametailpos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; overlapend = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(winstate-&gt;grouptailpos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;frametailpos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abs_pos -= overlapend - winstate-&gt;groupheadpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1485" title="executor/nodeWindowAgg.c:1485">update_frameheadpos</a>(winstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (abs_pos &lt; winstate-&gt;frameheadpos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_frame;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mark_pos = winstate-&gt;frameheadpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FRAMEOPTION_EXCLUDE_TIES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1985" title="executor/nodeWindowAgg.c:1985">update_grouptailpos</a>(winstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (abs_pos &lt; winstate-&gt;grouptailpos &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winstate-&gt;groupheadpos &lt; winstate-&gt;frametailpos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; overlapend = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(winstate-&gt;grouptailpos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;frametailpos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (abs_pos == overlapend - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abs_pos = winstate-&gt;currentpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abs_pos -= overlapend - <span class="Constant">1</span> - winstate-&gt;groupheadpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1485" title="executor/nodeWindowAgg.c:1485">update_frameheadpos</a>(winstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (abs_pos &lt; winstate-&gt;frameheadpos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_frame;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mark_pos = winstate-&gt;frameheadpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized frame option state: 0x</span><span class="Special">%x</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; winstate-&gt;frameOptions);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mark_pos = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized window seek type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, seektype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abs_pos = mark_pos = <span class="Constant">0</span>; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3067" title="executor/nodeWindowAgg.c:3067">window_gettupleslot</a>(winobj, abs_pos, slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_frame;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The code above does not detect all out-of-frame cases, so check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1385" title="executor/nodeWindowAgg.c:1385">row_is_in_frame</a>(winstate, abs_pos, slot) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_frame;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isout)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *isout = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (set_mark)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3219" title="executor/nodeWindowAgg.c:3219">WinSetMarkPosition</a>(winobj, mark_pos);<br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_outertuple = slot;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ExecEvalExpr((ExprState *) list_nth(winobj-&gt;argstates, argno),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext, isnull);<br/></li>
<li><br/></li>
<li><span class="Statement">out_of_frame</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isout)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *isout = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3594" title="executor/nodeWindowAgg.c:3594">WinGetFuncArgCurrent</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Evaluate a window function's argument expression on the current row.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * argno: argument number to evaluate (counted from 0)<br/></li>
<li></span><span class="Comment"> * isnull: output argument, receives isnull status of result<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this isn't quite equivalent to <a href="#L3311" title="executor/nodeWindowAgg.c:3311">WinGetFuncArgInPartition</a> or<br/></li>
<li></span><span class="Comment"> * <a href="#L3399" title="executor/nodeWindowAgg.c:3399">WinGetFuncArgInFrame</a> targeting the current row, because it will succeed<br/></li>
<li></span><span class="Comment"> * even if the WindowObject's mark has been set beyond the current row.<br/></li>
<li></span><span class="Comment"> * This should generally be used for &quot;ordinary&quot; arguments of a window<br/></li>
<li></span><span class="Comment"> * function, such as the offset argument of lead() or lag().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3594">&#x200c;</a><span class="linkable">WinGetFuncArgCurrent</span>(WindowObject winobj, <span class="Type">int</span> argno, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WindowAggState *winstate;<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(WindowObjectIsValid(winobj));<br/></li>
<li>&nbsp; &nbsp; winstate = winobj-&gt;winstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; econtext = winstate-&gt;ss.ps.ps_ExprContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; econtext-&gt;ecxt_outertuple = winstate-&gt;ss.ss_ScanTupleSlot;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ExecEvalExpr((ExprState *) list_nth(winobj-&gt;argstates, argno),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext, isnull);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
