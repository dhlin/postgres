<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>executor/nodeSetOp.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>executor/nodeSetOp.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L64">SetOpStatePerGroupData</a></li>
<li><a href="#L68">SetOpStatePerGroupData</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L583">ExecEndSetOp</a></li>
<li><a href="#L481">ExecInitSetOp</a></li>
<li><a href="#L594">ExecReScanSetOp</a></li>
<li><a href="#L190">ExecSetOp</a></li>
<li><a href="#L89">advance_counts</a></li>
<li><a href="#L120">build_hash_table</a></li>
<li><a href="#L102">fetch_tuple_flag</a></li>
<li><a href="#L80">initialize_counts</a></li>
<li><a href="#L150">set_output_count</a></li>
<li><a href="#L339">setop_fill_hash_table</a></li>
<li><a href="#L227">setop_retrieve_direct</a></li>
<li><a href="#L425">setop_retrieve_hash_table</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * nodeSetOp.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines to handle INTERSECT and EXCEPT selection<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The input of a SetOp node consists of tuples from two relations,<br/></li>
<li></span><span class="Comment"> * which have been combined into one dataset, with a junk attribute added<br/></li>
<li></span><span class="Comment"> * that shows which relation each tuple came from.&nbsp; In SETOP_SORTED mode,<br/></li>
<li></span><span class="Comment"> * the input has furthermore been sorted according to all the grouping<br/></li>
<li></span><span class="Comment"> * columns (ie, all the non-junk attributes).&nbsp; The SetOp node scans each<br/></li>
<li></span><span class="Comment"> * group of identical tuples to determine how many came from each input<br/></li>
<li></span><span class="Comment"> * relation.&nbsp; Then it is a simple matter to emit the output demanded by the<br/></li>
<li></span><span class="Comment"> * SQL spec for INTERSECT, INTERSECT ALL, EXCEPT, or EXCEPT ALL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In SETOP_HASHED mode, the input is delivered in no particular order,<br/></li>
<li></span><span class="Comment"> * except that we know all the tuples from one input relation will come <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * all the tuples of the other.&nbsp; The <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> guarantees that the first input<br/></li>
<li></span><span class="Comment"> * relation is the left-hand one for EXCEPT, and tries to make the smaller<br/></li>
<li></span><span class="Comment"> * input relation come first for INTERSECT.&nbsp; We build a <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table in memory<br/></li>
<li></span><span class="Comment"> * with one entry for each group of identical tuples, and count the number of<br/></li>
<li></span><span class="Comment"> * tuples in the group from each relation.&nbsp; After seeing all the input, we<br/></li>
<li></span><span class="Comment"> * scan the hashtable and generate the correct output using those counts.<br/></li>
<li></span><span class="Comment"> * We can avoid making hashtable entries for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples appearing only in the<br/></li>
<li></span><span class="Comment"> * second input relation, since they cannot result in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> output.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This node type is not used for UNION or UNION ALL, since those can be<br/></li>
<li></span><span class="Comment"> * implemented more cheaply (there's no need for the junk attribute to<br/></li>
<li></span><span class="Comment"> * identify the source relation).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that SetOp does no qual checking nor projection.&nbsp; The delivered<br/></li>
<li></span><span class="Comment"> * output tuples are just copies of the first-to-arrive tuple in each<br/></li>
<li></span><span class="Comment"> * input group.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/executor/nodeSetOp.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeSetOp.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L64" title="executor/nodeSetOp.c:64">SetOpStatePerGroupData</a> - per-group working state<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are working state that is initialized at the start of<br/></li>
<li></span><span class="Comment"> * an input tuple group and updated for each input tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In SETOP_SORTED mode, we need only one of these structs, and it's kept in<br/></li>
<li></span><span class="Comment"> * the plan state node.&nbsp; In SETOP_HASHED mode, the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table contains one<br/></li>
<li></span><span class="Comment"> * of these for each tuple group.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L64">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">SetOpStatePerGroupData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; numLeft;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of left-input dups in group */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; numRight;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of right-input dups in group */<br/></li>
<li><a id="L68">&#x200c;</a></span>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">SetOpStatePerGroupData</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> TupleTableSlot *<a href="#L227" title="executor/nodeSetOp.c:227">setop_retrieve_direct</a>(SetOpState *setopstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L339" title="executor/nodeSetOp.c:339">setop_fill_hash_table</a>(SetOpState *setopstate);<br/></li>
<li><span class="Type">static</span> TupleTableSlot *<a href="#L425" title="executor/nodeSetOp.c:425">setop_retrieve_hash_table</a>(SetOpState *setopstate);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize state for a new group of input <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L80">&#x200c;</a></span><span class="linkable">initialize_counts</span>(SetOpStatePerGroup pergroup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pergroup-&gt;numLeft = pergroup-&gt;numRight = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Advance the appropriate counter for one input tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L89">&#x200c;</a></span><span class="linkable">advance_counts</span>(SetOpStatePerGroup pergroup, <span class="Type">int</span> flag)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flag)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pergroup-&gt;numRight++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pergroup-&gt;numLeft++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch the &quot;flag&quot; column from an input tuple.<br/></li>
<li></span><span class="Comment"> * This is an integer column with value 0 for left side, 1 for right side.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L102">&#x200c;</a></span><span class="linkable">fetch_tuple_flag</span>(SetOpState *setopstate, TupleTableSlot *inputslot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SetOp&nbsp; &nbsp; &nbsp;&nbsp; *node = (SetOp *) setopstate-&gt;ps.plan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flag;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; flag = DatumGetInt32(slot_getattr(inputslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;flagColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isNull));<br/></li>
<li>&nbsp; &nbsp; Assert(!isNull);<br/></li>
<li>&nbsp; &nbsp; Assert(flag == <span class="Constant">0</span> || flag == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> flag;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table to empty.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L120">&#x200c;</a></span><span class="linkable">build_hash_table</span>(SetOpState *setopstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SetOp&nbsp; &nbsp; &nbsp;&nbsp; *node = (SetOp *) setopstate-&gt;ps.plan;<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext = setopstate-&gt;ps.ps_ExprContext;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; desc = <a href="execUtils.c.html#L493" title="executor/execUtils.c:493">ExecGetResultType</a>(outerPlanState(setopstate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(node-&gt;strategy == SETOP_HASHED);<br/></li>
<li>&nbsp; &nbsp; Assert(node-&gt;numGroups &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; setopstate-&gt;hashtable = <a href="execGrouping.c.html#L153" title="executor/execGrouping.c:153">BuildTupleHashTableExt</a>(&amp;setopstate-&gt;ps,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; desc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;numCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;dupColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; setopstate-&gt;eqfuncoids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; setopstate-&gt;hashfunctions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;dupCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;numGroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; setopstate-&gt;ps.state-&gt;es_query_cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; setopstate-&gt;tableContext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; econtext-&gt;ecxt_per_tuple_memory,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We've completed processing a tuple group.&nbsp; Decide how many copies (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>)<br/></li>
<li></span><span class="Comment"> * of its representative row to emit, and store the count into numOutput.<br/></li>
<li></span><span class="Comment"> * This logic is straight from the SQL92 specification.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L150">&#x200c;</a></span><span class="linkable">set_output_count</span>(SetOpState *setopstate, SetOpStatePerGroup pergroup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SetOp&nbsp; &nbsp; &nbsp;&nbsp; *plannode = (SetOp *) setopstate-&gt;ps.plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (plannode-&gt;cmd)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SETOPCMD_INTERSECT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pergroup-&gt;numLeft &gt; <span class="Constant">0</span> &amp;&amp; pergroup-&gt;numRight &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setopstate-&gt;numOutput = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setopstate-&gt;numOutput = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SETOPCMD_INTERSECT_ALL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setopstate-&gt;numOutput =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (pergroup-&gt;numLeft &lt; pergroup-&gt;numRight) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pergroup-&gt;numLeft : pergroup-&gt;numRight;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SETOPCMD_EXCEPT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pergroup-&gt;numLeft &gt; <span class="Constant">0</span> &amp;&amp; pergroup-&gt;numRight == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setopstate-&gt;numOutput = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setopstate-&gt;numOutput = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SETOPCMD_EXCEPT_ALL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setopstate-&gt;numOutput =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (pergroup-&gt;numLeft &lt; pergroup-&gt;numRight) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span> : (pergroup-&gt;numLeft - pergroup-&gt;numRight);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized set op: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) plannode-&gt;cmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L190" title="executor/nodeSetOp.c:190">ExecSetOp</a><br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TupleTableSlot *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return: a tuple or NULL */<br/></li>
<li><a id="L190">&#x200c;</a></span><span class="linkable">ExecSetOp</span>(PlanState *pstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SetOpState *node = castNode(SetOpState, pstate);<br/></li>
<li>&nbsp; &nbsp; SetOp&nbsp; &nbsp; &nbsp;&nbsp; *plannode = (SetOp *) node-&gt;ps.plan;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *resultTupleSlot = node-&gt;ps.ps_ResultTupleSlot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the previously-returned tuple needs to be returned more than once,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keep returning it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;numOutput &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;numOutput--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> resultTupleSlot;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise, we're done if we are out of groups */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;setop_done)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple group according to the correct strategy */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plannode-&gt;strategy == SETOP_HASHED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!node-&gt;table_filled)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L339" title="executor/nodeSetOp.c:339">setop_fill_hash_table</a>(node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L425" title="executor/nodeSetOp.c:425">setop_retrieve_hash_table</a>(node);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L227" title="executor/nodeSetOp.c:227">setop_retrieve_direct</a>(node);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L190" title="executor/nodeSetOp.c:190">ExecSetOp</a> for non-hashed case<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TupleTableSlot *<br/></li>
<li><a id="L227">&#x200c;</a><span class="linkable">setop_retrieve_direct</span>(SetOpState *setopstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlanState&nbsp; *outerPlan;<br/></li>
<li>&nbsp; &nbsp; SetOpStatePerGroup pergroup;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *outerslot;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *resultTupleSlot;<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext = setopstate-&gt;ps.ps_ExprContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get state info from node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; outerPlan = outerPlanState(setopstate);<br/></li>
<li>&nbsp; &nbsp; pergroup = (SetOpStatePerGroup) setopstate-&gt;pergroup;<br/></li>
<li>&nbsp; &nbsp; resultTupleSlot = setopstate-&gt;ps.ps_ResultTupleSlot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We loop retrieving groups until we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one we should return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (!setopstate-&gt;setop_done)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we don't already have the first tuple of the new group, fetch it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from the outer plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (setopstate-&gt;grp_firstTuple == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outerslot = ExecProcNode(outerPlan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TupIsNull(outerslot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make a copy of the first input tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setopstate-&gt;grp_firstTuple = ExecCopySlotHeapTuple(outerslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* outer plan produced no tuples at all */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setopstate-&gt;setop_done = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Store the copied first input tuple in the tuple table slot reserved<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for it.&nbsp; The tuple will be deleted when it is cleared from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * slot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L1439" title="executor/execTuples.c:1439">ExecStoreHeapTuple</a>(setopstate-&gt;grp_firstTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; resultTupleSlot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; setopstate-&gt;grp_firstTuple = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* don't keep two pointers */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize working state for a new input tuple group */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L80" title="executor/nodeSetOp.c:80">initialize_counts</a>(pergroup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Count the first input tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L89" title="executor/nodeSetOp.c:89">advance_counts</a>(pergroup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L102" title="executor/nodeSetOp.c:102">fetch_tuple_flag</a>(setopstate, resultTupleSlot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Scan the outer plan until we exhaust it or cross a group boundary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outerslot = ExecProcNode(outerPlan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TupIsNull(outerslot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no more outer-plan tuples available */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setopstate-&gt;setop_done = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check whether we've crossed a group boundary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_outertuple = resultTupleSlot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_innertuple = outerslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ExecQualAndReset(setopstate-&gt;eqfunction, econtext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Save the first input tuple of the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setopstate-&gt;grp_firstTuple = ExecCopySlotHeapTuple(outerslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Still in same group, so count this tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L89" title="executor/nodeSetOp.c:89">advance_counts</a>(pergroup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L102" title="executor/nodeSetOp.c:102">fetch_tuple_flag</a>(setopstate, outerslot));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Done scanning input tuple group.&nbsp; See if we should emit <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> copies<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of result tuple, and if so return the first copy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L150" title="executor/nodeSetOp.c:150">set_output_count</a>(setopstate, pergroup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (setopstate-&gt;numOutput &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setopstate-&gt;numOutput--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> resultTupleSlot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No more groups */<br/></li>
<li></span>&nbsp; &nbsp; ExecClearTuple(resultTupleSlot);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L190" title="executor/nodeSetOp.c:190">ExecSetOp</a> for hashed case: phase 1, read input and build <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L339">&#x200c;</a></span><span class="linkable">setop_fill_hash_table</span>(SetOpState *setopstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SetOp&nbsp; &nbsp; &nbsp;&nbsp; *node = (SetOp *) setopstate-&gt;ps.plan;<br/></li>
<li>&nbsp; &nbsp; PlanState&nbsp; *outerPlan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstFlag;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; in_first_rel <a href="../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext = setopstate-&gt;ps.ps_ExprContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get state info from node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; outerPlan = outerPlanState(setopstate);<br/></li>
<li>&nbsp; &nbsp; firstFlag = node-&gt;firstFlag;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* verify <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> didn't mess up */<br/></li>
<li></span>&nbsp; &nbsp; Assert(firstFlag == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (firstFlag == <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (node-&gt;cmd == SETOPCMD_INTERSECT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;cmd == SETOPCMD_INTERSECT_ALL)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Process each outer-plan tuple, and then fetch the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one, until we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exhaust the outer plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; in_first_rel = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *outerslot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleHashEntryData *entry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnew;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outerslot = ExecProcNode(outerPlan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TupIsNull(outerslot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Identify whether it's left or right input */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; flag = <a href="#L102" title="executor/nodeSetOp.c:102">fetch_tuple_flag</a>(setopstate, outerslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flag == firstFlag)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* (still) in first input relation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(in_first_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find or build hashtable entry for this tuple's group */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry = <a href="execGrouping.c.html#L305" title="executor/execGrouping.c:305">LookupTupleHashEntry</a>(setopstate-&gt;hashtable, outerslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;isnew, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If new tuple group, <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> counts */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnew)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;additional = (SetOpStatePerGroup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(setopstate-&gt;hashtable-&gt;tablecxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L64" title="executor/nodeSetOp.c:64">SetOpStatePerGroupData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L80" title="executor/nodeSetOp.c:80">initialize_counts</a>((SetOpStatePerGroup) entry-&gt;additional);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance the counts */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L89" title="executor/nodeSetOp.c:89">advance_counts</a>((SetOpStatePerGroup) entry-&gt;additional, flag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reached second relation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in_first_rel = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* For tuples not seen previously, do not make hashtable entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry = <a href="execGrouping.c.html#L305" title="executor/execGrouping.c:305">LookupTupleHashEntry</a>(setopstate-&gt;hashtable, outerslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance the counts if entry is already present */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L89" title="executor/nodeSetOp.c:89">advance_counts</a>((SetOpStatePerGroup) entry-&gt;additional, flag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must reset expression context after each hashtable lookup */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ResetExprContext(econtext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; setopstate-&gt;table_filled = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize to walk the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; ResetTupleHashIterator(setopstate-&gt;hashtable, &amp;setopstate-&gt;hashiter);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L190" title="executor/nodeSetOp.c:190">ExecSetOp</a> for hashed case: phase 2, retrieving groups from <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TupleTableSlot *<br/></li>
<li><a id="L425">&#x200c;</a><span class="linkable">setop_retrieve_hash_table</span>(SetOpState *setopstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleHashEntryData *entry;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *resultTupleSlot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get state info from node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; resultTupleSlot = setopstate-&gt;ps.ps_ResultTupleSlot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We loop retrieving groups until we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one we should return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (!setopstate-&gt;setop_done)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> entry in the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; entry = ScanTupleHashTable(setopstate-&gt;hashtable, &amp;setopstate-&gt;hashiter);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No more entries in hashtable, so done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setopstate-&gt;setop_done = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * See if we should emit <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> copies of this tuple, and if so return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the first copy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L150" title="executor/nodeSetOp.c:150">set_output_count</a>(setopstate, (SetOpStatePerGroup) entry-&gt;additional);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (setopstate-&gt;numOutput &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setopstate-&gt;numOutput--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="execTuples.c.html#L1533" title="executor/execTuples.c:1533">ExecStoreMinimalTuple</a>(entry-&gt;firstTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; resultTupleSlot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No more groups */<br/></li>
<li></span>&nbsp; &nbsp; ExecClearTuple(resultTupleSlot);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L481" title="executor/nodeSetOp.c:481">ExecInitSetOp</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This initializes the setop node state structures and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the node's subplan.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>SetOpState *<br/></li>
<li><a id="L481">&#x200c;</a><span class="linkable">ExecInitSetOp</span>(SetOp *node, EState *estate, <span class="Type">int</span> eflags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SetOpState *setopstate;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; outerDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for unsupported flags */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!(eflags &amp; (EXEC_FLAG_BACKWARD | EXEC_FLAG_MARK)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create state structure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; setopstate = makeNode(SetOpState);<br/></li>
<li>&nbsp; &nbsp; setopstate-&gt;ps.plan = (Plan *) node;<br/></li>
<li>&nbsp; &nbsp; setopstate-&gt;ps.state = estate;<br/></li>
<li>&nbsp; &nbsp; setopstate-&gt;ps.ExecProcNode = <a href="#L190" title="executor/nodeSetOp.c:190">ExecSetOp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; setopstate-&gt;eqfuncoids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; setopstate-&gt;hashfunctions = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; setopstate-&gt;setop_done = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; setopstate-&gt;numOutput = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; setopstate-&gt;pergroup = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; setopstate-&gt;grp_firstTuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; setopstate-&gt;hashtable = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; setopstate-&gt;tableContext = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create expression context<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execUtils.c.html#L483" title="executor/execUtils.c:483">ExecAssignExprContext</a>(estate, &amp;setopstate-&gt;ps);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If hashing, we also need a longer-lived context to store the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table.&nbsp; The table can't just be kept in the per-query context because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we want to be able to throw it away in <a href="#L594" title="executor/nodeSetOp.c:594">ExecReScanSetOp</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;strategy == SETOP_HASHED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; setopstate-&gt;tableContext =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;SetOp <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> child nodes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are hashing then the child plan does not need to handle REWIND<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * efficiently; see <a href="#L594" title="executor/nodeSetOp.c:594">ExecReScanSetOp</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;strategy == SETOP_HASHED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eflags &amp;= ~EXEC_FLAG_REWIND;<br/></li>
<li>&nbsp; &nbsp; outerPlanState(setopstate) = <a href="execProcnode.c.html#L142" title="executor/execProcnode.c:142">ExecInitNode</a>(outerPlan(node), estate, eflags);<br/></li>
<li>&nbsp; &nbsp; outerDesc = <a href="execUtils.c.html#L493" title="executor/execUtils.c:493">ExecGetResultType</a>(outerPlanState(setopstate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize result slot and type. Setop nodes do no projections, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> projection info for this node appropriately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execTuples.c.html#L1886" title="executor/execTuples.c:1886">ExecInitResultTupleSlotTL</a>(&amp;setopstate-&gt;ps,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;strategy == SETOP_HASHED ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a> : &amp;<a href="execTuples.c.html#L85" title="executor/execTuples.c:85">TTSOpsHeapTuple</a>);<br/></li>
<li>&nbsp; &nbsp; setopstate-&gt;ps.ps_ProjInfo = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Precompute fmgr lookup data for inner loop. We need both equality and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hashing <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to do it by hashing, but only equality if not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hashing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;strategy == SETOP_HASHED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execGrouping.c.html#L95" title="executor/execGrouping.c:95">execTuplesHashPrepare</a>(node-&gt;numCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;dupOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;setopstate-&gt;eqfuncoids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;setopstate-&gt;hashfunctions);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; setopstate-&gt;eqfunction =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execGrouping.c.html#L58" title="executor/execGrouping.c:58">execTuplesMatchPrepare</a>(outerDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;numCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;dupColIdx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;dupOperators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;dupCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;setopstate-&gt;ps);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;strategy == SETOP_HASHED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeRecursiveunion.c.html#L32" title="executor/nodeRecursiveunion.c:32">build_hash_table</a>(setopstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; setopstate-&gt;table_filled = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; setopstate-&gt;pergroup =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (SetOpStatePerGroup) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L64" title="executor/nodeSetOp.c:64">SetOpStatePerGroupData</a>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> setopstate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L583" title="executor/nodeSetOp.c:583">ExecEndSetOp</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This shuts down the subplan and frees resources allocated<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; to this node.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L583">&#x200c;</a></span><span class="linkable">ExecEndSetOp</span>(SetOpState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* free subsidiary stuff including hashtable */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;tableContext)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(node-&gt;tableContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="execProcnode.c.html#L557" title="executor/execProcnode.c:557">ExecEndNode</a>(outerPlanState(node));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L594">&#x200c;</a></span><span class="linkable">ExecReScanSetOp</span>(SetOpState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlanState&nbsp; *outerPlan = outerPlanState(node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(node-&gt;ps.ps_ResultTupleSlot);<br/></li>
<li>&nbsp; &nbsp; node-&gt;setop_done = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;numOutput = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (((SetOp *) node-&gt;ps.plan)-&gt;strategy == SETOP_HASHED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the hashed case, if we haven't yet built the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table then we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can just return; nothing done yet, so nothing to undo. If subnode's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * chgParam is not NULL then it will be re-scanned by ExecProcNode,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * else no reason to re-scan it at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!node-&gt;table_filled)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we do have the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table and the subplan does not have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parameter changes, then we can just rescan the existing <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no need to build it again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (outerPlan-&gt;chgParam == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResetTupleHashIterator(node-&gt;hashtable, &amp;node-&gt;hashiter);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release first tuple of group, if we have made a copy */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;grp_firstTuple != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(node-&gt;grp_firstTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;grp_firstTuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> hashtable storage */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;tableContext)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(node-&gt;tableContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And rebuild empty hashtable if needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (((SetOp *) node-&gt;ps.plan)-&gt;strategy == SETOP_HASHED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execGrouping.c.html#L284" title="executor/execGrouping.c:284">ResetTupleHashTable</a>(node-&gt;hashtable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;table_filled = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if chgParam of subnode is not null then plan will be re-scanned by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first ExecProcNode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (outerPlan-&gt;chgParam == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execAmi.c.html#L76" title="executor/execAmi.c:76">ExecReScan</a>(outerPlan);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
