<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>executor/nodeMemoize.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>executor/nodeMemoize.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L115">MemoizeEntry</a></li>
<li><a href="#L123">MemoizeEntry</a></li>
<li><a href="#L105">MemoizeKey</a></li>
<li><a href="#L109">MemoizeKey</a></li>
<li><a href="#L94">MemoizeTuple</a></li>
<li><a href="#L99">MemoizeTuple</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1080">ExecEndMemoize</a></li>
<li><a href="#L1172">ExecEstimateCacheEntryOverheadBytes</a></li>
<li><a href="#L952">ExecInitMemoize</a></li>
<li><a href="#L697">ExecMemoize</a></li>
<li><a href="#L1190">ExecMemoizeEstimate</a></li>
<li><a href="#L1211">ExecMemoizeInitializeDSM</a></li>
<li><a href="#L1236">ExecMemoizeInitializeWorker</a></li>
<li><a href="#L1249">ExecMemoizeRetrieveInstrumentation</a></li>
<li><a href="#L1140">ExecReScanMemoize</a></li>
<li><a href="#L221">MemoizeHash_equal</a></li>
<li><a href="#L158">MemoizeHash_hash</a></li>
<li><a href="#L283">build_hash_table</a></li>
<li><a href="#L528">cache_lookup</a></li>
<li><a href="#L402">cache_purge_all</a></li>
<li><a href="#L440">cache_reduce_memory</a></li>
<li><a href="#L625">cache_store_tuple</a></li>
<li><a href="#L344">entry_purge_tuples</a></li>
<li><a href="#L302">prepare_probe_slot</a></li>
<li><a href="#L374">remove_cache_entry</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L90">CACHE_TUPLE_BYTES</a></li>
<li><a href="#L87">EMPTY_ENTRY_MEMORY_BYTES</a></li>
<li><a href="#L81">MEMO_CACHE_BYPASS_MODE</a></li>
<li><a href="#L79">MEMO_CACHE_FETCH_NEXT_TUPLE</a></li>
<li><a href="#L78">MEMO_CACHE_LOOKUP</a></li>
<li><a href="#L83">MEMO_END_OF_SCAN</a></li>
<li><a href="#L80">MEMO_FILLING_CACHE</a></li>
<li><a href="#L130">SH_DECLARE</a></li>
<li><a href="#L148">SH_DEFINE</a></li>
<li><a href="#L127">SH_ELEMENT_TYPE</a></li>
<li><a href="#L140">SH_ELEMENT_TYPE</a></li>
<li><a href="#L144">SH_EQUAL</a></li>
<li><a href="#L147">SH_GET_HASH</a></li>
<li><a href="#L143">SH_HASH_KEY</a></li>
<li><a href="#L142">SH_KEY</a></li>
<li><a href="#L128">SH_KEY_TYPE</a></li>
<li><a href="#L141">SH_KEY_TYPE</a></li>
<li><a href="#L126">SH_PREFIX</a></li>
<li><a href="#L139">SH_PREFIX</a></li>
<li><a href="#L129">SH_SCOPE</a></li>
<li><a href="#L145">SH_SCOPE</a></li>
<li><a href="#L146">SH_STORE_HASH</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * nodeMemoize.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines to handle caching of results from parameterized nodes<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 2021-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/executor/nodeMemoize.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Memoize nodes are intended to sit above parameterized nodes in the plan<br/></li>
<li></span><span class="Comment"> * tree in order to cache results from them.&nbsp; The intention here is that a<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> scan with a parameter value that has already been seen by the node<br/></li>
<li></span><span class="Comment"> * can fetch tuples from the cache rather than having to re-scan the inner<br/></li>
<li></span><span class="Comment"> * node all over again.&nbsp; The query <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> may choose to make use of one of<br/></li>
<li></span><span class="Comment"> * these when it thinks rescans for previously seen <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are likely enough<br/></li>
<li></span><span class="Comment"> * to warrant adding the additional node.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The method of cache we use is a <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.&nbsp; When the cache fills, we never<br/></li>
<li></span><span class="Comment"> * spill tuples to disk, instead, we choose to evict the least recently used<br/></li>
<li></span><span class="Comment"> * cache entry from the cache.&nbsp; We remember the least recently used entry by<br/></li>
<li></span><span class="Comment"> * always pushing new entries and entries we look for onto the tail of a<br/></li>
<li></span><span class="Comment"> * doubly linked list.&nbsp; This means that older items always bubble to the top<br/></li>
<li></span><span class="Comment"> * of this LRU list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Sometimes our callers won't run their scans to completion. For example a<br/></li>
<li></span><span class="Comment"> * semi-join only needs to run until it finds a matching tuple, and once it<br/></li>
<li></span><span class="Comment"> * does, the join operator skips to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> outer tuple and does not execute<br/></li>
<li></span><span class="Comment"> * the inner side again on that scan.&nbsp; Because of this, we must keep track of<br/></li>
<li></span><span class="Comment"> * when a cache entry is complete, and by default, we know it is when we run<br/></li>
<li></span><span class="Comment"> * out of tuples to read during the scan.&nbsp; However, there are cases where we<br/></li>
<li></span><span class="Comment"> * can mark the cache entry as complete without exhausting the scan of all<br/></li>
<li></span><span class="Comment"> * tuples.&nbsp; One case is unique joins, where the join operator knows that there<br/></li>
<li></span><span class="Comment"> * will only be at most one match for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> given outer tuple.&nbsp; In order to<br/></li>
<li></span><span class="Comment"> * support such cases we allow the &quot;singlerow&quot; option to be set for the cache.<br/></li>
<li></span><span class="Comment"> * This option marks the cache entry as complete after we read the first tuple<br/></li>
<li></span><span class="Comment"> * from the subnode.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It's possible when we're filling the cache for a given set of parameters<br/></li>
<li></span><span class="Comment"> * that we're unable to free enough memory to store <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more tuples.&nbsp; If this<br/></li>
<li></span><span class="Comment"> * happens then we'll have already evicted all other cache entries.&nbsp; When<br/></li>
<li></span><span class="Comment"> * caching another tuple would cause us to exceed our memory budget, we must<br/></li>
<li></span><span class="Comment"> * free the entry that we're currently populating and move the state machine<br/></li>
<li></span><span class="Comment"> * into <a href="#L81" title="executor/nodeMemoize.c:81">MEMO_CACHE_BYPASS_MODE</a>.&nbsp; This means that we'll not attempt to cache<br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> further tuples for this particular scan.&nbsp; We don't have the memory for<br/></li>
<li></span><span class="Comment"> * it.&nbsp; The state machine will be reset again on the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> rescan.&nbsp; If the<br/></li>
<li></span><span class="Comment"> * memory requirements to cache the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> parameter's tuples are less<br/></li>
<li></span><span class="Comment"> * demanding, then that may allow us to start putting useful entries back into<br/></li>
<li></span><span class="Comment"> * the cache again.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * INTERFACE ROUTINES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L697" title="executor/nodeMemoize.c:697">ExecMemoize</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - lookup cache, exec subplan when not found<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L952" title="executor/nodeMemoize.c:952">ExecInitMemoize</a>&nbsp; &nbsp; &nbsp; &nbsp; - <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> node and subnodes<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1080" title="executor/nodeMemoize.c:1080">ExecEndMemoize</a>&nbsp; &nbsp; &nbsp; &nbsp; - shutdown node and subnodes<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1140" title="executor/nodeMemoize.c:1140">ExecReScanMemoize</a>&nbsp; &nbsp; - rescan the memoize node<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1190" title="executor/nodeMemoize.c:1190">ExecMemoizeEstimate</a>&nbsp; &nbsp; &nbsp; &nbsp; estimates DSM space needed for parallel plan<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1211" title="executor/nodeMemoize.c:1211">ExecMemoizeInitializeDSM</a> <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> DSM for parallel plan<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1236" title="executor/nodeMemoize.c:1236">ExecMemoizeInitializeWorker</a> attach to DSM info in parallel worker<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1249" title="executor/nodeMemoize.c:1249">ExecMemoizeRetrieveInstrumentation</a> get instrumentation from worker<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;common/hashfn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/nodeMemoize.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/ilist.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* States of the <a href="#L697" title="executor/nodeMemoize.c:697">ExecMemoize</a> state machine */<br/></li>
<li><a id="L78">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MEMO_CACHE_LOOKUP</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">1</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* Attempt to perform a cache lookup */<br/></li>
<li><a id="L79">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MEMO_CACHE_FETCH_NEXT_TUPLE</span>&nbsp; &nbsp; </span><span class="Constant">2</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* Get another tuple from the cache */<br/></li>
<li><a id="L80">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MEMO_FILLING_CACHE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">3</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* Read outer node to fill cache */<br/></li>
<li><a id="L81">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MEMO_CACHE_BYPASS_MODE</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">4</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* Bypass mode.&nbsp; Just read from our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subplan without caching anything */<br/></li>
<li><a id="L83">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MEMO_END_OF_SCAN</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">5</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* Ready for rescan */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* Helper macros for memory accounting */<br/></li>
<li><a id="L87">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EMPTY_ENTRY_MEMORY_BYTES</span>(e)&nbsp; &nbsp; &nbsp; &nbsp; (</span><span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(<a href="#L115" title="executor/nodeMemoize.c:115">MemoizeEntry</a>) + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(<a href="#L105" title="executor/nodeMemoize.c:105">MemoizeKey</a>) + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (e)-&gt;key-&gt;params-&gt;t_len);<br/></li>
<li><a id="L90">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CACHE_TUPLE_BYTES</span>(t)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (</span><span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(<a href="#L94" title="executor/nodeMemoize.c:94">MemoizeTuple</a>) + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (t)-&gt;mintuple-&gt;t_len)<br/></li>
<li></span><br/></li>
<li> <span class="Comment">/* <a href="#L94" title="executor/nodeMemoize.c:94">MemoizeTuple</a> Stores an individually cached tuple */<br/></li>
<li><a id="L94">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">MemoizeTuple</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MinimalTuple mintuple;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Cached tuple */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L94" title="executor/nodeMemoize.c:94">MemoizeTuple</a> *<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;&nbsp; &nbsp; <span class="Comment">/* The <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple with the same parameter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> or NULL if it's the last one */<br/></li>
<li><a id="L99">&#x200c;</a></span>} <span class="linkable">MemoizeTuple</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L105" title="executor/nodeMemoize.c:105">MemoizeKey</a><br/></li>
<li></span><span class="Comment"> * The <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table key for cached entries plus the LRU list link<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L105">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">MemoizeKey</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MinimalTuple params;<br/></li>
<li>&nbsp; &nbsp; dlist_node&nbsp; &nbsp; lru_node;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Pointer to <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>/prev key in LRU list */<br/></li>
<li><a id="L109">&#x200c;</a></span>} <span class="linkable">MemoizeKey</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L115" title="executor/nodeMemoize.c:115">MemoizeEntry</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The data struct that the cache <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table stores<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L115">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">MemoizeEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L105" title="executor/nodeMemoize.c:105">MemoizeKey</a> *key;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Hash key for <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table lookups */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L94" title="executor/nodeMemoize.c:94">MemoizeTuple</a> *tuplehead;&nbsp; &nbsp; <span class="Comment">/* Pointer to the first tuple or NULL if no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples are cached for this entry */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Hash value (cached) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; status;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Hash status */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; complete;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Did we read the outer plan to completion? */<br/></li>
<li><a id="L123">&#x200c;</a></span>} <span class="linkable">MemoizeEntry</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L126">&#x200c;</a><span class="PreProc">#define <span class="linkable">SH_PREFIX</span> memoize<br/></li>
<li><a id="L127">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_ELEMENT_TYPE</span> <a href="#L115" title="executor/nodeMemoize.c:115">MemoizeEntry</a><br/></li>
<li><a id="L128">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_KEY_TYPE</span> <a href="#L105" title="executor/nodeMemoize.c:105">MemoizeKey</a> *<br/></li>
<li><a id="L129">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_SCOPE</span> </span><span class="Type">static</span><span class="PreProc"> </span><span class="Type">inline<br/></li>
<li><a id="L130">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_DECLARE</span><br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/simplehash.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> uint32 <a href="#L158" title="executor/nodeMemoize.c:158">MemoizeHash_hash</a>(<span class="Type">struct</span> memoize_hash *tb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <a href="#L105" title="executor/nodeMemoize.c:105">MemoizeKey</a> *key);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L221" title="executor/nodeMemoize.c:221">MemoizeHash_equal</a>(<span class="Type">struct</span> memoize_hash *tb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <a href="#L105" title="executor/nodeMemoize.c:105">MemoizeKey</a> *key1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <a href="#L105" title="executor/nodeMemoize.c:105">MemoizeKey</a> *key2);<br/></li>
<li><br/></li>
<li><a id="L139">&#x200c;</a><span class="PreProc">#define <span class="linkable">SH_PREFIX</span> memoize<br/></li>
<li><a id="L140">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_ELEMENT_TYPE</span> <a href="#L115" title="executor/nodeMemoize.c:115">MemoizeEntry</a><br/></li>
<li><a id="L141">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_KEY_TYPE</span> <a href="#L105" title="executor/nodeMemoize.c:105">MemoizeKey</a> *<br/></li>
<li><a id="L142">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_KEY</span> key<br/></li>
<li><a id="L143">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_HASH_KEY</span>(tb, key) <a href="#L158" title="executor/nodeMemoize.c:158">MemoizeHash_hash</a>(tb, key)<br/></li>
<li><a id="L144">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_EQUAL</span>(tb, a, b) <a href="#L221" title="executor/nodeMemoize.c:221">MemoizeHash_equal</a>(tb, a, b)<br/></li>
<li><a id="L145">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_SCOPE</span> </span><span class="Type">static</span><span class="PreProc"> </span><span class="Type">inline<br/></li>
<li><a id="L146">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_STORE_HASH</span><br/></li>
<li><a id="L147">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_GET_HASH</span>(tb, a) a-&gt;<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li><a id="L148">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_DEFINE</span><br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/simplehash.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L158" title="executor/nodeMemoize.c:158">MemoizeHash_hash</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Hash function for simplehash hashtable.&nbsp; 'key' is unused here as we<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; require that all table lookups first populate the MemoizeState's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; probeslot with the key <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to be looked up.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint32<br/></li>
<li><a id="L158">&#x200c;</a><span class="linkable">MemoizeHash_hash</span>(<span class="Type">struct</span> memoize_hash *tb, <span class="Type">const</span> <a href="#L105" title="executor/nodeMemoize.c:105">MemoizeKey</a> *key)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoizeState *mstate = (MemoizeState *) tb-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext = mstate-&gt;ss.ps.ps_ExprContext;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *pslot = mstate-&gt;probeslot;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hashkey = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numkeys = mstate-&gt;nkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(econtext-&gt;ecxt_per_tuple_memory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mstate-&gt;binary_mode)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; numkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> successive hashkeys by rotating */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashkey = pg_rotate_left32(hashkey, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pslot-&gt;tts_isnull[i])&nbsp; &nbsp; <span class="Comment">/* treat nulls as having <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FormData_pg_attribute *attr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attr = &amp;pslot-&gt;tts_tupleDescriptor-&gt;attrs[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hkey = <a href="../utils/adt/datum.c.html#L338" title="utils/adt/datum.c:338">datum_image_hash</a>(pslot-&gt;tts_values[i], attr-&gt;attbyval, attr-&gt;attlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashkey ^= hkey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *hashfunctions = mstate-&gt;hashfunctions;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *collations = mstate-&gt;collations;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; numkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> successive hashkeys by rotating */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashkey = pg_rotate_left32(hashkey, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pslot-&gt;tts_isnull[i])&nbsp; &nbsp; <span class="Comment">/* treat nulls as having <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hkey = DatumGetUInt32(<a href="../utils/fmgr/fmgr.c.html#L1129" title="utils/fmgr/fmgr.c:1129">FunctionCall1Coll</a>(&amp;hashfunctions[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collations[i], pslot-&gt;tts_values[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashkey ^= hkey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> murmurhash32(hashkey);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L221" title="executor/nodeMemoize.c:221">MemoizeHash_equal</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Equality function for confirming <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value matches during a <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; table lookup.&nbsp; 'key2' is never used.&nbsp; Instead the MemoizeState's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; probeslot is always populated with details of what's being looked up.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L221">&#x200c;</a></span><span class="linkable">MemoizeHash_equal</span>(<span class="Type">struct</span> memoize_hash *tb, <span class="Type">const</span> <a href="#L105" title="executor/nodeMemoize.c:105">MemoizeKey</a> *key1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <a href="#L105" title="executor/nodeMemoize.c:105">MemoizeKey</a> *key2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoizeState *mstate = (MemoizeState *) tb-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext = mstate-&gt;ss.ps.ps_ExprContext;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *tslot = mstate-&gt;tableslot;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *pslot = mstate-&gt;probeslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* probeslot should have already been prepared by <a href="#L302" title="executor/nodeMemoize.c:302">prepare_probe_slot</a>() */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execTuples.c.html#L1533" title="executor/execTuples.c:1533">ExecStoreMinimalTuple</a>(key1-&gt;params, tslot, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mstate-&gt;binary_mode)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numkeys = mstate-&gt;nkeys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; match = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(econtext-&gt;ecxt_per_tuple_memory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot_getallattrs(tslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot_getallattrs(pslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; numkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FormData_pg_attribute *attr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tslot-&gt;tts_isnull[i] != pslot-&gt;tts_isnull[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* both NULL? they're <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tslot-&gt;tts_isnull[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* perform binary comparison on the two datums */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attr = &amp;tslot-&gt;tts_tupleDescriptor-&gt;attrs[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/adt/datum.c.html#L266" title="utils/adt/datum.c:266">datum_image_eq</a>(tslot-&gt;tts_values[i], pslot-&gt;tts_values[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attr-&gt;attbyval, attr-&gt;attlen))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> match;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_innertuple = tslot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_outertuple = pslot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ExecQual(mstate-&gt;cache_eq_expr, econtext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table to empty.&nbsp; The MemoizeState's hashtable field<br/></li>
<li></span><span class="Comment"> * must point to NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L283">&#x200c;</a></span><span class="linkable">build_hash_table</span>(MemoizeState *mstate, uint32 size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(mstate-&gt;hashtable == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make a guess at a good size when we're not given a valid size. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (size == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size = <span class="Constant">1024</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* memoize_create will convert the size to a power of 2 */<br/></li>
<li></span>&nbsp; &nbsp; mstate-&gt;hashtable = memoize_create(mstate-&gt;tableContext, size, mstate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L302" title="executor/nodeMemoize.c:302">prepare_probe_slot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Populate mstate's probeslot with the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> from the tuple stored<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; in 'key'.&nbsp; If 'key' is NULL, then perform the population by evaluating<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; mstate's param_exprs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L302">&#x200c;</a></span><span class="linkable">prepare_probe_slot</span>(MemoizeState *mstate, <a href="#L105" title="executor/nodeMemoize.c:105">MemoizeKey</a> *key)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *pslot = mstate-&gt;probeslot;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *tslot = mstate-&gt;tableslot;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numKeys = mstate-&gt;nkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(pslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (key == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExprContext *econtext = mstate-&gt;ss.ps.ps_ExprContext;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(econtext-&gt;ecxt_per_tuple_memory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set the probeslot's <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> based on the current parameter <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; numKeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pslot-&gt;tts_values[i] = ExecEvalExpr(mstate-&gt;param_exprs[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;pslot-&gt;tts_isnull[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Process the key's MinimalTuple and store the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in probeslot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L1533" title="executor/execTuples.c:1533">ExecStoreMinimalTuple</a>(key-&gt;params, tslot, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot_getallattrs(tslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(pslot-&gt;tts_values, tslot-&gt;tts_values, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * numKeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(pslot-&gt;tts_isnull, tslot-&gt;tts_isnull, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * numKeys);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="execTuples.c.html#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a>(pslot);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L344" title="executor/nodeMemoize.c:344">entry_purge_tuples</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Remove all tuples from the cache entry pointed to by 'entry'.&nbsp; This<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; leaves an empty cache entry.&nbsp; Also, update the memory accounting to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; reflect the removal of the tuples.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L344">&#x200c;</a></span><span class="linkable">entry_purge_tuples</span>(MemoizeState *mstate, <a href="#L115" title="executor/nodeMemoize.c:115">MemoizeEntry</a> *entry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L94" title="executor/nodeMemoize.c:94">MemoizeTuple</a> *tuple = entry-&gt;tuplehead;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; freed_mem = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (tuple != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L94" title="executor/nodeMemoize.c:94">MemoizeTuple</a> *<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = tuple-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freed_mem += <a href="#L90" title="executor/nodeMemoize.c:90">CACHE_TUPLE_BYTES</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Free memory used for this tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tuple-&gt;mintuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entry-&gt;complete = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; entry-&gt;tuplehead = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update the memory accounting */<br/></li>
<li></span>&nbsp; &nbsp; mstate-&gt;mem_used -= freed_mem;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L374" title="executor/nodeMemoize.c:374">remove_cache_entry</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Remove 'entry' from the cache and free memory used by it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L374">&#x200c;</a></span><span class="linkable">remove_cache_entry</span>(MemoizeState *mstate, <a href="#L115" title="executor/nodeMemoize.c:115">MemoizeEntry</a> *entry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L105" title="executor/nodeMemoize.c:105">MemoizeKey</a> *key = entry-&gt;key;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_delete(&amp;entry-&gt;key-&gt;lru_node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove all of the tuples from this entry */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L344" title="executor/nodeMemoize.c:344">entry_purge_tuples</a>(mstate, entry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update memory accounting. <a href="#L344" title="executor/nodeMemoize.c:344">entry_purge_tuples</a> should have already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subtracted the memory used for each cached tuple.&nbsp; Here we just update<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the amount used by the entry itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mstate-&gt;mem_used -= <a href="#L87" title="executor/nodeMemoize.c:87">EMPTY_ENTRY_MEMORY_BYTES</a>(entry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove the entry from the cache */<br/></li>
<li></span>&nbsp; &nbsp; memoize_delete_item(mstate-&gt;hashtable, entry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(key-&gt;params);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(key);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L402" title="executor/nodeMemoize.c:402">cache_purge_all</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Remove all items from the cache<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L402">&#x200c;</a></span><span class="linkable">cache_purge_all</span>(MemoizeState *mstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; evictions = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mstate-&gt;hashtable != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; evictions = mstate-&gt;hashtable-&gt;members;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likely the most efficient way to remove all items is to just reset the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory context for the cache and then rebuild a fresh <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * saves having to remove each item one by one and <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> each cached tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(mstate-&gt;tableContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NULLify so we recreate the table on the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call */<br/></li>
<li></span>&nbsp; &nbsp; mstate-&gt;hashtable = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* reset the LRU list */<br/></li>
<li></span>&nbsp; &nbsp; dlist_init(&amp;mstate-&gt;lru_list);<br/></li>
<li>&nbsp; &nbsp; mstate-&gt;last_tuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; mstate-&gt;entry = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mstate-&gt;mem_used = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> should we add something new to track these purges? */<br/></li>
<li></span>&nbsp; &nbsp; mstate-&gt;stats.cache_evictions += evictions; <span class="Comment">/* Update Stats */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L440" title="executor/nodeMemoize.c:440">cache_reduce_memory</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Evict older and less recently used items from the cache in order to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; reduce the memory consumption back to something below the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; MemoizeState's mem_limit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'specialkey', if not NULL, causes the function to return false if the entry<br/></li>
<li></span><span class="Comment"> * which the key belongs to is removed from the cache.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L440">&#x200c;</a></span><span class="linkable">cache_reduce_memory</span>(MemoizeState *mstate, <a href="#L105" title="executor/nodeMemoize.c:105">MemoizeKey</a> *specialkey)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; specialkey_intact = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; dlist_mutable_iter iter;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; evictions = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update peak memory usage */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (mstate-&gt;mem_used &gt; mstate-&gt;stats.mem_peak)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mstate-&gt;stats.mem_peak = mstate-&gt;mem_used;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We expect only to be called when we've gone over budget on memory */<br/></li>
<li></span>&nbsp; &nbsp; Assert(mstate-&gt;mem_used &gt; mstate-&gt;mem_limit);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Start the eviction process starting at the head of the LRU list. */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach_modify(iter, &amp;mstate-&gt;lru_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L105" title="executor/nodeMemoize.c:105">MemoizeKey</a> *key = dlist_container(<a href="#L105" title="executor/nodeMemoize.c:105">MemoizeKey</a>, lru_node, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L115" title="executor/nodeMemoize.c:115">MemoizeEntry</a> *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Populate the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> probe slot in preparation for looking up this LRU<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L302" title="executor/nodeMemoize.c:302">prepare_probe_slot</a>(mstate, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ideally the LRU list pointers would be stored in the entry itself<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rather than in the key.&nbsp; Unfortunately, we can't do that as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * simplehash.h code may <a href="../lib/dshash.c.html#L858" title="lib/dshash.c:858">resize</a> the table and allocate new memory for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entries which would result in those pointers pointing to the old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buckets.&nbsp; However, it's fine to use the key to store this as that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only referenced by a pointer in the entry, which of course follows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the entry whenever the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table is resized.&nbsp; Since we only have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pointer to the key here, we must perform a <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table lookup to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the entry that the key belongs to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; entry = memoize_lookup(mstate-&gt;hashtable, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sanity check that we found the entry belonging to the LRU list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * item.&nbsp; A misbehaving <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> or equality function could cause the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry not to be found or the wrong entry to be found.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(entry == <span class="Constant">NULL</span> || entry-&gt;key != key))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> memoization table entry&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're being called to free memory while the cache is being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * populated with new tuples, then we'd better take some care as we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could end up freeing the entry which 'specialkey' belongs to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Generally callers will pass 'specialkey' as the key for the cache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry which is currently being populated, so we must set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 'specialkey_intact' to false to inform the caller the specialkey<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry has been removed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key == specialkey)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; specialkey_intact = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Finally remove the entry.&nbsp; This will remove from the LRU list too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L374" title="executor/nodeMemoize.c:374">remove_cache_entry</a>(mstate, entry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; evictions++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Exit if we've freed enough memory */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mstate-&gt;mem_used &lt;= mstate-&gt;mem_limit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mstate-&gt;stats.cache_evictions += evictions; <span class="Comment">/* Update Stats */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> specialkey_intact;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L528" title="executor/nodeMemoize.c:528">cache_lookup</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Perform a lookup to see if we've already cached tuples based on the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; scan's current parameters.&nbsp; If we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an existing entry we move it to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the end of the LRU list, set *found to true then return it.&nbsp; If we<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; don't <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an entry then we create a new one and add it to the end of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the LRU list.&nbsp; We also update cache memory accounting and remove older<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; entries if we go over the memory budget.&nbsp; If we managed to free enough<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; memory we return the new entry, else we return NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Callers can assume we'll never return NULL when *found is true.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L115" title="executor/nodeMemoize.c:115">MemoizeEntry</a> *<br/></li>
<li><a id="L528">&#x200c;</a><span class="linkable">cache_lookup</span>(MemoizeState *mstate, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *found)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L105" title="executor/nodeMemoize.c:105">MemoizeKey</a> *key;<br/></li>
<li>&nbsp; &nbsp; <a href="#L115" title="executor/nodeMemoize.c:115">MemoizeEntry</a> *entry;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prepare the probe slot with the current scan parameters */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L302" title="executor/nodeMemoize.c:302">prepare_probe_slot</a>(mstate, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add the new entry to the cache.&nbsp; No need to pass a valid key since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function uses mstate's probeslot, which we populated above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; entry = memoize_insert(mstate-&gt;hashtable, <span class="Constant">NULL</span>, found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Move existing entry to the tail of the LRU list to mark it as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * most recently used item.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dlist_move_tail(&amp;mstate-&gt;lru_list, &amp;entry-&gt;key-&gt;lru_node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> entry;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(mstate-&gt;tableContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate a new key */<br/></li>
<li></span>&nbsp; &nbsp; entry-&gt;key = key = (<a href="#L105" title="executor/nodeMemoize.c:105">MemoizeKey</a> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L105" title="executor/nodeMemoize.c:105">MemoizeKey</a>));<br/></li>
<li>&nbsp; &nbsp; key-&gt;params = ExecCopySlotMinimalTuple(mstate-&gt;probeslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update the total cache memory utilization */<br/></li>
<li></span>&nbsp; &nbsp; mstate-&gt;mem_used += <a href="#L87" title="executor/nodeMemoize.c:87">EMPTY_ENTRY_MEMORY_BYTES</a>(entry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize this entry */<br/></li>
<li></span>&nbsp; &nbsp; entry-&gt;complete = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; entry-&gt;tuplehead = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since this is the most recently used entry, <a href="../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> this entry onto the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end of the LRU list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dlist_push_tail(&amp;mstate-&gt;lru_list, &amp;entry-&gt;key-&gt;lru_node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mstate-&gt;last_tuple = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we've gone over our memory budget, then we'll free up some space in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the cache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (mstate-&gt;mem_used &gt; mstate-&gt;mem_limit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to free up some memory.&nbsp; It's highly unlikely that we'll fail<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to do so here since the entry we've just added is yet to contain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples and we're able to remove <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other entry to reduce the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memory consumption.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(!<a href="#L440" title="executor/nodeMemoize.c:440">cache_reduce_memory</a>(mstate, key)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The process of removing entries from the cache may have caused the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * code in simplehash.h to shuffle elements to earlier buckets in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.&nbsp; If it has, we'll need to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the entry again by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * performing a lookup.&nbsp; Fortunately, we can detect if this has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * happened by seeing if the entry is still in use and that the key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pointer matches our expected key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;status != memoize_SH_IN_USE || entry-&gt;key != key)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to repopulate the probeslot as lookups performed during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the cache evictions above will have stored some other key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L302" title="executor/nodeMemoize.c:302">prepare_probe_slot</a>(mstate, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Re-<a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the newly added entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry = memoize_lookup(mstate-&gt;hashtable, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(entry != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> entry;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L625" title="executor/nodeMemoize.c:625">cache_store_tuple</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Add the tuple stored in 'slot' to the mstate's current cache entry.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The cache entry must have already been made with <a href="#L528" title="executor/nodeMemoize.c:528">cache_lookup</a>().<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; mstate's last_tuple field must point to the tail of mstate-&gt;entry's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; list of tuples.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L625">&#x200c;</a></span><span class="linkable">cache_store_tuple</span>(MemoizeState *mstate, TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L94" title="executor/nodeMemoize.c:94">MemoizeTuple</a> *tuple;<br/></li>
<li>&nbsp; &nbsp; <a href="#L115" title="executor/nodeMemoize.c:115">MemoizeEntry</a> *entry = mstate-&gt;entry;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(slot != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(entry != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(mstate-&gt;tableContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = (<a href="#L94" title="executor/nodeMemoize.c:94">MemoizeTuple</a> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L94" title="executor/nodeMemoize.c:94">MemoizeTuple</a>));<br/></li>
<li>&nbsp; &nbsp; tuple-&gt;mintuple = ExecCopySlotMinimalTuple(slot);<br/></li>
<li>&nbsp; &nbsp; tuple-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Account for the memory we just consumed */<br/></li>
<li></span>&nbsp; &nbsp; mstate-&gt;mem_used += <a href="#L90" title="executor/nodeMemoize.c:90">CACHE_TUPLE_BYTES</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;tuplehead == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is the first tuple for this entry, so just point the list head<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;tuplehead = tuple;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> this tuple onto the tail of the list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mstate-&gt;last_tuple-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = tuple;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mstate-&gt;last_tuple = tuple;<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we've gone over our memory budget then free up some space in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (mstate-&gt;mem_used &gt; mstate-&gt;mem_limit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L105" title="executor/nodeMemoize.c:105">MemoizeKey</a> *key = entry-&gt;key;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L440" title="executor/nodeMemoize.c:440">cache_reduce_memory</a>(mstate, key))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The process of removing entries from the cache may have caused the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * code in simplehash.h to shuffle elements to earlier buckets in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.&nbsp; If it has, we'll need to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the entry again by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * performing a lookup.&nbsp; Fortunately, we can detect if this has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * happened by seeing if the entry is still in use and that the key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pointer matches our expected key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;status != memoize_SH_IN_USE || entry-&gt;key != key)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to repopulate the probeslot as lookups performed during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the cache evictions above will have stored some other key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L302" title="executor/nodeMemoize.c:302">prepare_probe_slot</a>(mstate, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Re-<a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mstate-&gt;entry = entry = memoize_lookup(mstate-&gt;hashtable, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(entry != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> TupleTableSlot *<br/></li>
<li><a id="L697">&#x200c;</a><span class="linkable">ExecMemoize</span>(PlanState *pstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoizeState *node = castNode(MemoizeState, pstate);<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext = node-&gt;ss.ps.ps_ExprContext;<br/></li>
<li>&nbsp; &nbsp; PlanState&nbsp; *outerNode;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset per-tuple memory context to free <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> expression evaluation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * storage allocated in the previous tuple cycle.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ResetExprContext(econtext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (node-&gt;mstatus)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L78" title="executor/nodeMemoize.c:78">MEMO_CACHE_LOOKUP</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L115" title="executor/nodeMemoize.c:115">MemoizeEntry</a> *entry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *outerslot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(node-&gt;entry == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first call? we'll need a <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(node-&gt;hashtable == <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nodeRecursiveunion.c.html#L32" title="executor/nodeRecursiveunion.c:32">build_hash_table</a>(node, ((Memoize *) pstate-&gt;plan)-&gt;est_entries);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're only ever in this state for the first call of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan.&nbsp; Here we have a look to see if we've already seen the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current parameters <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> and if we have already cached a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * complete set of <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> that the outer plan will return for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * these parameters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a valid cache entry, we'll return the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple from it. If not found, we'll create a cache entry and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then try to fetch a tuple from the outer scan.&nbsp; If we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one there, we'll try to cache it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see if we've got anything cached for the current parameters */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry = <a href="#L528" title="executor/nodeMemoize.c:528">cache_lookup</a>(node, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found &amp;&amp; entry-&gt;complete)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;stats.cache_hits += <span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* stats update */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set last_tuple and entry so that the state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L79" title="executor/nodeMemoize.c:79">MEMO_CACHE_FETCH_NEXT_TUPLE</a> can easily <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple for these parameters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;last_tuple = entry-&gt;tuplehead;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;entry = entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch the first cached tuple, if there is one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;tuplehead)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;mstatus = <a href="#L79" title="executor/nodeMemoize.c:79">MEMO_CACHE_FETCH_NEXT_TUPLE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot = node-&gt;ss.ps.ps_ResultTupleSlot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L1533" title="executor/execTuples.c:1533">ExecStoreMinimalTuple</a>(entry-&gt;tuplehead-&gt;mintuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The cache entry is void of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;mstatus = <a href="#L83" title="executor/nodeMemoize.c:83">MEMO_END_OF_SCAN</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Handle cache <a href="../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;stats.cache_misses += <span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* stats update */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A cache entry was found, but the scan for that entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * did not run to completion.&nbsp; We'll just remove all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples and start again.&nbsp; It might be tempting to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * continue where we left off, but there's no guarantee<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the outer node will produce the tuples in the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * order as it did last time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L344" title="executor/nodeMemoize.c:344">entry_purge_tuples</a>(node, entry);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Scan the outer node for a tuple to cache */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outerNode = outerPlanState(node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outerslot = ExecProcNode(outerNode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TupIsNull(outerslot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L528" title="executor/nodeMemoize.c:528">cache_lookup</a> may have returned NULL due to failure to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * free enough cache space, so ensure we don't do anything<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here that assumes it worked. There's no need to go into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bypass mode here as we're setting mstatus to end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (likely(entry))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;complete = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;mstatus = <a href="#L83" title="executor/nodeMemoize.c:83">MEMO_END_OF_SCAN</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;entry = entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we failed to create the entry or failed to store the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple in the entry, then go into bypass mode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(entry == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="#L625" title="executor/nodeMemoize.c:625">cache_store_tuple</a>(node, outerslot)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;stats.cache_overflows += <span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* stats update */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;mstatus = <a href="#L81" title="executor/nodeMemoize.c:81">MEMO_CACHE_BYPASS_MODE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No need to clear out last_tuple as we'll stay in bypass<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mode until the end of the scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we only expect a single row from this scan then we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can mark that we're not expecting more.&nbsp; This allows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cache lookups to work even when the scan has not been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * executed to completion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;complete = node-&gt;singlerow;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;mstatus = <a href="#L80" title="executor/nodeMemoize.c:80">MEMO_FILLING_CACHE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot = node-&gt;ss.ps.ps_ResultTupleSlot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecCopySlot(slot, outerslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L79" title="executor/nodeMemoize.c:79">MEMO_CACHE_FETCH_NEXT_TUPLE</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We shouldn't be in this state if these are not set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(node-&gt;entry != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(node-&gt;last_tuple != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple to output */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;last_tuple = node-&gt;last_tuple-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No more tuples in the cache */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;last_tuple == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;mstatus = <a href="#L83" title="executor/nodeMemoize.c:83">MEMO_END_OF_SCAN</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot = node-&gt;ss.ps.ps_ResultTupleSlot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="execTuples.c.html#L1533" title="executor/execTuples.c:1533">ExecStoreMinimalTuple</a>(node-&gt;last_tuple-&gt;mintuple, slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L80" title="executor/nodeMemoize.c:80">MEMO_FILLING_CACHE</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *outerslot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L115" title="executor/nodeMemoize.c:115">MemoizeEntry</a> *entry = node-&gt;entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* entry should already have been set by <a href="#L78" title="executor/nodeMemoize.c:78">MEMO_CACHE_LOOKUP</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(entry != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When in the <a href="#L80" title="executor/nodeMemoize.c:80">MEMO_FILLING_CACHE</a> state, we've just had a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cache <a href="../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> and are populating the cache with the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outerNode = outerPlanState(node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outerslot = ExecProcNode(outerNode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TupIsNull(outerslot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No more tuples.&nbsp; Mark it as complete */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;complete = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;mstatus = <a href="#L83" title="executor/nodeMemoize.c:83">MEMO_END_OF_SCAN</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Validate if the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> properly set the singlerow flag. It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should only set that if each cache entry can, at most,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * return 1 row.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(entry-&gt;complete))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache entry already complete&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Record the tuple in the current cache entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(!<a href="#L625" title="executor/nodeMemoize.c:625">cache_store_tuple</a>(node, outerslot)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Couldn't store it?&nbsp; Handle overflow */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;stats.cache_overflows += <span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* stats update */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;mstatus = <a href="#L81" title="executor/nodeMemoize.c:81">MEMO_CACHE_BYPASS_MODE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No need to clear out entry or last_tuple as we'll stay<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in bypass mode until the end of the scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot = node-&gt;ss.ps.ps_ResultTupleSlot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecCopySlot(slot, outerslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L81" title="executor/nodeMemoize.c:81">MEMO_CACHE_BYPASS_MODE</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *outerslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When in bypass mode we just continue to read tuples without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caching.&nbsp; We need to wait until the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> rescan <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can come out of this mode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outerNode = outerPlanState(node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outerslot = ExecProcNode(outerNode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TupIsNull(outerslot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;mstatus = <a href="#L83" title="executor/nodeMemoize.c:83">MEMO_END_OF_SCAN</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot = node-&gt;ss.ps.ps_ResultTupleSlot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecCopySlot(slot, outerslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L83" title="executor/nodeMemoize.c:83">MEMO_END_OF_SCAN</a>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We've already returned NULL for this scan, but just in case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * something calls us again by mistake.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized memoize state: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) node-&gt;mstatus);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* switch */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li>MemoizeState *<br/></li>
<li><a id="L952">&#x200c;</a><span class="linkable">ExecInitMemoize</span>(Memoize *node, EState *estate, <span class="Type">int</span> eflags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoizeState *mstate = makeNode(MemoizeState);<br/></li>
<li>&nbsp; &nbsp; Plan&nbsp; &nbsp; &nbsp;&nbsp; *outerNode;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nkeys;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *eqfuncoids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for unsupported flags */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!(eflags &amp; (EXEC_FLAG_BACKWARD | EXEC_FLAG_MARK)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mstate-&gt;ss.ps.plan = (Plan *) node;<br/></li>
<li>&nbsp; &nbsp; mstate-&gt;ss.ps.state = estate;<br/></li>
<li>&nbsp; &nbsp; mstate-&gt;ss.ps.ExecProcNode = <a href="#L697" title="executor/nodeMemoize.c:697">ExecMemoize</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Miscellaneous initialization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create expression context for node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execUtils.c.html#L483" title="executor/execUtils.c:483">ExecAssignExprContext</a>(estate, &amp;mstate-&gt;ss.ps);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; outerNode = outerPlan(node);<br/></li>
<li>&nbsp; &nbsp; outerPlanState(mstate) = <a href="execProcnode.c.html#L142" title="executor/execProcnode.c:142">ExecInitNode</a>(outerNode, estate, eflags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize return slot and type. No need to <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> projection info<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because this node doesn't do projections.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execTuples.c.html#L1886" title="executor/execTuples.c:1886">ExecInitResultTupleSlotTL</a>(&amp;mstate-&gt;ss.ps, &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li>&nbsp; &nbsp; mstate-&gt;ss.ps.ps_ProjInfo = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize scan slot and type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execUtils.c.html#L659" title="executor/execUtils.c:659">ExecCreateScanSlotFromOuterPlan</a>(estate, &amp;mstate-&gt;ss, &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set the state machine to lookup the cache.&nbsp; We won't <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> anything<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * until we cache something, but this saves a special case to create the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mstate-&gt;mstatus = <a href="#L78" title="executor/nodeMemoize.c:78">MEMO_CACHE_LOOKUP</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mstate-&gt;nkeys = nkeys = node-&gt;numKeys;<br/></li>
<li>&nbsp; &nbsp; mstate-&gt;hashkeydesc = <a href="execTuples.c.html#L2084" title="executor/execTuples.c:2084">ExecTypeFromExprList</a>(node-&gt;param_exprs);<br/></li>
<li>&nbsp; &nbsp; mstate-&gt;tableslot = <a href="execTuples.c.html#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>(mstate-&gt;hashkeydesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li>&nbsp; &nbsp; mstate-&gt;probeslot = <a href="execTuples.c.html#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>(mstate-&gt;hashkeydesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mstate-&gt;param_exprs = (ExprState **) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nkeys * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ExprState *));<br/></li>
<li>&nbsp; &nbsp; mstate-&gt;collations = node-&gt;collations;&nbsp; &nbsp; <span class="Comment">/* Just point directly to the plan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * data */<br/></li>
<li></span>&nbsp; &nbsp; mstate-&gt;hashfunctions = (FmgrInfo *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nkeys * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FmgrInfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; eqfuncoids = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nkeys * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashop = node-&gt;hashOperators[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left_hashfn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right_hashfn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *param_expr = (Expr *) list_nth(node-&gt;param_exprs, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/cache/lsyscache.c.html#L510" title="utils/cache/lsyscache.c:510">get_op_hash_functions</a>(hashop, &amp;left_hashfn, &amp;right_hashfn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function for <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> operator </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hashop);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(left_hashfn, &amp;mstate-&gt;hashfunctions[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mstate-&gt;param_exprs[i] = <a href="execExpr.c.html#L134" title="executor/execExpr.c:134">ExecInitExpr</a>(param_expr, (PlanState *) mstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eqfuncoids[i] = <a href="../utils/cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(hashop);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mstate-&gt;cache_eq_expr = <a href="execExpr.c.html#L4103" title="executor/execExpr.c:4103">ExecBuildParamSetEqual</a>(mstate-&gt;hashkeydesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; eqfuncoids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;collations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;param_exprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (PlanState *) mstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(eqfuncoids);<br/></li>
<li>&nbsp; &nbsp; mstate-&gt;mem_used = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Limit the total memory consumed by the cache to this */<br/></li>
<li></span>&nbsp; &nbsp; mstate-&gt;mem_limit = <a href="nodeHash.c.html#L3595" title="executor/nodeHash.c:3595">get_hash_memory_limit</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* A memory context dedicated for the cache */<br/></li>
<li></span>&nbsp; &nbsp; mstate-&gt;tableContext = AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;MemoizeHashTable&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_init(&amp;mstate-&gt;lru_list);<br/></li>
<li>&nbsp; &nbsp; mstate-&gt;last_tuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; mstate-&gt;entry = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark if we can assume the cache entry is completed after we get the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first record for it.&nbsp; Some callers might not call us again after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * getting the first match. e.g. A join operator performing a unique join<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is able to <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> outer tuple after getting the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matching inner tuple.&nbsp; In this case, the cache entry is complete after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * getting the first tuple.&nbsp; This allows us to mark it as so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mstate-&gt;singlerow = node-&gt;singlerow;<br/></li>
<li>&nbsp; &nbsp; mstate-&gt;keyparamids = node-&gt;keyparamids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Record if the cache keys should be compared <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> by <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>, or logically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using the type's <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> equality operator<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mstate-&gt;binary_mode = node-&gt;binary_mode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Zero the statistics counters */<br/></li>
<li></span>&nbsp; &nbsp; memset(&amp;mstate-&gt;stats, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MemoizeInstrumentation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because it may require a large allocation, we delay building of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table until executor run.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mstate-&gt;hashtable = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> mstate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1080">&#x200c;</a></span><span class="linkable">ExecEndMemoize</span>(MemoizeState *node)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Validate the memory accounting code is correct in assert builds. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;hashtable != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; mem = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memoize_iterator i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L115" title="executor/nodeMemoize.c:115">MemoizeEntry</a> *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memoize_start_iterate(node-&gt;hashtable, &amp;i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((entry = memoize_iterate(node-&gt;hashtable, &amp;i)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L94" title="executor/nodeMemoize.c:94">MemoizeTuple</a> *tuple = entry-&gt;tuplehead;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mem += <a href="#L87" title="executor/nodeMemoize.c:87">EMPTY_ENTRY_MEMORY_BYTES</a>(entry);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (tuple != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mem += <a href="#L90" title="executor/nodeMemoize.c:90">CACHE_TUPLE_BYTES</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple = tuple-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(count == node-&gt;hashtable-&gt;members);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(mem == node-&gt;mem_used);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When ending a parallel worker, copy the statistics gathered by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worker back into shared memory so that it can be picked up by the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process to report in EXPLAIN ANALYZE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;shared_info != <span class="Constant">NULL</span> &amp;&amp; IsParallelWorker())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoizeInstrumentation *si;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make mem_peak available for EXPLAIN */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;stats.mem_peak == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node-&gt;stats.mem_peak = node-&gt;mem_used;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../access/transam/parallel.c.html#L112" title="access/transam/parallel.c:112">ParallelWorkerNumber</a> &lt;= node-&gt;shared_info-&gt;num_workers);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; si = &amp;node-&gt;shared_info-&gt;sinstrument[<a href="../access/transam/parallel.c.html#L112" title="access/transam/parallel.c:112">ParallelWorkerNumber</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(si, &amp;node-&gt;stats, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MemoizeInstrumentation));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove the cache context */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(node-&gt;tableContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shut down the subplan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="execProcnode.c.html#L557" title="executor/execProcnode.c:557">ExecEndNode</a>(outerPlanState(node));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1140">&#x200c;</a></span><span class="linkable">ExecReScanMemoize</span>(MemoizeState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlanState&nbsp; *outerPlan = outerPlanState(node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark that we must lookup the cache for a new set of parameters */<br/></li>
<li></span>&nbsp; &nbsp; node-&gt;mstatus = <a href="#L78" title="executor/nodeMemoize.c:78">MEMO_CACHE_LOOKUP</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* nullify pointers used for the last scan */<br/></li>
<li></span>&nbsp; &nbsp; node-&gt;entry = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;last_tuple = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if chgParam of subnode is not null then plan will be re-scanned by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first ExecProcNode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (outerPlan-&gt;chgParam == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="execAmi.c.html#L76" title="executor/execAmi.c:76">ExecReScan</a>(outerPlan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Purge the entire cache if a parameter changed that is not part of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cache key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/bitmapset.c.html#L641" title="nodes/bitmapset.c:641">bms_nonempty_difference</a>(outerPlan-&gt;chgParam, node-&gt;keyparamids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L402" title="executor/nodeMemoize.c:402">cache_purge_all</a>(node);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1172" title="executor/nodeMemoize.c:1172">ExecEstimateCacheEntryOverheadBytes</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; For use in the query <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> to <a href="../main/main.c.html#L320" title="main/main.c:320">help</a> it estimate the amount of memory<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; required to store a single entry in the cache.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">double<br/></li>
<li><a id="L1172">&#x200c;</a></span><span class="linkable">ExecEstimateCacheEntryOverheadBytes</span>(<span class="Type">double</span> ntuples)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L115" title="executor/nodeMemoize.c:115">MemoizeEntry</a>) + <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L105" title="executor/nodeMemoize.c:105">MemoizeKey</a>) + <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L94" title="executor/nodeMemoize.c:94">MemoizeTuple</a>) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ntuples;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Parallel Query Support<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li> <span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment">&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1190" title="executor/nodeMemoize.c:1190">ExecMemoizeEstimate</a><br/></li>
<li></span><span class="Comment">&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; Estimate space required to propagate memoize statistics.<br/></li>
<li></span><span class="Comment">&nbsp; * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment">&nbsp; */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1190">&#x200c;</a></span><span class="linkable">ExecMemoizeEstimate</span>(MemoizeState *node, ParallelContext *pcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't need this if not instrumenting or no workers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!node-&gt;ss.ps.instrument || pcxt-&gt;nworkers == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = <a href="../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(pcxt-&gt;nworkers, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MemoizeInstrumentation));<br/></li>
<li>&nbsp; &nbsp; size = <a href="../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, offsetof(SharedMemoizeInfo, sinstrument));<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, size);<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1211" title="executor/nodeMemoize.c:1211">ExecMemoizeInitializeDSM</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Initialize DSM space for memoize statistics.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1211">&#x200c;</a></span><span class="linkable">ExecMemoizeInitializeDSM</span>(MemoizeState *node, ParallelContext *pcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't need this if not instrumenting or no workers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!node-&gt;ss.ps.instrument || pcxt-&gt;nworkers == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = offsetof(SharedMemoizeInfo, sinstrument)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; + pcxt-&gt;nworkers * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MemoizeInstrumentation);<br/></li>
<li>&nbsp; &nbsp; node-&gt;shared_info = <a href="../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, size);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ensure <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unfilled slots will contain zeroes */<br/></li>
<li></span>&nbsp; &nbsp; memset(node-&gt;shared_info, <span class="Constant">0</span>, size);<br/></li>
<li>&nbsp; &nbsp; node-&gt;shared_info-&gt;num_workers = pcxt-&gt;nworkers;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, node-&gt;ss.ps.plan-&gt;plan_node_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node-&gt;shared_info);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1236" title="executor/nodeMemoize.c:1236">ExecMemoizeInitializeWorker</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Attach worker to DSM space for memoize statistics.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1236">&#x200c;</a></span><span class="linkable">ExecMemoizeInitializeWorker</span>(MemoizeState *node, ParallelWorkerContext *pwcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; node-&gt;shared_info =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(pwcxt-&gt;toc, node-&gt;ss.ps.plan-&gt;plan_node_id, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1249" title="executor/nodeMemoize.c:1249">ExecMemoizeRetrieveInstrumentation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Transfer memoize statistics from DSM to private memory.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1249">&#x200c;</a></span><span class="linkable">ExecMemoizeRetrieveInstrumentation</span>(MemoizeState *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; SharedMemoizeInfo *si;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node-&gt;shared_info == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = offsetof(SharedMemoizeInfo, sinstrument)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; + node-&gt;shared_info-&gt;num_workers * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MemoizeInstrumentation);<br/></li>
<li>&nbsp; &nbsp; si = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(size);<br/></li>
<li>&nbsp; &nbsp; memcpy(si, node-&gt;shared_info, size);<br/></li>
<li>&nbsp; &nbsp; node-&gt;shared_info = si;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
