<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>executor/execTuples.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>executor/execTuples.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L87">TTSOpsBufferHeapTuple</a></li>
<li><a href="#L1165">TTSOpsBufferHeapTuple</a></li>
<li><a href="#L85">TTSOpsHeapTuple</a></li>
<li><a href="#L1129">TTSOpsHeapTuple</a></li>
<li><a href="#L86">TTSOpsMinimalTuple</a></li>
<li><a href="#L1147">TTSOpsMinimalTuple</a></li>
<li><a href="#L84">TTSOpsVirtual</a></li>
<li><a href="#L1108">TTSOpsVirtual</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L2158">BlessTupleDesc</a></li>
<li><a href="#L2222">BuildTupleFromCStrings</a></li>
<li><a href="#L1258">ExecAllocTableSlot</a></li>
<li><a href="#L2037">ExecCleanTypeFromTL</a></li>
<li><a href="#L1341">ExecDropSingleTupleTableSlot</a></li>
<li><a href="#L1731">ExecFetchSlotHeapTuple</a></li>
<li><a href="#L1810">ExecFetchSlotHeapTupleDatum</a></li>
<li><a href="#L1779">ExecFetchSlotMinimalTuple</a></li>
<li><a href="#L1556">ExecForceStoreHeapTuple</a></li>
<li><a href="#L1599">ExecForceStoreMinimalTuple</a></li>
<li><a href="#L1918">ExecInitExtraTupleSlot</a></li>
<li><a href="#L1934">ExecInitNullTupleSlot</a></li>
<li><a href="#L1866">ExecInitResultSlot</a></li>
<li><a href="#L1886">ExecInitResultTupleSlotTL</a></li>
<li><a href="#L1842">ExecInitResultTypeTL</a></li>
<li><a href="#L1898">ExecInitScanTupleSlot</a></li>
<li><a href="#L1278">ExecResetTupleTable</a></li>
<li><a href="#L1376">ExecSetSlotDescriptor</a></li>
<li><a href="#L1663">ExecStoreAllNullTuple</a></li>
<li><a href="#L1479">ExecStoreBufferHeapTuple</a></li>
<li><a href="#L1439">ExecStoreHeapTuple</a></li>
<li><a href="#L1693">ExecStoreHeapTupleDatum</a></li>
<li><a href="#L1533">ExecStoreMinimalTuple</a></li>
<li><a href="#L1505">ExecStorePinnedBufferHeapTuple</a></li>
<li><a href="#L1639">ExecStoreVirtualTuple</a></li>
<li><a href="#L2084">ExecTypeFromExprList</a></li>
<li><a href="#L2025">ExecTypeFromTL</a></li>
<li><a href="#L2043">ExecTypeFromTLInternal</a></li>
<li><a href="#L2117">ExecTypeSetColNames</a></li>
<li><a href="#L2311">HeapTupleHeaderGetDatum</a></li>
<li><a href="#L1325">MakeSingleTupleTableSlot</a></li>
<li><a href="#L1199">MakeTupleTableSlot</a></li>
<li><a href="#L2173">TupleDescGetAttInMetadata</a></li>
<li><a href="#L2342">begin_tup_output_tupdesc</a></li>
<li><a href="#L2390">do_text_output_multiline</a></li>
<li><a href="#L2362">do_tup_output</a></li>
<li><a href="#L2420">end_tup_output</a></li>
<li><a href="#L1008">slot_deform_heap_tuple</a></li>
<li><a href="#L1955">slot_getmissingattrs</a></li>
<li><a href="#L1989">slot_getsomeattrs_int</a></li>
<li><a href="#L719">tts_buffer_heap_clear</a></li>
<li><a href="#L916">tts_buffer_heap_copy_heap_tuple</a></li>
<li><a href="#L929">tts_buffer_heap_copy_minimal_tuple</a></li>
<li><a href="#L861">tts_buffer_heap_copyslot</a></li>
<li><a href="#L903">tts_buffer_heap_get_heap_tuple</a></li>
<li><a href="#L749">tts_buffer_heap_getsomeattrs</a></li>
<li><a href="#L759">tts_buffer_heap_getsysattr</a></li>
<li><a href="#L709">tts_buffer_heap_init</a></li>
<li><a href="#L802">tts_buffer_heap_materialize</a></li>
<li><a href="#L714">tts_buffer_heap_release</a></li>
<li><a href="#L942">tts_buffer_heap_store_tuple</a></li>
<li><a href="#L779">tts_buffer_is_current_xact_tuple</a></li>
<li><a href="#L326">tts_heap_clear</a></li>
<li><a href="#L463">tts_heap_copy_heap_tuple</a></li>
<li><a href="#L475">tts_heap_copy_minimal_tuple</a></li>
<li><a href="#L438">tts_heap_copyslot</a></li>
<li><a href="#L451">tts_heap_get_heap_tuple</a></li>
<li><a href="#L345">tts_heap_getsomeattrs</a></li>
<li><a href="#L355">tts_heap_getsysattr</a></li>
<li><a href="#L316">tts_heap_init</a></li>
<li><a href="#L375">tts_heap_is_current_xact_tuple</a></li>
<li><a href="#L398">tts_heap_materialize</a></li>
<li><a href="#L321">tts_heap_release</a></li>
<li><a href="#L486">tts_heap_store_tuple</a></li>
<li><a href="#L525">tts_minimal_clear</a></li>
<li><a href="#L658">tts_minimal_copy_heap_tuple</a></li>
<li><a href="#L669">tts_minimal_copy_minimal_tuple</a></li>
<li><a href="#L634">tts_minimal_copyslot</a></li>
<li><a href="#L647">tts_minimal_get_minimal_tuple</a></li>
<li><a href="#L543">tts_minimal_getsomeattrs</a></li>
<li><a href="#L557">tts_minimal_getsysattr</a></li>
<li><a href="#L508">tts_minimal_init</a></li>
<li><a href="#L574">tts_minimal_is_current_xact_tuple</a></li>
<li><a href="#L586">tts_minimal_materialize</a></li>
<li><a href="#L520">tts_minimal_release</a></li>
<li><a href="#L680">tts_minimal_store_tuple</a></li>
<li><a href="#L108">tts_virtual_clear</a></li>
<li><a href="#L291">tts_virtual_copy_heap_tuple</a></li>
<li><a href="#L301">tts_virtual_copy_minimal_tuple</a></li>
<li><a href="#L269">tts_virtual_copyslot</a></li>
<li><a href="#L130">tts_virtual_getsomeattrs</a></li>
<li><a href="#L141">tts_virtual_getsysattr</a></li>
<li><a href="#L98">tts_virtual_init</a></li>
<li><a href="#L157">tts_virtual_is_current_xact_tuple</a></li>
<li><a href="#L176">tts_virtual_materialize</a></li>
<li><a href="#L103">tts_virtual_release</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * execTuples.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines dealing with TupleTableSlots.&nbsp; These are used for resource<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; management associated with tuples (eg, releasing buffer pins for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; tuples in disk buffers, or freeing the memory occupied by transient<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; tuples).&nbsp; Slots also provide access abstraction that lets us implement<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &quot;virtual&quot; tuples to reduce data-copying overhead.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines dealing with the type information for tuples. Currently,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the type information for a tuple is an array of FormData_pg_attribute.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; This information is needed by routines manipulating tuples<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; (getattribute, formtuple, etc.).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; EXAMPLE OF HOW TABLE ROUTINES <a href="../regex/regexec.c.html#L87" title="regex/regexec.c:87">WORK</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Suppose we have a query such as SELECT emp.name FROM emp and we have<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a single SeqScan node in the query plan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; At <a href="execMain.c.html#L124" title="executor/execMain.c:124">ExecutorStart</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ----------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - <a href="nodeSeqscan.c.html#L123" title="executor/nodeSeqscan.c:123">ExecInitSeqScan</a>() calls <a href="#L1898" title="executor/execTuples.c:1898">ExecInitScanTupleSlot</a>() to construct a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlots for the tuples returned by the access method, and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1842" title="executor/execTuples.c:1842">ExecInitResultTypeTL</a>() to define the node's return<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type. <a href="execScan.c.html#L270" title="executor/execScan.c:270">ExecAssignScanProjectionInfo</a>() will, if necessary, create<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; another TupleTableSlot for the tuples resulting from performing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target list projections.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; During <a href="execMain.c.html#L297" title="executor/execMain.c:297">ExecutorRun</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - <a href="nodeSeqscan.c.html#L50" title="executor/nodeSeqscan.c:50">SeqNext</a>() calls <a href="#L1479" title="executor/execTuples.c:1479">ExecStoreBufferHeapTuple</a>() to place the tuple<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returned by the access method into the scan tuple slot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - <a href="nodeSeqscan.c.html#L108" title="executor/nodeSeqscan.c:108">ExecSeqScan</a>() (via <a href="execScan.c.html#L156" title="executor/execScan.c:156">ExecScan</a>), if necessary, calls ExecProject(),<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; putting the result of the projection in the result tuple slot. If<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; not necessary, it directly returns the slot returned by <a href="nodeSeqscan.c.html#L50" title="executor/nodeSeqscan.c:50">SeqNext</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - <a href="execMain.c.html#L1601" title="executor/execMain.c:1601">ExecutePlan</a>() calls the output function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The important thing to watch in the executor code is how pointers<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; to the slots containing tuples are passed instead of the tuples<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; themselves.&nbsp; This facilitates the communication of related information<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (such as whether or not a tuple should be pfreed, what buffer contains<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; this tuple, the tuple's tuple descriptor, etc).&nbsp; It also allows us<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; to avoid physically constructing projection tuples in many cases.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/executor/execTuples.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/heaptoast.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tupdesc_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/expandeddatum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/typcache.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> TupleDesc <a href="#L2043" title="executor/execTuples.c:2043">ExecTypeFromTLInternal</a>(List *targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skipjunk);<br/></li>
<li><span class="Type">static</span> pg_attribute_always_inline <span class="Type">void</span> <a href="#L1008" title="executor/execTuples.c:1008">slot_deform_heap_tuple</a>(TupleTableSlot *slot, HeapTuple tuple, uint32 *offp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> natts);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L942" title="executor/execTuples.c:942">tts_buffer_heap_store_tuple</a>(TupleTableSlot *slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTuple tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> transfer_pin);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L486" title="executor/execTuples.c:486">tts_heap_store_tuple</a>(TupleTableSlot *slot, HeapTuple tuple, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> shouldFree);<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L84">&#x200c;</a><span class="Type">const</span> TupleTableSlotOps <span class="linkable">TTSOpsVirtual</span>;<br/></li>
<li><a id="L85">&#x200c;</a><span class="Type">const</span> TupleTableSlotOps <span class="linkable">TTSOpsHeapTuple</span>;<br/></li>
<li><a id="L86">&#x200c;</a><span class="Type">const</span> TupleTableSlotOps <span class="linkable">TTSOpsMinimalTuple</span>;<br/></li>
<li><a id="L87">&#x200c;</a><span class="Type">const</span> TupleTableSlotOps <span class="linkable">TTSOpsBufferHeapTuple</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * TupleTableSlotOps implementations.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * TupleTableSlotOps implementation for VirtualTupleTableSlot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L98">&#x200c;</a></span><span class="linkable">tts_virtual_init</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L103">&#x200c;</a></span><span class="linkable">tts_virtual_release</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L108">&#x200c;</a></span><span class="linkable">tts_virtual_clear</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(TTS_SHOULDFREE(slot)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VirtualTupleTableSlot *vslot = (VirtualTupleTableSlot *) slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(vslot-&gt;data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vslot-&gt;data = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_flags &amp;= ~TTS_FLAG_SHOULDFREE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_nvalid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_flags |= TTS_FLAG_EMPTY;<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;slot-&gt;tts_tid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * VirtualTupleTableSlots always have fully populated tts_values and<br/></li>
<li></span><span class="Comment"> * tts_isnull arrays.&nbsp; So this function should never be called.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L130">&#x200c;</a></span><span class="linkable">tts_virtual_getsomeattrs</span>(TupleTableSlot *slot, <span class="Type">int</span> natts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;getsomeattrs is not required to be called on a virtual tuple table slot&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * VirtualTupleTableSlots never provide system attributes (except those<br/></li>
<li></span><span class="Comment"> * handled generically, such as tableoid).&nbsp; We generally shouldn't get<br/></li>
<li></span><span class="Comment"> * here, but provide a user-friendly message if we do.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L141">&#x200c;</a><span class="linkable">tts_virtual_getsysattr</span>(TupleTableSlot *slot, <span class="Type">int</span> attnum, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_EMPTY(slot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot retrieve a system column in this context&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* silence compiler warnings */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * VirtualTupleTableSlots never have storage tuples.&nbsp; We generally<br/></li>
<li></span><span class="Comment"> * shouldn't get here, but provide a user-friendly message if we do.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L157">&#x200c;</a></span><span class="linkable">tts_virtual_is_current_xact_tuple</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_EMPTY(slot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;don't have transaction information for this type of tuple&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* silence compiler warnings */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * To materialize a virtual slot all the datums that aren't passed by value<br/></li>
<li></span><span class="Comment"> * have to be copied into the slot's memory context.&nbsp; To do so, compute the<br/></li>
<li></span><span class="Comment"> * required size, and allocate enough memory to store all attributes.&nbsp; That's<br/></li>
<li></span><span class="Comment"> * good for cache hit ratio, but more importantly requires only memory<br/></li>
<li></span><span class="Comment"> * allocation/deallocation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L176">&#x200c;</a></span><span class="linkable">tts_virtual_materialize</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VirtualTupleTableSlot *vslot = (VirtualTupleTableSlot *) slot;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; desc = slot-&gt;tts_tupleDescriptor;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; sz = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* already materialized */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TTS_SHOULDFREE(slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* compute size of memory required */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> natt = <span class="Constant">0</span>; natt &lt; desc-&gt;natts; natt++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(desc, natt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attbyval || slot-&gt;tts_isnull[natt])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; val = slot-&gt;tts_values[natt];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attlen == -<span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(val)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We want to flatten the expanded value so that the materialized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * slot doesn't depend on it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz = att_align_nominal(sz, att-&gt;attalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz += <a href="../utils/adt/expandeddatum.c.html#L75" title="utils/adt/expandeddatum.c:75">EOH_get_flat_size</a>(<a href="../utils/adt/expandeddatum.c.html#L29" title="utils/adt/expandeddatum.c:29">DatumGetEOHP</a>(val));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz = att_align_nominal(sz, att-&gt;attalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz = att_addlength_datum(sz, att-&gt;attlen, val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* all data is byval */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sz == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allocate memory */<br/></li>
<li></span>&nbsp; &nbsp; vslot-&gt;data = data = <a href="../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(slot-&gt;tts_mcxt, sz);<br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_flags |= TTS_FLAG_SHOULDFREE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and copy all attributes into the pre-allocated space */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> natt = <span class="Constant">0</span>; natt &lt; desc-&gt;natts; natt++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(desc, natt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attbyval || slot-&gt;tts_isnull[natt])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; val = slot-&gt;tts_values[natt];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attlen == -<span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(val)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; data_length;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We want to flatten the expanded value so that the materialized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * slot doesn't depend on it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExpandedObjectHeader *eoh = <a href="../utils/adt/expandeddatum.c.html#L29" title="utils/adt/expandeddatum.c:29">DatumGetEOHP</a>(val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data = (<span class="Type">char</span> *) att_align_nominal(data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att-&gt;attalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_length = <a href="../utils/adt/expandeddatum.c.html#L75" title="utils/adt/expandeddatum.c:75">EOH_get_flat_size</a>(eoh);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/expandeddatum.c.html#L81" title="utils/adt/expandeddatum.c:81">EOH_flatten_into</a>(eoh, data, data_length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_values[natt] = PointerGetDatum(data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += data_length;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; data_length = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data = (<span class="Type">char</span> *) att_align_nominal(data, att-&gt;attalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_length = att_addlength_datum(data_length, att-&gt;attlen, val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(data, DatumGetPointer(val), data_length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_values[natt] = PointerGetDatum(data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += data_length;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L269">&#x200c;</a></span><span class="linkable">tts_virtual_copyslot</span>(TupleTableSlot *dstslot, TupleTableSlot *srcslot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; srcdesc = srcslot-&gt;tts_tupleDescriptor;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="executor/execTuples.c:108">tts_virtual_clear</a>(dstslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slot_getallattrs(srcslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> natt = <span class="Constant">0</span>; natt &lt; srcdesc-&gt;natts; natt++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dstslot-&gt;tts_values[natt] = srcslot-&gt;tts_values[natt];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dstslot-&gt;tts_isnull[natt] = srcslot-&gt;tts_isnull[natt];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dstslot-&gt;tts_nvalid = srcdesc-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; dstslot-&gt;tts_flags &amp;= ~TTS_FLAG_EMPTY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure storage doesn't depend on external memory */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L176" title="executor/execTuples.c:176">tts_virtual_materialize</a>(dstslot);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> HeapTuple<br/></li>
<li><a id="L291">&#x200c;</a><span class="linkable">tts_virtual_copy_heap_tuple</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_EMPTY(slot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(slot-&gt;tts_tupleDescriptor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot-&gt;tts_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot-&gt;tts_isnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> MinimalTuple<br/></li>
<li><a id="L301">&#x200c;</a><span class="linkable">tts_virtual_copy_minimal_tuple</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_EMPTY(slot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../access/common/heaptuple.c.html#L1452" title="access/common/heaptuple.c:1452">heap_form_minimal_tuple</a>(slot-&gt;tts_tupleDescriptor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot-&gt;tts_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot-&gt;tts_isnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * TupleTableSlotOps implementation for HeapTupleTableSlot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L316">&#x200c;</a></span><span class="linkable">tts_heap_init</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L321">&#x200c;</a></span><span class="linkable">tts_heap_release</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L326">&#x200c;</a></span><span class="linkable">tts_heap_clear</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Free the memory for the heap tuple if it's allowed. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TTS_SHOULDFREE(slot))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(hslot-&gt;tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_flags &amp;= ~TTS_FLAG_SHOULDFREE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_nvalid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_flags |= TTS_FLAG_EMPTY;<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;slot-&gt;tts_tid);<br/></li>
<li>&nbsp; &nbsp; hslot-&gt;off = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; hslot-&gt;tuple = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L345">&#x200c;</a></span><span class="linkable">tts_heap_getsomeattrs</span>(TupleTableSlot *slot, <span class="Type">int</span> natts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_EMPTY(slot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1008" title="executor/execTuples.c:1008">slot_deform_heap_tuple</a>(slot, hslot-&gt;tuple, &amp;hslot-&gt;off, natts);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Datum<br/></li>
<li><a id="L355">&#x200c;</a><span class="linkable">tts_heap_getsysattr</span>(TupleTableSlot *slot, <span class="Type">int</span> attnum, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_EMPTY(slot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In some code paths it's possible to get here with a non-materialized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slot, in which case we can't retrieve system columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!hslot-&gt;tuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot retrieve a system column in this context&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../access/common/heaptuple.c.html#L723" title="access/common/heaptuple.c:723">heap_getsysattr</a>(hslot-&gt;tuple, attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot-&gt;tts_tupleDescriptor, isnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L375">&#x200c;</a></span><span class="linkable">tts_heap_is_current_xact_tuple</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;<br/></li>
<li>&nbsp; &nbsp; TransactionId xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_EMPTY(slot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In some code paths it's possible to get here with a non-materialized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slot, in which case we can't check if tuple is created by the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!hslot-&gt;tuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;don't have a storage tuple in this context&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xmin = HeapTupleHeaderGetRawXmin(hslot-&gt;tuple-&gt;t_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../access/transam/xact.c.html#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a>(xmin);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L398">&#x200c;</a></span><span class="linkable">tts_heap_materialize</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_EMPTY(slot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If slot has its tuple already materialized, nothing to do. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TTS_SHOULDFREE(slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldContext = MemoryContextSwitchTo(slot-&gt;tts_mcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Have to deform from scratch, otherwise tts_values[] entries could point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into the non-materialized tuple (which might be gone when accessed).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; slot-&gt;tts_nvalid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; hslot-&gt;off = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!hslot-&gt;tuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hslot-&gt;tuple = <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(slot-&gt;tts_tupleDescriptor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot-&gt;tts_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot-&gt;tts_isnull);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The tuple contained in this slot is not allocated in the memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * context of the given slot (else it would have TTS_FLAG_SHOULDFREE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set).&nbsp; Copy the tuple into the given slot's memory context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hslot-&gt;tuple = <a href="../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(hslot-&gt;tuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_flags |= TTS_FLAG_SHOULDFREE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L438">&#x200c;</a></span><span class="linkable">tts_heap_copyslot</span>(TupleTableSlot *dstslot, TupleTableSlot *srcslot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(dstslot-&gt;tts_mcxt);<br/></li>
<li>&nbsp; &nbsp; tuple = ExecCopySlotHeapTuple(srcslot);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1439" title="executor/execTuples.c:1439">ExecStoreHeapTuple</a>(tuple, dstslot, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> HeapTuple<br/></li>
<li><a id="L451">&#x200c;</a><span class="linkable">tts_heap_get_heap_tuple</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_EMPTY(slot));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!hslot-&gt;tuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L398" title="executor/execTuples.c:398">tts_heap_materialize</a>(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> hslot-&gt;tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> HeapTuple<br/></li>
<li><a id="L463">&#x200c;</a><span class="linkable">tts_heap_copy_heap_tuple</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_EMPTY(slot));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!hslot-&gt;tuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L398" title="executor/execTuples.c:398">tts_heap_materialize</a>(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(hslot-&gt;tuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> MinimalTuple<br/></li>
<li><a id="L475">&#x200c;</a><span class="linkable">tts_heap_copy_minimal_tuple</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!hslot-&gt;tuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L398" title="executor/execTuples.c:398">tts_heap_materialize</a>(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../access/common/heaptuple.c.html#L1576" title="access/common/heaptuple.c:1576">minimal_tuple_from_heap_tuple</a>(hslot-&gt;tuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L486">&#x200c;</a></span><span class="linkable">tts_heap_store_tuple</span>(TupleTableSlot *slot, HeapTuple tuple, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> shouldFree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleTableSlot *hslot = (HeapTupleTableSlot *) slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L326" title="executor/execTuples.c:326">tts_heap_clear</a>(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_nvalid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; hslot-&gt;tuple = tuple;<br/></li>
<li>&nbsp; &nbsp; hslot-&gt;off = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_flags &amp;= ~(TTS_FLAG_EMPTY | TTS_FLAG_SHOULDFREE);<br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_tid = tuple-&gt;t_self;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (shouldFree)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_flags |= TTS_FLAG_SHOULDFREE;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * TupleTableSlotOps implementation for MinimalTupleTableSlot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L508">&#x200c;</a></span><span class="linkable">tts_minimal_init</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MinimalTupleTableSlot *mslot = (MinimalTupleTableSlot *) slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the heap tuple pointer to access attributes of the minimal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple contained in the slot as if its a heap tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mslot-&gt;tuple = &amp;mslot-&gt;minhdr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L520">&#x200c;</a></span><span class="linkable">tts_minimal_release</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L525">&#x200c;</a></span><span class="linkable">tts_minimal_clear</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MinimalTupleTableSlot *mslot = (MinimalTupleTableSlot *) slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TTS_SHOULDFREE(slot))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1523" title="access/common/heaptuple.c:1523">heap_free_minimal_tuple</a>(mslot-&gt;mintuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_flags &amp;= ~TTS_FLAG_SHOULDFREE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_nvalid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_flags |= TTS_FLAG_EMPTY;<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;slot-&gt;tts_tid);<br/></li>
<li>&nbsp; &nbsp; mslot-&gt;off = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; mslot-&gt;mintuple = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L543">&#x200c;</a></span><span class="linkable">tts_minimal_getsomeattrs</span>(TupleTableSlot *slot, <span class="Type">int</span> natts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MinimalTupleTableSlot *mslot = (MinimalTupleTableSlot *) slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_EMPTY(slot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1008" title="executor/execTuples.c:1008">slot_deform_heap_tuple</a>(slot, mslot-&gt;tuple, &amp;mslot-&gt;off, natts);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * MinimalTupleTableSlots never provide system attributes. We generally<br/></li>
<li></span><span class="Comment"> * shouldn't get here, but provide a user-friendly message if we do.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L557">&#x200c;</a><span class="linkable">tts_minimal_getsysattr</span>(TupleTableSlot *slot, <span class="Type">int</span> attnum, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_EMPTY(slot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot retrieve a system column in this context&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* silence compiler warnings */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Within MinimalTuple abstraction transaction information is unavailable.<br/></li>
<li></span><span class="Comment"> * We generally shouldn't get here, but provide a user-friendly message if<br/></li>
<li></span><span class="Comment"> * we do.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L574">&#x200c;</a></span><span class="linkable">tts_minimal_is_current_xact_tuple</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_EMPTY(slot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;don't have transaction information for this type of tuple&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* silence compiler warnings */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L586">&#x200c;</a></span><span class="linkable">tts_minimal_materialize</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MinimalTupleTableSlot *mslot = (MinimalTupleTableSlot *) slot;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_EMPTY(slot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If slot has its tuple already materialized, nothing to do. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TTS_SHOULDFREE(slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldContext = MemoryContextSwitchTo(slot-&gt;tts_mcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Have to deform from scratch, otherwise tts_values[] entries could point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into the non-materialized tuple (which might be gone when accessed).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; slot-&gt;tts_nvalid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; mslot-&gt;off = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!mslot-&gt;mintuple)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mslot-&gt;mintuple = <a href="../access/common/heaptuple.c.html#L1452" title="access/common/heaptuple.c:1452">heap_form_minimal_tuple</a>(slot-&gt;tts_tupleDescriptor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_isnull);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The minimal tuple contained in this slot is not allocated in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memory context of the given slot (else it would have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TTS_FLAG_SHOULDFREE set).&nbsp; Copy the minimal tuple into the given<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * slot's memory context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mslot-&gt;mintuple = <a href="../access/common/heaptuple.c.html#L1535" title="access/common/heaptuple.c:1535">heap_copy_minimal_tuple</a>(mslot-&gt;mintuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_flags |= TTS_FLAG_SHOULDFREE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(mslot-&gt;tuple == &amp;mslot-&gt;minhdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mslot-&gt;minhdr.t_len = mslot-&gt;mintuple-&gt;t_len + MINIMAL_TUPLE_OFFSET;<br/></li>
<li>&nbsp; &nbsp; mslot-&gt;minhdr.t_data = (HeapTupleHeader) ((<span class="Type">char</span> *) mslot-&gt;mintuple - MINIMAL_TUPLE_OFFSET);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L634">&#x200c;</a></span><span class="linkable">tts_minimal_copyslot</span>(TupleTableSlot *dstslot, TupleTableSlot *srcslot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; MinimalTuple mintuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(dstslot-&gt;tts_mcxt);<br/></li>
<li>&nbsp; &nbsp; mintuple = ExecCopySlotMinimalTuple(srcslot);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1533" title="executor/execTuples.c:1533">ExecStoreMinimalTuple</a>(mintuple, dstslot, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> MinimalTuple<br/></li>
<li><a id="L647">&#x200c;</a><span class="linkable">tts_minimal_get_minimal_tuple</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MinimalTupleTableSlot *mslot = (MinimalTupleTableSlot *) slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!mslot-&gt;mintuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L586" title="executor/execTuples.c:586">tts_minimal_materialize</a>(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> mslot-&gt;mintuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> HeapTuple<br/></li>
<li><a id="L658">&#x200c;</a><span class="linkable">tts_minimal_copy_heap_tuple</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MinimalTupleTableSlot *mslot = (MinimalTupleTableSlot *) slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!mslot-&gt;mintuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L586" title="executor/execTuples.c:586">tts_minimal_materialize</a>(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../access/common/heaptuple.c.html#L1554" title="access/common/heaptuple.c:1554">heap_tuple_from_minimal_tuple</a>(mslot-&gt;mintuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> MinimalTuple<br/></li>
<li><a id="L669">&#x200c;</a><span class="linkable">tts_minimal_copy_minimal_tuple</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MinimalTupleTableSlot *mslot = (MinimalTupleTableSlot *) slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!mslot-&gt;mintuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L586" title="executor/execTuples.c:586">tts_minimal_materialize</a>(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../access/common/heaptuple.c.html#L1535" title="access/common/heaptuple.c:1535">heap_copy_minimal_tuple</a>(mslot-&gt;mintuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L680">&#x200c;</a></span><span class="linkable">tts_minimal_store_tuple</span>(TupleTableSlot *slot, MinimalTuple mtup, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> shouldFree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MinimalTupleTableSlot *mslot = (MinimalTupleTableSlot *) slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L525" title="executor/execTuples.c:525">tts_minimal_clear</a>(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_SHOULDFREE(slot));<br/></li>
<li>&nbsp; &nbsp; Assert(TTS_EMPTY(slot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_flags &amp;= ~TTS_FLAG_EMPTY;<br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_nvalid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; mslot-&gt;off = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mslot-&gt;mintuple = mtup;<br/></li>
<li>&nbsp; &nbsp; Assert(mslot-&gt;tuple == &amp;mslot-&gt;minhdr);<br/></li>
<li>&nbsp; &nbsp; mslot-&gt;minhdr.t_len = mtup-&gt;t_len + MINIMAL_TUPLE_OFFSET;<br/></li>
<li>&nbsp; &nbsp; mslot-&gt;minhdr.t_data = (HeapTupleHeader) ((<span class="Type">char</span> *) mtup - MINIMAL_TUPLE_OFFSET);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no need to set t_self or t_tableOid since we won't allow access */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (shouldFree)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_flags |= TTS_FLAG_SHOULDFREE;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * TupleTableSlotOps implementation for BufferHeapTupleTableSlot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L709">&#x200c;</a></span><span class="linkable">tts_buffer_heap_init</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L714">&#x200c;</a></span><span class="linkable">tts_buffer_heap_release</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L719">&#x200c;</a></span><span class="linkable">tts_buffer_heap_clear</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferHeapTupleTableSlot *bslot = (BufferHeapTupleTableSlot *) slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Free the memory for heap tuple if allowed. A tuple coming from buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can never be freed. But we may have materialized a tuple from buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Such a tuple can be freed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TTS_SHOULDFREE(slot))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We should have unpinned the buffer while materializing the tuple. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!BufferIsValid(bslot-&gt;buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(bslot-&gt;base.tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_flags &amp;= ~TTS_FLAG_SHOULDFREE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(bslot-&gt;buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(bslot-&gt;buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_nvalid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_flags |= TTS_FLAG_EMPTY;<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;slot-&gt;tts_tid);<br/></li>
<li>&nbsp; &nbsp; bslot-&gt;base.tuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; bslot-&gt;base.off = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; bslot-&gt;buffer = InvalidBuffer;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L749">&#x200c;</a></span><span class="linkable">tts_buffer_heap_getsomeattrs</span>(TupleTableSlot *slot, <span class="Type">int</span> natts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferHeapTupleTableSlot *bslot = (BufferHeapTupleTableSlot *) slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_EMPTY(slot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1008" title="executor/execTuples.c:1008">slot_deform_heap_tuple</a>(slot, bslot-&gt;base.tuple, &amp;bslot-&gt;base.off, natts);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Datum<br/></li>
<li><a id="L759">&#x200c;</a><span class="linkable">tts_buffer_heap_getsysattr</span>(TupleTableSlot *slot, <span class="Type">int</span> attnum, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferHeapTupleTableSlot *bslot = (BufferHeapTupleTableSlot *) slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_EMPTY(slot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In some code paths it's possible to get here with a non-materialized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slot, in which case we can't retrieve system columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!bslot-&gt;base.tuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot retrieve a system column in this context&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../access/common/heaptuple.c.html#L723" title="access/common/heaptuple.c:723">heap_getsysattr</a>(bslot-&gt;base.tuple, attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot-&gt;tts_tupleDescriptor, isnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L779">&#x200c;</a></span><span class="linkable">tts_buffer_is_current_xact_tuple</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferHeapTupleTableSlot *bslot = (BufferHeapTupleTableSlot *) slot;<br/></li>
<li>&nbsp; &nbsp; TransactionId xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_EMPTY(slot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In some code paths it's possible to get here with a non-materialized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slot, in which case we can't check if tuple is created by the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!bslot-&gt;base.tuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;don't have a storage tuple in this context&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xmin = HeapTupleHeaderGetRawXmin(bslot-&gt;base.tuple-&gt;t_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../access/transam/xact.c.html#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a>(xmin);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L802">&#x200c;</a></span><span class="linkable">tts_buffer_heap_materialize</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferHeapTupleTableSlot *bslot = (BufferHeapTupleTableSlot *) slot;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_EMPTY(slot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If slot has its tuple already materialized, nothing to do. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TTS_SHOULDFREE(slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldContext = MemoryContextSwitchTo(slot-&gt;tts_mcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Have to deform from scratch, otherwise tts_values[] entries could point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into the non-materialized tuple (which might be gone when accessed).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bslot-&gt;base.off = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_nvalid = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!bslot-&gt;base.tuple)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Normally BufferHeapTupleTableSlot should have a tuple + buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * associated with it, unless it's materialized (which would've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * returned above). But when it's useful to allow storing virtual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples in a buffer slot, which then also needs to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * materializable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; bslot-&gt;base.tuple = <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(slot-&gt;tts_tupleDescriptor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_isnull);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bslot-&gt;base.tuple = <a href="../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(bslot-&gt;base.tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A heap tuple stored in a BufferHeapTupleTableSlot should have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffer associated with it, unless it's materialized or virtual.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (likely(BufferIsValid(bslot-&gt;buffer)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(bslot-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bslot-&gt;buffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't set TTS_FLAG_SHOULDFREE until after releasing the buffer, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.&nbsp; This avoids having a transient state that would fall foul of our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assertions that a slot with TTS_FLAG_SHOULDFREE doesn't own a buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In the unlikely event that <a href="../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>() above errors out, we'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * effectively leak the copied tuple, but that seems fairly harmless.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; slot-&gt;tts_flags |= TTS_FLAG_SHOULDFREE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L861">&#x200c;</a></span><span class="linkable">tts_buffer_heap_copyslot</span>(TupleTableSlot *dstslot, TupleTableSlot *srcslot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferHeapTupleTableSlot *bsrcslot = (BufferHeapTupleTableSlot *) srcslot;<br/></li>
<li>&nbsp; &nbsp; BufferHeapTupleTableSlot *bdstslot = (BufferHeapTupleTableSlot *) dstslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the source slot is of a different kind, or is a buffer slot that has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * been materialized / is virtual, make a new copy of the tuple. Otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * make a new reference to the in-buffer tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dstslot-&gt;tts_ops != srcslot-&gt;tts_ops ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TTS_SHOULDFREE(srcslot) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !bsrcslot-&gt;base.tuple)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(dstslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dstslot-&gt;tts_flags &amp;= ~TTS_FLAG_EMPTY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldContext = MemoryContextSwitchTo(dstslot-&gt;tts_mcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bdstslot-&gt;base.tuple = ExecCopySlotHeapTuple(srcslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dstslot-&gt;tts_flags |= TTS_FLAG_SHOULDFREE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(BufferIsValid(bsrcslot-&gt;buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L942" title="executor/execTuples.c:942">tts_buffer_heap_store_tuple</a>(dstslot, bsrcslot-&gt;base.tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bsrcslot-&gt;buffer, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The HeapTupleData portion of the source tuple might be shorter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lived than the destination slot. Therefore copy the HeapTuple into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * our slot's tupdata, which is guaranteed to live long enough (but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will still point into the buffer).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;bdstslot-&gt;base.tupdata, bdstslot-&gt;base.tuple, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HeapTupleData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bdstslot-&gt;base.tuple = &amp;bdstslot-&gt;base.tupdata;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> HeapTuple<br/></li>
<li><a id="L903">&#x200c;</a><span class="linkable">tts_buffer_heap_get_heap_tuple</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferHeapTupleTableSlot *bslot = (BufferHeapTupleTableSlot *) slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_EMPTY(slot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!bslot-&gt;base.tuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L802" title="executor/execTuples.c:802">tts_buffer_heap_materialize</a>(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> bslot-&gt;base.tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> HeapTuple<br/></li>
<li><a id="L916">&#x200c;</a><span class="linkable">tts_buffer_heap_copy_heap_tuple</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferHeapTupleTableSlot *bslot = (BufferHeapTupleTableSlot *) slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_EMPTY(slot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!bslot-&gt;base.tuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L802" title="executor/execTuples.c:802">tts_buffer_heap_materialize</a>(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(bslot-&gt;base.tuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> MinimalTuple<br/></li>
<li><a id="L929">&#x200c;</a><span class="linkable">tts_buffer_heap_copy_minimal_tuple</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferHeapTupleTableSlot *bslot = (BufferHeapTupleTableSlot *) slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_EMPTY(slot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!bslot-&gt;base.tuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L802" title="executor/execTuples.c:802">tts_buffer_heap_materialize</a>(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../access/common/heaptuple.c.html#L1576" title="access/common/heaptuple.c:1576">minimal_tuple_from_heap_tuple</a>(bslot-&gt;base.tuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L942">&#x200c;</a></span><span class="linkable">tts_buffer_heap_store_tuple</span>(TupleTableSlot *slot, HeapTuple tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer buffer, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> transfer_pin)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BufferHeapTupleTableSlot *bslot = (BufferHeapTupleTableSlot *) slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TTS_SHOULDFREE(slot))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* materialized slot shouldn't have a buffer to release */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!BufferIsValid(bslot-&gt;buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(bslot-&gt;base.tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_flags &amp;= ~TTS_FLAG_SHOULDFREE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_flags &amp;= ~TTS_FLAG_EMPTY;<br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_nvalid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; bslot-&gt;base.tuple = tuple;<br/></li>
<li>&nbsp; &nbsp; bslot-&gt;base.off = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_tid = tuple-&gt;t_self;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If tuple is on a disk page, keep the page pinned as long as we hold a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pointer into it.&nbsp; We assume the caller already has such a pin.&nbsp; If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transfer_pin is true, we'll transfer that pin to this slot, if not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we'll pin it again ourselves.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is coded to <a href="../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> the case where the slot previously held a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple on the same disk page: in that case releasing and re-acquiring<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the pin is a waste of cycles.&nbsp; This is a common situation during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seqscans, so it's worth troubling over.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bslot-&gt;buffer != buffer)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(bslot-&gt;buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(bslot-&gt;buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bslot-&gt;buffer = buffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!transfer_pin &amp;&amp; BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L4882" title="storage/buffer/bufmgr.c:4882">IncrBufferRefCount</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (transfer_pin &amp;&amp; BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In transfer_pin mode the caller won't know about the same-page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * optimization, so we gotta release its pin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1008" title="executor/execTuples.c:1008">slot_deform_heap_tuple</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given a TupleTableSlot, extract data from the slot's physical tuple<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; into its Datum/isnull arrays.&nbsp; Data is extracted up through the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; natts'th column (caller must ensure this is a legal column number).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is essentially an incremental version of <a href="../access/common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; on each call we extract attributes up to the one needed, without<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; re-computing information about previously extracted attributes.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_nvalid is the number of attributes already extracted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is marked as always inline, so the different offp for different types<br/></li>
<li></span><span class="Comment"> * of slots gets optimized away.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> pg_attribute_always_inline <span class="Type">void<br/></li>
<li><a id="L1008">&#x200c;</a></span><span class="linkable">slot_deform_heap_tuple</span>(TupleTableSlot *slot, HeapTuple tuple, uint32 *offp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> natts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupleDesc = slot-&gt;tts_tupleDescriptor;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = slot-&gt;tts_values;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *isnull = slot-&gt;tts_isnull;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader tup = tuple-&gt;t_data;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasnulls = HeapTupleHasNulls(tuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ptr to tuple data */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; off;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* offset in tuple data */<br/></li>
<li></span>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *bp = tup-&gt;t_bits;&nbsp; &nbsp; <span class="Comment">/* ptr to null bitmap in tuple */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; slow;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can we use/set attcacheoff? */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can only fetch as many attributes as the tuple has. */<br/></li>
<li></span>&nbsp; &nbsp; natts = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(HeapTupleHeaderGetNatts(tuple-&gt;t_data), natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check whether the first call for this tuple, and <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> or restore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loop state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; attnum = slot-&gt;tts_nvalid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attnum == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Start from the first attribute */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; off = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slow = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Restore state from previous execution */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; off = *offp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slow = TTS_SLOW(slot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = (<span class="Type">char</span> *) tup + tup-&gt;t_hoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (; attnum &lt; natts; attnum++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute thisatt = TupleDescAttr(tupleDesc, attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hasnulls &amp;&amp; att_isnull(attnum, bp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[attnum] = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull[attnum] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slow = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't use attcacheoff anymore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isnull[attnum] = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!slow &amp;&amp; thisatt-&gt;attcacheoff &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off = thisatt-&gt;attcacheoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (thisatt-&gt;attlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can only cache the offset for a varlena attribute if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * offset is already suitably aligned, so that there would be no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pad bytes in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case: then the offset will be valid for either<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an aligned or unaligned value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!slow &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off == att_align_nominal(off, thisatt-&gt;attalign))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisatt-&gt;attcacheoff = off;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off = att_align_pointer(off, thisatt-&gt;attalign, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tp + off);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slow = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not varlena, so safe to use att_align_nominal */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off = att_align_nominal(off, thisatt-&gt;attalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!slow)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisatt-&gt;attcacheoff = off;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[attnum] = fetchatt(thisatt, tp + off);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; off = att_addlength_pointer(off, thisatt-&gt;attlen, tp + off);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (thisatt-&gt;attlen &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slow = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't use attcacheoff anymore */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Save state for <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> execution<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; slot-&gt;tts_nvalid = attnum;<br/></li>
<li>&nbsp; &nbsp; *offp = off;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (slow)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_flags |= TTS_FLAG_SLOW;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_flags &amp;= ~TTS_FLAG_SLOW;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1108">&#x200c;</a><span class="Type">const</span> TupleTableSlotOps <span class="linkable">TTSOpsVirtual</span> = {<br/></li>
<li>&nbsp; &nbsp; .base_slot_size = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(VirtualTupleTableSlot),<br/></li>
<li>&nbsp; &nbsp; .init = <a href="#L98" title="executor/execTuples.c:98">tts_virtual_init</a>,<br/></li>
<li>&nbsp; &nbsp; .release = <a href="#L103" title="executor/execTuples.c:103">tts_virtual_release</a>,<br/></li>
<li>&nbsp; &nbsp; .clear = <a href="#L108" title="executor/execTuples.c:108">tts_virtual_clear</a>,<br/></li>
<li>&nbsp; &nbsp; .getsomeattrs = <a href="#L130" title="executor/execTuples.c:130">tts_virtual_getsomeattrs</a>,<br/></li>
<li>&nbsp; &nbsp; .getsysattr = <a href="#L141" title="executor/execTuples.c:141">tts_virtual_getsysattr</a>,<br/></li>
<li>&nbsp; &nbsp; .materialize = <a href="#L176" title="executor/execTuples.c:176">tts_virtual_materialize</a>,<br/></li>
<li>&nbsp; &nbsp; .is_current_xact_tuple = <a href="#L157" title="executor/execTuples.c:157">tts_virtual_is_current_xact_tuple</a>,<br/></li>
<li>&nbsp; &nbsp; .copyslot = <a href="#L269" title="executor/execTuples.c:269">tts_virtual_copyslot</a>,<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A virtual tuple table slot can not &quot;own&quot; a heap tuple or a minimal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; .get_heap_tuple = <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; .get_minimal_tuple = <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; .copy_heap_tuple = <a href="#L291" title="executor/execTuples.c:291">tts_virtual_copy_heap_tuple</a>,<br/></li>
<li>&nbsp; &nbsp; .copy_minimal_tuple = <a href="#L301" title="executor/execTuples.c:301">tts_virtual_copy_minimal_tuple</a><br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L1129">&#x200c;</a><span class="Type">const</span> TupleTableSlotOps <span class="linkable">TTSOpsHeapTuple</span> = {<br/></li>
<li>&nbsp; &nbsp; .base_slot_size = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HeapTupleTableSlot),<br/></li>
<li>&nbsp; &nbsp; .init = <a href="#L316" title="executor/execTuples.c:316">tts_heap_init</a>,<br/></li>
<li>&nbsp; &nbsp; .release = <a href="#L321" title="executor/execTuples.c:321">tts_heap_release</a>,<br/></li>
<li>&nbsp; &nbsp; .clear = <a href="#L326" title="executor/execTuples.c:326">tts_heap_clear</a>,<br/></li>
<li>&nbsp; &nbsp; .getsomeattrs = <a href="#L345" title="executor/execTuples.c:345">tts_heap_getsomeattrs</a>,<br/></li>
<li>&nbsp; &nbsp; .getsysattr = <a href="#L355" title="executor/execTuples.c:355">tts_heap_getsysattr</a>,<br/></li>
<li>&nbsp; &nbsp; .is_current_xact_tuple = <a href="#L375" title="executor/execTuples.c:375">tts_heap_is_current_xact_tuple</a>,<br/></li>
<li>&nbsp; &nbsp; .materialize = <a href="#L398" title="executor/execTuples.c:398">tts_heap_materialize</a>,<br/></li>
<li>&nbsp; &nbsp; .copyslot = <a href="#L438" title="executor/execTuples.c:438">tts_heap_copyslot</a>,<br/></li>
<li>&nbsp; &nbsp; .get_heap_tuple = <a href="#L451" title="executor/execTuples.c:451">tts_heap_get_heap_tuple</a>,<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* A heap tuple table slot can not &quot;own&quot; a minimal tuple. */<br/></li>
<li></span>&nbsp; &nbsp; .get_minimal_tuple = <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; .copy_heap_tuple = <a href="#L463" title="executor/execTuples.c:463">tts_heap_copy_heap_tuple</a>,<br/></li>
<li>&nbsp; &nbsp; .copy_minimal_tuple = <a href="#L475" title="executor/execTuples.c:475">tts_heap_copy_minimal_tuple</a><br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L1147">&#x200c;</a><span class="Type">const</span> TupleTableSlotOps <span class="linkable">TTSOpsMinimalTuple</span> = {<br/></li>
<li>&nbsp; &nbsp; .base_slot_size = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MinimalTupleTableSlot),<br/></li>
<li>&nbsp; &nbsp; .init = <a href="#L508" title="executor/execTuples.c:508">tts_minimal_init</a>,<br/></li>
<li>&nbsp; &nbsp; .release = <a href="#L520" title="executor/execTuples.c:520">tts_minimal_release</a>,<br/></li>
<li>&nbsp; &nbsp; .clear = <a href="#L525" title="executor/execTuples.c:525">tts_minimal_clear</a>,<br/></li>
<li>&nbsp; &nbsp; .getsomeattrs = <a href="#L543" title="executor/execTuples.c:543">tts_minimal_getsomeattrs</a>,<br/></li>
<li>&nbsp; &nbsp; .getsysattr = <a href="#L557" title="executor/execTuples.c:557">tts_minimal_getsysattr</a>,<br/></li>
<li>&nbsp; &nbsp; .is_current_xact_tuple = <a href="#L574" title="executor/execTuples.c:574">tts_minimal_is_current_xact_tuple</a>,<br/></li>
<li>&nbsp; &nbsp; .materialize = <a href="#L586" title="executor/execTuples.c:586">tts_minimal_materialize</a>,<br/></li>
<li>&nbsp; &nbsp; .copyslot = <a href="#L634" title="executor/execTuples.c:634">tts_minimal_copyslot</a>,<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* A minimal tuple table slot can not &quot;own&quot; a heap tuple. */<br/></li>
<li></span>&nbsp; &nbsp; .get_heap_tuple = <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; .get_minimal_tuple = <a href="#L647" title="executor/execTuples.c:647">tts_minimal_get_minimal_tuple</a>,<br/></li>
<li>&nbsp; &nbsp; .copy_heap_tuple = <a href="#L658" title="executor/execTuples.c:658">tts_minimal_copy_heap_tuple</a>,<br/></li>
<li>&nbsp; &nbsp; .copy_minimal_tuple = <a href="#L669" title="executor/execTuples.c:669">tts_minimal_copy_minimal_tuple</a><br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L1165">&#x200c;</a><span class="Type">const</span> TupleTableSlotOps <span class="linkable">TTSOpsBufferHeapTuple</span> = {<br/></li>
<li>&nbsp; &nbsp; .base_slot_size = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BufferHeapTupleTableSlot),<br/></li>
<li>&nbsp; &nbsp; .init = <a href="#L709" title="executor/execTuples.c:709">tts_buffer_heap_init</a>,<br/></li>
<li>&nbsp; &nbsp; .release = <a href="#L714" title="executor/execTuples.c:714">tts_buffer_heap_release</a>,<br/></li>
<li>&nbsp; &nbsp; .clear = <a href="#L719" title="executor/execTuples.c:719">tts_buffer_heap_clear</a>,<br/></li>
<li>&nbsp; &nbsp; .getsomeattrs = <a href="#L749" title="executor/execTuples.c:749">tts_buffer_heap_getsomeattrs</a>,<br/></li>
<li>&nbsp; &nbsp; .getsysattr = <a href="#L759" title="executor/execTuples.c:759">tts_buffer_heap_getsysattr</a>,<br/></li>
<li>&nbsp; &nbsp; .is_current_xact_tuple = <a href="#L779" title="executor/execTuples.c:779">tts_buffer_is_current_xact_tuple</a>,<br/></li>
<li>&nbsp; &nbsp; .materialize = <a href="#L802" title="executor/execTuples.c:802">tts_buffer_heap_materialize</a>,<br/></li>
<li>&nbsp; &nbsp; .copyslot = <a href="#L861" title="executor/execTuples.c:861">tts_buffer_heap_copyslot</a>,<br/></li>
<li>&nbsp; &nbsp; .get_heap_tuple = <a href="#L903" title="executor/execTuples.c:903">tts_buffer_heap_get_heap_tuple</a>,<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* A buffer heap tuple table slot can not &quot;own&quot; a minimal tuple. */<br/></li>
<li></span>&nbsp; &nbsp; .get_minimal_tuple = <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; .copy_heap_tuple = <a href="#L916" title="executor/execTuples.c:916">tts_buffer_heap_copy_heap_tuple</a>,<br/></li>
<li>&nbsp; &nbsp; .copy_minimal_tuple = <a href="#L929" title="executor/execTuples.c:929">tts_buffer_heap_copy_minimal_tuple</a><br/></li>
<li>};<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple table create/delete <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1199" title="executor/execTuples.c:1199">MakeTupleTableSlot</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Basic routine to make an empty TupleTableSlot of given<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlotType. If tupleDesc is specified the slot's descriptor is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; fixed for its lifetime, gaining some efficiency. If that's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; undesirable, pass NULL.<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleTableSlot *<br/></li>
<li><a id="L1199">&#x200c;</a><span class="linkable">MakeTupleTableSlot</span>(TupleDesc tupleDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> TupleTableSlotOps *tts_ops)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; basesz,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allocsz;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; basesz = tts_ops-&gt;base_slot_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When a fixed descriptor is specified, we can reduce overhead by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocating the entire slot in one go.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tupleDesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; allocsz = MAXALIGN(basesz) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN(tupleDesc-&gt;natts * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum)) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN(tupleDesc-&gt;natts * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; allocsz = basesz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slot = <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(allocsz);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* const for optimization purposes, OK to modify at allocation time */<br/></li>
<li></span>&nbsp; &nbsp; *((<span class="Type">const</span> TupleTableSlotOps **) &amp;slot-&gt;tts_ops) = tts_ops;<br/></li>
<li>&nbsp; &nbsp; slot-&gt;type = T_TupleTableSlot;<br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_flags |= TTS_FLAG_EMPTY;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tupleDesc != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_flags |= TTS_FLAG_FIXED;<br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_tupleDescriptor = tupleDesc;<br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_mcxt = <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_nvalid = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tupleDesc != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_values = (Datum *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (((<span class="Type">char</span> *) slot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; + MAXALIGN(basesz));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_isnull = (<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (((<span class="Type">char</span> *) slot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; + MAXALIGN(basesz)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; + MAXALIGN(tupleDesc-&gt;natts * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PinTupleDesc(tupleDesc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And allow slot type specific initialization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; slot-&gt;tts_ops-&gt;init(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> slot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1258" title="executor/execTuples.c:1258">ExecAllocTableSlot</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Create a tuple table slot within a tuple table (which is just a List).<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleTableSlot *<br/></li>
<li><a id="L1258">&#x200c;</a><span class="linkable">ExecAllocTableSlot</span>(List **tupleTable, TupleDesc desc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> TupleTableSlotOps *tts_ops)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot = <a href="#L1199" title="executor/execTuples.c:1199">MakeTupleTableSlot</a>(desc, tts_ops);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *tupleTable = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*tupleTable, slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> slot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1278" title="executor/execTuples.c:1278">ExecResetTupleTable</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This releases <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> resources (buffer pins, tupdesc refcounts)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; held by the tuple table, and optionally releases the memory<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; occupied by the tuple table data structure.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; It is expected that this routine be called by <a href="execMain.c.html#L1478" title="executor/execMain.c:1478">ExecEndPlan</a>().<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1278">&#x200c;</a></span><span class="linkable">ExecResetTupleTable</span>(List *tupleTable,&nbsp; &nbsp; <span class="Comment">/* tuple table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> shouldFree)&nbsp; &nbsp; <span class="Comment">/* true if we should free memory */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, tupleTable)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *slot = lfirst_node(TupleTableSlot, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Always release resources and reset the slot to empty */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_ops-&gt;release(slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;tts_tupleDescriptor)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReleaseTupleDesc(slot-&gt;tts_tupleDescriptor);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_tupleDescriptor = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If shouldFree, release memory occupied by the slot itself */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shouldFree)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TTS_FIXED(slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;tts_values)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(slot-&gt;tts_values);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;tts_isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(slot-&gt;tts_isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If shouldFree, release the list structure */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (shouldFree)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(tupleTable);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is a convenience routine for operations that need a standalone<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot not gotten from the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> executor tuple table.&nbsp; It makes<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a single slot of given TupleTableSlotType and initializes it to use the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; given tuple descriptor.<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleTableSlot *<br/></li>
<li><a id="L1325">&#x200c;</a><span class="linkable">MakeSingleTupleTableSlot</span>(TupleDesc tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> TupleTableSlotOps *tts_ops)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot = <a href="#L1199" title="executor/execTuples.c:1199">MakeTupleTableSlot</a>(tupdesc, tts_ops);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> slot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1341" title="executor/execTuples.c:1341">ExecDropSingleTupleTableSlot</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Release a TupleTableSlot made with <a href="#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; DON'T use this on a slot that's part of a tuple table list!<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1341">&#x200c;</a></span><span class="linkable">ExecDropSingleTupleTableSlot</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This should match <a href="#L1278" title="executor/execTuples.c:1278">ExecResetTupleTable</a>'s processing of one slot */<br/></li>
<li></span>&nbsp; &nbsp; Assert(IsA(slot, TupleTableSlot));<br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_ops-&gt;release(slot);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;tts_tupleDescriptor)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReleaseTupleDesc(slot-&gt;tts_tupleDescriptor);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TTS_FIXED(slot))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;tts_values)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(slot-&gt;tts_values);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;tts_isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(slot-&gt;tts_isnull);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(slot);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple table slot accessor <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1376" title="executor/execTuples.c:1376">ExecSetSlotDescriptor</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This function is used to set the tuple descriptor associated<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; with the slot's tuple.&nbsp; The passed descriptor must have lifespan<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; at least <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the slot's.&nbsp; If it is a reference-counted descriptor<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; then the reference count is incremented for as long as the slot holds<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a reference.<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1376">&#x200c;</a></span><span class="linkable">ExecSetSlotDescriptor</span>(TupleTableSlot *slot, <span class="Comment">/* slot to change */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDesc tupdesc)&nbsp; &nbsp; <span class="Comment">/* new tuple descriptor */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_FIXED(slot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For safety, make sure slot is empty <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> changing it */<br/></li>
<li></span>&nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> old descriptor.&nbsp; Also release old Datum/isnull arrays if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * present (we don't bother to check if they could be re-used).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;tts_tupleDescriptor)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReleaseTupleDesc(slot-&gt;tts_tupleDescriptor);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;tts_values)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(slot-&gt;tts_values);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;tts_isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(slot-&gt;tts_isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Install the new descriptor; if it's refcounted, bump its refcount.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; slot-&gt;tts_tupleDescriptor = tupdesc;<br/></li>
<li>&nbsp; &nbsp; PinTupleDesc(tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate Datum/isnull arrays of the appropriate size.&nbsp; These must have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same lifetime as the slot, so allocate in the slot's own context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; slot-&gt;tts_values = (Datum *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(slot-&gt;tts_mcxt, tupdesc-&gt;natts * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_isnull = (<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(slot-&gt;tts_mcxt, tupdesc-&gt;natts * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1439" title="executor/execTuples.c:1439">ExecStoreHeapTuple</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This function is used to store an on-the-fly physical tuple into a specified<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; slot in the tuple table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; tuple:&nbsp; &nbsp; tuple to store<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; slot:&nbsp; &nbsp; <a href="#L85" title="executor/execTuples.c:85">TTSOpsHeapTuple</a> type slot to store it in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; shouldFree: true if ExecClearTuple should <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>() the tuple<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; when done with it<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * shouldFree is normally set 'true' for tuples constructed on-the-fly.&nbsp; But it<br/></li>
<li></span><span class="Comment"> * can be 'false' when the referenced tuple is held in a tuple table slot<br/></li>
<li></span><span class="Comment"> * belonging to a <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level executor Proc node.&nbsp; In this case the <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level<br/></li>
<li></span><span class="Comment"> * slot retains ownership and responsibility for eventually releasing the<br/></li>
<li></span><span class="Comment"> * tuple.&nbsp; When this method is used, we must be certain that the <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level<br/></li>
<li></span><span class="Comment"> * Proc node will lose interest in the tuple sooner than the <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level one<br/></li>
<li></span><span class="Comment"> * does!&nbsp; If you're not certain, copy the <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level tuple with <a href="../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a><br/></li>
<li></span><span class="Comment"> * and let the <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level table slot assume ownership of the copy!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value is just the passed-in slot pointer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the target slot is not guaranteed to be <a href="#L85" title="executor/execTuples.c:85">TTSOpsHeapTuple</a> type slot, use<br/></li>
<li></span><span class="Comment"> * the, more expensive, <a href="#L1556" title="executor/execTuples.c:1556">ExecForceStoreHeapTuple</a>().<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleTableSlot *<br/></li>
<li><a id="L1439">&#x200c;</a><span class="linkable">ExecStoreHeapTuple</span>(HeapTuple tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> shouldFree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sanity checks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(tuple != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(slot != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(slot-&gt;tts_tupleDescriptor != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(!TTS_IS_HEAPTUPLE(slot)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;trying to store a heap tuple into wrong type of slot&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L486" title="executor/execTuples.c:486">tts_heap_store_tuple</a>(slot, tuple, shouldFree);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_tableOid = tuple-&gt;t_tableOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> slot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1479" title="executor/execTuples.c:1479">ExecStoreBufferHeapTuple</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This function is used to store an on-disk physical tuple from a buffer<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; into a specified slot in the tuple table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; tuple:&nbsp; &nbsp; tuple to store<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; slot:&nbsp; &nbsp; <a href="#L87" title="executor/execTuples.c:87">TTSOpsBufferHeapTuple</a> type slot to store it in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; buffer: disk buffer if tuple is in a disk page, else InvalidBuffer<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The tuple table code acquires a pin on the buffer which is held until the<br/></li>
<li></span><span class="Comment"> * slot is cleared, so that the tuple won't go away on us.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value is just the passed-in slot pointer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the target slot is not guaranteed to be <a href="#L87" title="executor/execTuples.c:87">TTSOpsBufferHeapTuple</a> type slot,<br/></li>
<li></span><span class="Comment"> * use the, more expensive, <a href="#L1556" title="executor/execTuples.c:1556">ExecForceStoreHeapTuple</a>().<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleTableSlot *<br/></li>
<li><a id="L1479">&#x200c;</a><span class="linkable">ExecStoreBufferHeapTuple</span>(HeapTuple tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sanity checks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(tuple != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(slot != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(slot-&gt;tts_tupleDescriptor != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(BufferIsValid(buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(!TTS_IS_BUFFERTUPLE(slot)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;trying to store an on-disk heap tuple into wrong type of slot&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L942" title="executor/execTuples.c:942">tts_buffer_heap_store_tuple</a>(slot, tuple, buffer, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_tableOid = tuple-&gt;t_tableOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> slot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Like <a href="#L1479" title="executor/execTuples.c:1479">ExecStoreBufferHeapTuple</a>, but transfer an existing pin from the caller<br/></li>
<li></span><span class="Comment"> * to the slot, i.e. the caller doesn't need to, and may not, release the pin.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleTableSlot *<br/></li>
<li><a id="L1505">&#x200c;</a><span class="linkable">ExecStorePinnedBufferHeapTuple</span>(HeapTuple tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sanity checks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(tuple != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(slot != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(slot-&gt;tts_tupleDescriptor != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(BufferIsValid(buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(!TTS_IS_BUFFERTUPLE(slot)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;trying to store an on-disk heap tuple into wrong type of slot&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L942" title="executor/execTuples.c:942">tts_buffer_heap_store_tuple</a>(slot, tuple, buffer, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_tableOid = tuple-&gt;t_tableOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> slot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Store a minimal tuple into <a href="#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a> type slot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the target slot is not guaranteed to be <a href="#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a> type slot,<br/></li>
<li></span><span class="Comment"> * use the, more expensive, <a href="#L1599" title="executor/execTuples.c:1599">ExecForceStoreMinimalTuple</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleTableSlot *<br/></li>
<li><a id="L1533">&#x200c;</a><span class="linkable">ExecStoreMinimalTuple</span>(MinimalTuple mtup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> shouldFree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sanity checks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(mtup != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(slot != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(slot-&gt;tts_tupleDescriptor != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(!TTS_IS_MINIMALTUPLE(slot)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;trying to store a minimal tuple into wrong type of slot&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L680" title="executor/execTuples.c:680">tts_minimal_store_tuple</a>(slot, mtup, shouldFree);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> slot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Store a HeapTuple into <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> kind of slot, performing conversion if<br/></li>
<li></span><span class="Comment"> * necessary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1556">&#x200c;</a></span><span class="linkable">ExecForceStoreHeapTuple</span>(HeapTuple tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> shouldFree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TTS_IS_HEAPTUPLE(slot))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1439" title="executor/execTuples.c:1439">ExecStoreHeapTuple</a>(tuple, slot, shouldFree);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (TTS_IS_BUFFERTUPLE(slot))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BufferHeapTupleTableSlot *bslot = (BufferHeapTupleTableSlot *) slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_flags &amp;= ~TTS_FLAG_EMPTY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldContext = MemoryContextSwitchTo(slot-&gt;tts_mcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bslot-&gt;base.tuple = <a href="../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_flags |= TTS_FLAG_SHOULDFREE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shouldFree)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(tuple, slot-&gt;tts_tupleDescriptor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_values, slot-&gt;tts_isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a>(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shouldFree)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecMaterializeSlot(slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Store a MinimalTuple into <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> kind of slot, performing conversion if<br/></li>
<li></span><span class="Comment"> * necessary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1599">&#x200c;</a></span><span class="linkable">ExecForceStoreMinimalTuple</span>(MinimalTuple mtup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> shouldFree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TTS_IS_MINIMALTUPLE(slot))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L680" title="executor/execTuples.c:680">tts_minimal_store_tuple</a>(slot, mtup, shouldFree);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleData htup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup.t_len = mtup-&gt;t_len + MINIMAL_TUPLE_OFFSET;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup.t_data = (HeapTupleHeader) ((<span class="Type">char</span> *) mtup - MINIMAL_TUPLE_OFFSET);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(&amp;htup, slot-&gt;tts_tupleDescriptor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_values, slot-&gt;tts_isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a>(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shouldFree)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecMaterializeSlot(slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(mtup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Mark a slot as containing a virtual tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The protocol for loading a slot with virtual tuple data is:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; * Call ExecClearTuple to mark the slot empty.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; * Store data into the Datum/isnull arrays.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; * Call <a href="#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a> to mark the slot valid.<br/></li>
<li></span><span class="Comment"> * This is a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> unclean but it avoids one round of data copying.<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleTableSlot *<br/></li>
<li><a id="L1639">&#x200c;</a><span class="linkable">ExecStoreVirtualTuple</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sanity checks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(slot != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(slot-&gt;tts_tupleDescriptor != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(TTS_EMPTY(slot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_flags &amp;= ~TTS_FLAG_EMPTY;<br/></li>
<li>&nbsp; &nbsp; slot-&gt;tts_nvalid = slot-&gt;tts_tupleDescriptor-&gt;natts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> slot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1663" title="executor/execTuples.c:1663">ExecStoreAllNullTuple</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set up the slot to contain a null in every column.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At first glance this might sound just like ExecClearTuple, but it's<br/></li>
<li></span><span class="Comment"> * entirely different: the slot ends up full, not empty.<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleTableSlot *<br/></li>
<li><a id="L1663">&#x200c;</a><span class="linkable">ExecStoreAllNullTuple</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sanity checks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(slot != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(slot-&gt;tts_tupleDescriptor != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clear <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> old contents */<br/></li>
<li></span>&nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill all the columns of the virtual tuple with nulls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(slot-&gt;tts_values, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot-&gt;tts_tupleDescriptor-&gt;natts * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; memset(slot-&gt;tts_isnull, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot-&gt;tts_tupleDescriptor-&gt;natts * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a>(slot);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Store a HeapTuple in datum form, into a slot. That always requires<br/></li>
<li></span><span class="Comment"> * deforming it and storing it in virtual form.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Until the slot is materialized, the contents of the slot depend on the<br/></li>
<li></span><span class="Comment"> * datum.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1693">&#x200c;</a></span><span class="linkable">ExecStoreHeapTupleDatum</span>(Datum data, TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tuple = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader td;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; td = DatumGetHeapTupleHeader(data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple.t_len = HeapTupleHeaderGetDatumLength(td);<br/></li>
<li>&nbsp; &nbsp; tuple.t_self = td-&gt;t_ctid;<br/></li>
<li>&nbsp; &nbsp; tuple.t_data = td;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(&amp;tuple, slot-&gt;tts_tupleDescriptor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_values, slot-&gt;tts_isnull);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a>(slot);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1731" title="executor/execTuples.c:1731">ExecFetchSlotHeapTuple</a> - fetch HeapTuple representing the slot's content<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned HeapTuple represents the slot's content as closely as<br/></li>
<li></span><span class="Comment"> * possible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If materialize is true, the contents of the slots will be made independent<br/></li>
<li></span><span class="Comment"> * from the underlying storage (i.e. all buffer pins are released, memory is<br/></li>
<li></span><span class="Comment"> * allocated in the slot's context).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If shouldFree is not-NULL it'll be set to true if the returned tuple has<br/></li>
<li></span><span class="Comment"> * been allocated in the calling memory context, and must be freed by the<br/></li>
<li></span><span class="Comment"> * caller (via explicit <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>() or a memory context reset).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: If materialize is true, modifications of the returned tuple are<br/></li>
<li></span><span class="Comment"> * allowed. But it depends on the type of the slot whether such modifications<br/></li>
<li></span><span class="Comment"> * will also affect the slot's contents. While that is not the nicest<br/></li>
<li></span><span class="Comment"> * behaviour, all such modifications are in the process of being removed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>HeapTuple<br/></li>
<li><a id="L1731">&#x200c;</a><span class="linkable">ExecFetchSlotHeapTuple</span>(TupleTableSlot *slot, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> materialize, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *shouldFree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sanity checks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(slot != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_EMPTY(slot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Materialize the tuple so that the slot &quot;owns&quot; it, if requested. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (materialize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_ops-&gt;materialize(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;tts_ops-&gt;get_heap_tuple == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shouldFree)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *shouldFree = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> slot-&gt;tts_ops-&gt;copy_heap_tuple(slot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shouldFree)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *shouldFree = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> slot-&gt;tts_ops-&gt;get_heap_tuple(slot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1779" title="executor/execTuples.c:1779">ExecFetchSlotMinimalTuple</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Fetch the slot's minimal physical tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If the given tuple table slot can hold a minimal tuple, indicated by a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; non-NULL get_minimal_tuple callback, the function returns the minimal<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; tuple returned by that callback. It assumes that the minimal tuple<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; returned by the callback is &quot;owned&quot; by the slot i.e. the slot is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; responsible for freeing the memory consumed by the tuple. Hence it sets<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; *shouldFree to false, indicating that the caller should not free the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; memory consumed by the minimal tuple. In this case the returned minimal<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; tuple should be considered as read-only.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If that callback is not supported, it calls copy_minimal_tuple callback<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; which is expected to return a copy of minimal tuple representing the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; contents of the slot. In this case *shouldFree is set to true,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; indicating the caller that it should free the memory consumed by the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; minimal tuple. In this case the returned minimal tuple may be written<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; up.<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MinimalTuple<br/></li>
<li><a id="L1779">&#x200c;</a><span class="linkable">ExecFetchSlotMinimalTuple</span>(TupleTableSlot *slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *shouldFree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sanity checks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(slot != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(!TTS_EMPTY(slot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;tts_ops-&gt;get_minimal_tuple)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shouldFree)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *shouldFree = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> slot-&gt;tts_ops-&gt;get_minimal_tuple(slot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shouldFree)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *shouldFree = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> slot-&gt;tts_ops-&gt;copy_minimal_tuple(slot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1810" title="executor/execTuples.c:1810">ExecFetchSlotHeapTupleDatum</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Fetch the slot's tuple as a composite-type Datum.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The result is always freshly <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d in the caller's memory context.<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1810">&#x200c;</a><span class="linkable">ExecFetchSlotHeapTupleDatum</span>(TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; shouldFree;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch slot's contents in regular-physical-tuple form */<br/></li>
<li></span>&nbsp; &nbsp; tup = <a href="#L1731" title="executor/execTuples.c:1731">ExecFetchSlotHeapTuple</a>(slot, <span class="Constant">false</span>, &amp;shouldFree);<br/></li>
<li>&nbsp; &nbsp; tupdesc = slot-&gt;tts_tupleDescriptor;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert to Datum form */<br/></li>
<li></span>&nbsp; &nbsp; ret = <a href="../access/common/heaptuple.c.html#L1080" title="access/common/heaptuple.c:1080">heap_copy_tuple_as_datum</a>(tup, tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (shouldFree)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; convenience initialization routines<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1842" title="executor/execTuples.c:1842">ExecInitResultTypeTL</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Initialize result type, using the plan node's targetlist.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1842">&#x200c;</a></span><span class="linkable">ExecInitResultTypeTL</span>(PlanState *planstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc = <a href="#L2025" title="executor/execTuples.c:2025">ExecTypeFromTL</a>(planstate-&gt;plan-&gt;targetlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; planstate-&gt;ps_ResultTupleDesc = tupDesc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ExecInit{Result,Scan,Extra}TupleSlot[TL]<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; These are convenience routines to <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the specified slot<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; in nodes inheriting the appropriate state.&nbsp; <a href="#L1918" title="executor/execTuples.c:1918">ExecInitExtraTupleSlot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; is used for initializing special-purpose slots.<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1886" title="executor/execTuples.c:1886">ExecInitResultTupleSlotTL</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Initialize result tuple slot, using the tuple descriptor previously<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; computed with <a href="#L1842" title="executor/execTuples.c:1842">ExecInitResultTypeTL</a>().<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1866">&#x200c;</a></span><span class="linkable">ExecInitResultSlot</span>(PlanState *planstate, <span class="Type">const</span> TupleTableSlotOps *tts_ops)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slot = <a href="#L1258" title="executor/execTuples.c:1258">ExecAllocTableSlot</a>(&amp;planstate-&gt;state-&gt;es_tupleTable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; planstate-&gt;ps_ResultTupleDesc, tts_ops);<br/></li>
<li>&nbsp; &nbsp; planstate-&gt;ps_ResultTupleSlot = slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; planstate-&gt;resultopsfixed = planstate-&gt;ps_ResultTupleDesc != <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; planstate-&gt;resultops = tts_ops;<br/></li>
<li>&nbsp; &nbsp; planstate-&gt;resultopsset = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1886" title="executor/execTuples.c:1886">ExecInitResultTupleSlotTL</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Initialize result tuple slot, using the plan node's targetlist.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1886">&#x200c;</a></span><span class="linkable">ExecInitResultTupleSlotTL</span>(PlanState *planstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> TupleTableSlotOps *tts_ops)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1842" title="executor/execTuples.c:1842">ExecInitResultTypeTL</a>(planstate);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1866" title="executor/execTuples.c:1866">ExecInitResultSlot</a>(planstate, tts_ops);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1898" title="executor/execTuples.c:1898">ExecInitScanTupleSlot</a><br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1898">&#x200c;</a></span><span class="linkable">ExecInitScanTupleSlot</span>(EState *estate, ScanState *scanstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDesc tupledesc, <span class="Type">const</span> TupleTableSlotOps *tts_ops)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; scanstate-&gt;ss_ScanTupleSlot = <a href="#L1258" title="executor/execTuples.c:1258">ExecAllocTableSlot</a>(&amp;estate-&gt;es_tupleTable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tupledesc, tts_ops);<br/></li>
<li>&nbsp; &nbsp; scanstate-&gt;ps.scandesc = tupledesc;<br/></li>
<li>&nbsp; &nbsp; scanstate-&gt;ps.scanopsfixed = tupledesc != <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; scanstate-&gt;ps.scanops = tts_ops;<br/></li>
<li>&nbsp; &nbsp; scanstate-&gt;ps.scanopsset = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1918" title="executor/execTuples.c:1918">ExecInitExtraTupleSlot</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return a newly created slot. If tupledesc is non-NULL the slot will have<br/></li>
<li></span><span class="Comment"> * that as its fixed tupledesc. Otherwise the caller needs to use<br/></li>
<li></span><span class="Comment"> * <a href="#L1376" title="executor/execTuples.c:1376">ExecSetSlotDescriptor</a>() to set the descriptor <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> use.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleTableSlot *<br/></li>
<li><a id="L1918">&#x200c;</a><span class="linkable">ExecInitExtraTupleSlot</span>(EState *estate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleDesc tupledesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> TupleTableSlotOps *tts_ops)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1258" title="executor/execTuples.c:1258">ExecAllocTableSlot</a>(&amp;estate-&gt;es_tupleTable, tupledesc, tts_ops);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1934" title="executor/execTuples.c:1934">ExecInitNullTupleSlot</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Build a slot containing an all-nulls tuple of the given type.<br/></li>
<li></span><span class="Comment"> * This is used as a substitute for an input tuple when performing an<br/></li>
<li></span><span class="Comment"> * outer join.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleTableSlot *<br/></li>
<li><a id="L1934">&#x200c;</a><span class="linkable">ExecInitNullTupleSlot</span>(EState *estate, TupleDesc tupType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> TupleTableSlotOps *tts_ops)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot = <a href="#L1918" title="executor/execTuples.c:1918">ExecInitExtraTupleSlot</a>(estate, tupType, tts_ops);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1663" title="executor/execTuples.c:1663">ExecStoreAllNullTuple</a>(slot);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ---------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines for setting/accessing attributes in a slot.<br/></li>
<li></span><span class="Comment"> * ---------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fill in missing <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for a TupleTableSlot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is only exposed because it's needed for JIT compiled tuple<br/></li>
<li></span><span class="Comment"> * deforming. That exception aside, there should be no callers outside of this<br/></li>
<li></span><span class="Comment"> * file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1955">&#x200c;</a></span><span class="linkable">slot_getmissingattrs</span>(TupleTableSlot *slot, <span class="Type">int</span> startAttNum, <span class="Type">int</span> lastAttNum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AttrMissing *attrmiss = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;tts_tupleDescriptor-&gt;constr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attrmiss = slot-&gt;tts_tupleDescriptor-&gt;constr-&gt;missing;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!attrmiss)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no missing <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> array at all, so just fill everything in as NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memset(slot-&gt;tts_values + startAttNum, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (lastAttNum - startAttNum) * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(slot-&gt;tts_isnull + startAttNum, <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (lastAttNum - startAttNum) * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; missattnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if there is a missing <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> array we must process them one by one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (missattnum = startAttNum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; missattnum &lt; lastAttNum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; missattnum++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_values[missattnum] = attrmiss[missattnum].am_value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_isnull[missattnum] = !attrmiss[missattnum].am_present;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1989" title="executor/execTuples.c:1989">slot_getsomeattrs_int</a> - workhorse for slot_getsomeattrs()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1989">&#x200c;</a></span><span class="linkable">slot_getsomeattrs_int</span>(TupleTableSlot *slot, <span class="Type">int</span> attnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for caller errors */<br/></li>
<li></span>&nbsp; &nbsp; Assert(slot-&gt;tts_nvalid &lt; attnum);&nbsp; &nbsp; <span class="Comment">/* checked in slot_getsomeattrs */<br/></li>
<li></span>&nbsp; &nbsp; Assert(attnum &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(attnum &gt; slot-&gt;tts_tupleDescriptor-&gt;natts))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid attribute number </span><span class="Special">%d</span><span class="Constant">&quot;</span>, attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch as many attributes as possible from the underlying tuple. */<br/></li>
<li></span>&nbsp; &nbsp; slot-&gt;tts_ops-&gt;getsomeattrs(slot, attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the underlying tuple doesn't have enough attributes, tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * descriptor must have the missing attributes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(slot-&gt;tts_nvalid &lt; attnum))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1955" title="executor/execTuples.c:1955">slot_getmissingattrs</a>(slot, slot-&gt;tts_nvalid, attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_nvalid = attnum;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2025" title="executor/execTuples.c:2025">ExecTypeFromTL</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Generate a tuple descriptor for the result tuple of a targetlist.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (A <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>/plan tlist must be passed, not an ExprState tlist.)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Note that resjunk columns, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, are included in the result.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Currently there are about 4 different places where we create<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; TupleDescriptors.&nbsp; They should all be merged, or perhaps<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; be rewritten to call BuildDesc().<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleDesc<br/></li>
<li><a id="L2025">&#x200c;</a><span class="linkable">ExecTypeFromTL</span>(List *targetList)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2043" title="executor/execTuples.c:2043">ExecTypeFromTLInternal</a>(targetList, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2037" title="executor/execTuples.c:2037">ExecCleanTypeFromTL</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Same as above, but resjunk columns are omitted from the result.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleDesc<br/></li>
<li><a id="L2037">&#x200c;</a><span class="linkable">ExecCleanTypeFromTL</span>(List *targetList)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2043" title="executor/execTuples.c:2043">ExecTypeFromTLInternal</a>(targetList, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> TupleDesc<br/></li>
<li><a id="L2043">&#x200c;</a><span class="linkable">ExecTypeFromTLInternal</span>(List *targetList, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skipjunk)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; typeInfo;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_resno = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (skipjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = <a href="execUtils.c.html#L1119" title="executor/execUtils.c:1119">ExecCleanTargetListLength</a>(targetList);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; len = <a href="execUtils.c.html#L1109" title="executor/execUtils.c:1109">ExecTargetListLength</a>(targetList);<br/></li>
<li>&nbsp; &nbsp; typeInfo = <a href="../access/common/tupdesc.c.html#L67" title="access/common/tupdesc.c:67">CreateTemplateTupleDesc</a>(len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, targetList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (skipjunk &amp;&amp; tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(typeInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur_resno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tle-&gt;resname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) tle-&gt;expr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>((Node *) tle-&gt;expr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L833" title="access/common/tupdesc.c:833">TupleDescInitEntryCollation</a>(typeInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_resno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>((Node *) tle-&gt;expr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cur_resno++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> typeInfo;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2084" title="executor/execTuples.c:2084">ExecTypeFromExprList</a> - build a tuple descriptor from a list of Exprs<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is roughly like <a href="#L2025" title="executor/execTuples.c:2025">ExecTypeFromTL</a>, but we work from bare expressions<br/></li>
<li></span><span class="Comment"> * not TargetEntrys.&nbsp; No names are attached to the tupledesc's columns.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleDesc<br/></li>
<li><a id="L2084">&#x200c;</a><span class="linkable">ExecTypeFromExprList</span>(List *exprList)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; typeInfo;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_resno = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typeInfo = <a href="../access/common/tupdesc.c.html#L67" title="access/common/tupdesc.c:67">CreateTemplateTupleDesc</a>(list_length(exprList));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, exprList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *e = lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(typeInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur_resno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(e),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>(e),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/tupdesc.c.html#L833" title="access/common/tupdesc.c:833">TupleDescInitEntryCollation</a>(typeInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_resno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>(e));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cur_resno++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> typeInfo;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2117" title="executor/execTuples.c:2117">ExecTypeSetColNames</a> - set column names in a RECORD TupleDesc<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Column names must be provided as an alias list (list of String nodes).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2117">&#x200c;</a></span><span class="linkable">ExecTypeSetColNames</span>(TupleDesc typeInfo, List *namesList)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* It's only OK to change col names in a not-yet-blessed RECORD type */<br/></li>
<li></span>&nbsp; &nbsp; Assert(typeInfo-&gt;tdtypeid == RECORDOID);<br/></li>
<li>&nbsp; &nbsp; Assert(typeInfo-&gt;tdtypmod &lt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, namesList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../regex/regc_locale.c.html#L55" title="regex/regc_locale.c:55">cname</a> = strVal(lfirst(lc));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Guard against too-long names list (probably can't happen) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (colno &gt;= typeInfo-&gt;natts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attr = TupleDescAttr(typeInfo, colno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; colno++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do nothing for empty aliases or dropped columns (these cases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * probably can't arise in RECORD types, either)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../regex/regc_locale.c.html#L55" title="regex/regc_locale.c:55">cname</a>[<span class="Constant">0</span>] == <span class="Special">'\0'</span> || attr-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, assign the column name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/name.c.html#L233" title="utils/adt/name.c:233">namestrcpy</a>(&amp;(attr-&gt;attname), <a href="../regex/regc_locale.c.html#L55" title="regex/regc_locale.c:55">cname</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2158" title="executor/execTuples.c:2158">BlessTupleDesc</a> - make a completed tuple descriptor useful for SRFs<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Rowtype Datums returned by a function must contain valid type information.<br/></li>
<li></span><span class="Comment"> * This happens &quot;for free&quot; if the tupdesc came from a relcache entry, but<br/></li>
<li></span><span class="Comment"> * not if we have manufactured a tupdesc for a transient RECORD datatype.<br/></li>
<li></span><span class="Comment"> * In that case we have to notify typcache.c of the existence of the type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleDesc<br/></li>
<li><a id="L2158">&#x200c;</a><span class="linkable">BlessTupleDesc</span>(TupleDesc tupdesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tupdesc-&gt;tdtypeid == RECORDOID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupdesc-&gt;tdtypmod &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/typcache.c.html#L1953" title="utils/cache/typcache.c:1953">assign_record_type_typmod</a>(tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tupdesc;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just for notational convenience */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2173" title="executor/execTuples.c:2173">TupleDescGetAttInMetadata</a> - Build an AttInMetadata structure based on the<br/></li>
<li></span><span class="Comment"> * supplied TupleDesc. AttInMetadata can be used in conjunction with C strings<br/></li>
<li></span><span class="Comment"> * to produce a properly formed tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>AttInMetadata *<br/></li>
<li><a id="L2173">&#x200c;</a><span class="linkable">TupleDescGetAttInMetadata</span>(TupleDesc tupdesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; natts = tupdesc-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atttypeid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attinfuncid;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *attinfuncinfo;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *attioparams;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp;&nbsp; *atttypmods;<br/></li>
<li>&nbsp; &nbsp; AttInMetadata *attinmeta;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attinmeta = (AttInMetadata *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttInMetadata));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* &quot;Bless&quot; the tupledesc so that we can make rowtype datums with it */<br/></li>
<li></span>&nbsp; &nbsp; attinmeta-&gt;tupdesc = <a href="#L2158" title="executor/execTuples.c:2158">BlessTupleDesc</a>(tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Gather info needed later to call the &quot;in&quot; function for each attribute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; attinfuncinfo = (FmgrInfo *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(natts * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FmgrInfo));<br/></li>
<li>&nbsp; &nbsp; attioparams = (Oid *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(natts * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; atttypmods = (int32 *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(natts * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(tupdesc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore dropped attributes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!att-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atttypeid = att-&gt;atttypid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L2874" title="utils/cache/lsyscache.c:2874">getTypeInputInfo</a>(atttypeid, &amp;attinfuncid, &amp;attioparams[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(attinfuncid, &amp;attinfuncinfo[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atttypmods[i] = att-&gt;atttypmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; attinmeta-&gt;attinfuncs = attinfuncinfo;<br/></li>
<li>&nbsp; &nbsp; attinmeta-&gt;attioparams = attioparams;<br/></li>
<li>&nbsp; &nbsp; attinmeta-&gt;atttypmods = atttypmods;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> attinmeta;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2222" title="executor/execTuples.c:2222">BuildTupleFromCStrings</a> - build a HeapTuple given user data in C string form.<br/></li>
<li></span><span class="Comment"> * <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> is an array of C strings, one for each attribute of the return tuple.<br/></li>
<li></span><span class="Comment"> * A NULL string pointer indicates we want to create a NULL field.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>HeapTuple<br/></li>
<li><a id="L2222">&#x200c;</a><span class="linkable">BuildTupleFromCStrings</span>(AttInMetadata *attinmeta, <span class="Type">char</span> **<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc = attinmeta-&gt;tupdesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; natts = tupdesc-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *dvalues;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dvalues = (Datum *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(natts * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; nulls = (<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(natts * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call the &quot;in&quot; function for each non-dropped attribute, even for nulls,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to support domains.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TupleDescAttr(tupdesc, i)-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Non-dropped attributes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dvalues[i] = <a href="../utils/fmgr/fmgr.c.html#L1530" title="utils/fmgr/fmgr.c:1530">InputFunctionCall</a>(&amp;attinmeta-&gt;attinfuncs[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attinmeta-&gt;attioparams[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attinmeta-&gt;atttypmods[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Handle dropped attributes by setting to NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dvalues[i] = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Form a tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tuple = <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(tupdesc, dvalues, nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release locally <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d space.&nbsp; </span><span class="Todo">XXX</span><span class="Comment"> would probably be good to <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of pass-by-reference datums, as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(dvalues);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2311" title="executor/execTuples.c:2311">HeapTupleHeaderGetDatum</a> - convert a HeapTupleHeader pointer to a Datum.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This must *not* get applied to an on-disk tuple; the tuple should be<br/></li>
<li></span><span class="Comment"> * freshly made by <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a> or some wrapper routine for it (such as<br/></li>
<li></span><span class="Comment"> * <a href="#L2222" title="executor/execTuples.c:2222">BuildTupleFromCStrings</a>).&nbsp; Be sure also that the tupledesc used to build<br/></li>
<li></span><span class="Comment"> * the tuple has a properly &quot;blessed&quot; rowtype.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Formerly this was a macro equivalent to PointerGetDatum, relying on the<br/></li>
<li></span><span class="Comment"> * fact that <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a> fills in the appropriate tuple header fields<br/></li>
<li></span><span class="Comment"> * for a composite Datum.&nbsp; However, we <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> require that composite Datums not<br/></li>
<li></span><span class="Comment"> * contain <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> external TOAST pointers.&nbsp; We do not want <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a> itself<br/></li>
<li></span><span class="Comment"> * to enforce that; more specifically, the rule applies only to actual Datums<br/></li>
<li></span><span class="Comment"> * and not to HeapTuple structures.&nbsp; Therefore, <a href="#L2311" title="executor/execTuples.c:2311">HeapTupleHeaderGetDatum</a> is<br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> a function that detects whether there are externally-toasted fields<br/></li>
<li></span><span class="Comment"> * and constructs a new tuple with inlined fields if so.&nbsp; We still need<br/></li>
<li></span><span class="Comment"> * <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a> to insert the Datum header fields, because otherwise this<br/></li>
<li></span><span class="Comment"> * code would have no way to obtain a tupledesc for the tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that if we do build a new tuple, it's <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d in the current<br/></li>
<li></span><span class="Comment"> * memory context.&nbsp; Beware of code that changes context between the initial<br/></li>
<li></span><span class="Comment"> * <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>/etc call and calling HeapTuple(Header)GetDatum.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For performance-critical callers, it could be worthwhile to take extra<br/></li>
<li></span><span class="Comment"> * steps to ensure that there aren't TOAST pointers in the output of<br/></li>
<li></span><span class="Comment"> * <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a> to begin with.&nbsp; It's likely however that the costs of the<br/></li>
<li></span><span class="Comment"> * typcache lookup and tuple disassembly/reassembly are swamped by TOAST<br/></li>
<li></span><span class="Comment"> * dereference costs, so that the benefits of such extra effort would be<br/></li>
<li></span><span class="Comment"> * minimal.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> it would likely be better to create wrapper <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that produce<br/></li>
<li></span><span class="Comment"> * a composite Datum from the field <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in one step.&nbsp; However, there's<br/></li>
<li></span><span class="Comment"> * enough code using the existing APIs that we couldn't get rid of this<br/></li>
<li></span><span class="Comment"> * hack anytime soon.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2311">&#x200c;</a><span class="linkable">HeapTupleHeaderGetDatum</span>(HeapTupleHeader tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No work if there are no external TOAST pointers in the tuple */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleHeaderHasExternal(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use the type data saved by <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a> to look up the rowtype */<br/></li>
<li></span>&nbsp; &nbsp; tupDesc = <a href="../utils/cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(HeapTupleHeaderGetTypeId(tuple),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTupleHeaderGetTypMod(tuple));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And do the flattening */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="../access/heap/heaptoast.c.html#L449" title="access/heap/heaptoast.c:449">toast_flatten_tuple_to_datum</a>(tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderGetDatumLength(tuple),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupDesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseTupleDesc(tupDesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Functions for sending tuples to the frontend (or other specified destination)<br/></li>
<li></span><span class="Comment"> * as though it is a SELECT result. These are used by utility commands that<br/></li>
<li></span><span class="Comment"> * need to project directly to the destination and don't need or want full<br/></li>
<li></span><span class="Comment"> * table function capability. Currently used by EXPLAIN and SHOW ALL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupOutputState *<br/></li>
<li><a id="L2342">&#x200c;</a><span class="linkable">begin_tup_output_tupdesc</span>(DestReceiver *dest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleDesc tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> TupleTableSlotOps *tts_ops)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupOutputState *tstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tstate = (TupOutputState *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TupOutputState));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tstate-&gt;slot = <a href="#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>(tupdesc, tts_ops);<br/></li>
<li>&nbsp; &nbsp; tstate-&gt;dest = dest;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tstate-&gt;dest-&gt;rStartup(tstate-&gt;dest, (<span class="Type">int</span>) CMD_SELECT, tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tstate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * write a single tuple<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2362">&#x200c;</a></span><span class="linkable">do_tup_output</span>(TupOutputState *tstate, <span class="Type">const</span> Datum *<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, <span class="Type">const</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot = tstate-&gt;slot;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; natts = slot-&gt;tts_tupleDescriptor-&gt;natts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure the slot is clear */<br/></li>
<li></span>&nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* insert data */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(slot-&gt;tts_values, <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, natts * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; memcpy(slot-&gt;tts_isnull, isnull, natts * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* mark slot as containing a virtual tuple */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a>(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the tuple to the receiver */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) tstate-&gt;dest-&gt;receiveSlot(slot, tstate-&gt;dest);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* clean up */<br/></li>
<li></span>&nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * write a chunk of text, breaking at <a href="../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a> characters<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Should only be used with a single-TEXT-attribute tupdesc.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2390">&#x200c;</a></span><span class="linkable">do_text_output_multiline</span>(TupOutputState *tstate, <span class="Type">const</span> <span class="Type">char</span> *txt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull[<span class="Constant">1</span>] = {<span class="Constant">false</span>};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (*txt)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *eol;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eol = strchr(txt, <span class="Special">'\n'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (eol)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = eol - txt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eol++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = strlen(txt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eol = txt + len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = PointerGetDatum(<a href="../utils/adt/varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(txt, len));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2362" title="executor/execTuples.c:2362">do_tup_output</a>(tstate, <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txt = eol;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L2420">&#x200c;</a></span><span class="linkable">end_tup_output</span>(TupOutputState *tstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; tstate-&gt;dest-&gt;rShutdown(tstate-&gt;dest);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* note that destroying the dest is not ours to do */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1341" title="executor/execTuples.c:1341">ExecDropSingleTupleTableSlot</a>(tstate-&gt;slot);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tstate);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
