<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/sort/logtape.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/sort/logtape.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L137">LogicalTape</a></li>
<li><a href="#L187">LogicalTapeSet</a></li>
<li><a href="#L95">TapeBlockTrailer</a></li>
<li><a href="#L101">TapeBlockTrailer</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1062">LogicalTapeBackspace</a></li>
<li><a href="#L733">LogicalTapeClose</a></li>
<li><a href="#L680">LogicalTapeCreate</a></li>
<li><a href="#L981">LogicalTapeFreeze</a></li>
<li><a href="#L609">LogicalTapeImport</a></li>
<li><a href="#L928">LogicalTapeRead</a></li>
<li><a href="#L846">LogicalTapeRewindForRead</a></li>
<li><a href="#L1133">LogicalTapeSeek</a></li>
<li><a href="#L1181">LogicalTapeSetBlocks</a></li>
<li><a href="#L667">LogicalTapeSetClose</a></li>
<li><a href="#L556">LogicalTapeSetCreate</a></li>
<li><a href="#L750">LogicalTapeSetForgetFreeSpace</a></li>
<li><a href="#L1162">LogicalTapeTell</a></li>
<li><a href="#L761">LogicalTapeWrite</a></li>
<li><a href="#L337">left_offset</a></li>
<li><a href="#L696">ltsCreateTape</a></li>
<li><a href="#L358">ltsGetBlock</a></li>
<li><a href="#L371">ltsGetFreeBlock</a></li>
<li><a href="#L431">ltsGetPreallocBlock</a></li>
<li><a href="#L522">ltsInitReadBuffer</a></li>
<li><a href="#L282">ltsReadBlock</a></li>
<li><a href="#L298">ltsReadFillBuffer</a></li>
<li><a href="#L469">ltsReleaseBlock</a></li>
<li><a href="#L238">ltsWriteBlock</a></li>
<li><a href="#L349">parent_offset</a></li>
<li><a href="#L343">right_offset</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L125">TAPE_WRITE_PREALLOC_MAX</a></li>
<li><a href="#L124">TAPE_WRITE_PREALLOC_MIN</a></li>
<li><a href="#L108">TapeBlockGetNBytes</a></li>
<li><a href="#L104">TapeBlockGetTrailer</a></li>
<li><a href="#L107">TapeBlockIsLast</a></li>
<li><a href="#L103">TapeBlockPayloadSize</a></li>
<li><a href="#L111">TapeBlockSetNBytes</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * logtape.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Management of &quot;logical tapes&quot; within temporary files.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This module exists to support sorting via multiple <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> passes (see<br/></li>
<li></span><span class="Comment"> * tuplesort.c).&nbsp; Merging is an ideal algorithm for tape devices, but if<br/></li>
<li></span><span class="Comment"> * we implement it on disk by creating a separate file for each &quot;tape&quot;,<br/></li>
<li></span><span class="Comment"> * there is an annoying problem: the peak space usage is at least twice<br/></li>
<li></span><span class="Comment"> * the volume of actual data to be sorted.&nbsp; (This must be so because each<br/></li>
<li></span><span class="Comment"> * datum will appear in both the input and output tapes of the final<br/></li>
<li></span><span class="Comment"> * <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> pass.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We can work around this problem by recognizing that <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one tape<br/></li>
<li></span><span class="Comment"> * dataset (with the possible exception of the final output) is written<br/></li>
<li></span><span class="Comment"> * and read exactly once in a perfectly sequential manner.&nbsp; Therefore,<br/></li>
<li></span><span class="Comment"> * a datum once read will not be required again, and we can recycle its<br/></li>
<li></span><span class="Comment"> * space for use by the new tape dataset(s) being generated.&nbsp; In this way,<br/></li>
<li></span><span class="Comment"> * the total space usage is essentially just the actual data volume, plus<br/></li>
<li></span><span class="Comment"> * insignificant bookkeeping and start/stop overhead.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Few OSes allow arbitrary parts of a file to be released back to the OS,<br/></li>
<li></span><span class="Comment"> * so we have to implement this space-recycling ourselves within a single<br/></li>
<li></span><span class="Comment"> * logical file.&nbsp; logtape.c exists to perform this bookkeeping and provide<br/></li>
<li></span><span class="Comment"> * the illusion of N independent tape devices to tuplesort.c.&nbsp; Note that<br/></li>
<li></span><span class="Comment"> * logtape.c itself depends on buffile.c to provide a &quot;logical file&quot; of<br/></li>
<li></span><span class="Comment"> * larger size than the underlying OS may support.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For simplicity, we allocate and release space in the underlying file<br/></li>
<li></span><span class="Comment"> * in BLCKSZ-size blocks.&nbsp; Space allocation boils down to keeping track<br/></li>
<li></span><span class="Comment"> * of which blocks in the underlying file belong to which logical tape,<br/></li>
<li></span><span class="Comment"> * plus <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> blocks that are free (recycled and not yet reused).<br/></li>
<li></span><span class="Comment"> * The blocks in each logical tape form a chain, with a prev- and <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-<br/></li>
<li></span><span class="Comment"> * pointer in each block.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The initial write pass is guaranteed to fill the underlying file<br/></li>
<li></span><span class="Comment"> * perfectly sequentially, no matter how data is divided into logical tapes.<br/></li>
<li></span><span class="Comment"> * Once we begin <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> passes, the access pattern becomes considerably<br/></li>
<li></span><span class="Comment"> * less predictable --- but the seeking involved should be comparable to<br/></li>
<li></span><span class="Comment"> * what would happen if we kept each logical tape in a separate file,<br/></li>
<li></span><span class="Comment"> * so there's no serious performance penalty paid to obtain the space<br/></li>
<li></span><span class="Comment"> * savings of recycling.&nbsp; We try to localize the write accesses by always<br/></li>
<li></span><span class="Comment"> * writing to the lowest-numbered free block when we have a choice; it's<br/></li>
<li></span><span class="Comment"> * not clear this helps much, but it can't hurt.&nbsp; (</span><span class="Todo">XXX</span><span class="Comment"> perhaps a LIFO<br/></li>
<li></span><span class="Comment"> * policy for free blocks would be better?)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To further make the I/Os more sequential, we can use a larger buffer<br/></li>
<li></span><span class="Comment"> * when reading, and read multiple blocks from the same tape in one go,<br/></li>
<li></span><span class="Comment"> * whenever the buffer becomes empty.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To support the above policy of writing to the lowest free block, the<br/></li>
<li></span><span class="Comment"> * freelist is a min heap.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since all the bookkeeping and buffer memory is allocated with <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(),<br/></li>
<li></span><span class="Comment"> * and the underlying file(s) are made with <a href="../../storage/file/fd.c.html#L1724" title="storage/file/fd.c:1724">OpenTemporaryFile</a>, all resources<br/></li>
<li></span><span class="Comment"> * for a logical tape set are certain to be cleaned up even if processing<br/></li>
<li></span><span class="Comment"> * is aborted by ereport(ERROR).&nbsp; To avoid confusion, the caller should take<br/></li>
<li></span><span class="Comment"> * care that all calls for a single <a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> are made in the same<br/></li>
<li></span><span class="Comment"> * <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> context.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To support parallel sort operations involving coordinated callers to<br/></li>
<li></span><span class="Comment"> * tuplesort.c routines across multiple workers, it is necessary to<br/></li>
<li></span><span class="Comment"> * concatenate each worker <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a>/tapeset into one single logical tapeset<br/></li>
<li></span><span class="Comment"> * managed by the leader.&nbsp; Workers should have produced one final<br/></li>
<li></span><span class="Comment"> * materialized tape (their entire output) when this happens in leader.<br/></li>
<li></span><span class="Comment"> * There will always be the same number of runs as input tapes, and the same<br/></li>
<li></span><span class="Comment"> * number of input tapes as participants (worker Tuplesortstates).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/sort/logtape.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;storage/buffile.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/logtape.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memdebug.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A <a href="#L95" title="utils/sort/logtape.c:95">TapeBlockTrailer</a> is stored at the end of each BLCKSZ block.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The first block of a tape has prev == -1.&nbsp; The last block of a tape<br/></li>
<li></span><span class="Comment"> * stores the number of valid bytes on the block, inverted, in '<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>'<br/></li>
<li></span><span class="Comment"> * Therefore <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> &lt; 0 indicates the last block.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L95">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">TapeBlockTrailer</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; prev;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* previous block on this tape, or -1 on first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * block */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block on this tape, or # of valid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bytes on last block (if &lt; 0) */<br/></li>
<li><a id="L101">&#x200c;</a></span>} <span class="linkable">TapeBlockTrailer</span>;<br/></li>
<li><br/></li>
<li><a id="L103">&#x200c;</a><span class="PreProc">#define <span class="linkable">TapeBlockPayloadSize</span>&nbsp; (BLCKSZ - </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(<a href="#L95" title="utils/sort/logtape.c:95">TapeBlockTrailer</a>))<br/></li>
<li><a id="L104">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TapeBlockGetTrailer</span>(buf) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((<a href="#L95" title="utils/sort/logtape.c:95">TapeBlockTrailer</a> *) ((</span><span class="Type">char</span><span class="PreProc"> *) buf + <a href="#L103" title="utils/sort/logtape.c:103">TapeBlockPayloadSize</a>))<br/></li>
<li></span><br/></li>
<li><a id="L107">&#x200c;</a><span class="PreProc">#define <span class="linkable">TapeBlockIsLast</span>(buf) (<a href="#L104" title="utils/sort/logtape.c:104">TapeBlockGetTrailer</a>(buf)-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> &lt; </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L108">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TapeBlockGetNBytes</span>(buf) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (<a href="#L107" title="utils/sort/logtape.c:107">TapeBlockIsLast</a>(buf) ? \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; (- <a href="#L104" title="utils/sort/logtape.c:104">TapeBlockGetTrailer</a>(buf)-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>) : <a href="#L103" title="utils/sort/logtape.c:103">TapeBlockPayloadSize</a>)<br/></li>
<li><a id="L111">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TapeBlockSetNBytes</span>(buf, nbytes) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (<a href="#L104" title="utils/sort/logtape.c:104">TapeBlockGetTrailer</a>(buf)-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = -(nbytes))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When multiple tapes are being written to concurrently (as in HashAgg),<br/></li>
<li></span><span class="Comment"> * avoid excessive fragmentation by preallocating block numbers to individual<br/></li>
<li></span><span class="Comment"> * tapes. Each preallocation doubles in size starting at<br/></li>
<li></span><span class="Comment"> * <a href="#L124" title="utils/sort/logtape.c:124">TAPE_WRITE_PREALLOC_MIN</a> blocks up to <a href="#L125" title="utils/sort/logtape.c:125">TAPE_WRITE_PREALLOC_MAX</a> blocks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * No filesystem operations are performed for preallocation; only the block<br/></li>
<li></span><span class="Comment"> * numbers are reserved. This may lead to sparse writes, which will cause<br/></li>
<li></span><span class="Comment"> * <a href="#L238" title="utils/sort/logtape.c:238">ltsWriteBlock</a>() to fill in holes with zeros.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L124">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TAPE_WRITE_PREALLOC_MIN</span> </span><span class="Constant">8<br/></li>
<li><a id="L125">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TAPE_WRITE_PREALLOC_MAX</span> </span><span class="Constant">128<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This data structure represents a single &quot;logical tape&quot; within the set<br/></li>
<li></span><span class="Comment"> * of logical tapes stored in the same file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * While writing, we hold the current partially-written data block in the<br/></li>
<li></span><span class="Comment"> * buffer.&nbsp; While reading, we can hold multiple blocks in the buffer.&nbsp; Note<br/></li>
<li></span><span class="Comment"> * that we don't retain the trailers of a block when it's read into the<br/></li>
<li></span><span class="Comment"> * buffer.&nbsp; The buffer therefore contains one large contiguous chunk of data<br/></li>
<li></span><span class="Comment"> * from the tape.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L137">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">LogicalTape</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *tapeSet;&nbsp; &nbsp; <span class="Comment">/* tape set this tape is part of */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; writing;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* T while in write phase */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; frozen;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* T if blocks should not be freed when read */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dirty;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* does buffer need to be written? */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Block numbers of the first, current, and <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block of the tape.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The &quot;current&quot; block number is only valid when writing, or reading from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a frozen tape.&nbsp; (When reading from an unfrozen tape, we use a larger<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * read buffer that holds multiple blocks, so the &quot;current&quot; block is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ambiguous.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When concatenation of worker tape BufFiles is performed, an offset to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the first block in the unified <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a> space is applied during reads.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; firstBlockNumber;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; curBlockNumber;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; nextBlockNumber;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; offsetBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Buffer for current data block(s).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buffer;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* physical buffer (separately <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer_size;&nbsp; &nbsp; <span class="Comment">/* allocated size of the buffer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_size;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* highest useful, safe buffer_size */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> read/write position in buffer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* total # of valid bytes in buffer */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Preallocated block numbers are held in an array sorted in descending<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * order; blocks are consumed from the end of the array (lowest block<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * numbers first).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp;&nbsp; *prealloc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nprealloc;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of elements in list */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prealloc_size;&nbsp; &nbsp; <span class="Comment">/* number of elements list can hold */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This data structure represents a set of related &quot;logical tapes&quot; sharing<br/></li>
<li></span><span class="Comment"> * space in a single underlying file.&nbsp; (But that &quot;file&quot; may be multiple files<br/></li>
<li></span><span class="Comment"> * if needed to escape OS limits on file size; buffile.c handles that for us.)<br/></li>
<li></span><span class="Comment"> * Tapes belonging to a tape set can be created and destroyed on-the-fly, on<br/></li>
<li></span><span class="Comment"> * demand.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L187">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">LogicalTapeSet</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a>&nbsp; &nbsp; *pfile;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* underlying file for whole tape set */<br/></li>
<li></span>&nbsp; &nbsp; SharedFileSet *fileset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worker;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* worker # if shared, -1 for leader/serial */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * File size tracking.&nbsp; nBlocksWritten is the size of the underlying file,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in BLCKSZ blocks.&nbsp; nBlocksAllocated is the number of blocks allocated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by <a href="#L469" title="utils/sort/logtape.c:469">ltsReleaseBlock</a>(), and it is always greater than or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nBlocksWritten.&nbsp; Blocks between nBlocksAllocated and nBlocksWritten are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * blocks that have been allocated for a tape, but have not been written<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the underlying file yet.&nbsp; nHoleBlocks tracks the total number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * blocks that are in unused holes between worker spaces following <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concatenation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; nBlocksAllocated;&nbsp; &nbsp; <span class="Comment">/* # of blocks allocated */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; nBlocksWritten; <span class="Comment">/* # of blocks used in underlying file */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; nHoleBlocks;&nbsp; &nbsp; <span class="Comment">/* # of &quot;hole&quot; blocks left */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We store the numbers of recycled-and-available blocks in freeBlocks[].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When there are no such blocks, we extend the underlying file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If forgetFreeSpace is true then <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> freed blocks are simply forgotten<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rather than being remembered in freeBlocks[].&nbsp; See notes for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L750" title="utils/sort/logtape.c:750">LogicalTapeSetForgetFreeSpace</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; forgetFreeSpace;&nbsp; &nbsp; <span class="Comment">/* are we remembering free blocks? */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp;&nbsp; *freeBlocks;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* resizable array holding minheap */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; nFreeBlocks;&nbsp; &nbsp; <span class="Comment">/* # of currently free blocks */<br/></li>
<li></span>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; freeBlocksLen;&nbsp; &nbsp; <span class="Comment">/* current allocated length of freeBlocks[] */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; enable_prealloc;&nbsp; &nbsp; <span class="Comment">/* preallocate write blocks? */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *<a href="#L696" title="utils/sort/logtape.c:696">ltsCreateTape</a>(<a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *lts);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L238" title="utils/sort/logtape.c:238">ltsWriteBlock</a>(<a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *lts, int64 blocknum, <span class="Type">const</span> <span class="Type">void</span> *buffer);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L282" title="utils/sort/logtape.c:282">ltsReadBlock</a>(<a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *lts, int64 blocknum, <span class="Type">void</span> *buffer);<br/></li>
<li><span class="Type">static</span> int64 <a href="#L358" title="utils/sort/logtape.c:358">ltsGetBlock</a>(<a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *lts, <a href="#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *lt);<br/></li>
<li><span class="Type">static</span> int64 <a href="#L371" title="utils/sort/logtape.c:371">ltsGetFreeBlock</a>(<a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *lts);<br/></li>
<li><span class="Type">static</span> int64 <a href="#L431" title="utils/sort/logtape.c:431">ltsGetPreallocBlock</a>(<a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *lts, <a href="#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *lt);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L469" title="utils/sort/logtape.c:469">ltsReleaseBlock</a>(<a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *lts, int64 blocknum);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L522" title="utils/sort/logtape.c:522">ltsInitReadBuffer</a>(<a href="#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *lt);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write a block-sized buffer to the specified block of the underlying file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * No need for an error return convention; we ereport() on <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L238">&#x200c;</a></span><span class="linkable">ltsWriteBlock</span>(<a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *lts, int64 blocknum, <span class="Type">const</span> <span class="Type">void</span> *buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a> does not support &quot;holes&quot;, so if we're about to write a block<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that's past the current end of file, fill the space between the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end of file and the target block with zeros.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This can happen either when tapes preallocate blocks; or for the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * block of a tape which might not have been flushed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a> concatenation can leave &quot;holes&quot; in <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a> between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worker-owned block ranges.&nbsp; These are tracked for reporting purposes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only.&nbsp; We never read from nor write to these hole blocks, and so they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are not considered here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (blocknum &gt; lts-&gt;nBlocksWritten)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGIOAlignedBlock zerobuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(zerobuf.data, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(zerobuf));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L238" title="utils/sort/logtape.c:238">ltsWriteBlock</a>(lts, lts-&gt;nBlocksWritten, zerobuf.data);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Write the requested block */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/buffile.c.html#L851" title="storage/file/buffile.c:851">BufFileSeekBlock</a>(lts-&gt;pfile, blocknum) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not seek to block </span><span class="Special">%lld</span><span class="Constant"> of temporary file&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) blocknum)));<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L676" title="storage/file/buffile.c:676">BufFileWrite</a>(lts-&gt;pfile, buffer, BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update nBlocksWritten, if we extended the file */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (blocknum == lts-&gt;nBlocksWritten)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lts-&gt;nBlocksWritten++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read a block-sized buffer from the specified block of the underlying file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * No need for an error return convention; we ereport() on <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error.&nbsp;&nbsp; This<br/></li>
<li></span><span class="Comment"> * module should never attempt to read a block it doesn't know is there.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L282">&#x200c;</a></span><span class="linkable">ltsReadBlock</span>(<a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *lts, int64 blocknum, <span class="Type">void</span> *buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/buffile.c.html#L851" title="storage/file/buffile.c:851">BufFileSeekBlock</a>(lts-&gt;pfile, blocknum) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not seek to block </span><span class="Special">%lld</span><span class="Constant"> of temporary file&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) blocknum)));<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L654" title="storage/file/buffile.c:654">BufFileReadExact</a>(lts-&gt;pfile, buffer, BLCKSZ);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read as many blocks as we can into the per-tape buffer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if anything was read, 'false' on EOF.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L298">&#x200c;</a></span><span class="linkable">ltsReadFillBuffer</span>(<a href="#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *lt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; lt-&gt;pos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; lt-&gt;nbytes = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *thisbuf = lt-&gt;buffer + lt-&gt;nbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; datablocknum = lt-&gt;nextBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block number */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (datablocknum == -<span class="Constant">1L</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* EOF */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Apply worker offset, needed for leader tapesets */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; datablocknum += lt-&gt;offsetBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Read the block */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L282" title="utils/sort/logtape.c:282">ltsReadBlock</a>(lt-&gt;tapeSet, datablocknum, thisbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!lt-&gt;frozen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L469" title="utils/sort/logtape.c:469">ltsReleaseBlock</a>(lt-&gt;tapeSet, datablocknum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;curBlockNumber = lt-&gt;nextBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;nbytes += <a href="#L108" title="utils/sort/logtape.c:108">TapeBlockGetNBytes</a>(thisbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L107" title="utils/sort/logtape.c:107">TapeBlockIsLast</a>(thisbuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;nextBlockNumber = -<span class="Constant">1L</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* EOF */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;nextBlockNumber = <a href="#L104" title="utils/sort/logtape.c:104">TapeBlockGetTrailer</a>(thisbuf)-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block, if we have buffer space left */<br/></li>
<li></span>&nbsp; &nbsp; } <span class="Statement">while</span> (lt-&gt;buffer_size - lt-&gt;nbytes &gt; BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (lt-&gt;nbytes &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> uint64<br/></li>
<li><a id="L337">&#x200c;</a><span class="linkable">left_offset</span>(uint64 i)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">2</span> * i + <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> uint64<br/></li>
<li><a id="L343">&#x200c;</a><span class="linkable">right_offset</span>(uint64 i)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">2</span> * i + <span class="Constant">2</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> uint64<br/></li>
<li><a id="L349">&#x200c;</a><span class="linkable">parent_offset</span>(uint64 i)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (i - <span class="Constant">1</span>) / <span class="Constant">2</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block for writing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> int64<br/></li>
<li><a id="L358">&#x200c;</a><span class="linkable">ltsGetBlock</span>(<a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *lts, <a href="#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *lt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lts-&gt;enable_prealloc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L431" title="utils/sort/logtape.c:431">ltsGetPreallocBlock</a>(lts, lt);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L371" title="utils/sort/logtape.c:371">ltsGetFreeBlock</a>(lts);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Select the lowest currently unused block from the tape set's global free<br/></li>
<li></span><span class="Comment"> * list min heap.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> int64<br/></li>
<li><a id="L371">&#x200c;</a><span class="linkable">ltsGetFreeBlock</span>(<a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *lts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp;&nbsp; *heap = lts-&gt;freeBlocks;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; blocknum;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; heapsize;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; holeval;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; holepos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* freelist empty; allocate a new block */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lts-&gt;nFreeBlocks == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> lts-&gt;nBlocksAllocated++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* easy if heap contains one <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lts-&gt;nFreeBlocks == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lts-&gt;nFreeBlocks--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> lts-&gt;freeBlocks[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remove top of minheap */<br/></li>
<li></span>&nbsp; &nbsp; blocknum = heap[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we'll replace it with end of minheap array */<br/></li>
<li></span>&nbsp; &nbsp; holeval = heap[--lts-&gt;nFreeBlocks];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sift down */<br/></li>
<li></span>&nbsp; &nbsp; holepos = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* holepos is where the &quot;hole&quot; is */<br/></li>
<li></span>&nbsp; &nbsp; heapsize = lts-&gt;nFreeBlocks;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; left = <a href="#L337" title="utils/sort/logtape.c:337">left_offset</a>(holepos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; right = <a href="#L343" title="utils/sort/logtape.c:343">right_offset</a>(holepos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; min_child;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (left &lt; heapsize &amp;&amp; right &lt; heapsize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_child = (heap[left] &lt; heap[right]) ? left : right;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (left &lt; heapsize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_child = left;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (right &lt; heapsize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_child = right;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (heap[min_child] &gt;= holeval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; heap[holepos] = heap[min_child];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; holepos = min_child;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; heap[holepos] = holeval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> blocknum;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the lowest free block number from the tape's preallocation list.<br/></li>
<li></span><span class="Comment"> * Refill the preallocation list with blocks from the tape set's free list if<br/></li>
<li></span><span class="Comment"> * necessary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> int64<br/></li>
<li><a id="L431">&#x200c;</a><span class="linkable">ltsGetPreallocBlock</span>(<a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *lts, <a href="#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *lt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sorted in descending order, so return the last <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;nprealloc &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> lt-&gt;prealloc[--lt-&gt;nprealloc];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;prealloc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;prealloc_size = <a href="#L124" title="utils/sort/logtape.c:124">TAPE_WRITE_PREALLOC_MIN</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;prealloc = (int64 *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64) * lt-&gt;prealloc_size);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (lt-&gt;prealloc_size &lt; <a href="#L125" title="utils/sort/logtape.c:125">TAPE_WRITE_PREALLOC_MAX</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* when the preallocation list runs out, double the size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;prealloc_size *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;prealloc_size &gt; <a href="#L125" title="utils/sort/logtape.c:125">TAPE_WRITE_PREALLOC_MAX</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;prealloc_size = <a href="#L125" title="utils/sort/logtape.c:125">TAPE_WRITE_PREALLOC_MAX</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;prealloc = (int64 *) <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(lt-&gt;prealloc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64) * lt-&gt;prealloc_size);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* refill preallocation list */<br/></li>
<li></span>&nbsp; &nbsp; lt-&gt;nprealloc = lt-&gt;prealloc_size;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = lt-&gt;nprealloc; i &gt; <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;prealloc[i - <span class="Constant">1</span>] = <a href="#L371" title="utils/sort/logtape.c:371">ltsGetFreeBlock</a>(lts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* verify descending order */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(i == lt-&gt;nprealloc || lt-&gt;prealloc[i - <span class="Constant">1</span>] &gt; lt-&gt;prealloc[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> lt-&gt;prealloc[--lt-&gt;nprealloc];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return a block# to the freelist.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L469">&#x200c;</a></span><span class="linkable">ltsReleaseBlock</span>(<a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *lts, int64 blocknum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp;&nbsp; *heap;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; holepos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do nothing if we're no longer interested in remembering free space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lts-&gt;forgetFreeSpace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Enlarge freeBlocks array if full.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lts-&gt;nFreeBlocks &gt;= lts-&gt;freeBlocksLen)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the freelist becomes very large, just return and leak this free<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * block.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lts-&gt;freeBlocksLen * <span class="Constant">2</span> * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64) &gt; MaxAllocSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lts-&gt;freeBlocksLen *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lts-&gt;freeBlocks = (int64 *) <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(lts-&gt;freeBlocks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lts-&gt;freeBlocksLen * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* create a &quot;hole&quot; at end of minheap array */<br/></li>
<li></span>&nbsp; &nbsp; heap = lts-&gt;freeBlocks;<br/></li>
<li>&nbsp; &nbsp; holepos = lts-&gt;nFreeBlocks;<br/></li>
<li>&nbsp; &nbsp; lts-&gt;nFreeBlocks++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sift up to insert blocknum */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (holepos != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; parent = <a href="#L349" title="utils/sort/logtape.c:349">parent_offset</a>(holepos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (heap[parent] &lt; blocknum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; heap[holepos] = heap[parent];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; holepos = parent;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; heap[holepos] = blocknum;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Lazily allocate and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the read buffer. This avoids waste when many<br/></li>
<li></span><span class="Comment"> * tapes are open at once, but not all are active between rewinding and<br/></li>
<li></span><span class="Comment"> * reading.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L522">&#x200c;</a></span><span class="linkable">ltsInitReadBuffer</span>(<a href="#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *lt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(lt-&gt;buffer_size &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; lt-&gt;buffer = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(lt-&gt;buffer_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Read the first block, or reset if tape is empty */<br/></li>
<li></span>&nbsp; &nbsp; lt-&gt;nextBlockNumber = lt-&gt;firstBlockNumber;<br/></li>
<li>&nbsp; &nbsp; lt-&gt;pos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; lt-&gt;nbytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L298" title="utils/sort/logtape.c:298">ltsReadFillBuffer</a>(lt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a tape set, backed by a temporary underlying file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The tape set is initially empty. Use <a href="#L680" title="utils/sort/logtape.c:680">LogicalTapeCreate</a>() to create<br/></li>
<li></span><span class="Comment"> * tapes in it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In a single-process sort, pass NULL argument for fileset, and -1 for<br/></li>
<li></span><span class="Comment"> * worker.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In a parallel sort, parallel workers pass the shared fileset handle and<br/></li>
<li></span><span class="Comment"> * their own worker number.&nbsp; After the workers have finished, create the<br/></li>
<li></span><span class="Comment"> * tape set in the leader, passing the shared fileset handle and -1 for<br/></li>
<li></span><span class="Comment"> * worker, and use <a href="#L609" title="utils/sort/logtape.c:609">LogicalTapeImport</a>() to import the worker tapes into it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently, the leader will only import worker tapes into the set, it does<br/></li>
<li></span><span class="Comment"> * not create tapes of its own, although in principle that should work.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If preallocate is true, blocks for each individual tape are allocated in<br/></li>
<li></span><span class="Comment"> * batches.&nbsp; This avoids fragmentation when writing multiple tapes at the<br/></li>
<li></span><span class="Comment"> * same time.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *<br/></li>
<li><a id="L556">&#x200c;</a><span class="linkable">LogicalTapeSetCreate</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> preallocate, SharedFileSet *fileset, <span class="Type">int</span> worker)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *lts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create top-level struct including per-tape <a href="#L137" title="utils/sort/logtape.c:137">LogicalTape</a> structs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lts = (<a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a>));<br/></li>
<li>&nbsp; &nbsp; lts-&gt;nBlocksAllocated = <span class="Constant">0L</span>;<br/></li>
<li>&nbsp; &nbsp; lts-&gt;nBlocksWritten = <span class="Constant">0L</span>;<br/></li>
<li>&nbsp; &nbsp; lts-&gt;nHoleBlocks = <span class="Constant">0L</span>;<br/></li>
<li>&nbsp; &nbsp; lts-&gt;forgetFreeSpace = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; lts-&gt;freeBlocksLen = <span class="Constant">32</span>;&nbsp; &nbsp; <span class="Comment">/* reasonable initial guess */<br/></li>
<li></span>&nbsp; &nbsp; lts-&gt;freeBlocks = (int64 *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(lts-&gt;freeBlocksLen * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64));<br/></li>
<li>&nbsp; &nbsp; lts-&gt;nFreeBlocks = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; lts-&gt;enable_prealloc = preallocate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lts-&gt;fileset = fileset;<br/></li>
<li>&nbsp; &nbsp; lts-&gt;worker = worker;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create temp <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a> storage as required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In leader, we hijack the <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a> of the first tape that's imported, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concatenate the BufFiles of <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subsequent tapes to that. Hence don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create a <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a> here. Things are simpler for the worker case and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * serial case, though.&nbsp; They are generally very similar -- workers use a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared fileset, whereas serial sorts use a conventional serial <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fileset &amp;&amp; worker == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lts-&gt;pfile = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (fileset)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; filename[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../adt/numutils.c.html#L1044" title="utils/adt/numutils.c:1044">pg_itoa</a>(worker, filename);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lts-&gt;pfile = <a href="../../storage/file/buffile.c.html#L267" title="storage/file/buffile.c:267">BufFileCreateFileSet</a>(&amp;fileset-&gt;fs, filename);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lts-&gt;pfile = <a href="../../storage/file/buffile.c.html#L193" title="storage/file/buffile.c:193">BufFileCreateTemp</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> lts;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Claim ownership of a logical tape from an existing shared <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller should be leader process.&nbsp; Though tapes are marked as frozen in<br/></li>
<li></span><span class="Comment"> * workers, they are not frozen when opened within leader, since unfrozen tapes<br/></li>
<li></span><span class="Comment"> * use a larger read buffer. (Frozen tapes have smaller read buffer, optimized<br/></li>
<li></span><span class="Comment"> * for random access.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *<br/></li>
<li><a id="L609">&#x200c;</a><span class="linkable">LogicalTapeImport</span>(<a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *lts, <span class="Type">int</span> worker, TapeShare *shared)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *lt;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; tapeblocks;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; filename[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a>&nbsp; &nbsp; *file;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; filesize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lt = <a href="#L696" title="utils/sort/logtape.c:696">ltsCreateTape</a>(lts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * build concatenated view of all buffiles, remembering the block number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where each source file begins.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../adt/numutils.c.html#L1044" title="utils/adt/numutils.c:1044">pg_itoa</a>(worker, filename);<br/></li>
<li>&nbsp; &nbsp; file = <a href="../../storage/file/buffile.c.html#L291" title="storage/file/buffile.c:291">BufFileOpenFileSet</a>(&amp;lts-&gt;fileset-&gt;fs, filename, O_RDONLY, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; filesize = <a href="../../storage/file/buffile.c.html#L866" title="storage/file/buffile.c:866">BufFileSize</a>(file);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Stash first <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a>, and concatenate subsequent BufFiles to that. Store<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * block offset into each tape as we go.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lt-&gt;firstBlockNumber = shared-&gt;firstblocknumber;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lts-&gt;pfile == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lts-&gt;pfile = file;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;offsetBlockNumber = <span class="Constant">0L</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;offsetBlockNumber = <a href="../../storage/file/buffile.c.html#L905" title="storage/file/buffile.c:905">BufFileAppend</a>(lts-&gt;pfile, file);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't allocate more for read buffer than could possibly <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> */<br/></li>
<li></span>&nbsp; &nbsp; lt-&gt;max_size = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(MaxAllocSize, filesize);<br/></li>
<li>&nbsp; &nbsp; tapeblocks = filesize / BLCKSZ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update # of allocated blocks and # blocks written to reflect the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * imported <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a>.&nbsp; Allocated/written blocks include space used by holes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * left between concatenated BufFiles.&nbsp; Also track the number of hole<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * blocks so that we can later work backwards to calculate the number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * physical blocks for instrumentation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lts-&gt;nHoleBlocks += lt-&gt;offsetBlockNumber - lts-&gt;nBlocksAllocated;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lts-&gt;nBlocksAllocated = lt-&gt;offsetBlockNumber + tapeblocks;<br/></li>
<li>&nbsp; &nbsp; lts-&gt;nBlocksWritten = lts-&gt;nBlocksAllocated;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> lt;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Close a logical tape set and release all resources.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: This doesn't close <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the tapes!&nbsp; You must close them<br/></li>
<li></span><span class="Comment"> * first, or you can let them be destroyed along with the memory context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L667">&#x200c;</a></span><span class="linkable">LogicalTapeSetClose</span>(<a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *lts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L412" title="storage/file/buffile.c:412">BufFileClose</a>(lts-&gt;pfile);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(lts-&gt;freeBlocks);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(lts);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a logical tape in the given tapeset.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The tape is initialized in write state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *<br/></li>
<li><a id="L680">&#x200c;</a><span class="linkable">LogicalTapeCreate</span>(<a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *lts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The only thing that currently prevents creating new tapes in leader is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the fact that BufFiles opened using BufFileOpenShared() are read-only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by definition, but that could be changed if it seemed worthwhile.&nbsp; For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, writing to the leader tape will raise a &quot;Bad file descriptor&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * error, so tuplesort must avoid writing to the leader tape altogether.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lts-&gt;fileset &amp;&amp; lts-&gt;worker == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot create new tapes in leader process&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L696" title="utils/sort/logtape.c:696">ltsCreateTape</a>(lts);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *<br/></li>
<li><a id="L696">&#x200c;</a><span class="linkable">ltsCreateTape</span>(<a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *lts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *lt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create per-tape struct.&nbsp; Note we allocate the I/O buffer lazily.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lt = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L137" title="utils/sort/logtape.c:137">LogicalTape</a>));<br/></li>
<li>&nbsp; &nbsp; lt-&gt;tapeSet = lts;<br/></li>
<li>&nbsp; &nbsp; lt-&gt;writing = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; lt-&gt;frozen = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; lt-&gt;dirty = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; lt-&gt;firstBlockNumber = -<span class="Constant">1L</span>;<br/></li>
<li>&nbsp; &nbsp; lt-&gt;curBlockNumber = -<span class="Constant">1L</span>;<br/></li>
<li>&nbsp; &nbsp; lt-&gt;nextBlockNumber = -<span class="Constant">1L</span>;<br/></li>
<li>&nbsp; &nbsp; lt-&gt;offsetBlockNumber = <span class="Constant">0L</span>;<br/></li>
<li>&nbsp; &nbsp; lt-&gt;buffer = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; lt-&gt;buffer_size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>() larger than MaxAllocSize would fail */<br/></li>
<li></span>&nbsp; &nbsp; lt-&gt;max_size = MaxAllocSize;<br/></li>
<li>&nbsp; &nbsp; lt-&gt;pos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; lt-&gt;nbytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; lt-&gt;prealloc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; lt-&gt;nprealloc = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; lt-&gt;prealloc_size = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> lt;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Close a logical tape.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: This doesn't return <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> blocks to the free list!&nbsp; You must read<br/></li>
<li></span><span class="Comment"> * the tape to the end first, to reuse the space.&nbsp; In current use, though,<br/></li>
<li></span><span class="Comment"> * we only close tapes after fully reading them.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L733">&#x200c;</a></span><span class="linkable">LogicalTapeClose</span>(<a href="#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *lt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;buffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(lt-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(lt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Mark a logical tape set as not needing management of free space anymore.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be called if the caller does not intend to write <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more data<br/></li>
<li></span><span class="Comment"> * into the tape set, but is reading from un-frozen tapes.&nbsp; Since no more<br/></li>
<li></span><span class="Comment"> * writes are planned, remembering free blocks is no longer useful.&nbsp; Setting<br/></li>
<li></span><span class="Comment"> * this flag lets us avoid wasting time and space in <a href="#L469" title="utils/sort/logtape.c:469">ltsReleaseBlock</a>(), which<br/></li>
<li></span><span class="Comment"> * is not designed to handle large numbers of free blocks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L750">&#x200c;</a></span><span class="linkable">LogicalTapeSetForgetFreeSpace</span>(<a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *lts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; lts-&gt;forgetFreeSpace = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write to a logical tape.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There are no error returns; we ereport() on failure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L761">&#x200c;</a></span><span class="linkable">LogicalTapeWrite</span>(<a href="#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *lt, <span class="Type">const</span> <span class="Type">void</span> *ptr, <span class="Type">size_t</span> size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *lts = lt-&gt;tapeSet;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; nthistime;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(lt-&gt;writing);<br/></li>
<li>&nbsp; &nbsp; Assert(lt-&gt;offsetBlockNumber == <span class="Constant">0L</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate data buffer and first block on first write */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;buffer == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;buffer = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;buffer_size = BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;curBlockNumber == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(lt-&gt;firstBlockNumber == -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(lt-&gt;pos == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;curBlockNumber = <a href="#L358" title="utils/sort/logtape.c:358">ltsGetBlock</a>(lts, lt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;firstBlockNumber = lt-&gt;curBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L104" title="utils/sort/logtape.c:104">TapeBlockGetTrailer</a>(lt-&gt;buffer)-&gt;prev = -<span class="Constant">1L</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(lt-&gt;buffer_size == BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (size &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;pos &gt;= (<span class="Type">int</span>) <a href="#L103" title="utils/sort/logtape.c:103">TapeBlockPayloadSize</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Buffer full, <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> it out */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; nextBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!lt-&gt;dirty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Hmm, went directly from reading to writing? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid logtape state: should be dirty&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First allocate the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block, so that we can store it in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * '<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>' pointer of this block.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextBlockNumber = <a href="#L358" title="utils/sort/logtape.c:358">ltsGetBlock</a>(lt-&gt;tapeSet, lt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-pointer and <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> the current block. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L104" title="utils/sort/logtape.c:104">TapeBlockGetTrailer</a>(lt-&gt;buffer)-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = nextBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L238" title="utils/sort/logtape.c:238">ltsWriteBlock</a>(lt-&gt;tapeSet, lt-&gt;curBlockNumber, lt-&gt;buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the prev-pointer of the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L104" title="utils/sort/logtape.c:104">TapeBlockGetTrailer</a>(lt-&gt;buffer)-&gt;prev = lt-&gt;curBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;curBlockNumber = nextBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;pos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;nbytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nthistime = <a href="#L103" title="utils/sort/logtape.c:103">TapeBlockPayloadSize</a> - lt-&gt;pos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nthistime &gt; size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nthistime = size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nthistime &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(lt-&gt;buffer + lt-&gt;pos, ptr, nthistime);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;dirty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;pos += nthistime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;nbytes &lt; lt-&gt;pos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;nbytes = lt-&gt;pos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr = (<span class="Type">const</span> <span class="Type">char</span> *) ptr + nthistime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size -= nthistime;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Rewind logical tape and switch from writing to reading.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The tape must currently be in writing state, or &quot;frozen&quot; in read state.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'buffer_size' specifies how much memory to use for the read buffer.<br/></li>
<li></span><span class="Comment"> * Regardless of the argument, the actual amount of memory used is between<br/></li>
<li></span><span class="Comment"> * BLCKSZ and MaxAllocSize, and is a multiple of BLCKSZ.&nbsp; The given value is<br/></li>
<li></span><span class="Comment"> * rounded down and truncated to fit those constraints, if necessary.&nbsp; If the<br/></li>
<li></span><span class="Comment"> * tape is frozen, the 'buffer_size' argument is ignored, and a small BLCKSZ<br/></li>
<li></span><span class="Comment"> * byte buffer is used.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L846">&#x200c;</a></span><span class="linkable">LogicalTapeRewindForRead</span>(<a href="#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *lt, <span class="Type">size_t</span> buffer_size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *lts = lt-&gt;tapeSet;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Round and cap buffer_size if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;frozen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer_size = BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* need at least one block */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buffer_size &lt; BLCKSZ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer_size = BLCKSZ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>() larger than max_size is unlikely to be helpful */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buffer_size &gt; lt-&gt;max_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer_size = lt-&gt;max_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* round down to BLCKSZ boundary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buffer_size -= buffer_size % BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;writing)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Completion of a write phase.&nbsp; Flush last partial data block, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rewind for normal (destructive) read.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;dirty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As long as we've filled the buffer at least once, its contents<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are entirely defined from valgrind's point of view, even though<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contents beyond the current end point may be stale.&nbsp; But it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible - at least in the case of a parallel sort - to sort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * such small amount of data that we do not fill the buffer even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * once.&nbsp; Tell valgrind that its contents are defined, so it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doesn't bleat.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(lt-&gt;buffer + lt-&gt;nbytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;buffer_size - lt-&gt;nbytes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L111" title="utils/sort/logtape.c:111">TapeBlockSetNBytes</a>(lt-&gt;buffer, lt-&gt;nbytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L238" title="utils/sort/logtape.c:238">ltsWriteBlock</a>(lt-&gt;tapeSet, lt-&gt;curBlockNumber, lt-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;writing = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is only OK if tape is frozen; we rewind for (another) read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pass.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(lt-&gt;frozen);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;buffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(lt-&gt;buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the buffer is lazily allocated, but set the size here */<br/></li>
<li></span>&nbsp; &nbsp; lt-&gt;buffer = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; lt-&gt;buffer_size = buffer_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* free the preallocation list, and return unused block numbers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;prealloc != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = lt-&gt;nprealloc; i &gt; <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L469" title="utils/sort/logtape.c:469">ltsReleaseBlock</a>(lts, lt-&gt;prealloc[i - <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(lt-&gt;prealloc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;prealloc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;nprealloc = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;prealloc_size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read from a logical tape.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Early EOF is indicated by return value less than #bytes requested.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">size_t<br/></li>
<li><a id="L928">&#x200c;</a></span><span class="linkable">LogicalTapeRead</span>(<a href="#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *lt, <span class="Type">void</span> *ptr, <span class="Type">size_t</span> size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; nread = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; nthistime;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!lt-&gt;writing);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;buffer == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L522" title="utils/sort/logtape.c:522">ltsInitReadBuffer</a>(lt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (size &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;pos &gt;= lt-&gt;nbytes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to load more data into buffer. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L298" title="utils/sort/logtape.c:298">ltsReadFillBuffer</a>(lt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* EOF */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nthistime = lt-&gt;nbytes - lt-&gt;pos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nthistime &gt; size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nthistime = size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nthistime &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, lt-&gt;buffer + lt-&gt;pos, nthistime);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;pos += nthistime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr = (<span class="Type">char</span> *) ptr + nthistime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size -= nthistime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nread += nthistime;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nread;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * &quot;Freeze&quot; the contents of a tape so that it can be read multiple times<br/></li>
<li></span><span class="Comment"> * and/or read backwards.&nbsp; Once a tape is frozen, its contents will not<br/></li>
<li></span><span class="Comment"> * be released until the <a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> is destroyed.&nbsp; This is expected<br/></li>
<li></span><span class="Comment"> * to be used only for the final output pass of a <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This *must* be called just at the end of a write pass, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment"> * tape is rewound (after rewind is too late!).&nbsp; It performs a rewind<br/></li>
<li></span><span class="Comment"> * and switch to read mode &quot;for free&quot;.&nbsp; An immediately following rewind-<br/></li>
<li></span><span class="Comment"> * for-read call is OK but not necessary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * share output argument is set with details of storage used for tape after<br/></li>
<li></span><span class="Comment"> * freezing, which may be passed to <a href="#L556" title="utils/sort/logtape.c:556">LogicalTapeSetCreate</a> within leader<br/></li>
<li></span><span class="Comment"> * process later.&nbsp; This metadata is only of interest to worker callers<br/></li>
<li></span><span class="Comment"> * freezing their final output for leader (single materialized tape).<br/></li>
<li></span><span class="Comment"> * Serial sorts should set share to NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L981">&#x200c;</a></span><span class="linkable">LogicalTapeFreeze</span>(<a href="#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *lt, TapeShare *share)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *lts = lt-&gt;tapeSet;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(lt-&gt;writing);<br/></li>
<li>&nbsp; &nbsp; Assert(lt-&gt;offsetBlockNumber == <span class="Constant">0L</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Completion of a write phase.&nbsp; Flush last partial data block, and rewind<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for nondestructive read.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;dirty)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As long as we've filled the buffer at least once, its contents are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entirely defined from valgrind's point of view, even though<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contents beyond the current end point may be stale.&nbsp; But it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible - at least in the case of a parallel sort - to sort such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * small amount of data that we do not fill the buffer even once. Tell<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * valgrind that its contents are defined, so it doesn't bleat.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(lt-&gt;buffer + lt-&gt;nbytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;buffer_size - lt-&gt;nbytes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L111" title="utils/sort/logtape.c:111">TapeBlockSetNBytes</a>(lt-&gt;buffer, lt-&gt;nbytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L238" title="utils/sort/logtape.c:238">ltsWriteBlock</a>(lt-&gt;tapeSet, lt-&gt;curBlockNumber, lt-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; lt-&gt;writing = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; lt-&gt;frozen = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The seek and backspace <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> assume a single block read buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * That's OK with current usage.&nbsp; A larger buffer is helpful to make the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * read pattern of the backing file look more sequential to the OS, when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're reading from multiple tapes.&nbsp; But at the end of a sort, when a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tape is frozen, we only read from a single tape anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!lt-&gt;buffer || lt-&gt;buffer_size != BLCKSZ)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;buffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(lt-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;buffer = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;buffer_size = BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Read the first block, or reset if tape is empty */<br/></li>
<li></span>&nbsp; &nbsp; lt-&gt;curBlockNumber = lt-&gt;firstBlockNumber;<br/></li>
<li>&nbsp; &nbsp; lt-&gt;pos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; lt-&gt;nbytes = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;firstBlockNumber == -<span class="Constant">1L</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;nextBlockNumber = -<span class="Constant">1L</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L282" title="utils/sort/logtape.c:282">ltsReadBlock</a>(lt-&gt;tapeSet, lt-&gt;curBlockNumber, lt-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L107" title="utils/sort/logtape.c:107">TapeBlockIsLast</a>(lt-&gt;buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;nextBlockNumber = -<span class="Constant">1L</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;nextBlockNumber = <a href="#L104" title="utils/sort/logtape.c:104">TapeBlockGetTrailer</a>(lt-&gt;buffer)-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; lt-&gt;nbytes = <a href="#L108" title="utils/sort/logtape.c:108">TapeBlockGetNBytes</a>(lt-&gt;buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle extra steps when caller is to share its tapeset */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (share)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L394" title="storage/file/buffile.c:394">BufFileExportFileSet</a>(lts-&gt;pfile);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; share-&gt;firstblocknumber = lt-&gt;firstBlockNumber;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Backspace the tape a given number of bytes.&nbsp; (We also support a more<br/></li>
<li></span><span class="Comment"> * general seek interface, see below.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *Only* a frozen-for-read tape can be backed up; we don't support<br/></li>
<li></span><span class="Comment"> * random access during write, and an unfrozen read tape may have<br/></li>
<li></span><span class="Comment"> * already discarded the desired data!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the number of bytes backed up.&nbsp; It can be less than the<br/></li>
<li></span><span class="Comment"> * requested amount, if there isn't that much data <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the current<br/></li>
<li></span><span class="Comment"> * position.&nbsp; The tape is positioned to the beginning of the tape in<br/></li>
<li></span><span class="Comment"> * that case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">size_t<br/></li>
<li><a id="L1062">&#x200c;</a></span><span class="linkable">LogicalTapeBackspace</span>(<a href="#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *lt, <span class="Type">size_t</span> size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; seekpos = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(lt-&gt;frozen);<br/></li>
<li>&nbsp; &nbsp; Assert(lt-&gt;buffer_size == BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;buffer == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L522" title="utils/sort/logtape.c:522">ltsInitReadBuffer</a>(lt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Easy case for seek within current block.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (size &lt;= (<span class="Type">size_t</span>) lt-&gt;pos)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;pos -= (<span class="Type">int</span>) size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Not-so-easy case, have to walk back the chain of blocks.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * implementation would be pretty inefficient for long seeks, but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * really aren't doing that (a seek over one tuple is typical).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; seekpos = (<span class="Type">size_t</span>) lt-&gt;pos; <span class="Comment">/* part within this block */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (size &gt; seekpos)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; prev = <a href="#L104" title="utils/sort/logtape.c:104">TapeBlockGetTrailer</a>(lt-&gt;buffer)-&gt;prev;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prev == -<span class="Constant">1L</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Tried to back up beyond the beginning of tape. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;curBlockNumber != lt-&gt;firstBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected end of tape&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;pos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> seekpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L282" title="utils/sort/logtape.c:282">ltsReadBlock</a>(lt-&gt;tapeSet, prev, lt-&gt;buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L104" title="utils/sort/logtape.c:104">TapeBlockGetTrailer</a>(lt-&gt;buffer)-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> != lt-&gt;curBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;broken tape, <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> of block </span><span class="Special">%lld</span><span class="Constant"> is </span><span class="Special">%lld</span><span class="Constant">, expected </span><span class="Special">%lld</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span>) prev,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span>) (<a href="#L104" title="utils/sort/logtape.c:104">TapeBlockGetTrailer</a>(lt-&gt;buffer)-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span>) lt-&gt;curBlockNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;nbytes = <a href="#L103" title="utils/sort/logtape.c:103">TapeBlockPayloadSize</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;curBlockNumber = prev;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;nextBlockNumber = <a href="#L104" title="utils/sort/logtape.c:104">TapeBlockGetTrailer</a>(lt-&gt;buffer)-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seekpos += <a href="#L103" title="utils/sort/logtape.c:103">TapeBlockPayloadSize</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'seekpos' can <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> be greater than 'size', because it points to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * beginning the target block.&nbsp; The difference is the position within the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lt-&gt;pos = seekpos - size;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Seek to an arbitrary position in a logical tape.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *Only* a frozen-for-read tape can be seeked.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Must be called with a block/offset previously returned by<br/></li>
<li></span><span class="Comment"> * <a href="#L1162" title="utils/sort/logtape.c:1162">LogicalTapeTell</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1133">&#x200c;</a></span><span class="linkable">LogicalTapeSeek</span>(<a href="#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *lt, int64 blocknum, <span class="Type">int</span> offset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(lt-&gt;frozen);<br/></li>
<li>&nbsp; &nbsp; Assert(offset &gt;= <span class="Constant">0</span> &amp;&amp; offset &lt;= <a href="#L103" title="utils/sort/logtape.c:103">TapeBlockPayloadSize</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(lt-&gt;buffer_size == BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;buffer == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L522" title="utils/sort/logtape.c:522">ltsInitReadBuffer</a>(lt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (blocknum != lt-&gt;curBlockNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L282" title="utils/sort/logtape.c:282">ltsReadBlock</a>(lt-&gt;tapeSet, blocknum, lt-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;curBlockNumber = blocknum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;nbytes = <a href="#L103" title="utils/sort/logtape.c:103">TapeBlockPayloadSize</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt-&gt;nextBlockNumber = <a href="#L104" title="utils/sort/logtape.c:104">TapeBlockGetTrailer</a>(lt-&gt;buffer)-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (offset &gt; lt-&gt;nbytes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid tape seek position&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; lt-&gt;pos = offset;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Obtain current position in a form suitable for a later <a href="#L1133" title="utils/sort/logtape.c:1133">LogicalTapeSeek</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: it'd be OK to do this during write phase with intention of using<br/></li>
<li></span><span class="Comment"> * the position for a seek after freezing.&nbsp; Not clear if anyone needs that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1162">&#x200c;</a></span><span class="linkable">LogicalTapeTell</span>(<a href="#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *lt, int64 *blocknum, <span class="Type">int</span> *offset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;buffer == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L522" title="utils/sort/logtape.c:522">ltsInitReadBuffer</a>(lt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(lt-&gt;offsetBlockNumber == <span class="Constant">0L</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* With a larger buffer, 'pos' wouldn't be the same as offset within page */<br/></li>
<li></span>&nbsp; &nbsp; Assert(lt-&gt;buffer_size == BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *blocknum = lt-&gt;curBlockNumber;<br/></li>
<li>&nbsp; &nbsp; *offset = lt-&gt;pos;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Obtain total disk space currently used by a <a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a>, in blocks. Does<br/></li>
<li></span><span class="Comment"> * not account for open write buffer, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>int64<br/></li>
<li><a id="L1181">&#x200c;</a><span class="linkable">LogicalTapeSetBlocks</span>(<a href="#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *lts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> lts-&gt;nBlocksWritten - lts-&gt;nHoleBlocks;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
