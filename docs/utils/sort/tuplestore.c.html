<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/sort/tuplestore.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/sort/tuplestore.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L98">TSReadPointer</a></li>
<li><a href="#L77">TupStoreStatus</a></li>
<li><a href="#L103">Tuplestorestate</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1490">copytup_heap</a></li>
<li><a href="#L1206">dumptuples</a></li>
<li><a href="#L1466">getlen</a></li>
<li><a href="#L578">grow_memtuples</a></li>
<li><a href="#L1521">readtup_heap</a></li>
<li><a href="#L1110">tuplestore_advance</a></li>
<li><a href="#L383">tuplestore_alloc_read_pointer</a></li>
<li><a href="#L557">tuplestore_ateof</a></li>
<li><a href="#L253">tuplestore_begin_common</a></li>
<li><a href="#L318">tuplestore_begin_heap</a></li>
<li><a href="#L418">tuplestore_clear</a></li>
<li><a href="#L1268">tuplestore_copy_read_pointer</a></li>
<li><a href="#L453">tuplestore_end</a></li>
<li><a href="#L903">tuplestore_gettuple</a></li>
<li><a href="#L1078">tuplestore_gettupleslot</a></li>
<li><a href="#L1455">tuplestore_in_memory</a></li>
<li><a href="#L730">tuplestore_puttuple</a></li>
<li><a href="#L765">tuplestore_puttuple_common</a></li>
<li><a href="#L708">tuplestore_puttupleslot</a></li>
<li><a href="#L750">tuplestore_putvalues</a></li>
<li><a href="#L1233">tuplestore_rescan</a></li>
<li><a href="#L473">tuplestore_select_read_pointer</a></li>
<li><a href="#L359">tuplestore_set_eflags</a></li>
<li><a href="#L1135">tuplestore_skiptuples</a></li>
<li><a href="#L1360">tuplestore_trim</a></li>
<li><a href="#L546">tuplestore_tuple_count</a></li>
<li><a href="#L1500">writetup_heap</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L183">COPYTUP</a></li>
<li><a href="#L188">FREEMEM</a></li>
<li><a href="#L186">LACKMEM</a></li>
<li><a href="#L185">READTUP</a></li>
<li><a href="#L187">USEMEM</a></li>
<li><a href="#L184">WRITETUP</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tuplestore.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Generalized routines for temporary tuple storage.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This module handles temporary storage of tuples for purposes such<br/></li>
<li></span><span class="Comment"> * as Materialize nodes, hashjoin batch files, etc.&nbsp; It is essentially<br/></li>
<li></span><span class="Comment"> * a dumbed-down version of tuplesort.c; it does no sorting of tuples<br/></li>
<li></span><span class="Comment"> * but can only store and regurgitate a sequence of tuples.&nbsp; However,<br/></li>
<li></span><span class="Comment"> * because no sort is required, it is allowed to start reading the sequence<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it has all been written.&nbsp; This is particularly useful for cursors,<br/></li>
<li></span><span class="Comment"> * because it allows random access within the already-scanned portion of<br/></li>
<li></span><span class="Comment"> * a query without having to process the underlying scan to completion.<br/></li>
<li></span><span class="Comment"> * Also, it is possible to support multiple independent read pointers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A temporary file is used to handle the data if it exceeds the<br/></li>
<li></span><span class="Comment"> * space limit specified by the caller.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The (approximate) amount of memory allowed to the tuplestore is specified<br/></li>
<li></span><span class="Comment"> * in kilobytes by the caller.&nbsp; We absorb tuples and simply store them in an<br/></li>
<li></span><span class="Comment"> * in-memory array as long as we haven't exceeded maxKBytes.&nbsp; If we do exceed<br/></li>
<li></span><span class="Comment"> * maxKBytes, we <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> all the tuples into a temp file and then read from that<br/></li>
<li></span><span class="Comment"> * when needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Upon creation, a tuplestore supports a single read pointer, numbered 0.<br/></li>
<li></span><span class="Comment"> * Additional read pointers can be created using <a href="#L383" title="utils/sort/tuplestore.c:383">tuplestore_alloc_read_pointer</a>.<br/></li>
<li></span><span class="Comment"> * Mark/restore behavior is supported by copying read pointers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When the caller requests backward-scan capability, we write the temp file<br/></li>
<li></span><span class="Comment"> * in a format that allows either forward or backward scan.&nbsp; Otherwise, only<br/></li>
<li></span><span class="Comment"> * forward scan is allowed.&nbsp; A request for backward scan must be made <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * putting <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples into the tuplestore.&nbsp; Rewind is normally allowed but<br/></li>
<li></span><span class="Comment"> * can be turned off via <a href="#L359" title="utils/sort/tuplestore.c:359">tuplestore_set_eflags</a>; turning off rewind for all<br/></li>
<li></span><span class="Comment"> * read pointers enables truncation of the tuplestore at the oldest read point<br/></li>
<li></span><span class="Comment"> * for minimal memory usage.&nbsp; (The caller must explicitly call <a href="#L1360" title="utils/sort/tuplestore.c:1360">tuplestore_trim</a><br/></li>
<li></span><span class="Comment"> * at appropriate times for truncation to actually happen.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: in TSS_WRITEFILE state, the temp file's seek position is the<br/></li>
<li></span><span class="Comment"> * current write position, and the write-position variables in the tuplestore<br/></li>
<li></span><span class="Comment"> * aren't kept up to date.&nbsp; Similarly, in TSS_READFILE state the temp file's<br/></li>
<li></span><span class="Comment"> * seek position is the active read pointer's position, and that read pointer<br/></li>
<li></span><span class="Comment"> * isn't kept up to date.&nbsp; We update the appropriate variables using ftell()<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> switching to the other state or activating a different read pointer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/sort/tuplestore.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/tablespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/buffile.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/resowner.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Possible states of a Tuplestore object.&nbsp; These denote the states that<br/></li>
<li></span><span class="Comment"> * persist between calls of Tuplestore routines.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; TSS_INMEM,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Tuples still fit in memory */<br/></li>
<li></span>&nbsp; &nbsp; TSS_WRITEFILE,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Writing to temp file */<br/></li>
<li></span>&nbsp; &nbsp; TSS_READFILE,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reading from temp file */<br/></li>
<li><a id="L77">&#x200c;</a></span>} <span class="linkable">TupStoreStatus</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * State for a single read pointer.&nbsp; If we are in state INMEM then all the<br/></li>
<li></span><span class="Comment"> * read pointers' &quot;current&quot; fields denote the read positions.&nbsp; In state<br/></li>
<li></span><span class="Comment"> * WRITEFILE, the file/offset fields denote the read positions.&nbsp; In state<br/></li>
<li></span><span class="Comment"> * READFILE, inactive read pointers have valid file/offset, but the active<br/></li>
<li></span><span class="Comment"> * read pointer implicitly has position <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the temp file's seek position.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Special case: if eof_reached is true, then the pointer's read position is<br/></li>
<li></span><span class="Comment"> * implicitly <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the write position, and current/file/offset aren't<br/></li>
<li></span><span class="Comment"> * maintained.&nbsp; This way we need not update all the read pointers each time<br/></li>
<li></span><span class="Comment"> * we write.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eflags;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* capability flags */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; eof_reached;&nbsp; &nbsp; <span class="Comment">/* read has reached EOF */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> array index to read */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* temp file# */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; offset;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* byte offset in file */<br/></li>
<li><a id="L98">&#x200c;</a></span>} <span class="linkable">TSReadPointer</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Private state of a Tuplestore operation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L103">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">Tuplestorestate</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L77" title="utils/sort/tuplestore.c:77">TupStoreStatus</a> status;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* enumerated value as shown above */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eflags;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* capability flags (OR of pointers' flags) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; backward;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* store extra length words in file? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; interXact;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep open through transactions? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; truncated;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L1360" title="utils/sort/tuplestore.c:1360">tuplestore_trim</a> has removed tuples? */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; availMem;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remaining memory available, in bytes */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; allowedMem;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* total memory allowed, in bytes */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; tuples;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of tuples added */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a>&nbsp; &nbsp; *myfile;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* underlying file, or NULL if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext context;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* memory context for holding tuples */<br/></li>
<li></span>&nbsp; &nbsp; ResourceOwner resowner;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* resowner for holding temp files */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These function pointers decouple the routines that must know what kind<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of tuple we are handling from the routines that don't need to know it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * They are set up by the tuplestore_begin_xxx routines.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Although tuplestore.c currently only supports heap tuples, I've copied<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this part of tuplesort.c so that extension to other kinds of objects<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will be easy if it's ever needed.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Function to copy a supplied input tuple into <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d space. (NB: we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assume that a single <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>() is enough to release the tuple later, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the representation must be &quot;flat&quot; in one <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> chunk.) state-&gt;availMem<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must be decreased by the amount of space used.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *(*copytup) (<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state, <span class="Type">void</span> *tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Function to write a stored tuple onto tape.&nbsp; The representation of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple on tape need not be the same as it is in memory; requirements on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the tape representation are given below.&nbsp; After writing the tuple,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>() it, and increase state-&gt;availMem by the amount of memory space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * thereby released.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp; &nbsp; (*writetup) (<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state, <span class="Type">void</span> *tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Function to read a stored tuple from tape back into memory. 'len' is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the already-read length of the stored tuple.&nbsp; Create and return a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d copy, and decrease state-&gt;availMem by the amount of memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * space consumed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *(*readtup) (<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state, <span class="Type">unsigned</span> <span class="Type">int</span> len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This array holds pointers to tuples in memory if we are in state INMEM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In states WRITEFILE and READFILE it's not used.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When memtupdeleted &gt; 0, the first memtupdeleted pointers are already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * released due to a <a href="#L1360" title="utils/sort/tuplestore.c:1360">tuplestore_trim</a>() operation, but we haven't expended<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the effort to slide the remaining pointers down.&nbsp; These unused pointers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are set to NULL to catch <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> invalid accesses.&nbsp; Note that memtupcount<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * includes the deleted pointers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp; **memtuples;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* array of pointers to <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d tuples */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memtupdeleted;&nbsp; &nbsp; <span class="Comment">/* the first N slots are currently unused */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memtupcount;&nbsp; &nbsp; <span class="Comment">/* number of tuples currently present */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memtupsize;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocated length of memtuples array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; growmemtuples;&nbsp; &nbsp; <span class="Comment">/* memtuples' growth still underway? */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These variables are used to keep track of the current positions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In state WRITEFILE, the current file seek position is the write point;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in state READFILE, the write position is remembered in writepos_xxx.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (The write position is the same as EOF, but since <a href="../../storage/file/buffile.c.html#L740" title="storage/file/buffile.c:740">BufFileSeek</a> doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * currently implement SEEK_END, we have to remember it explicitly.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L98" title="utils/sort/tuplestore.c:98">TSReadPointer</a> *readptrs;&nbsp; &nbsp; <span class="Comment">/* array of read pointers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; activeptr;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* index of the active read pointer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptrcount;&nbsp; &nbsp; <span class="Comment">/* number of pointers currently valid */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptrsize;&nbsp; &nbsp; <span class="Comment">/* allocated length of readptrs array */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; writepos_file;&nbsp; &nbsp; <span class="Comment">/* file# (valid if READFILE state) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; writepos_offset;&nbsp; &nbsp; <span class="Comment">/* offset (valid if READFILE state) */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><a id="L183">&#x200c;</a><span class="PreProc">#define <span class="linkable">COPYTUP</span>(state,tup)&nbsp; &nbsp; ((*(state)-&gt;copytup) (state, tup))<br/></li>
<li><a id="L184">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITETUP</span>(state,tup) ((*(state)-&gt;writetup) (state, tup))<br/></li>
<li><a id="L185">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READTUP</span>(state,len)&nbsp; &nbsp; ((*(state)-&gt;readtup) (state, len))<br/></li>
<li><a id="L186">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LACKMEM</span>(state)&nbsp; &nbsp; &nbsp; &nbsp; ((state)-&gt;availMem &lt; </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L187">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">USEMEM</span>(state,amt)&nbsp; &nbsp; ((state)-&gt;availMem -= (amt))<br/></li>
<li><a id="L188">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FREEMEM</span>(state,amt)&nbsp; &nbsp; ((state)-&gt;availMem += (amt))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*--------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES about on-tape representation of tuples:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We require the first &quot;unsigned int&quot; of a stored tuple to be the total size<br/></li>
<li></span><span class="Comment"> * on-tape of the tuple, including itself (so it is never zero).<br/></li>
<li></span><span class="Comment"> * The remainder of the stored tuple<br/></li>
<li></span><span class="Comment"> * may or may not match the in-memory representation of the tuple ---<br/></li>
<li></span><span class="Comment"> * <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> conversion needed is the job of the writetup and readtup routines.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If state-&gt;backward is true, then the stored representation of<br/></li>
<li></span><span class="Comment"> * the tuple must be followed by another &quot;unsigned int&quot; that is a copy of the<br/></li>
<li></span><span class="Comment"> * length --- so the total tape space used is actually <a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(unsigned int)<br/></li>
<li></span><span class="Comment"> * more than the stored length value.&nbsp; This allows read-backwards.&nbsp; When<br/></li>
<li></span><span class="Comment"> * state-&gt;backward is not set, the write/read routines may omit the extra<br/></li>
<li></span><span class="Comment"> * length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * writetup is expected to write both length words as well as the tuple<br/></li>
<li></span><span class="Comment"> * data.&nbsp; When readtup is called, the tape is positioned just after the<br/></li>
<li></span><span class="Comment"> * front length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>; readtup must read the tuple data and advance past<br/></li>
<li></span><span class="Comment"> * the back length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> (if present).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The write/read routines can make use of the tuple description data<br/></li>
<li></span><span class="Comment"> * stored in the <a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> record, if needed. They are also expected<br/></li>
<li></span><span class="Comment"> * to adjust state-&gt;availMem by the amount of memory space (not tape space!)<br/></li>
<li></span><span class="Comment"> * released or consumed.&nbsp; There is no error return from either writetup<br/></li>
<li></span><span class="Comment"> * or readtup; they should ereport() on failure.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES about memory consumption calculations:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We count space allocated for tuples against the maxKBytes limit,<br/></li>
<li></span><span class="Comment"> * plus the space used by the variable-size array memtuples.<br/></li>
<li></span><span class="Comment"> * Fixed-size space (primarily the <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a> I/O buffer) is not counted.<br/></li>
<li></span><span class="Comment"> * We don't worry about the size of the read pointer array, either.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we count actual space used (as shown by <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>)<br/></li>
<li></span><span class="Comment"> * rather than the originally-requested size.&nbsp; This is important since<br/></li>
<li></span><span class="Comment"> * <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> can add substantial overhead.&nbsp; It's not a complete answer since<br/></li>
<li></span><span class="Comment"> * we won't count <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> wasted space in <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> allocation blocks, but it's<br/></li>
<li></span><span class="Comment"> * a lot better than what we were doing <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> 7.3.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *--------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *<a href="#L253" title="utils/sort/tuplestore.c:253">tuplestore_begin_common</a>(<span class="Type">int</span> eflags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> interXact,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> maxKBytes);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L765" title="utils/sort/tuplestore.c:765">tuplestore_puttuple_common</a>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state, <span class="Type">void</span> *tuple);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="tuplesort.c.html#L2339" title="utils/sort/tuplesort.c:2339">dumptuples</a>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">unsigned</span> <span class="Type">int</span> <a href="tuplesort.c.html#L2894" title="utils/sort/tuplesort.c:2894">getlen</a>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> eofOK);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> *<a href="#L1490" title="utils/sort/tuplestore.c:1490">copytup_heap</a>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state, <span class="Type">void</span> *tup);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="tuplesortvariants.c.html#L1158" title="utils/sort/tuplesortvariants.c:1158">writetup_heap</a>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state, <span class="Type">void</span> *tup);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> *<a href="tuplesortvariants.c.html#L1177" title="utils/sort/tuplesortvariants.c:1177">readtup_heap</a>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state, <span class="Type">unsigned</span> <span class="Type">int</span> len);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; tuplestore_begin_xxx<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Initialize for a tuple store operation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *<br/></li>
<li><a id="L253">&#x200c;</a><span class="linkable">tuplestore_begin_common</span>(<span class="Type">int</span> eflags, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> interXact, <span class="Type">int</span> maxKBytes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = (<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;status = TSS_INMEM;<br/></li>
<li>&nbsp; &nbsp; state-&gt;eflags = eflags;<br/></li>
<li>&nbsp; &nbsp; state-&gt;interXact = interXact;<br/></li>
<li>&nbsp; &nbsp; state-&gt;truncated = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;allowedMem = maxKBytes * <span class="Constant">1024L</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;availMem = state-&gt;allowedMem;<br/></li>
<li>&nbsp; &nbsp; state-&gt;myfile = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;context = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;resowner = <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;memtupdeleted = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;memtupcount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;tuples = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * see comments in <a href="tuplesort.c.html#L1072" title="utils/sort/tuplesort.c:1072">grow_memtuples</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;memtupsize = Max(<span class="Constant">16384</span> / <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">void</span> *),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_SEPARATE_THRESHOLD / <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">void</span> *) + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;growmemtuples = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;memtuples = (<span class="Type">void</span> **) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(state-&gt;memtupsize * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">void</span> *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="tuplesort.c.html#L404" title="utils/sort/tuplesort.c:404">USEMEM</a>(state, <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>(state-&gt;memtuples));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;activeptr = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;readptrcount = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;readptrsize = <span class="Constant">8</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* arbitrary */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;readptrs = (<a href="#L98" title="utils/sort/tuplestore.c:98">TSReadPointer</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(state-&gt;readptrsize * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L98" title="utils/sort/tuplestore.c:98">TSReadPointer</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;readptrs[<span class="Constant">0</span>].eflags = eflags;<br/></li>
<li>&nbsp; &nbsp; state-&gt;readptrs[<span class="Constant">0</span>].eof_reached = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;readptrs[<span class="Constant">0</span>].current = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L318" title="utils/sort/tuplestore.c:318">tuplestore_begin_heap</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Create a new tuplestore; other types of tuple stores (other than<br/></li>
<li></span><span class="Comment"> * &quot;heap&quot; tuple stores, for heap tuples) are possible, but not presently<br/></li>
<li></span><span class="Comment"> * implemented.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * randomAccess: if true, both forward and backward accesses to the<br/></li>
<li></span><span class="Comment"> * tuple store are allowed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * interXact: if true, the files used for on-disk storage persist beyond the<br/></li>
<li></span><span class="Comment"> * end of the current transaction.&nbsp; <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: It's the caller's responsibility to<br/></li>
<li></span><span class="Comment"> * create such a tuplestore in a memory context and resource owner that will<br/></li>
<li></span><span class="Comment"> * also survive transaction boundaries, and to ensure the tuplestore is closed<br/></li>
<li></span><span class="Comment"> * when it's no longer wanted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * maxKBytes: how much data to store in memory (<a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data beyond this<br/></li>
<li></span><span class="Comment"> * amount is paged to disk).&nbsp; When in doubt, use <a href="../init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *<br/></li>
<li><a id="L318">&#x200c;</a><span class="linkable">tuplestore_begin_heap</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> randomAccess, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> interXact, <span class="Type">int</span> maxKBytes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eflags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This interpretation of the meaning of randomAccess is compatible with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the pre-8.3 behavior of tuplestores.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; eflags = randomAccess ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (EXEC_FLAG_BACKWARD | EXEC_FLAG_REWIND) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (EXEC_FLAG_REWIND);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = <a href="#L253" title="utils/sort/tuplestore.c:253">tuplestore_begin_common</a>(eflags, interXact, maxKBytes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;copytup = <a href="#L1490" title="utils/sort/tuplestore.c:1490">copytup_heap</a>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;writetup = <a href="tuplesortvariants.c.html#L1158" title="utils/sort/tuplesortvariants.c:1158">writetup_heap</a>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;readtup = <a href="tuplesortvariants.c.html#L1177" title="utils/sort/tuplesortvariants.c:1177">readtup_heap</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L359" title="utils/sort/tuplestore.c:359">tuplestore_set_eflags</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Set the capability flags for read pointer 0 at a finer grain than is<br/></li>
<li></span><span class="Comment"> * allowed by tuplestore_begin_xxx.&nbsp; This must be called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> inserting<br/></li>
<li></span><span class="Comment"> * <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data into the tuplestore.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * eflags is a bitmask following the meanings used for executor node<br/></li>
<li></span><span class="Comment"> * startup flags (see executor.h).&nbsp; tuplestore pays attention to these bits:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; EXEC_FLAG_REWIND&nbsp; &nbsp; &nbsp; &nbsp; need rewind to start<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; EXEC_FLAG_BACKWARD&nbsp; &nbsp; &nbsp; &nbsp; need backward fetch<br/></li>
<li></span><span class="Comment"> * If <a href="#L359" title="utils/sort/tuplestore.c:359">tuplestore_set_eflags</a> is not called, REWIND is allowed, and BACKWARD<br/></li>
<li></span><span class="Comment"> * is set per &quot;randomAccess&quot; in the tuplestore_begin_xxx call.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: setting BACKWARD without REWIND means the pointer can read backwards,<br/></li>
<li></span><span class="Comment"> * but not further than the truncation point (the furthest-back read pointer<br/></li>
<li></span><span class="Comment"> * position at the time of the last <a href="#L1360" title="utils/sort/tuplestore.c:1360">tuplestore_trim</a> call).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L359">&#x200c;</a></span><span class="linkable">tuplestore_set_eflags</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state, <span class="Type">int</span> eflags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;status != TSS_INMEM || state-&gt;memtupcount != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;too late to call <a href="#L359" title="utils/sort/tuplestore.c:359">tuplestore_set_eflags</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;readptrs[<span class="Constant">0</span>].eflags = eflags;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; state-&gt;readptrcount; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eflags |= state-&gt;readptrs[i].eflags;<br/></li>
<li>&nbsp; &nbsp; state-&gt;eflags = eflags;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L383" title="utils/sort/tuplestore.c:383">tuplestore_alloc_read_pointer</a> - allocate another read pointer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the pointer's index.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The new pointer initially copies the position of read pointer 0.<br/></li>
<li></span><span class="Comment"> * It can have its own eflags, but if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data has been inserted into<br/></li>
<li></span><span class="Comment"> * the tuplestore, these eflags must not represent an increase in<br/></li>
<li></span><span class="Comment"> * requirements.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L383">&#x200c;</a></span><span class="linkable">tuplestore_alloc_read_pointer</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state, <span class="Type">int</span> eflags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for possible increase of requirements */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;status != TSS_INMEM || state-&gt;memtupcount != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((state-&gt;eflags | eflags) != state-&gt;eflags)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;too late to require new tuplestore eflags&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make room for another read pointer if needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;readptrcount &gt;= state-&gt;readptrsize)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcnt = state-&gt;readptrsize * <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;readptrs = (<a href="#L98" title="utils/sort/tuplestore.c:98">TSReadPointer</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(state-&gt;readptrs, newcnt * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L98" title="utils/sort/tuplestore.c:98">TSReadPointer</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;readptrsize = newcnt;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And set it up */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;readptrs[state-&gt;readptrcount] = state-&gt;readptrs[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; state-&gt;readptrs[state-&gt;readptrcount].eflags = eflags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;eflags |= eflags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state-&gt;readptrcount++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L418" title="utils/sort/tuplestore.c:418">tuplestore_clear</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> all the contents of a tuplestore, and reset its read pointers<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; to the start.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L418">&#x200c;</a></span><span class="linkable">tuplestore_clear</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <a href="#L98" title="utils/sort/tuplestore.c:98">TSReadPointer</a> *readptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;myfile)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L412" title="storage/file/buffile.c:412">BufFileClose</a>(state-&gt;myfile);<br/></li>
<li>&nbsp; &nbsp; state-&gt;myfile = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;memtuples)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = state-&gt;memtupdeleted; i &lt; state-&gt;memtupcount; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tuplesort.c.html#L405" title="utils/sort/tuplesort.c:405">FREEMEM</a>(state, <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>(state-&gt;memtuples[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state-&gt;memtuples[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; state-&gt;status = TSS_INMEM;<br/></li>
<li>&nbsp; &nbsp; state-&gt;truncated = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;memtupdeleted = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;memtupcount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;tuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; readptr = state-&gt;readptrs;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; state-&gt;readptrcount; readptr++, i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;eof_reached = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;current = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L453" title="utils/sort/tuplestore.c:453">tuplestore_end</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Release resources and clean up.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L453">&#x200c;</a></span><span class="linkable">tuplestore_end</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;myfile)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L412" title="storage/file/buffile.c:412">BufFileClose</a>(state-&gt;myfile);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;memtuples)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = state-&gt;memtupdeleted; i &lt; state-&gt;memtupcount; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state-&gt;memtuples[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state-&gt;memtuples);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state-&gt;readptrs);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L473" title="utils/sort/tuplestore.c:473">tuplestore_select_read_pointer</a> - make the specified read pointer active<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L473">&#x200c;</a></span><span class="linkable">tuplestore_select_read_pointer</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state, <span class="Type">int</span> ptr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L98" title="utils/sort/tuplestore.c:98">TSReadPointer</a> *readptr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L98" title="utils/sort/tuplestore.c:98">TSReadPointer</a> *oldptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(ptr &gt;= <span class="Constant">0</span> &amp;&amp; ptr &lt; state-&gt;readptrcount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No work if already active */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ptr == state-&gt;activeptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; readptr = &amp;state-&gt;readptrs[ptr];<br/></li>
<li>&nbsp; &nbsp; oldptr = &amp;state-&gt;readptrs[state-&gt;activeptr];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (state-&gt;status)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_INMEM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_WRITEFILE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no work */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_READFILE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First, save the current read position in the pointer about to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * become inactive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!oldptr-&gt;eof_reached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L833" title="storage/file/buffile.c:833">BufFileTell</a>(state-&gt;myfile,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;oldptr-&gt;file,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;oldptr-&gt;offset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to make the temp file's seek position <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * logical position of the new read pointer.&nbsp; In eof_reached<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * state, that's the EOF, which we have available from the saved<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * write position.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readptr-&gt;eof_reached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/buffile.c.html#L740" title="storage/file/buffile.c:740">BufFileSeek</a>(state-&gt;myfile,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;writepos_file,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;writepos_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">SEEK_SET</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not seek in tuplestore temporary file&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/buffile.c.html#L740" title="storage/file/buffile.c:740">BufFileSeek</a>(state-&gt;myfile,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;file,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">SEEK_SET</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not seek in tuplestore temporary file&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid tuplestore state&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;activeptr = ptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L546" title="utils/sort/tuplestore.c:546">tuplestore_tuple_count</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the number of tuples added since creation or the last<br/></li>
<li></span><span class="Comment"> * <a href="#L418" title="utils/sort/tuplestore.c:418">tuplestore_clear</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>int64<br/></li>
<li><a id="L546">&#x200c;</a><span class="linkable">tuplestore_tuple_count</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state-&gt;tuples;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L557" title="utils/sort/tuplestore.c:557">tuplestore_ateof</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the active read pointer's eof_reached state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L557">&#x200c;</a></span><span class="linkable">tuplestore_ateof</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state-&gt;readptrs[state-&gt;activeptr].eof_reached;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Grow the memtuples[] array, if possible within our memory constraint.&nbsp; We<br/></li>
<li></span><span class="Comment"> * must not exceed INT_MAX tuples in memory or the caller-provided memory<br/></li>
<li></span><span class="Comment"> * limit.&nbsp; Return true if we were able to enlarge the array, false if not.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Normally, at each increment we double the size of the array.&nbsp; When doing<br/></li>
<li></span><span class="Comment"> * that would exceed a limit, we attempt one last, smaller increase (and then<br/></li>
<li></span><span class="Comment"> * clear the growmemtuples flag so we don't try <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more).&nbsp; That allows us to<br/></li>
<li></span><span class="Comment"> * use memory as fully as permitted; sticking to the pure doubling rule could<br/></li>
<li></span><span class="Comment"> * result in almost half going unused.&nbsp; Because availMem moves around with<br/></li>
<li></span><span class="Comment"> * tuple addition/removal, we need some rule to prevent making repeated small<br/></li>
<li></span><span class="Comment"> * increases in memtupsize, which would just be useless thrashing.&nbsp; The<br/></li>
<li></span><span class="Comment"> * growmemtuples flag accomplishes that and also prevents useless<br/></li>
<li></span><span class="Comment"> * recalculations in this function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L578">&#x200c;</a></span><span class="linkable">grow_memtuples</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newmemtupsize;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memtupsize = state-&gt;memtupsize;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; memNowUsed = state-&gt;allowedMem - state-&gt;availMem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Forget it if we've already maxed out memtuples, per comment above */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!state-&gt;growmemtuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Select new value of memtupsize */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (memNowUsed &lt;= state-&gt;availMem)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We've used no more than half of allowedMem; double our usage,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clamping at INT_MAX tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (memtupsize &lt; <span class="Constant">INT_MAX</span> / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newmemtupsize = memtupsize * <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newmemtupsize = <span class="Constant">INT_MAX</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;growmemtuples = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This will be the last increment of memtupsize.&nbsp; Abandon doubling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * strategy and instead increase as much as we safely can.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To stay within allowedMem, we can't increase memtupsize by more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than availMem / <a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(void *) elements. In practice, we want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * increase it by considerably less, because we need to leave some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * space for the tuples to which the new array slots will refer.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assume the new tuples will be about the same size as the tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we've already seen, and thus we can extrapolate from the space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consumption so far to estimate an appropriate new size for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memtuples array.&nbsp; The optimal value might be higher or <a href="../adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this estimate, but it's hard to know that in advance.&nbsp; We again<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clamp at INT_MAX tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This calculation is safe against enlarging the array so much that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="tuplesort.c.html#L403" title="utils/sort/tuplesort.c:403">LACKMEM</a> becomes true, because the memory currently used includes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the present array; thus, there would be enough allowedMem for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new array elements even if no other memory were currently used.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We do the arithmetic in float8, because otherwise the product of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memtupsize and allowedMem could overflow.&nbsp; Any inaccuracy in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result should be insignificant; but even if we computed a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * completely insane result, the checks below will prevent anything<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * really bad from happening.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; grow_ratio;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; grow_ratio = (<span class="Type">double</span>) state-&gt;allowedMem / (<span class="Type">double</span>) memNowUsed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (memtupsize * grow_ratio &lt; <span class="Constant">INT_MAX</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newmemtupsize = (<span class="Type">int</span>) (memtupsize * grow_ratio);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newmemtupsize = <span class="Constant">INT_MAX</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We won't make <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> further enlargement attempts */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;growmemtuples = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must enlarge array by at least one <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, else report failure */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newmemtupsize &lt;= memtupsize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> noalloc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On a 32-<a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> machine, allowedMem could exceed MaxAllocHugeSize.&nbsp; Clamp<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to ensure our request won't be rejected.&nbsp; Note that we can easily<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exhaust address space <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> facing this outcome.&nbsp; (This is presently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * impossible due to guc.c's MAX_KILOBYTES limitation on <a href="../init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't rely on that at this distance.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((Size) newmemtupsize &gt;= MaxAllocHugeSize / <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">void</span> *))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newmemtupsize = (<span class="Type">int</span>) (MaxAllocHugeSize / <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">void</span> *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;growmemtuples = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* can't grow <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to be sure that we do not cause <a href="tuplesort.c.html#L403" title="utils/sort/tuplesort.c:403">LACKMEM</a> to become true, else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the space management algorithm will go nuts.&nbsp; The code above should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * never generate a dangerous request, but to be safe, check explicitly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that the array growth fits within availMem.&nbsp; (We could still cause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="tuplesort.c.html#L403" title="utils/sort/tuplesort.c:403">LACKMEM</a> if the memory chunk overhead associated with the memtuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * array were to increase.&nbsp; That shouldn't happen because we chose the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initial array size large enough to ensure that <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> will be treating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * both old and new arrays as separate chunks.&nbsp; But we'll check <a href="tuplesort.c.html#L403" title="utils/sort/tuplesort.c:403">LACKMEM</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * explicitly below just in case.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;availMem &lt; (int64) ((newmemtupsize - memtupsize) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">void</span> *)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> noalloc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, do it */<br/></li>
<li></span>&nbsp; &nbsp; <a href="tuplesort.c.html#L405" title="utils/sort/tuplesort.c:405">FREEMEM</a>(state, <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>(state-&gt;memtuples));<br/></li>
<li>&nbsp; &nbsp; state-&gt;memtupsize = newmemtupsize;<br/></li>
<li>&nbsp; &nbsp; state-&gt;memtuples = (<span class="Type">void</span> **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1671" title="utils/mmgr/mcxt.c:1671">repalloc_huge</a>(state-&gt;memtuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;memtupsize * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">void</span> *));<br/></li>
<li>&nbsp; &nbsp; <a href="tuplesort.c.html#L404" title="utils/sort/tuplesort.c:404">USEMEM</a>(state, <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>(state-&gt;memtuples));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="tuplesort.c.html#L403" title="utils/sort/tuplesort.c:403">LACKMEM</a>(state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected out-of-memory situation in tuplestore&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li><span class="Statement">noalloc</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* If for <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> reason we didn't realloc, shut off future attempts */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;growmemtuples = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Accept one tuple and append it to the tuplestore.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the input tuple is always copied; the caller need not save it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the active read pointer is currently &quot;at EOF&quot;, it remains so (the read<br/></li>
<li></span><span class="Comment"> * pointer implicitly advances along with the write pointer); otherwise the<br/></li>
<li></span><span class="Comment"> * read pointer is unchanged.&nbsp; Non-active read pointers do not move, which<br/></li>
<li></span><span class="Comment"> * means they are certain to not be &quot;at EOF&quot; immediately after puttuple.<br/></li>
<li></span><span class="Comment"> * This curious-seeming behavior is for the convenience of nodeMaterial.c and<br/></li>
<li></span><span class="Comment"> * nodeCtescan.c, which would otherwise need to do extra pointer repositioning<br/></li>
<li></span><span class="Comment"> * steps.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L708" title="utils/sort/tuplestore.c:708">tuplestore_puttupleslot</a>() is a convenience routine to collect data from<br/></li>
<li></span><span class="Comment"> * a TupleTableSlot without an extra copy operation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L708">&#x200c;</a></span><span class="linkable">tuplestore_puttupleslot</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MinimalTuple tuple;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt = MemoryContextSwitchTo(state-&gt;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Form a MinimalTuple in working memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tuple = ExecCopySlotMinimalTuple(slot);<br/></li>
<li>&nbsp; &nbsp; <a href="tuplesort.c.html#L404" title="utils/sort/tuplesort.c:404">USEMEM</a>(state, <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>(tuple));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L765" title="utils/sort/tuplestore.c:765">tuplestore_puttuple_common</a>(state, (<span class="Type">void</span> *) tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * &quot;Standard&quot; case to copy from a HeapTuple.&nbsp; This is actually <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> somewhat<br/></li>
<li></span><span class="Comment"> * deprecated, but not worth getting rid of in view of the number of callers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L730">&#x200c;</a></span><span class="linkable">tuplestore_puttuple</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state, HeapTuple tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt = MemoryContextSwitchTo(state-&gt;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy the tuple.&nbsp; (Must do this even in WRITEFILE case.&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L183" title="utils/sort/tuplestore.c:183">COPYTUP</a> includes <a href="tuplesort.c.html#L404" title="utils/sort/tuplesort.c:404">USEMEM</a>, so we needn't do that here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tuple = <a href="#L183" title="utils/sort/tuplestore.c:183">COPYTUP</a>(state, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L765" title="utils/sort/tuplestore.c:765">tuplestore_puttuple_common</a>(state, (<span class="Type">void</span> *) tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Similar to <a href="#L730" title="utils/sort/tuplestore.c:730">tuplestore_puttuple</a>(), but work from <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> + nulls arrays.<br/></li>
<li></span><span class="Comment"> * This avoids an extra tuple-construction operation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L750">&#x200c;</a></span><span class="linkable">tuplestore_putvalues</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state, TupleDesc tdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, <span class="Type">const</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MinimalTuple tuple;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt = MemoryContextSwitchTo(state-&gt;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../../access/common/heaptuple.c.html#L1452" title="access/common/heaptuple.c:1452">heap_form_minimal_tuple</a>(tdesc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull);<br/></li>
<li>&nbsp; &nbsp; <a href="tuplesort.c.html#L404" title="utils/sort/tuplesort.c:404">USEMEM</a>(state, <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>(tuple));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L765" title="utils/sort/tuplestore.c:765">tuplestore_puttuple_common</a>(state, (<span class="Type">void</span> *) tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L765">&#x200c;</a></span><span class="linkable">tuplestore_puttuple_common</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state, <span class="Type">void</span> *tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L98" title="utils/sort/tuplestore.c:98">TSReadPointer</a> *readptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; ResourceOwner oldowner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;tuples++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (state-&gt;status)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_INMEM:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update read pointers as needed; see API spec above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr = state-&gt;readptrs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; state-&gt;readptrcount; readptr++, i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readptr-&gt;eof_reached &amp;&amp; i != state-&gt;activeptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;eof_reached = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;current = state-&gt;memtupcount;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Grow the array as needed.&nbsp; Note that we try to grow the array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when there is still one free slot remaining --- if we fail,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there'll still be room to store the incoming tuple, and then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll switch to tape-based operation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;memtupcount &gt;= state-&gt;memtupsize - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="tuplesort.c.html#L1072" title="utils/sort/tuplesort.c:1072">grow_memtuples</a>(state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;memtupcount &lt; state-&gt;memtupsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Stash the tuple in the in-memory array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;memtuples[state-&gt;memtupcount++] = tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Done if we still fit in available memory and have array slots.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;memtupcount &lt; state-&gt;memtupsize &amp;&amp; !<a href="tuplesort.c.html#L403" title="utils/sort/tuplesort.c:403">LACKMEM</a>(state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Nope; time to switch to tape-based operation.&nbsp; Make sure that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the temp file(s) are created in suitable temp tablespaces.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/tablespace.c.html#L1331" title="commands/tablespace.c:1331">PrepareTempTablespaces</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* associate the file with the store's resource owner */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldowner = <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = state-&gt;resowner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;myfile = <a href="../../storage/file/buffile.c.html#L193" title="storage/file/buffile.c:193">BufFileCreateTemp</a>(state-&gt;interXact);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = oldowner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Freeze the decision about whether trailing length words will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * used.&nbsp; We can't change this choice once data is on tape, even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * though callers might drop the requirement.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;backward = (state-&gt;eflags &amp; EXEC_FLAG_BACKWARD) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;status = TSS_WRITEFILE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tuplesort.c.html#L2339" title="utils/sort/tuplesort.c:2339">dumptuples</a>(state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_WRITEFILE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update read pointers as needed; see API spec above. Note:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/file/buffile.c.html#L833" title="storage/file/buffile.c:833">BufFileTell</a> is quite cheap, so not worth trying to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multiple calls.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr = state-&gt;readptrs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; state-&gt;readptrcount; readptr++, i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readptr-&gt;eof_reached &amp;&amp; i != state-&gt;activeptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;eof_reached = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L833" title="storage/file/buffile.c:833">BufFileTell</a>(state-&gt;myfile,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;readptr-&gt;file,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;readptr-&gt;offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tuplesort.c.html#L400" title="utils/sort/tuplesort.c:400">WRITETUP</a>(state, tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_READFILE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Switch from reading to writing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!state-&gt;readptrs[state-&gt;activeptr].eof_reached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L833" title="storage/file/buffile.c:833">BufFileTell</a>(state-&gt;myfile,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;state-&gt;readptrs[state-&gt;activeptr].file,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;state-&gt;readptrs[state-&gt;activeptr].offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/buffile.c.html#L740" title="storage/file/buffile.c:740">BufFileSeek</a>(state-&gt;myfile,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;writepos_file, state-&gt;writepos_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">SEEK_SET</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not seek in tuplestore temporary file&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;status = TSS_WRITEFILE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update read pointers as needed; see API spec above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr = state-&gt;readptrs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; state-&gt;readptrcount; readptr++, i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readptr-&gt;eof_reached &amp;&amp; i != state-&gt;activeptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;eof_reached = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;file = state-&gt;writepos_file;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;offset = state-&gt;writepos_offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tuplesort.c.html#L400" title="utils/sort/tuplesort.c:400">WRITETUP</a>(state, tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid tuplestore state&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple in either forward or back direction.<br/></li>
<li></span><span class="Comment"> * Returns NULL if no more tuples.&nbsp; If should_free is set, the<br/></li>
<li></span><span class="Comment"> * caller must <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> the returned tuple when done with it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Backward scan is only allowed if randomAccess was set true or<br/></li>
<li></span><span class="Comment"> * EXEC_FLAG_BACKWARD was specified to <a href="#L359" title="utils/sort/tuplestore.c:359">tuplestore_set_eflags</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> *<br/></li>
<li><a id="L903">&#x200c;</a><span class="linkable">tuplestore_gettuple</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forward,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *should_free)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L98" title="utils/sort/tuplestore.c:98">TSReadPointer</a> *readptr = &amp;state-&gt;readptrs[state-&gt;activeptr];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> tuplen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *tup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(forward || (readptr-&gt;eflags &amp; EXEC_FLAG_BACKWARD));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (state-&gt;status)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_INMEM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *should_free = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (forward)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readptr-&gt;eof_reached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readptr-&gt;current &lt; state-&gt;memtupcount)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have another tuple, so return it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> state-&gt;memtuples[readptr-&gt;current++];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;eof_reached = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if all tuples are fetched already then we return last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple, else tuple <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> last returned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readptr-&gt;eof_reached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;current = state-&gt;memtupcount;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;eof_reached = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readptr-&gt;current &lt;= state-&gt;memtupdeleted)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!state-&gt;truncated);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;current--; <span class="Comment">/* last returned tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readptr-&gt;current &lt;= state-&gt;memtupdeleted)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!state-&gt;truncated);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> state-&gt;memtuples[readptr-&gt;current - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_WRITEFILE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip state change if we'll just return NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readptr-&gt;eof_reached &amp;&amp; forward)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Switch from writing to reading.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L833" title="storage/file/buffile.c:833">BufFileTell</a>(state-&gt;myfile,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;state-&gt;writepos_file, &amp;state-&gt;writepos_offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!readptr-&gt;eof_reached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/buffile.c.html#L740" title="storage/file/buffile.c:740">BufFileSeek</a>(state-&gt;myfile,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;file, readptr-&gt;offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">SEEK_SET</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not seek in tuplestore temporary file&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;status = TSS_READFILE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALLTHROUGH */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_READFILE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *should_free = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (forward)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((tuplen = <a href="tuplesort.c.html#L2894" title="utils/sort/tuplesort.c:2894">getlen</a>(state, <span class="Constant">true</span>)) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tup = <a href="tuplesort.c.html#L401" title="utils/sort/tuplesort.c:401">READTUP</a>(state, tuplen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> tup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;eof_reached = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Backward.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if all tuples are fetched already then we return last tuple,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * else tuple <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> last returned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Back up to fetch previously-returned tuple's ending length<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>. If seek fails, assume we are at start of file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/buffile.c.html#L740" title="storage/file/buffile.c:740">BufFileSeek</a>(state-&gt;myfile, <span class="Constant">0</span>, -(<span class="Type">long</span>) <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">unsigned</span> <span class="Type">int</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">SEEK_CUR</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* even a failed backwards fetch gets you out of eof state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;eof_reached = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!state-&gt;truncated);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuplen = <a href="tuplesort.c.html#L2894" title="utils/sort/tuplesort.c:2894">getlen</a>(state, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readptr-&gt;eof_reached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;eof_reached = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We will return the tuple returned <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Back up to get ending length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> of tuple <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/buffile.c.html#L740" title="storage/file/buffile.c:740">BufFileSeek</a>(state-&gt;myfile, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -(<span class="Type">long</span>) (tuplen + <span class="Constant">2</span> * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">unsigned</span> <span class="Type">int</span>)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">SEEK_CUR</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If that fails, presumably the prev tuple is the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the file.&nbsp; Back up so that it becomes <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> to read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in forward direction (not obviously right, but that is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * what in-memory case does).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/buffile.c.html#L740" title="storage/file/buffile.c:740">BufFileSeek</a>(state-&gt;myfile, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -(<span class="Type">long</span>) (tuplen + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">unsigned</span> <span class="Type">int</span>)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">SEEK_CUR</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not seek in tuplestore temporary file&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!state-&gt;truncated);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuplen = <a href="tuplesort.c.html#L2894" title="utils/sort/tuplesort.c:2894">getlen</a>(state, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now we have the length of the prior tuple, back up and read it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: <a href="tuplesort.c.html#L401" title="utils/sort/tuplesort.c:401">READTUP</a> expects we are positioned after the initial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> of the tuple, so back up to that point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/buffile.c.html#L740" title="storage/file/buffile.c:740">BufFileSeek</a>(state-&gt;myfile, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -(<span class="Type">long</span>) tuplen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">SEEK_CUR</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not seek in tuplestore temporary file&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tup = <a href="tuplesort.c.html#L401" title="utils/sort/tuplesort.c:401">READTUP</a>(state, tuplen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> tup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid tuplestore state&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1078" title="utils/sort/tuplestore.c:1078">tuplestore_gettupleslot</a> - exported function to fetch a MinimalTuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If successful, put tuple in slot and return true; else, clear the slot<br/></li>
<li></span><span class="Comment"> * and return false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If copy is true, the slot receives a copied tuple (allocated in current<br/></li>
<li></span><span class="Comment"> * memory context) that will stay valid regardless of future manipulations of<br/></li>
<li></span><span class="Comment"> * the tuplestore's state.&nbsp; If copy is false, the slot may just receive a<br/></li>
<li></span><span class="Comment"> * pointer to a tuple held within the tuplestore.&nbsp; The latter is more<br/></li>
<li></span><span class="Comment"> * efficient but the slot contents may be corrupted if additional writes to<br/></li>
<li></span><span class="Comment"> * the tuplestore occur.&nbsp; (If using <a href="#L1360" title="utils/sort/tuplestore.c:1360">tuplestore_trim</a>, see comments therein.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1078">&#x200c;</a></span><span class="linkable">tuplestore_gettupleslot</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forward,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> copy, TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MinimalTuple tuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; should_free;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = (MinimalTuple) <a href="#L903" title="utils/sort/tuplestore.c:903">tuplestore_gettuple</a>(state, forward, &amp;should_free);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tuple)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (copy &amp;&amp; !should_free)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../../access/common/heaptuple.c.html#L1535" title="access/common/heaptuple.c:1535">heap_copy_minimal_tuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; should_free = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execTuples.c.html#L1533" title="executor/execTuples.c:1533">ExecStoreMinimalTuple</a>(tuple, slot, should_free);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1110" title="utils/sort/tuplestore.c:1110">tuplestore_advance</a> - exported function to adjust position without fetching<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We could <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> this case to avoid <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>/<a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> overhead, but for the<br/></li>
<li></span><span class="Comment"> * moment it doesn't seem worthwhile.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1110">&#x200c;</a></span><span class="linkable">tuplestore_advance</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forward)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *tuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; should_free;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="#L903" title="utils/sort/tuplestore.c:903">tuplestore_gettuple</a>(state, forward, &amp;should_free);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tuple)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (should_free)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Advance over N tuples in either forward or back direction,<br/></li>
<li></span><span class="Comment"> * without returning <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data.&nbsp; N&lt;=0 is a no-op.<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if ran out of tuples.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1135">&#x200c;</a></span><span class="linkable">tuplestore_skiptuples</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state, int64 ntuples, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forward)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L98" title="utils/sort/tuplestore.c:98">TSReadPointer</a> *readptr = &amp;state-&gt;readptrs[state-&gt;activeptr];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(forward || (readptr-&gt;eflags &amp; EXEC_FLAG_BACKWARD));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ntuples &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (state-&gt;status)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_INMEM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (forward)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readptr-&gt;eof_reached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;memtupcount - readptr-&gt;current &gt;= ntuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;current += ntuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;current = state-&gt;memtupcount;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;eof_reached = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readptr-&gt;eof_reached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;current = state-&gt;memtupcount;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;eof_reached = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntuples--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readptr-&gt;current - state-&gt;memtupdeleted &gt; ntuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;current -= ntuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!state-&gt;truncated);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;current = state-&gt;memtupdeleted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't currently try hard to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> other cases */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (ntuples-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; should_free;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="#L903" title="utils/sort/tuplestore.c:903">tuplestore_gettuple</a>(state, forward, &amp;should_free);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tuple == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (should_free)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="tuplesort.c.html#L2339" title="utils/sort/tuplesort.c:2339">dumptuples</a> - remove tuples from memory and write to tape<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As a side effect, we must convert each read pointer's position from<br/></li>
<li></span><span class="Comment"> * &quot;current&quot; to file/offset format.&nbsp; But eof_reached pointers don't<br/></li>
<li></span><span class="Comment"> * need to change state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1206">&#x200c;</a></span><span class="linkable">dumptuples</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = state-&gt;memtupdeleted;; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L98" title="utils/sort/tuplestore.c:98">TSReadPointer</a> *readptr = state-&gt;readptrs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; state-&gt;readptrcount; readptr++, j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == readptr-&gt;current &amp;&amp; !readptr-&gt;eof_reached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L833" title="storage/file/buffile.c:833">BufFileTell</a>(state-&gt;myfile,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;readptr-&gt;file, &amp;readptr-&gt;offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= state-&gt;memtupcount)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="tuplesort.c.html#L400" title="utils/sort/tuplesort.c:400">WRITETUP</a>(state, state-&gt;memtuples[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; state-&gt;memtupdeleted = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;memtupcount = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1233" title="utils/sort/tuplestore.c:1233">tuplestore_rescan</a>&nbsp; &nbsp; &nbsp; &nbsp; - rewind the active read pointer to start<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1233">&#x200c;</a></span><span class="linkable">tuplestore_rescan</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L98" title="utils/sort/tuplestore.c:98">TSReadPointer</a> *readptr = &amp;state-&gt;readptrs[state-&gt;activeptr];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(readptr-&gt;eflags &amp; EXEC_FLAG_REWIND);<br/></li>
<li>&nbsp; &nbsp; Assert(!state-&gt;truncated);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (state-&gt;status)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_INMEM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;eof_reached = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;current = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_WRITEFILE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;eof_reached = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;file = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_READFILE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readptr-&gt;eof_reached = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/buffile.c.html#L740" title="storage/file/buffile.c:740">BufFileSeek</a>(state-&gt;myfile, <span class="Constant">0</span>, <span class="Constant">0</span>, <span class="Constant">SEEK_SET</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not seek in tuplestore temporary file&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid tuplestore state&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1268" title="utils/sort/tuplestore.c:1268">tuplestore_copy_read_pointer</a> - copy a read pointer's state to another<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1268">&#x200c;</a></span><span class="linkable">tuplestore_copy_read_pointer</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> srcptr, <span class="Type">int</span> destptr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L98" title="utils/sort/tuplestore.c:98">TSReadPointer</a> *sptr = &amp;state-&gt;readptrs[srcptr];<br/></li>
<li>&nbsp; &nbsp; <a href="#L98" title="utils/sort/tuplestore.c:98">TSReadPointer</a> *dptr = &amp;state-&gt;readptrs[destptr];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(srcptr &gt;= <span class="Constant">0</span> &amp;&amp; srcptr &lt; state-&gt;readptrcount);<br/></li>
<li>&nbsp; &nbsp; Assert(destptr &gt;= <span class="Constant">0</span> &amp;&amp; destptr &lt; state-&gt;readptrcount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assigning to self is a no-op */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (srcptr == destptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dptr-&gt;eflags != sptr-&gt;eflags)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Possible change of overall eflags, so copy and then recompute */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eflags;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *dptr = *sptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eflags = state-&gt;readptrs[<span class="Constant">0</span>].eflags;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; state-&gt;readptrcount; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eflags |= state-&gt;readptrs[i].eflags;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;eflags = eflags;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *dptr = *sptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (state-&gt;status)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_INMEM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_WRITEFILE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no work */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_READFILE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This case is a <a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> tricky since the active read pointer's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * position corresponds to the seek point, not what is in its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * variables.&nbsp; Assigning to the active requires a seek, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assigning from the active requires a tell, except when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * eof_reached.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (destptr == state-&gt;activeptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dptr-&gt;eof_reached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/buffile.c.html#L740" title="storage/file/buffile.c:740">BufFileSeek</a>(state-&gt;myfile,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;writepos_file,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;writepos_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">SEEK_SET</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not seek in tuplestore temporary file&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/buffile.c.html#L740" title="storage/file/buffile.c:740">BufFileSeek</a>(state-&gt;myfile,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dptr-&gt;file, dptr-&gt;offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">SEEK_SET</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not seek in tuplestore temporary file&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (srcptr == state-&gt;activeptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!dptr-&gt;eof_reached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L833" title="storage/file/buffile.c:833">BufFileTell</a>(state-&gt;myfile,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;dptr-&gt;file,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;dptr-&gt;offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid tuplestore state&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1360" title="utils/sort/tuplestore.c:1360">tuplestore_trim</a>&nbsp; &nbsp; - remove all no-longer-needed tuples<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Calling this function authorizes the tuplestore to delete all tuples<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the oldest read pointer, if no read pointer is marked as requiring<br/></li>
<li></span><span class="Comment"> * REWIND capability.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this is obviously safe if no pointer has BACKWARD capability either.<br/></li>
<li></span><span class="Comment"> * If a pointer is marked as BACKWARD but not REWIND capable, it means that<br/></li>
<li></span><span class="Comment"> * the pointer can be moved backward but not <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the oldest other read<br/></li>
<li></span><span class="Comment"> * pointer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1360">&#x200c;</a></span><span class="linkable">tuplestore_trim</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldest;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nremove;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Truncation is disallowed if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> read pointer requires rewind<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * capability.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;eflags &amp; EXEC_FLAG_REWIND)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't bother trimming temp files since it usually would mean more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * work than just letting them sit in kernel buffers until they age out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;status != TSS_INMEM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the oldest read pointer */<br/></li>
<li></span>&nbsp; &nbsp; oldest = state-&gt;memtupcount;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; state-&gt;readptrcount; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!state-&gt;readptrs[i].eof_reached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldest = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(oldest, state-&gt;readptrs[i].current);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: you might think we could remove all the tuples <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the oldest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;current&quot;, since that one is the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> to be returned.&nbsp; However, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L903" title="utils/sort/tuplestore.c:903">tuplestore_gettuple</a> returns a direct pointer to our <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> copy of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the tuple, it's likely that the caller has still got the tuple just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> &quot;current&quot; referenced in a slot. So we keep one extra tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the oldest &quot;current&quot;.&nbsp; (Strictly speaking, we could require such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * callers to use the &quot;copy&quot; flag to <a href="#L1078" title="utils/sort/tuplestore.c:1078">tuplestore_gettupleslot</a>, but for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * efficiency we allow this one case to not use &quot;copy&quot;.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nremove = oldest - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nremove &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; Assert(nremove &gt;= state-&gt;memtupdeleted);<br/></li>
<li>&nbsp; &nbsp; Assert(nremove &lt;= state-&gt;memtupcount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release no-longer-needed tuples */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = state-&gt;memtupdeleted; i &lt; nremove; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="tuplesort.c.html#L405" title="utils/sort/tuplesort.c:405">FREEMEM</a>(state, <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>(state-&gt;memtuples[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state-&gt;memtuples[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;memtuples[i] = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; state-&gt;memtupdeleted = nremove;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* mark tuplestore as truncated (used for Assert crosschecks only) */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;truncated = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If nremove is less than 1/8th memtupcount, just stop here, leaving the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;deleted&quot; slots as NULL.&nbsp; This prevents us from expending O(N^2) time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * repeatedly memmove-ing a large pointer array.&nbsp; The worst case space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wastage is pretty small, since it's just pointers and not whole tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nremove &lt; state-&gt;memtupcount / <span class="Constant">8</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Slide the array down and readjust pointers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In mergejoin's current usage, it's demonstrable that there will always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be exactly one non-removed tuple; so <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nremove + <span class="Constant">1</span> == state-&gt;memtupcount)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;memtuples[<span class="Constant">0</span>] = state-&gt;memtuples[nremove];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memmove(state-&gt;memtuples, state-&gt;memtuples + nremove,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (state-&gt;memtupcount - nremove) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">void</span> *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;memtupdeleted = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;memtupcount -= nremove;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; state-&gt;readptrcount; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!state-&gt;readptrs[i].eof_reached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;readptrs[i].current -= nremove;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1455" title="utils/sort/tuplestore.c:1455">tuplestore_in_memory</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if the tuplestore has not spilled to disk.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> exposing this is a violation of modularity ... should get rid of it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1455">&#x200c;</a></span><span class="linkable">tuplestore_in_memory</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (state-&gt;status == TSS_INMEM);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Tape interface routines<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">unsigned</span> <span class="Type">int<br/></li>
<li><a id="L1466">&#x200c;</a></span><span class="linkable">getlen</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> eofOK)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nbytes = <a href="../../storage/file/buffile.c.html#L664" title="storage/file/buffile.c:664">BufFileReadMaybeEOF</a>(state-&gt;myfile, &amp;len, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len), eofOK);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nbytes == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> len;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Routines specialized for HeapTuple case<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The stored form is actually a MinimalTuple, but for largely historical<br/></li>
<li></span><span class="Comment"> * reasons we allow <a href="#L183" title="utils/sort/tuplestore.c:183">COPYTUP</a> to work from a HeapTuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since MinimalTuple already has length in its first <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>, we don't need<br/></li>
<li></span><span class="Comment"> * to write that separately.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> *<br/></li>
<li><a id="L1490">&#x200c;</a><span class="linkable">copytup_heap</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state, <span class="Type">void</span> *tup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MinimalTuple tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../../access/common/heaptuple.c.html#L1576" title="access/common/heaptuple.c:1576">minimal_tuple_from_heap_tuple</a>((HeapTuple) tup);<br/></li>
<li>&nbsp; &nbsp; <a href="tuplesort.c.html#L404" title="utils/sort/tuplesort.c:404">USEMEM</a>(state, <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>(tuple));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">void</span> *) tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1500">&#x200c;</a></span><span class="linkable">writetup_heap</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state, <span class="Type">void</span> *tup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MinimalTuple tuple = (MinimalTuple) tup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the part of the MinimalTuple we'll write: */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tupbody = (<span class="Type">char</span> *) tuple + MINIMAL_TUPLE_DATA_OFFSET;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> tupbodylen = tuple-&gt;t_len - MINIMAL_TUPLE_DATA_OFFSET;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* total on-disk footprint: */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> tuplen = tupbodylen + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L676" title="storage/file/buffile.c:676">BufFileWrite</a>(state-&gt;myfile, &amp;tuplen, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tuplen));<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L676" title="storage/file/buffile.c:676">BufFileWrite</a>(state-&gt;myfile, tupbody, tupbodylen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;backward)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* need trailing length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L676" title="storage/file/buffile.c:676">BufFileWrite</a>(state-&gt;myfile, &amp;tuplen, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tuplen));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="tuplesort.c.html#L405" title="utils/sort/tuplesort.c:405">FREEMEM</a>(state, <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>(tuple));<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1523" title="access/common/heaptuple.c:1523">heap_free_minimal_tuple</a>(tuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> *<br/></li>
<li><a id="L1521">&#x200c;</a><span class="linkable">readtup_heap</span>(<a href="#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *state, <span class="Type">unsigned</span> <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> tupbodylen = len - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> tuplen = tupbodylen + MINIMAL_TUPLE_DATA_OFFSET;<br/></li>
<li>&nbsp; &nbsp; MinimalTuple tuple = (MinimalTuple) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(tuplen);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tupbody = (<span class="Type">char</span> *) tuple + MINIMAL_TUPLE_DATA_OFFSET;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="tuplesort.c.html#L404" title="utils/sort/tuplesort.c:404">USEMEM</a>(state, <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>(tuple));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read in the tuple proper */<br/></li>
<li></span>&nbsp; &nbsp; tuple-&gt;t_len = tuplen;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L654" title="storage/file/buffile.c:654">BufFileReadExact</a>(state-&gt;myfile, tupbody, tupbodylen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;backward)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* need trailing length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L654" title="storage/file/buffile.c:654">BufFileReadExact</a>(state-&gt;myfile, &amp;tuplen, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tuplen));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">void</span> *) tuple;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
