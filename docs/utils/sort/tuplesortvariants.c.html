<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/sort/tuplesortvariants.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/sort/tuplesortvariants.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L157">BrinSortTuple</a></li>
<li><a href="#L161">BrinSortTuple</a></li>
<li><a href="#L105">TuplesortClusterArg</a></li>
<li><a href="#L150">TuplesortDatumArg</a></li>
<li><a href="#L115">TuplesortIndexArg</a></li>
<li><a href="#L126">TuplesortIndexBTreeArg</a></li>
<li><a href="#L138">TuplesortIndexHashArg</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1227">comparetup_cluster</a></li>
<li><a href="#L1248">comparetup_cluster_tiebreak</a></li>
<li><a href="#L1794">comparetup_datum</a></li>
<li><a href="#L1809">comparetup_datum_tiebreak</a></li>
<li><a href="#L1085">comparetup_heap</a></li>
<li><a href="#L1104">comparetup_heap_tiebreak</a></li>
<li><a href="#L1725">comparetup_index_brin</a></li>
<li><a href="#L1442">comparetup_index_btree</a></li>
<li><a href="#L1466">comparetup_index_btree_tiebreak</a></li>
<li><a href="#L1588">comparetup_index_hash</a></li>
<li><a href="#L1664">comparetup_index_hash_tiebreak</a></li>
<li><a href="#L1399">freestate_cluster</a></li>
<li><a href="#L1370">readtup_cluster</a></li>
<li><a href="#L1858">readtup_datum</a></li>
<li><a href="#L1177">readtup_heap</a></li>
<li><a href="#L1687">readtup_index</a></li>
<li><a href="#L1755">readtup_index_brin</a></li>
<li><a href="#L1208">removeabbrev_cluster</a></li>
<li><a href="#L1785">removeabbrev_datum</a></li>
<li><a href="#L1064">removeabbrev_heap</a></li>
<li><a href="#L1423">removeabbrev_index</a></li>
<li><a href="#L1711">removeabbrev_index_brin</a></li>
<li><a href="#L243">tuplesort_begin_cluster</a></li>
<li><a href="#L584">tuplesort_begin_datum</a></li>
<li><a href="#L168">tuplesort_begin_heap</a></li>
<li><a href="#L555">tuplesort_begin_index_brin</a></li>
<li><a href="#L352">tuplesort_begin_index_btree</a></li>
<li><a href="#L490">tuplesort_begin_index_gist</a></li>
<li><a href="#L437">tuplesort_begin_index_hash</a></li>
<li><a href="#L970">tuplesort_getbrintuple</a></li>
<li><a href="#L1018">tuplesort_getdatum</a></li>
<li><a href="#L928">tuplesort_getheaptuple</a></li>
<li><a href="#L949">tuplesort_getindextuple</a></li>
<li><a href="#L890">tuplesort_gettupleslot</a></li>
<li><a href="#L788">tuplesort_putbrintuple</a></li>
<li><a href="#L826">tuplesort_putdatum</a></li>
<li><a href="#L709">tuplesort_putheaptuple</a></li>
<li><a href="#L752">tuplesort_putindextuplevalues</a></li>
<li><a href="#L669">tuplesort_puttupleslot</a></li>
<li><a href="#L1355">writetup_cluster</a></li>
<li><a href="#L1824">writetup_datum</a></li>
<li><a href="#L1158">writetup_heap</a></li>
<li><a href="#L1673">writetup_index</a></li>
<li><a href="#L1741">writetup_index_brin</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L164">BRINSORTTUPLE_SIZE</a></li>
<li><a href="#L39">CLUSTER_SORT</a></li>
<li><a href="#L38">DATUM_SORT</a></li>
<li><a href="#L36">HEAP_SORT</a></li>
<li><a href="#L37">INDEX_SORT</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tuplesortvariants.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Implementation of tuple sorting variants.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This module handles the sorting of heap tuples, index tuples, or single<br/></li>
<li></span><span class="Comment"> * Datums.&nbsp; The implementation is based on the generalized tuple sorting<br/></li>
<li></span><span class="Comment"> * facility given in tuplesort.c.&nbsp; Support other kinds of sortable objects<br/></li>
<li></span><span class="Comment"> * could be easily added here, another module, or even an extension.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2022-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/sort/tuplesortvariants.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/brin_tuple.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/nbtree.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/index.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pg_trace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/tuplesort.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* sort-type codes for sort__start probes */<br/></li>
<li><a id="L36">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">HEAP_SORT</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0<br/></li>
<li><a id="L37">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">INDEX_SORT</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">1<br/></li>
<li><a id="L38">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DATUM_SORT</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">2<br/></li>
<li><a id="L39">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CLUSTER_SORT</span>&nbsp; &nbsp; </span><span class="Constant">3<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1064" title="utils/sort/tuplesortvariants.c:1064">removeabbrev_heap</a>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *stups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> count);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1208" title="utils/sort/tuplesortvariants.c:1208">removeabbrev_cluster</a>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *stups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> count);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1423" title="utils/sort/tuplesortvariants.c:1423">removeabbrev_index</a>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *stups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> count);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1711" title="utils/sort/tuplesortvariants.c:1711">removeabbrev_index_brin</a>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *stups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> count);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1785" title="utils/sort/tuplesortvariants.c:1785">removeabbrev_datum</a>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *stups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> count);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1085" title="utils/sort/tuplesortvariants.c:1085">comparetup_heap</a>(<span class="Type">const</span> SortTuple *a, <span class="Type">const</span> SortTuple *b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1104" title="utils/sort/tuplesortvariants.c:1104">comparetup_heap_tiebreak</a>(<span class="Type">const</span> SortTuple *a, <span class="Type">const</span> SortTuple *b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1158" title="utils/sort/tuplesortvariants.c:1158">writetup_heap</a>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortTuple *stup);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1177" title="utils/sort/tuplesortvariants.c:1177">readtup_heap</a>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *stup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape, <span class="Type">unsigned</span> <span class="Type">int</span> len);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1227" title="utils/sort/tuplesortvariants.c:1227">comparetup_cluster</a>(<span class="Type">const</span> SortTuple *a, <span class="Type">const</span> SortTuple *b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1248" title="utils/sort/tuplesortvariants.c:1248">comparetup_cluster_tiebreak</a>(<span class="Type">const</span> SortTuple *a, <span class="Type">const</span> SortTuple *b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1355" title="utils/sort/tuplesortvariants.c:1355">writetup_cluster</a>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SortTuple *stup);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1370" title="utils/sort/tuplesortvariants.c:1370">readtup_cluster</a>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *stup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape, <span class="Type">unsigned</span> <span class="Type">int</span> tuplen);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1442" title="utils/sort/tuplesortvariants.c:1442">comparetup_index_btree</a>(<span class="Type">const</span> SortTuple *a, <span class="Type">const</span> SortTuple *b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1466" title="utils/sort/tuplesortvariants.c:1466">comparetup_index_btree_tiebreak</a>(<span class="Type">const</span> SortTuple *a, <span class="Type">const</span> SortTuple *b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1588" title="utils/sort/tuplesortvariants.c:1588">comparetup_index_hash</a>(<span class="Type">const</span> SortTuple *a, <span class="Type">const</span> SortTuple *b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1664" title="utils/sort/tuplesortvariants.c:1664">comparetup_index_hash_tiebreak</a>(<span class="Type">const</span> SortTuple *a, <span class="Type">const</span> SortTuple *b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1725" title="utils/sort/tuplesortvariants.c:1725">comparetup_index_brin</a>(<span class="Type">const</span> SortTuple *a, <span class="Type">const</span> SortTuple *b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1673" title="utils/sort/tuplesortvariants.c:1673">writetup_index</a>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SortTuple *stup);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1687" title="utils/sort/tuplesortvariants.c:1687">readtup_index</a>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *stup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape, <span class="Type">unsigned</span> <span class="Type">int</span> len);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1741" title="utils/sort/tuplesortvariants.c:1741">writetup_index_brin</a>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortTuple *stup);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1755" title="utils/sort/tuplesortvariants.c:1755">readtup_index_brin</a>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *stup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape, <span class="Type">unsigned</span> <span class="Type">int</span> len);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1794" title="utils/sort/tuplesortvariants.c:1794">comparetup_datum</a>(<span class="Type">const</span> SortTuple *a, <span class="Type">const</span> SortTuple *b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1809" title="utils/sort/tuplesortvariants.c:1809">comparetup_datum_tiebreak</a>(<span class="Type">const</span> SortTuple *a, <span class="Type">const</span> SortTuple *b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1824" title="utils/sort/tuplesortvariants.c:1824">writetup_datum</a>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SortTuple *stup);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1858" title="utils/sort/tuplesortvariants.c:1858">readtup_datum</a>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *stup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape, <span class="Type">unsigned</span> <span class="Type">int</span> len);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1399" title="utils/sort/tuplesortvariants.c:1399">freestate_cluster</a>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Data structure pointed by &quot;TuplesortPublic.arg&quot; for the CLUSTER case.&nbsp; Set by<br/></li>
<li></span><span class="Comment"> * the <a href="#L243" title="utils/sort/tuplesortvariants.c:243">tuplesort_begin_cluster</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; IndexInfo&nbsp; *indexInfo;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* info about index being used for reference */<br/></li>
<li></span>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for evaluating index expressions */<br/></li>
<li><a id="L105">&#x200c;</a></span>} <span class="linkable">TuplesortClusterArg</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Data structure pointed by &quot;TuplesortPublic.arg&quot; for the IndexTuple case.<br/></li>
<li></span><span class="Comment"> * Set by tuplesort_begin_index_xxx and used only by the IndexTuple routines.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; heapRel;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* table the index is being built on */<br/></li>
<li></span>&nbsp; &nbsp; Relation&nbsp; &nbsp; indexRel;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* index being built */<br/></li>
<li><a id="L115">&#x200c;</a></span>} <span class="linkable">TuplesortIndexArg</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Data structure pointed by &quot;TuplesortPublic.arg&quot; for the index_btree subcase.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L115" title="utils/sort/tuplesortvariants.c:115">TuplesortIndexArg</a> index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; enforceUnique;&nbsp; &nbsp; <span class="Comment">/* complain if we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> duplicate tuples */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; uniqueNullsNotDistinct; <span class="Comment">/* unique constraint null treatment */<br/></li>
<li><a id="L126">&#x200c;</a></span>} <span class="linkable">TuplesortIndexBTreeArg</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Data structure pointed by &quot;TuplesortPublic.arg&quot; for the index_hash subcase.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L115" title="utils/sort/tuplesortvariants.c:115">TuplesortIndexArg</a> index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; high_mask;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* masks for sortable part of <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; low_mask;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; max_buckets;<br/></li>
<li><a id="L138">&#x200c;</a>} <span class="linkable">TuplesortIndexHashArg</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Data structure pointed by &quot;TuplesortPublic.arg&quot; for the Datum case.<br/></li>
<li></span><span class="Comment"> * Set by <a href="#L584" title="utils/sort/tuplesortvariants.c:584">tuplesort_begin_datum</a> and used only by the DatumTuple routines.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the datatype oid of Datum's to be sorted */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datumType;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we need typelen in order to know how to copy the Datums. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datumTypeLen;<br/></li>
<li><a id="L150">&#x200c;</a>} <span class="linkable">TuplesortDatumArg</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Computing BrinTuple size with only the tuple is difficult, so we want to track<br/></li>
<li></span><span class="Comment"> * the length referenced by the SortTuple. That's what <a href="#L157" title="utils/sort/tuplesortvariants.c:157">BrinSortTuple</a> is meant<br/></li>
<li></span><span class="Comment"> * to do - it's essentially a BrinTuple prefixed by its length.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L157">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BrinSortTuple</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; tuplen;<br/></li>
<li>&nbsp; &nbsp; BrinTuple&nbsp; &nbsp; tuple;<br/></li>
<li><a id="L161">&#x200c;</a>} <span class="linkable">BrinSortTuple</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Size of the <a href="#L157" title="utils/sort/tuplesortvariants.c:157">BrinSortTuple</a>, given length of the BrinTuple. */<br/></li>
<li><a id="L164">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BRINSORTTUPLE_SIZE</span>(len)&nbsp; &nbsp; &nbsp; &nbsp; (offsetof(<a href="#L157" title="utils/sort/tuplesortvariants.c:157">BrinSortTuple</a>, tuple) + (len))<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *<br/></li>
<li><a id="L168">&#x200c;</a><span class="linkable">tuplesort_begin_heap</span>(TupleDesc tupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nkeys, AttrNumber *attNums,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *sortOperators, Oid *sortCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *nullsFirstFlags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> workMem, SortCoordinate coordinate, <span class="Type">int</span> sortopt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state = <a href="tuplesort.c.html#L645" title="utils/sort/tuplesort.c:645">tuplesort_begin_common</a>(workMem, coordinate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sortopt);<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(base-&gt;maincontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(nkeys &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="tuplesort.c.html#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;begin tuple sort: nkeys = </span><span class="Special">%d</span><span class="Constant">, workMem = </span><span class="Special">%d</span><span class="Constant">, randomAccess = </span><span class="Special">%c</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nkeys, workMem, sortopt &amp; TUPLESORT_RANDOMACCESS ? <span class="Constant">'t'</span> : <span class="Constant">'f'</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; base-&gt;nKeys = nkeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_SORT_START(<a href="#L36" title="utils/sort/tuplesortvariants.c:36">HEAP_SORT</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,&nbsp; &nbsp; <span class="Comment">/* no unique check */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workMem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortopt &amp; TUPLESORT_RANDOMACCESS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PARALLEL_SORT(coordinate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; base-&gt;removeabbrev = <a href="#L1064" title="utils/sort/tuplesortvariants.c:1064">removeabbrev_heap</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;comparetup = <a href="#L1085" title="utils/sort/tuplesortvariants.c:1085">comparetup_heap</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;comparetup_tiebreak = <a href="#L1104" title="utils/sort/tuplesortvariants.c:1104">comparetup_heap_tiebreak</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;writetup = <a href="#L1158" title="utils/sort/tuplesortvariants.c:1158">writetup_heap</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;readtup = <a href="#L1177" title="utils/sort/tuplesortvariants.c:1177">readtup_heap</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;haveDatum1 = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;arg = tupDesc;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* assume we need not copy tupDesc */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare SortSupport data for each column */<br/></li>
<li></span>&nbsp; &nbsp; base-&gt;sortKeys = (SortSupport) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(nkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortSupportData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortSupport sortKey = base-&gt;sortKeys + i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(attNums[i] != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(sortOperators[i] != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_cxt = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_collation = sortCollations[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_nulls_first = nullsFirstFlags[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_attno = attNums[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Convey if abbreviation optimization is applicable in principle */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;abbreviate = (i == <span class="Constant">0</span> &amp;&amp; base-&gt;haveDatum1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="sortsupport.c.html#L134" title="utils/sort/sortsupport.c:134">PrepareSortSupportFromOrderingOp</a>(sortOperators[i], sortKey);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The &quot;onlyKey&quot; optimization cannot be used with abbreviated keys, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tie-breaker comparisons may be required.&nbsp; Typically, the optimization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is only of value to pass-by-value types anyway, whereas abbreviated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keys are typically only of value to pass-by-reference types.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nkeys == <span class="Constant">1</span> &amp;&amp; !base-&gt;sortKeys-&gt;abbrev_converter)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; base-&gt;onlyKey = base-&gt;sortKeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *<br/></li>
<li><a id="L243">&#x200c;</a><span class="linkable">tuplesort_begin_cluster</span>(TupleDesc tupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation indexRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> workMem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortCoordinate coordinate, <span class="Type">int</span> sortopt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state = <a href="tuplesort.c.html#L645" title="utils/sort/tuplesort.c:645">tuplesort_begin_common</a>(workMem, coordinate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sortopt);<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; BTScanInsert indexScanKey;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; <a href="#L105" title="utils/sort/tuplesortvariants.c:105">TuplesortClusterArg</a> *arg;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(indexRel-&gt;rd_rel-&gt;relam == BTREE_AM_OID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(base-&gt;maincontext);<br/></li>
<li>&nbsp; &nbsp; arg = (<a href="#L105" title="utils/sort/tuplesortvariants.c:105">TuplesortClusterArg</a> *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L105" title="utils/sort/tuplesortvariants.c:105">TuplesortClusterArg</a>));<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="tuplesort.c.html#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;begin tuple sort: nkeys = </span><span class="Special">%d</span><span class="Constant">, workMem = </span><span class="Special">%d</span><span class="Constant">, randomAccess = </span><span class="Special">%c</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetNumberOfAttributes(indexRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; workMem, sortopt &amp; TUPLESORT_RANDOMACCESS ? <span class="Constant">'t'</span> : <span class="Constant">'f'</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; base-&gt;nKeys = IndexRelationGetNumberOfKeyAttributes(indexRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_SORT_START(<a href="#L39" title="utils/sort/tuplesortvariants.c:39">CLUSTER_SORT</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,&nbsp; &nbsp; <span class="Comment">/* no unique check */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base-&gt;nKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workMem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortopt &amp; TUPLESORT_RANDOMACCESS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PARALLEL_SORT(coordinate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; base-&gt;removeabbrev = <a href="#L1208" title="utils/sort/tuplesortvariants.c:1208">removeabbrev_cluster</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;comparetup = <a href="#L1227" title="utils/sort/tuplesortvariants.c:1227">comparetup_cluster</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;comparetup_tiebreak = <a href="#L1248" title="utils/sort/tuplesortvariants.c:1248">comparetup_cluster_tiebreak</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;writetup = <a href="#L1355" title="utils/sort/tuplesortvariants.c:1355">writetup_cluster</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;readtup = <a href="#L1370" title="utils/sort/tuplesortvariants.c:1370">readtup_cluster</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;<a href="../../regex/regc_nfa.c.html#L242" title="regex/regc_nfa.c:242">freestate</a> = <a href="#L1399" title="utils/sort/tuplesortvariants.c:1399">freestate_cluster</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;arg = arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; arg-&gt;indexInfo = <a href="../../catalog/index.c.html#L2407" title="catalog/index.c:2407">BuildIndexInfo</a>(indexRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we don't have a simple leading attribute, we don't currently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> datum1, so disable optimizations that require it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (arg-&gt;indexInfo-&gt;ii_IndexAttrNumbers[<span class="Constant">0</span>] == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; base-&gt;haveDatum1 = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; base-&gt;haveDatum1 = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; arg-&gt;tupDesc = tupDesc;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* assume we need not copy tupDesc */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; indexScanKey = <a href="../../access/nbtree/nbtutils.c.html#L129" title="access/nbtree/nbtutils.c:129">_bt_mkscankey</a>(indexRel, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg-&gt;indexInfo-&gt;ii_Expressions != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We will need to use <a href="../../catalog/index.c.html#L2705" title="catalog/index.c:2705">FormIndexDatum</a> to evaluate the index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expressions.&nbsp; To do that, we need an EState, as well as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TupleTableSlot to put the table tuples into.&nbsp; The econtext's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scantuple has to point to that slot, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; arg-&gt;estate = <a href="../../executor/execUtils.c.html#L88" title="executor/execUtils.c:88">CreateExecutorState</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot = <a href="../../executor/execTuples.c.html#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>(tupDesc, &amp;<a href="../../executor/execTuples.c.html#L85" title="executor/execTuples.c:85">TTSOpsHeapTuple</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; econtext = GetPerTupleExprContext(arg-&gt;estate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;ecxt_scantuple = slot;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare SortSupport data for each column */<br/></li>
<li></span>&nbsp; &nbsp; base-&gt;sortKeys = (SortSupport) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(base-&gt;nKeys *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortSupportData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; base-&gt;nKeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortSupport sortKey = base-&gt;sortKeys + i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; scanKey = indexScanKey-&gt;scankeys + i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; strategy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_cxt = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_collation = scanKey-&gt;sk_collation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_nulls_first =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (scanKey-&gt;sk_flags &amp; SK_BT_NULLS_FIRST) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_attno = scanKey-&gt;sk_attno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Convey if abbreviation optimization is applicable in principle */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;abbreviate = (i == <span class="Constant">0</span> &amp;&amp; base-&gt;haveDatum1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(sortKey-&gt;ssup_attno != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strategy = (scanKey-&gt;sk_flags &amp; SK_BT_DESC) != <span class="Constant">0</span> ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTGreaterStrategyNumber : BTLessStrategyNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="sortsupport.c.html#L161" title="utils/sort/sortsupport.c:161">PrepareSortSupportFromIndexRel</a>(indexRel, strategy, sortKey);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(indexScanKey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *<br/></li>
<li><a id="L352">&#x200c;</a><span class="linkable">tuplesort_begin_index_btree</span>(Relation heapRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation indexRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> enforceUnique,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> uniqueNullsNotDistinct,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> workMem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortCoordinate coordinate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> sortopt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state = <a href="tuplesort.c.html#L645" title="utils/sort/tuplesort.c:645">tuplesort_begin_common</a>(workMem, coordinate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sortopt);<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; BTScanInsert indexScanKey;<br/></li>
<li>&nbsp; &nbsp; <a href="#L126" title="utils/sort/tuplesortvariants.c:126">TuplesortIndexBTreeArg</a> *arg;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(base-&gt;maincontext);<br/></li>
<li>&nbsp; &nbsp; arg = (<a href="#L126" title="utils/sort/tuplesortvariants.c:126">TuplesortIndexBTreeArg</a> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L126" title="utils/sort/tuplesortvariants.c:126">TuplesortIndexBTreeArg</a>));<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="tuplesort.c.html#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;begin index sort: unique = </span><span class="Special">%c</span><span class="Constant">, workMem = </span><span class="Special">%d</span><span class="Constant">, randomAccess = </span><span class="Special">%c</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; enforceUnique ? <span class="Constant">'t'</span> : <span class="Constant">'f'</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; workMem, sortopt &amp; TUPLESORT_RANDOMACCESS ? <span class="Constant">'t'</span> : <span class="Constant">'f'</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; base-&gt;nKeys = IndexRelationGetNumberOfKeyAttributes(indexRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_SORT_START(<a href="#L37" title="utils/sort/tuplesortvariants.c:37">INDEX_SORT</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; enforceUnique,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base-&gt;nKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workMem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortopt &amp; TUPLESORT_RANDOMACCESS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PARALLEL_SORT(coordinate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; base-&gt;removeabbrev = <a href="#L1423" title="utils/sort/tuplesortvariants.c:1423">removeabbrev_index</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;comparetup = <a href="#L1442" title="utils/sort/tuplesortvariants.c:1442">comparetup_index_btree</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;comparetup_tiebreak = <a href="#L1466" title="utils/sort/tuplesortvariants.c:1466">comparetup_index_btree_tiebreak</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;writetup = <a href="#L1673" title="utils/sort/tuplesortvariants.c:1673">writetup_index</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;readtup = <a href="#L1687" title="utils/sort/tuplesortvariants.c:1687">readtup_index</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;haveDatum1 = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;arg = arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; arg-&gt;index.heapRel = heapRel;<br/></li>
<li>&nbsp; &nbsp; arg-&gt;index.indexRel = indexRel;<br/></li>
<li>&nbsp; &nbsp; arg-&gt;enforceUnique = enforceUnique;<br/></li>
<li>&nbsp; &nbsp; arg-&gt;uniqueNullsNotDistinct = uniqueNullsNotDistinct;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indexScanKey = <a href="../../access/nbtree/nbtutils.c.html#L129" title="access/nbtree/nbtutils.c:129">_bt_mkscankey</a>(indexRel, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare SortSupport data for each column */<br/></li>
<li></span>&nbsp; &nbsp; base-&gt;sortKeys = (SortSupport) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(base-&gt;nKeys *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortSupportData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; base-&gt;nKeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortSupport sortKey = base-&gt;sortKeys + i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; scanKey = indexScanKey-&gt;scankeys + i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; strategy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_cxt = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_collation = scanKey-&gt;sk_collation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_nulls_first =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (scanKey-&gt;sk_flags &amp; SK_BT_NULLS_FIRST) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_attno = scanKey-&gt;sk_attno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Convey if abbreviation optimization is applicable in principle */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;abbreviate = (i == <span class="Constant">0</span> &amp;&amp; base-&gt;haveDatum1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(sortKey-&gt;ssup_attno != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strategy = (scanKey-&gt;sk_flags &amp; SK_BT_DESC) != <span class="Constant">0</span> ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTGreaterStrategyNumber : BTLessStrategyNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="sortsupport.c.html#L161" title="utils/sort/sortsupport.c:161">PrepareSortSupportFromIndexRel</a>(indexRel, strategy, sortKey);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(indexScanKey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *<br/></li>
<li><a id="L437">&#x200c;</a><span class="linkable">tuplesort_begin_index_hash</span>(Relation heapRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation indexRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 high_mask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 low_mask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 max_buckets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> workMem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SortCoordinate coordinate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> sortopt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state = <a href="tuplesort.c.html#L645" title="utils/sort/tuplesort.c:645">tuplesort_begin_common</a>(workMem, coordinate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sortopt);<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; <a href="#L138" title="utils/sort/tuplesortvariants.c:138">TuplesortIndexHashArg</a> *arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(base-&gt;maincontext);<br/></li>
<li>&nbsp; &nbsp; arg = (<a href="#L138" title="utils/sort/tuplesortvariants.c:138">TuplesortIndexHashArg</a> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L138" title="utils/sort/tuplesortvariants.c:138">TuplesortIndexHashArg</a>));<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="tuplesort.c.html#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;begin index sort: high_mask = 0x</span><span class="Special">%x</span><span class="Constant">, low_mask = 0x</span><span class="Special">%x</span><span class="Constant">, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;max_buckets = 0x</span><span class="Special">%x</span><span class="Constant">, workMem = </span><span class="Special">%d</span><span class="Constant">, randomAccess = </span><span class="Special">%c</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; high_mask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; low_mask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; max_buckets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; workMem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sortopt &amp; TUPLESORT_RANDOMACCESS ? <span class="Constant">'t'</span> : <span class="Constant">'f'</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; base-&gt;nKeys = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Only one sort column, the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; base-&gt;removeabbrev = <a href="#L1423" title="utils/sort/tuplesortvariants.c:1423">removeabbrev_index</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;comparetup = <a href="#L1588" title="utils/sort/tuplesortvariants.c:1588">comparetup_index_hash</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;comparetup_tiebreak = <a href="#L1664" title="utils/sort/tuplesortvariants.c:1664">comparetup_index_hash_tiebreak</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;writetup = <a href="#L1673" title="utils/sort/tuplesortvariants.c:1673">writetup_index</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;readtup = <a href="#L1687" title="utils/sort/tuplesortvariants.c:1687">readtup_index</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;haveDatum1 = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;arg = arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; arg-&gt;index.heapRel = heapRel;<br/></li>
<li>&nbsp; &nbsp; arg-&gt;index.indexRel = indexRel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; arg-&gt;high_mask = high_mask;<br/></li>
<li>&nbsp; &nbsp; arg-&gt;low_mask = low_mask;<br/></li>
<li>&nbsp; &nbsp; arg-&gt;max_buckets = max_buckets;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *<br/></li>
<li><a id="L490">&#x200c;</a><span class="linkable">tuplesort_begin_index_gist</span>(Relation heapRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation indexRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> workMem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SortCoordinate coordinate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> sortopt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state = <a href="tuplesort.c.html#L645" title="utils/sort/tuplesort.c:645">tuplesort_begin_common</a>(workMem, coordinate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sortopt);<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; <a href="#L126" title="utils/sort/tuplesortvariants.c:126">TuplesortIndexBTreeArg</a> *arg;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(base-&gt;maincontext);<br/></li>
<li>&nbsp; &nbsp; arg = (<a href="#L126" title="utils/sort/tuplesortvariants.c:126">TuplesortIndexBTreeArg</a> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L126" title="utils/sort/tuplesortvariants.c:126">TuplesortIndexBTreeArg</a>));<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="tuplesort.c.html#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;begin index sort: workMem = </span><span class="Special">%d</span><span class="Constant">, randomAccess = </span><span class="Special">%c</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; workMem, sortopt &amp; TUPLESORT_RANDOMACCESS ? <span class="Constant">'t'</span> : <span class="Constant">'f'</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; base-&gt;nKeys = IndexRelationGetNumberOfKeyAttributes(indexRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; base-&gt;removeabbrev = <a href="#L1423" title="utils/sort/tuplesortvariants.c:1423">removeabbrev_index</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;comparetup = <a href="#L1442" title="utils/sort/tuplesortvariants.c:1442">comparetup_index_btree</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;comparetup_tiebreak = <a href="#L1466" title="utils/sort/tuplesortvariants.c:1466">comparetup_index_btree_tiebreak</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;writetup = <a href="#L1673" title="utils/sort/tuplesortvariants.c:1673">writetup_index</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;readtup = <a href="#L1687" title="utils/sort/tuplesortvariants.c:1687">readtup_index</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;haveDatum1 = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;arg = arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; arg-&gt;index.heapRel = heapRel;<br/></li>
<li>&nbsp; &nbsp; arg-&gt;index.indexRel = indexRel;<br/></li>
<li>&nbsp; &nbsp; arg-&gt;enforceUnique = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; arg-&gt;uniqueNullsNotDistinct = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare SortSupport data for each column */<br/></li>
<li></span>&nbsp; &nbsp; base-&gt;sortKeys = (SortSupport) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(base-&gt;nKeys *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortSupportData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; base-&gt;nKeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortSupport sortKey = base-&gt;sortKeys + i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_cxt = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_collation = indexRel-&gt;rd_indcollation[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_nulls_first = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_attno = i + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Convey if abbreviation optimization is applicable in principle */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;abbreviate = (i == <span class="Constant">0</span> &amp;&amp; base-&gt;haveDatum1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(sortKey-&gt;ssup_attno != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Look for a sort support function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="sortsupport.c.html#L188" title="utils/sort/sortsupport.c:188">PrepareSortSupportFromGistIndexRel</a>(indexRel, sortKey);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *<br/></li>
<li><a id="L555">&#x200c;</a><span class="linkable">tuplesort_begin_index_brin</span>(<span class="Type">int</span> workMem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SortCoordinate coordinate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> sortopt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state = <a href="tuplesort.c.html#L645" title="utils/sort/tuplesort.c:645">tuplesort_begin_common</a>(workMem, coordinate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sortopt);<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="tuplesort.c.html#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;begin index sort: workMem = </span><span class="Special">%d</span><span class="Constant">, randomAccess = </span><span class="Special">%c</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; workMem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sortopt &amp; TUPLESORT_RANDOMACCESS ? <span class="Constant">'t'</span> : <span class="Constant">'f'</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; base-&gt;nKeys = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Only one sort column, the block number */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; base-&gt;removeabbrev = <a href="#L1711" title="utils/sort/tuplesortvariants.c:1711">removeabbrev_index_brin</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;comparetup = <a href="#L1725" title="utils/sort/tuplesortvariants.c:1725">comparetup_index_brin</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;writetup = <a href="#L1741" title="utils/sort/tuplesortvariants.c:1741">writetup_index_brin</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;readtup = <a href="#L1755" title="utils/sort/tuplesortvariants.c:1755">readtup_index_brin</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;haveDatum1 = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;arg = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *<br/></li>
<li><a id="L584">&#x200c;</a><span class="linkable">tuplesort_begin_datum</span>(Oid datumType, Oid sortOperator, Oid sortCollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nullsFirstFlag, <span class="Type">int</span> workMem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortCoordinate coordinate, <span class="Type">int</span> sortopt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state = <a href="tuplesort.c.html#L645" title="utils/sort/tuplesort.c:645">tuplesort_begin_common</a>(workMem, coordinate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sortopt);<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; <a href="#L150" title="utils/sort/tuplesortvariants.c:150">TuplesortDatumArg</a> *arg;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(base-&gt;maincontext);<br/></li>
<li>&nbsp; &nbsp; arg = (<a href="#L150" title="utils/sort/tuplesortvariants.c:150">TuplesortDatumArg</a> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L150" title="utils/sort/tuplesortvariants.c:150">TuplesortDatumArg</a>));<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="tuplesort.c.html#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;begin datum sort: workMem = </span><span class="Special">%d</span><span class="Constant">, randomAccess = </span><span class="Special">%c</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; workMem, sortopt &amp; TUPLESORT_RANDOMACCESS ? <span class="Constant">'t'</span> : <span class="Constant">'f'</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; base-&gt;nKeys = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* always a one-column sort */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_SORT_START(<a href="#L38" title="utils/sort/tuplesortvariants.c:38">DATUM_SORT</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,&nbsp; &nbsp; <span class="Comment">/* no unique check */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workMem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortopt &amp; TUPLESORT_RANDOMACCESS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PARALLEL_SORT(coordinate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; base-&gt;removeabbrev = <a href="#L1785" title="utils/sort/tuplesortvariants.c:1785">removeabbrev_datum</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;comparetup = <a href="#L1794" title="utils/sort/tuplesortvariants.c:1794">comparetup_datum</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;comparetup_tiebreak = <a href="#L1809" title="utils/sort/tuplesortvariants.c:1809">comparetup_datum_tiebreak</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;writetup = <a href="#L1824" title="utils/sort/tuplesortvariants.c:1824">writetup_datum</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;readtup = <a href="#L1858" title="utils/sort/tuplesortvariants.c:1858">readtup_datum</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;haveDatum1 = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;arg = arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; arg-&gt;datumType = datumType;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* lookup necessary attributes of the datum type */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2251" title="utils/cache/lsyscache.c:2251">get_typlenbyval</a>(datumType, &amp;typlen, &amp;typbyval);<br/></li>
<li>&nbsp; &nbsp; arg-&gt;datumTypeLen = typlen;<br/></li>
<li>&nbsp; &nbsp; base-&gt;tuples = !typbyval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare SortSupport data */<br/></li>
<li></span>&nbsp; &nbsp; base-&gt;sortKeys = (SortSupport) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortSupportData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; base-&gt;sortKeys-&gt;ssup_cxt = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; base-&gt;sortKeys-&gt;ssup_collation = sortCollation;<br/></li>
<li>&nbsp; &nbsp; base-&gt;sortKeys-&gt;ssup_nulls_first = nullsFirstFlag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Abbreviation is possible here only for by-reference types.&nbsp; In theory,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a pass-by-value datatype could have an abbreviated form that is cheaper<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>.&nbsp; In a tuple sort, we could support that, because we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * always extract the original datum from the tuple as needed.&nbsp; Here, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't, because a datum sort only stores a single copy of the datum; the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;tuple&quot; field of each SortTuple is NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; base-&gt;sortKeys-&gt;abbreviate = !typbyval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="sortsupport.c.html#L134" title="utils/sort/sortsupport.c:134">PrepareSortSupportFromOrderingOp</a>(sortOperator, base-&gt;sortKeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The &quot;onlyKey&quot; optimization cannot be used with abbreviated keys, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tie-breaker comparisons may be required.&nbsp; Typically, the optimization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is only of value to pass-by-value types anyway, whereas abbreviated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keys are typically only of value to pass-by-reference types.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!base-&gt;sortKeys-&gt;abbrev_converter)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; base-&gt;onlyKey = base-&gt;sortKeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Accept one tuple while collecting input data for sort.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the input data is always copied; the caller need not save it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L669">&#x200c;</a></span><span class="linkable">tuplesort_puttupleslot</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext = MemoryContextSwitchTo(base-&gt;tuplecontext);<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc = (TupleDesc) base-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; SortTuple&nbsp; &nbsp; stup;<br/></li>
<li>&nbsp; &nbsp; MinimalTuple tuple;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData htup;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; tuplen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy the tuple into sort storage */<br/></li>
<li></span>&nbsp; &nbsp; tuple = ExecCopySlotMinimalTuple(slot);<br/></li>
<li>&nbsp; &nbsp; stup.tuple = (<span class="Type">void</span> *) tuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set up first-column key value */<br/></li>
<li></span>&nbsp; &nbsp; htup.t_len = tuple-&gt;t_len + MINIMAL_TUPLE_OFFSET;<br/></li>
<li>&nbsp; &nbsp; htup.t_data = (HeapTupleHeader) ((<span class="Type">char</span> *) tuple - MINIMAL_TUPLE_OFFSET);<br/></li>
<li>&nbsp; &nbsp; stup.datum1 = heap_getattr(&amp;htup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; base-&gt;sortKeys[<span class="Constant">0</span>].ssup_attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;stup.isnull1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a> is not supported for bump contexts */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TupleSortUseBumpTupleCxt(base-&gt;sortopt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuplen = MAXALIGN(tuple-&gt;t_len);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuplen = <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="tuplesort.c.html#L1189" title="utils/sort/tuplesort.c:1189">tuplesort_puttuple_common</a>(state, &amp;stup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base-&gt;sortKeys-&gt;abbrev_converter &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !stup.isnull1, tuplen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Accept one tuple while collecting input data for sort.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the input data is always copied; the caller need not save it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L709">&#x200c;</a></span><span class="linkable">tuplesort_putheaptuple</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, HeapTuple tup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortTuple&nbsp; &nbsp; stup;<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext = MemoryContextSwitchTo(base-&gt;tuplecontext);<br/></li>
<li>&nbsp; &nbsp; <a href="#L105" title="utils/sort/tuplesortvariants.c:105">TuplesortClusterArg</a> *arg = (<a href="#L105" title="utils/sort/tuplesortvariants.c:105">TuplesortClusterArg</a> *) base-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; tuplen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy the tuple into sort storage */<br/></li>
<li></span>&nbsp; &nbsp; tup = <a href="../../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(tup);<br/></li>
<li>&nbsp; &nbsp; stup.tuple = (<span class="Type">void</span> *) tup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set up first-column key value, and potentially abbreviate, if it's a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * simple column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (base-&gt;haveDatum1)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stup.datum1 = heap_getattr(tup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; arg-&gt;indexInfo-&gt;ii_IndexAttrNumbers[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; arg-&gt;tupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;stup.isnull1);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a> is not supported for bump contexts */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TupleSortUseBumpTupleCxt(base-&gt;sortopt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuplen = MAXALIGN(HEAPTUPLESIZE + tup-&gt;t_len);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuplen = <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="tuplesort.c.html#L1189" title="utils/sort/tuplesort.c:1189">tuplesort_puttuple_common</a>(state, &amp;stup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base-&gt;haveDatum1 &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base-&gt;sortKeys-&gt;abbrev_converter &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !stup.isnull1, tuplen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Collect one index tuple while collecting input data for sort, building<br/></li>
<li></span><span class="Comment"> * it from caller-supplied <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L752">&#x200c;</a></span><span class="linkable">tuplesort_putindextuplevalues</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointer self, <span class="Type">const</span> Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortTuple&nbsp; &nbsp; stup;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; <a href="#L115" title="utils/sort/tuplesortvariants.c:115">TuplesortIndexArg</a> *arg = (<a href="#L115" title="utils/sort/tuplesortvariants.c:115">TuplesortIndexArg</a> *) base-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; tuplen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stup.tuple = <a href="../../access/common/indextuple.c.html#L65" title="access/common/indextuple.c:65">index_form_tuple_context</a>(RelationGetDescr(rel), <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull, base-&gt;tuplecontext);<br/></li>
<li>&nbsp; &nbsp; tuple = ((IndexTuple) stup.tuple);<br/></li>
<li>&nbsp; &nbsp; tuple-&gt;t_tid = *self;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set up first-column key value */<br/></li>
<li></span>&nbsp; &nbsp; stup.datum1 = index_getattr(tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetDescr(arg-&gt;indexRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;stup.isnull1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a> is not supported for bump contexts */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TupleSortUseBumpTupleCxt(base-&gt;sortopt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuplen = MAXALIGN(tuple-&gt;t_info &amp; INDEX_SIZE_MASK);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuplen = <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="tuplesort.c.html#L1189" title="utils/sort/tuplesort.c:1189">tuplesort_puttuple_common</a>(state, &amp;stup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base-&gt;sortKeys &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base-&gt;sortKeys-&gt;abbrev_converter &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !stup.isnull1, tuplen);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Collect one BRIN tuple while collecting input data for sort.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L788">&#x200c;</a></span><span class="linkable">tuplesort_putbrintuple</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, BrinTuple *tuple, Size size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortTuple&nbsp; &nbsp; stup;<br/></li>
<li>&nbsp; &nbsp; <a href="#L157" title="utils/sort/tuplesortvariants.c:157">BrinSortTuple</a> *bstup;<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext = MemoryContextSwitchTo(base-&gt;tuplecontext);<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; tuplen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allocate space for the whole BRIN sort tuple */<br/></li>
<li></span>&nbsp; &nbsp; bstup = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<a href="#L164" title="utils/sort/tuplesortvariants.c:164">BRINSORTTUPLE_SIZE</a>(size));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bstup-&gt;tuplen = size;<br/></li>
<li>&nbsp; &nbsp; memcpy(&amp;bstup-&gt;tuple, tuple, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stup.tuple = bstup;<br/></li>
<li>&nbsp; &nbsp; stup.datum1 = tuple-&gt;bt_blkno;<br/></li>
<li>&nbsp; &nbsp; stup.isnull1 = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a> is not supported for bump contexts */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TupleSortUseBumpTupleCxt(base-&gt;sortopt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuplen = MAXALIGN(<a href="#L164" title="utils/sort/tuplesortvariants.c:164">BRINSORTTUPLE_SIZE</a>(size));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuplen = <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>(bstup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="tuplesort.c.html#L1189" title="utils/sort/tuplesort.c:1189">tuplesort_puttuple_common</a>(state, &amp;stup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base-&gt;sortKeys &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base-&gt;sortKeys-&gt;abbrev_converter &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !stup.isnull1, tuplen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Accept one Datum while collecting input data for sort.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the Datum is pass-by-ref type, the value will be copied.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L826">&#x200c;</a></span><span class="linkable">tuplesort_putdatum</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, Datum val, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isNull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext = MemoryContextSwitchTo(base-&gt;tuplecontext);<br/></li>
<li>&nbsp; &nbsp; <a href="#L150" title="utils/sort/tuplesortvariants.c:150">TuplesortDatumArg</a> *arg = (<a href="#L150" title="utils/sort/tuplesortvariants.c:150">TuplesortDatumArg</a> *) base-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; SortTuple&nbsp; &nbsp; stup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Pass-by-value types or null <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are just stored directly in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stup.datum1 (and stup.tuple is not used and set to NULL).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Non-null pass-by-reference <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> need to be copied into memory we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * control, and possibly abbreviated. The copied value is pointed to by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stup.tuple and is treated as the canonical copy (e.g. to return via<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1018" title="utils/sort/tuplesortvariants.c:1018">tuplesort_getdatum</a> or when writing to tape); stup.datum1 gets the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * abbreviated value if abbreviation is happening, otherwise it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * identical to stup.tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isNull || !base-&gt;tuples)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set datum1 to zeroed representation for NULLs (to be consistent,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and to support cheap inequality tests for NULL abbreviated keys).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stup.datum1 = !isNull ? val : (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stup.isnull1 = isNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stup.tuple = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no separate storage */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stup.isnull1 = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stup.datum1 = <a href="../adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(val, <span class="Constant">false</span>, arg-&gt;datumTypeLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stup.tuple = DatumGetPointer(stup.datum1);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="tuplesort.c.html#L1189" title="utils/sort/tuplesort.c:1189">tuplesort_puttuple_common</a>(state, &amp;stup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base-&gt;tuples &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base-&gt;sortKeys-&gt;abbrev_converter &amp;&amp; !isNull, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple in either forward or back direction.<br/></li>
<li></span><span class="Comment"> * If successful, put tuple in slot and return true; else, clear the slot<br/></li>
<li></span><span class="Comment"> * and return false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller may optionally be passed back abbreviated value (on true return<br/></li>
<li></span><span class="Comment"> * value) when abbreviation was used, which can be used to cheaply avoid<br/></li>
<li></span><span class="Comment"> * equality checks that might otherwise be required.&nbsp; Caller can safely make a<br/></li>
<li></span><span class="Comment"> * determination of &quot;non-<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> tuple&quot; based on simple binary inequality.&nbsp; A<br/></li>
<li></span><span class="Comment"> * NULL value in leading attribute will set abbreviated value to zeroed<br/></li>
<li></span><span class="Comment"> * representation, which caller may rely on in abbreviated inequality check.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If copy is true, the slot receives a tuple that's been copied into the<br/></li>
<li></span><span class="Comment"> * caller's memory context, so that it will stay valid regardless of future<br/></li>
<li></span><span class="Comment"> * manipulations of the tuplesort's state (up to and including deleting the<br/></li>
<li></span><span class="Comment"> * tuplesort).&nbsp; If copy is false, the slot will just receive a pointer to a<br/></li>
<li></span><span class="Comment"> * tuple held within the tuplesort, which is more efficient, but only safe for<br/></li>
<li></span><span class="Comment"> * callers that are prepared to have <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subsequent manipulation of the<br/></li>
<li></span><span class="Comment"> * tuplesort's state invalidate slot contents.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L890">&#x200c;</a></span><span class="linkable">tuplesort_gettupleslot</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forward, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> copy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *slot, Datum *abbrev)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext = MemoryContextSwitchTo(base-&gt;sortcontext);<br/></li>
<li>&nbsp; &nbsp; SortTuple&nbsp; &nbsp; stup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="tuplesort.c.html#L1496" title="utils/sort/tuplesort.c:1496">tuplesort_gettuple_common</a>(state, forward, &amp;stup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stup.tuple = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stup.tuple)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Record abbreviated key for caller */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (base-&gt;sortKeys-&gt;abbrev_converter &amp;&amp; abbrev)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *abbrev = stup.datum1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (copy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stup.tuple = <a href="../../access/common/heaptuple.c.html#L1535" title="access/common/heaptuple.c:1535">heap_copy_minimal_tuple</a>((MinimalTuple) stup.tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execTuples.c.html#L1533" title="executor/execTuples.c:1533">ExecStoreMinimalTuple</a>((MinimalTuple) stup.tuple, slot, copy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple in either forward or back direction.<br/></li>
<li></span><span class="Comment"> * Returns NULL if no more tuples.&nbsp; Returned tuple belongs to tuplesort memory<br/></li>
<li></span><span class="Comment"> * context, and must not be freed by caller.&nbsp; Caller may not rely on tuple<br/></li>
<li></span><span class="Comment"> * remaining valid after <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> further manipulation of tuplesort.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>HeapTuple<br/></li>
<li><a id="L928">&#x200c;</a><span class="linkable">tuplesort_getheaptuple</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forward)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext = MemoryContextSwitchTo(base-&gt;sortcontext);<br/></li>
<li>&nbsp; &nbsp; SortTuple&nbsp; &nbsp; stup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="tuplesort.c.html#L1496" title="utils/sort/tuplesort.c:1496">tuplesort_gettuple_common</a>(state, forward, &amp;stup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stup.tuple = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> stup.tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> index tuple in either forward or back direction.<br/></li>
<li></span><span class="Comment"> * Returns NULL if no more tuples.&nbsp; Returned tuple belongs to tuplesort memory<br/></li>
<li></span><span class="Comment"> * context, and must not be freed by caller.&nbsp; Caller may not rely on tuple<br/></li>
<li></span><span class="Comment"> * remaining valid after <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> further manipulation of tuplesort.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexTuple<br/></li>
<li><a id="L949">&#x200c;</a><span class="linkable">tuplesort_getindextuple</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forward)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext = MemoryContextSwitchTo(base-&gt;sortcontext);<br/></li>
<li>&nbsp; &nbsp; SortTuple&nbsp; &nbsp; stup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="tuplesort.c.html#L1496" title="utils/sort/tuplesort.c:1496">tuplesort_gettuple_common</a>(state, forward, &amp;stup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stup.tuple = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (IndexTuple) stup.tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> BRIN tuple in either forward or back direction.<br/></li>
<li></span><span class="Comment"> * Returns NULL if no more tuples.&nbsp; Returned tuple belongs to tuplesort memory<br/></li>
<li></span><span class="Comment"> * context, and must not be freed by caller.&nbsp; Caller may not rely on tuple<br/></li>
<li></span><span class="Comment"> * remaining valid after <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> further manipulation of tuplesort.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BrinTuple *<br/></li>
<li><a id="L970">&#x200c;</a><span class="linkable">tuplesort_getbrintuple</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, Size *len, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forward)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext = MemoryContextSwitchTo(base-&gt;sortcontext);<br/></li>
<li>&nbsp; &nbsp; SortTuple&nbsp; &nbsp; stup;<br/></li>
<li>&nbsp; &nbsp; <a href="#L157" title="utils/sort/tuplesortvariants.c:157">BrinSortTuple</a> *btup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="tuplesort.c.html#L1496" title="utils/sort/tuplesort.c:1496">tuplesort_gettuple_common</a>(state, forward, &amp;stup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stup.tuple = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!stup.tuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; btup = (<a href="#L157" title="utils/sort/tuplesortvariants.c:157">BrinSortTuple</a> *) stup.tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *len = btup-&gt;tuplen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> &amp;btup-&gt;tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> Datum in either forward or back direction.<br/></li>
<li></span><span class="Comment"> * Returns false if no more datums.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the Datum is pass-by-ref type, the returned value is freshly <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d<br/></li>
<li></span><span class="Comment"> * in caller's context, and is <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> owned by the caller (this differs from<br/></li>
<li></span><span class="Comment"> * similar routines for other types of tuplesorts).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller may optionally be passed back abbreviated value (on true return<br/></li>
<li></span><span class="Comment"> * value) when abbreviation was used, which can be used to cheaply avoid<br/></li>
<li></span><span class="Comment"> * equality checks that might otherwise be required.&nbsp; Caller can safely make a<br/></li>
<li></span><span class="Comment"> * determination of &quot;non-<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> tuple&quot; based on simple binary inequality.&nbsp; A<br/></li>
<li></span><span class="Comment"> * NULL value will have a zeroed abbreviated value representation, which caller<br/></li>
<li></span><span class="Comment"> * may rely on in abbreviated inequality check.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For byref Datums, if copy is true, *val is set to a copy of the Datum<br/></li>
<li></span><span class="Comment"> * copied into the caller's memory context, so that it will stay valid<br/></li>
<li></span><span class="Comment"> * regardless of future manipulations of the tuplesort's state (up to and<br/></li>
<li></span><span class="Comment"> * including deleting the tuplesort).&nbsp; If copy is false, *val will just be<br/></li>
<li></span><span class="Comment"> * set to a pointer to the Datum held within the tuplesort, which is more<br/></li>
<li></span><span class="Comment"> * efficient, but only safe for callers that are prepared to have <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * subsequent manipulation of the tuplesort's state invalidate slot contents.<br/></li>
<li></span><span class="Comment"> * For byval Datums, the value of the 'copy' parameter has no effect.<br/></li>
<li></span><br/></li>
<li><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1018">&#x200c;</a></span><span class="linkable">tuplesort_getdatum</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forward, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> copy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *val, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isNull, Datum *abbrev)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext = MemoryContextSwitchTo(base-&gt;sortcontext);<br/></li>
<li>&nbsp; &nbsp; <a href="#L150" title="utils/sort/tuplesortvariants.c:150">TuplesortDatumArg</a> *arg = (<a href="#L150" title="utils/sort/tuplesortvariants.c:150">TuplesortDatumArg</a> *) base-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; SortTuple&nbsp; &nbsp; stup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="tuplesort.c.html#L1496" title="utils/sort/tuplesort.c:1496">tuplesort_gettuple_common</a>(state, forward, &amp;stup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure we copy into caller's memory context */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Record abbreviated key for caller */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (base-&gt;sortKeys-&gt;abbrev_converter &amp;&amp; abbrev)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *abbrev = stup.datum1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stup.isnull1 || !base-&gt;tuples)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *val = stup.datum1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *isNull = stup.isnull1;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* use stup.tuple because stup.datum1 may be an abbreviation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (copy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *val = <a href="../adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(PointerGetDatum(stup.tuple), <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; arg-&gt;datumTypeLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *val = PointerGetDatum(stup.tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *isNull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Routines specialized for HeapTuple (actually MinimalTuple) case<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1064">&#x200c;</a></span><span class="linkable">removeabbrev_heap</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *stups, <span class="Type">int</span> count)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; count; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleData htup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup.t_len = ((MinimalTuple) stups[i].tuple)-&gt;t_len +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MINIMAL_TUPLE_OFFSET;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup.t_data = (HeapTupleHeader) ((<span class="Type">char</span> *) stups[i].tuple -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MINIMAL_TUPLE_OFFSET);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stups[i].datum1 = heap_getattr(&amp;htup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; base-&gt;sortKeys[<span class="Constant">0</span>].ssup_attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (TupleDesc) base-&gt;arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;stups[i].isnull1);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1085">&#x200c;</a></span><span class="linkable">comparetup_heap</span>(<span class="Type">const</span> SortTuple *a, <span class="Type">const</span> SortTuple *b, <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; SortSupport sortKey = base-&gt;sortKeys;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compare the leading sort key */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> = ApplySortComparator(a-&gt;datum1, a-&gt;isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b-&gt;datum1, b-&gt;isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortKey);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compare additional sort keys */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1104" title="utils/sort/tuplesortvariants.c:1104">comparetup_heap_tiebreak</a>(a, b, state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1104">&#x200c;</a></span><span class="linkable">comparetup_heap_tiebreak</span>(<span class="Type">const</span> SortTuple *a, <span class="Type">const</span> SortTuple *b, <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; SortSupport sortKey = base-&gt;sortKeys;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData ltup;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData rtup;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nkey;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attno;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ltup.t_len = ((MinimalTuple) a-&gt;tuple)-&gt;t_len + MINIMAL_TUPLE_OFFSET;<br/></li>
<li>&nbsp; &nbsp; ltup.t_data = (HeapTupleHeader) ((<span class="Type">char</span> *) a-&gt;tuple - MINIMAL_TUPLE_OFFSET);<br/></li>
<li>&nbsp; &nbsp; rtup.t_len = ((MinimalTuple) b-&gt;tuple)-&gt;t_len + MINIMAL_TUPLE_OFFSET;<br/></li>
<li>&nbsp; &nbsp; rtup.t_data = (HeapTupleHeader) ((<span class="Type">char</span> *) b-&gt;tuple - MINIMAL_TUPLE_OFFSET);<br/></li>
<li>&nbsp; &nbsp; tupDesc = (TupleDesc) base-&gt;arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sortKey-&gt;abbrev_converter)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attno = sortKey-&gt;ssup_attno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum1 = heap_getattr(&amp;ltup, attno, tupDesc, &amp;isnull1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum2 = heap_getattr(&amp;rtup, attno, tupDesc, &amp;isnull2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> = ApplySortAbbrevFullComparator(datum1, isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum2, isnull2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortKey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sortKey++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (nkey = <span class="Constant">1</span>; nkey &lt; base-&gt;nKeys; nkey++, sortKey++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attno = sortKey-&gt;ssup_attno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum1 = heap_getattr(&amp;ltup, attno, tupDesc, &amp;isnull1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum2 = heap_getattr(&amp;rtup, attno, tupDesc, &amp;isnull2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> = ApplySortComparator(datum1, isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum2, isnull2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortKey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1158">&#x200c;</a></span><span class="linkable">writetup_heap</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape, SortTuple *stup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; MinimalTuple tuple = (MinimalTuple) stup-&gt;tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the part of the MinimalTuple we'll write: */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tupbody = (<span class="Type">char</span> *) tuple + MINIMAL_TUPLE_DATA_OFFSET;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> tupbodylen = tuple-&gt;t_len - MINIMAL_TUPLE_DATA_OFFSET;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* total on-disk footprint: */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> tuplen = tupbodylen + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="logtape.c.html#L761" title="utils/sort/logtape.c:761">LogicalTapeWrite</a>(tape, &amp;tuplen, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tuplen));<br/></li>
<li>&nbsp; &nbsp; <a href="logtape.c.html#L761" title="utils/sort/logtape.c:761">LogicalTapeWrite</a>(tape, tupbody, tupbodylen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (base-&gt;sortopt &amp; TUPLESORT_RANDOMACCESS) <span class="Comment">/* need trailing length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="logtape.c.html#L761" title="utils/sort/logtape.c:761">LogicalTapeWrite</a>(tape, &amp;tuplen, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tuplen));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1177">&#x200c;</a></span><span class="linkable">readtup_heap</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *stup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape, <span class="Type">unsigned</span> <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> tupbodylen = len - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> tuplen = tupbodylen + MINIMAL_TUPLE_DATA_OFFSET;<br/></li>
<li>&nbsp; &nbsp; MinimalTuple tuple = (MinimalTuple) <a href="tuplesort.c.html#L2921" title="utils/sort/tuplesort.c:2921">tuplesort_readtup_alloc</a>(state, tuplen);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tupbody = (<span class="Type">char</span> *) tuple + MINIMAL_TUPLE_DATA_OFFSET;<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; HeapTupleData htup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read in the tuple proper */<br/></li>
<li></span>&nbsp; &nbsp; tuple-&gt;t_len = tuplen;<br/></li>
<li>&nbsp; &nbsp; LogicalTapeReadExact(tape, tupbody, tupbodylen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (base-&gt;sortopt &amp; TUPLESORT_RANDOMACCESS) <span class="Comment">/* need trailing length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; LogicalTapeReadExact(tape, &amp;tuplen, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tuplen));<br/></li>
<li>&nbsp; &nbsp; stup-&gt;tuple = (<span class="Type">void</span> *) tuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set up first-column key value */<br/></li>
<li></span>&nbsp; &nbsp; htup.t_len = tuple-&gt;t_len + MINIMAL_TUPLE_OFFSET;<br/></li>
<li>&nbsp; &nbsp; htup.t_data = (HeapTupleHeader) ((<span class="Type">char</span> *) tuple - MINIMAL_TUPLE_OFFSET);<br/></li>
<li>&nbsp; &nbsp; stup-&gt;datum1 = heap_getattr(&amp;htup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base-&gt;sortKeys[<span class="Constant">0</span>].ssup_attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (TupleDesc) base-&gt;arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;stup-&gt;isnull1);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Routines specialized for the CLUSTER case (HeapTuple data, with<br/></li>
<li></span><span class="Comment"> * comparisons per a btree index definition)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1208">&#x200c;</a></span><span class="linkable">removeabbrev_cluster</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *stups, <span class="Type">int</span> count)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; <a href="#L105" title="utils/sort/tuplesortvariants.c:105">TuplesortClusterArg</a> *arg = (<a href="#L105" title="utils/sort/tuplesortvariants.c:105">TuplesortClusterArg</a> *) base-&gt;arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; count; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup = (HeapTuple) stups[i].tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stups[i].datum1 = heap_getattr(tup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; arg-&gt;indexInfo-&gt;ii_IndexAttrNumbers[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; arg-&gt;tupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;stups[i].isnull1);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1227">&#x200c;</a></span><span class="linkable">comparetup_cluster</span>(<span class="Type">const</span> SortTuple *a, <span class="Type">const</span> SortTuple *b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; SortSupport sortKey = base-&gt;sortKeys;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compare the leading sort key, if it's simple */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (base-&gt;haveDatum1)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> = ApplySortComparator(a-&gt;datum1, a-&gt;isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b-&gt;datum1, b-&gt;isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortKey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1248" title="utils/sort/tuplesortvariants.c:1248">comparetup_cluster_tiebreak</a>(a, b, state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1248">&#x200c;</a></span><span class="linkable">comparetup_cluster_tiebreak</span>(<span class="Type">const</span> SortTuple *a, <span class="Type">const</span> SortTuple *b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; <a href="#L105" title="utils/sort/tuplesortvariants.c:105">TuplesortClusterArg</a> *arg = (<a href="#L105" title="utils/sort/tuplesortvariants.c:105">TuplesortClusterArg</a> *) base-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; SortSupport sortKey = base-&gt;sortKeys;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; ltup;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; rtup;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nkey;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ltup = (HeapTuple) a-&gt;tuple;<br/></li>
<li>&nbsp; &nbsp; rtup = (HeapTuple) b-&gt;tuple;<br/></li>
<li>&nbsp; &nbsp; tupDesc = arg-&gt;tupDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compare the leading sort key, if it's simple */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (base-&gt;haveDatum1)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sortKey-&gt;abbrev_converter)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; leading = arg-&gt;indexInfo-&gt;ii_IndexAttrNumbers[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum1 = heap_getattr(ltup, leading, tupDesc, &amp;isnull1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum2 = heap_getattr(rtup, leading, tupDesc, &amp;isnull2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> = ApplySortAbbrevFullComparator(datum1, isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum2, isnull2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortKey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> != <span class="Constant">0</span> || base-&gt;nKeys == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compare additional columns the hard way */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sortKey++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nkey = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> all keys the hard way */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nkey = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg-&gt;indexInfo-&gt;ii_Expressions == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If not expression index, just <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the proper heap attrs */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; nkey &lt; base-&gt;nKeys; nkey++, sortKey++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attno = arg-&gt;indexInfo-&gt;ii_IndexAttrNumbers[nkey];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum1 = heap_getattr(ltup, attno, tupDesc, &amp;isnull1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum2 = heap_getattr(rtup, attno, tupDesc, &amp;isnull2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> = ApplySortComparator(datum1, isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum2, isnull2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortKey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the expression index case, compute the whole index tuple and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; It would perhaps be faster to compute only as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * many columns as we need to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>, but that would require<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * duplicating all the logic in <a href="../../catalog/index.c.html#L2705" title="catalog/index.c:2705">FormIndexDatum</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; l_index_values[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; l_index_isnull[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; r_index_values[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; r_index_isnull[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *ecxt_scantuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset context each time to prevent memory leakage */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ResetPerTupleExprContext(arg-&gt;estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ecxt_scantuple = GetPerTupleExprContext(arg-&gt;estate)-&gt;ecxt_scantuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execTuples.c.html#L1439" title="executor/execTuples.c:1439">ExecStoreHeapTuple</a>(ltup, ecxt_scantuple, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/index.c.html#L2705" title="catalog/index.c:2705">FormIndexDatum</a>(arg-&gt;indexInfo, ecxt_scantuple, arg-&gt;estate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; l_index_values, l_index_isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execTuples.c.html#L1439" title="executor/execTuples.c:1439">ExecStoreHeapTuple</a>(rtup, ecxt_scantuple, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/index.c.html#L2705" title="catalog/index.c:2705">FormIndexDatum</a>(arg-&gt;indexInfo, ecxt_scantuple, arg-&gt;estate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; r_index_values, r_index_isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; nkey &lt; base-&gt;nKeys; nkey++, sortKey++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> = ApplySortComparator(l_index_values[nkey],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l_index_isnull[nkey],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r_index_values[nkey],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r_index_isnull[nkey],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortKey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1355">&#x200c;</a></span><span class="linkable">writetup_cluster</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape, SortTuple *stup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple = (HeapTuple) stup-&gt;tuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> tuplen = tuple-&gt;t_len + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We need to store t_self, but not other fields of HeapTupleData */<br/></li>
<li></span>&nbsp; &nbsp; <a href="logtape.c.html#L761" title="utils/sort/logtape.c:761">LogicalTapeWrite</a>(tape, &amp;tuplen, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tuplen));<br/></li>
<li>&nbsp; &nbsp; <a href="logtape.c.html#L761" title="utils/sort/logtape.c:761">LogicalTapeWrite</a>(tape, &amp;tuple-&gt;t_self, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData));<br/></li>
<li>&nbsp; &nbsp; <a href="logtape.c.html#L761" title="utils/sort/logtape.c:761">LogicalTapeWrite</a>(tape, tuple-&gt;t_data, tuple-&gt;t_len);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (base-&gt;sortopt &amp; TUPLESORT_RANDOMACCESS) <span class="Comment">/* need trailing length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="logtape.c.html#L761" title="utils/sort/logtape.c:761">LogicalTapeWrite</a>(tape, &amp;tuplen, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tuplen));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1370">&#x200c;</a></span><span class="linkable">readtup_cluster</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *stup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape, <span class="Type">unsigned</span> <span class="Type">int</span> tuplen)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; <a href="#L105" title="utils/sort/tuplesortvariants.c:105">TuplesortClusterArg</a> *arg = (<a href="#L105" title="utils/sort/tuplesortvariants.c:105">TuplesortClusterArg</a> *) base-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> t_len = tuplen - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData) - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>);<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple = (HeapTuple) <a href="tuplesort.c.html#L2921" title="utils/sort/tuplesort.c:2921">tuplesort_readtup_alloc</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t_len + HEAPTUPLESIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reconstruct the HeapTupleData header */<br/></li>
<li></span>&nbsp; &nbsp; tuple-&gt;t_data = (HeapTupleHeader) ((<span class="Type">char</span> *) tuple + HEAPTUPLESIZE);<br/></li>
<li>&nbsp; &nbsp; tuple-&gt;t_len = t_len;<br/></li>
<li>&nbsp; &nbsp; LogicalTapeReadExact(tape, &amp;tuple-&gt;t_self, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We don't currently bother to reconstruct t_tableOid */<br/></li>
<li></span>&nbsp; &nbsp; tuple-&gt;t_tableOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Read in the tuple body */<br/></li>
<li></span>&nbsp; &nbsp; LogicalTapeReadExact(tape, tuple-&gt;t_data, tuple-&gt;t_len);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (base-&gt;sortopt &amp; TUPLESORT_RANDOMACCESS) <span class="Comment">/* need trailing length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; LogicalTapeReadExact(tape, &amp;tuplen, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tuplen));<br/></li>
<li>&nbsp; &nbsp; stup-&gt;tuple = (<span class="Type">void</span> *) tuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set up first-column key value, if it's a simple column */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (base-&gt;haveDatum1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stup-&gt;datum1 = heap_getattr(tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg-&gt;indexInfo-&gt;ii_IndexAttrNumbers[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg-&gt;tupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;stup-&gt;isnull1);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1399">&#x200c;</a></span><span class="linkable">freestate_cluster</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; <a href="#L105" title="utils/sort/tuplesortvariants.c:105">TuplesortClusterArg</a> *arg = (<a href="#L105" title="utils/sort/tuplesortvariants.c:105">TuplesortClusterArg</a> *) base-&gt;arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Free <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> execution state created for CLUSTER case */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (arg-&gt;estate != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExprContext *econtext = GetPerTupleExprContext(arg-&gt;estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execTuples.c.html#L1341" title="executor/execTuples.c:1341">ExecDropSingleTupleTableSlot</a>(econtext-&gt;ecxt_scantuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execUtils.c.html#L189" title="executor/execUtils.c:189">FreeExecutorState</a>(arg-&gt;estate);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Routines specialized for IndexTuple case<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The btree and <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> cases require separate comparison <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, but the<br/></li>
<li></span><span class="Comment"> * IndexTuple representation is the same so the copy/write/read support<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> can be shared.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1423">&#x200c;</a></span><span class="linkable">removeabbrev_index</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *stups, <span class="Type">int</span> count)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; <a href="#L115" title="utils/sort/tuplesortvariants.c:115">TuplesortIndexArg</a> *arg = (<a href="#L115" title="utils/sort/tuplesortvariants.c:115">TuplesortIndexArg</a> *) base-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; count; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = stups[i].tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stups[i].datum1 = index_getattr(tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetDescr(arg-&gt;indexRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;stups[i].isnull1);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1442">&#x200c;</a></span><span class="linkable">comparetup_index_btree</span>(<span class="Type">const</span> SortTuple *a, <span class="Type">const</span> SortTuple *b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is similar to <a href="#L1085" title="utils/sort/tuplesortvariants.c:1085">comparetup_heap</a>(), but expects index tuples.&nbsp; There<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is also special handling for enforcing uniqueness, and special<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * treatment for <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> keys at the end.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; SortSupport sortKey = base-&gt;sortKeys;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compare the leading sort key */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> = ApplySortComparator(a-&gt;datum1, a-&gt;isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b-&gt;datum1, b-&gt;isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortKey);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compare additional sort keys */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1466" title="utils/sort/tuplesortvariants.c:1466">comparetup_index_btree_tiebreak</a>(a, b, state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1466">&#x200c;</a></span><span class="linkable">comparetup_index_btree_tiebreak</span>(<span class="Type">const</span> SortTuple *a, <span class="Type">const</span> SortTuple *b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; <a href="#L126" title="utils/sort/tuplesortvariants.c:126">TuplesortIndexBTreeArg</a> *arg = (<a href="#L126" title="utils/sort/tuplesortvariants.c:126">TuplesortIndexBTreeArg</a> *) base-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; SortSupport sortKey = base-&gt;sortKeys;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; tuple1;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; tuple2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keysz;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; equal_hasnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nkey;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple1 = (IndexTuple) a-&gt;tuple;<br/></li>
<li>&nbsp; &nbsp; tuple2 = (IndexTuple) b-&gt;tuple;<br/></li>
<li>&nbsp; &nbsp; keysz = base-&gt;nKeys;<br/></li>
<li>&nbsp; &nbsp; tupDes = RelationGetDescr(arg-&gt;index.indexRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sortKey-&gt;abbrev_converter)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum1 = index_getattr(tuple1, <span class="Constant">1</span>, tupDes, &amp;isnull1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum2 = index_getattr(tuple2, <span class="Constant">1</span>, tupDes, &amp;isnull2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> = ApplySortAbbrevFullComparator(datum1, isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum2, isnull2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortKey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* they are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, so we only need to examine one null flag */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;isnull1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; equal_hasnull = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sortKey++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (nkey = <span class="Constant">2</span>; nkey &lt;= keysz; nkey++, sortKey++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum1 = index_getattr(tuple1, nkey, tupDes, &amp;isnull1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum2 = index_getattr(tuple2, nkey, tupDes, &amp;isnull2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> = ApplySortComparator(datum1, isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum2, isnull2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortKey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* done when we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> unequal attributes */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* they are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, so we only need to examine one null flag */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; equal_hasnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If btree has asked us to enforce uniqueness, complain if two <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuples are detected (unless there was at least one NULL field and NULLS<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NOT DISTINCT was not set).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is sufficient to make the test here, because if two tuples are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they *must* get compared at some stage of the sort --- otherwise the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sort algorithm wouldn't have checked whether one must appear <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (arg-&gt;enforceUnique &amp;&amp; !(!arg-&gt;uniqueNullsNotDistinct &amp;&amp; equal_hasnull))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *key_desc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Some rather brain-dead implementations of qsort (such as the one in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * QNX 4) will sometimes call the comparison routine to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * value to itself, but we always use our own implementation, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * does not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(tuple1 != tuple2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/indextuple.c.html#L456" title="access/common/indextuple.c:456">index_deform_tuple</a>(tuple1, tupDes, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key_desc = <a href="../../access/index/genam.c.html#L174" title="access/index/genam.c:174">BuildIndexValueDescription</a>(arg-&gt;index.indexRel, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNIQUE_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create unique index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(arg-&gt;index.indexRel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; key_desc ? <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Key </span><span class="Special">%s</span><span class="Constant"> is duplicated.&quot;</span>, key_desc) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Duplicate keys exist.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../cache/relcache.c.html#L5999" title="utils/cache/relcache.c:5999">errtableconstraint</a>(arg-&gt;index.heapRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(arg-&gt;index.indexRel))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, we sort on ItemPointer.&nbsp; This is required for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * btree indexes, since heap TID is treated as an implicit last key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attribute in order to ensure that all keys in the index are physically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unique.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blk1 = ItemPointerGetBlockNumber(&amp;tuple1-&gt;t_tid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blk2 = ItemPointerGetBlockNumber(&amp;tuple2-&gt;t_tid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blk1 != blk2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (blk1 &lt; blk2) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber pos1 = ItemPointerGetOffsetNumber(&amp;tuple1-&gt;t_tid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber pos2 = ItemPointerGetOffsetNumber(&amp;tuple2-&gt;t_tid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pos1 != pos2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (pos1 &lt; pos2) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ItemPointer <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> should never be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1588">&#x200c;</a></span><span class="linkable">comparetup_index_hash</span>(<span class="Type">const</span> SortTuple *a, <span class="Type">const</span> SortTuple *b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bucket&nbsp; &nbsp; &nbsp; &nbsp; bucket1;<br/></li>
<li>&nbsp; &nbsp; Bucket&nbsp; &nbsp; &nbsp; &nbsp; bucket2;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hash1;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hash2;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; tuple1;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; tuple2;<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; <a href="#L138" title="utils/sort/tuplesortvariants.c:138">TuplesortIndexHashArg</a> *arg = (<a href="#L138" title="utils/sort/tuplesortvariants.c:138">TuplesortIndexHashArg</a> *) base-&gt;arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> keys and mask off bits we don't want to sort by, so that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initial sort is just on the bucket number.&nbsp; We know that the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * column of the index tuple is the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!a-&gt;isnull1);<br/></li>
<li>&nbsp; &nbsp; bucket1 = <a href="../../access/hash/hashutil.c.html#L125" title="access/hash/hashutil.c:125">_hash_hashkey2bucket</a>(DatumGetUInt32(a-&gt;datum1),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; arg-&gt;max_buckets, arg-&gt;high_mask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; arg-&gt;low_mask);<br/></li>
<li>&nbsp; &nbsp; Assert(!b-&gt;isnull1);<br/></li>
<li>&nbsp; &nbsp; bucket2 = <a href="../../access/hash/hashutil.c.html#L125" title="access/hash/hashutil.c:125">_hash_hashkey2bucket</a>(DatumGetUInt32(b-&gt;datum1),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; arg-&gt;max_buckets, arg-&gt;high_mask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; arg-&gt;low_mask);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bucket1 &gt; bucket2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (bucket1 &lt; bucket2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If bucket <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, sort by <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; This allows us to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * insert directly onto bucket/overflow pages, where the index tuples are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stored in <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> order to allow fast binary search within each page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hash1 = DatumGetUInt32(a-&gt;datum1);<br/></li>
<li>&nbsp; &nbsp; hash2 = DatumGetUInt32(b-&gt;datum1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hash1 &gt; hash2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (hash1 &lt; hash2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, we sort on ItemPointer.&nbsp; This does not affect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * validity of the finished index, but it may be useful to have index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scans in physical order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tuple1 = (IndexTuple) a-&gt;tuple;<br/></li>
<li>&nbsp; &nbsp; tuple2 = (IndexTuple) b-&gt;tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blk1 = ItemPointerGetBlockNumber(&amp;tuple1-&gt;t_tid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blk2 = ItemPointerGetBlockNumber(&amp;tuple2-&gt;t_tid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blk1 != blk2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (blk1 &lt; blk2) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber pos1 = ItemPointerGetOffsetNumber(&amp;tuple1-&gt;t_tid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber pos2 = ItemPointerGetOffsetNumber(&amp;tuple2-&gt;t_tid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pos1 != pos2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (pos1 &lt; pos2) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ItemPointer <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> should never be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sorting for <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> indexes only uses one sort key, so this shouldn't ever be<br/></li>
<li></span><span class="Comment"> * called. It's only here for consistency.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1664">&#x200c;</a></span><span class="linkable">comparetup_index_hash_tiebreak</span>(<span class="Type">const</span> SortTuple *a, <span class="Type">const</span> SortTuple *b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1673">&#x200c;</a></span><span class="linkable">writetup_index</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape, SortTuple *stup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; tuple = (IndexTuple) stup-&gt;tuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> tuplen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuplen = IndexTupleSize(tuple) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tuplen);<br/></li>
<li>&nbsp; &nbsp; <a href="logtape.c.html#L761" title="utils/sort/logtape.c:761">LogicalTapeWrite</a>(tape, &amp;tuplen, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tuplen));<br/></li>
<li>&nbsp; &nbsp; <a href="logtape.c.html#L761" title="utils/sort/logtape.c:761">LogicalTapeWrite</a>(tape, tuple, IndexTupleSize(tuple));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (base-&gt;sortopt &amp; TUPLESORT_RANDOMACCESS) <span class="Comment">/* need trailing length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="logtape.c.html#L761" title="utils/sort/logtape.c:761">LogicalTapeWrite</a>(tape, &amp;tuplen, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tuplen));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1687">&#x200c;</a></span><span class="linkable">readtup_index</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *stup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape, <span class="Type">unsigned</span> <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; <a href="#L115" title="utils/sort/tuplesortvariants.c:115">TuplesortIndexArg</a> *arg = (<a href="#L115" title="utils/sort/tuplesortvariants.c:115">TuplesortIndexArg</a> *) base-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> tuplen = len - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">unsigned</span> <span class="Type">int</span>);<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; tuple = (IndexTuple) <a href="tuplesort.c.html#L2921" title="utils/sort/tuplesort.c:2921">tuplesort_readtup_alloc</a>(state, tuplen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LogicalTapeReadExact(tape, tuple, tuplen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (base-&gt;sortopt &amp; TUPLESORT_RANDOMACCESS) <span class="Comment">/* need trailing length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; LogicalTapeReadExact(tape, &amp;tuplen, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tuplen));<br/></li>
<li>&nbsp; &nbsp; stup-&gt;tuple = (<span class="Type">void</span> *) tuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set up first-column key value */<br/></li>
<li></span>&nbsp; &nbsp; stup-&gt;datum1 = index_getattr(tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetDescr(arg-&gt;indexRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;stup-&gt;isnull1);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Routines specialized for BrinTuple case<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1711">&#x200c;</a></span><span class="linkable">removeabbrev_index_brin</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *stups, <span class="Type">int</span> count)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; count; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L157" title="utils/sort/tuplesortvariants.c:157">BrinSortTuple</a> *tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = stups[i].tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stups[i].datum1 = tuple-&gt;tuple.bt_blkno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1725">&#x200c;</a></span><span class="linkable">comparetup_index_brin</span>(<span class="Type">const</span> SortTuple *a, <span class="Type">const</span> SortTuple *b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(TuplesortstateGetPublic(state)-&gt;haveDatum1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DatumGetUInt32(a-&gt;datum1) &gt; DatumGetUInt32(b-&gt;datum1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DatumGetUInt32(a-&gt;datum1) &lt; DatumGetUInt32(b-&gt;datum1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* silence compilers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1741">&#x200c;</a></span><span class="linkable">writetup_index_brin</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape, SortTuple *stup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; <a href="#L157" title="utils/sort/tuplesortvariants.c:157">BrinSortTuple</a> *tuple = (<a href="#L157" title="utils/sort/tuplesortvariants.c:157">BrinSortTuple</a> *) stup-&gt;tuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> tuplen = tuple-&gt;tuplen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuplen = tuplen + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tuplen);<br/></li>
<li>&nbsp; &nbsp; <a href="logtape.c.html#L761" title="utils/sort/logtape.c:761">LogicalTapeWrite</a>(tape, &amp;tuplen, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tuplen));<br/></li>
<li>&nbsp; &nbsp; <a href="logtape.c.html#L761" title="utils/sort/logtape.c:761">LogicalTapeWrite</a>(tape, &amp;tuple-&gt;tuple, tuple-&gt;tuplen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (base-&gt;sortopt &amp; TUPLESORT_RANDOMACCESS) <span class="Comment">/* need trailing length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="logtape.c.html#L761" title="utils/sort/logtape.c:761">LogicalTapeWrite</a>(tape, &amp;tuplen, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tuplen));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1755">&#x200c;</a></span><span class="linkable">readtup_index_brin</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *stup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape, <span class="Type">unsigned</span> <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L157" title="utils/sort/tuplesortvariants.c:157">BrinSortTuple</a> *tuple;<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> tuplen = len - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">unsigned</span> <span class="Type">int</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate space for the BRIN sort tuple, which is BrinTuple with an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extra length field.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tuple = (<a href="#L157" title="utils/sort/tuplesortvariants.c:157">BrinSortTuple</a> *) <a href="tuplesort.c.html#L2921" title="utils/sort/tuplesort.c:2921">tuplesort_readtup_alloc</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L164" title="utils/sort/tuplesortvariants.c:164">BRINSORTTUPLE_SIZE</a>(tuplen));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple-&gt;tuplen = tuplen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LogicalTapeReadExact(tape, &amp;tuple-&gt;tuple, tuplen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (base-&gt;sortopt &amp; TUPLESORT_RANDOMACCESS) <span class="Comment">/* need trailing length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; LogicalTapeReadExact(tape, &amp;tuplen, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tuplen));<br/></li>
<li>&nbsp; &nbsp; stup-&gt;tuple = (<span class="Type">void</span> *) tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set up first-column key value, which is block number */<br/></li>
<li></span>&nbsp; &nbsp; stup-&gt;datum1 = tuple-&gt;tuple.bt_blkno;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Routines specialized for DatumTuple case<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1785">&#x200c;</a></span><span class="linkable">removeabbrev_datum</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *stups, <span class="Type">int</span> count)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; count; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stups[i].datum1 = PointerGetDatum(stups[i].tuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1794">&#x200c;</a></span><span class="linkable">comparetup_datum</span>(<span class="Type">const</span> SortTuple *a, <span class="Type">const</span> SortTuple *b, <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> = ApplySortComparator(a-&gt;datum1, a-&gt;isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b-&gt;datum1, b-&gt;isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base-&gt;sortKeys);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1809" title="utils/sort/tuplesortvariants.c:1809">comparetup_datum_tiebreak</a>(a, b, state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1809">&#x200c;</a></span><span class="linkable">comparetup_datum_tiebreak</span>(<span class="Type">const</span> SortTuple *a, <span class="Type">const</span> SortTuple *b, <a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if we have abbreviations, then &quot;tuple&quot; has the original value */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (base-&gt;sortKeys-&gt;abbrev_converter)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> = ApplySortAbbrevFullComparator(PointerGetDatum(a-&gt;tuple), a-&gt;isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(b-&gt;tuple), b-&gt;isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base-&gt;sortKeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1824">&#x200c;</a></span><span class="linkable">writetup_datum</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape, SortTuple *stup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; <a href="#L150" title="utils/sort/tuplesortvariants.c:150">TuplesortDatumArg</a> *arg = (<a href="#L150" title="utils/sort/tuplesortvariants.c:150">TuplesortDatumArg</a> *) base-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *waddr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> tuplen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> writtenlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stup-&gt;isnull1)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; waddr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuplen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!base-&gt;tuples)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; waddr = &amp;stup-&gt;datum1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuplen = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; waddr = stup-&gt;tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuplen = <a href="../adt/datum.c.html#L65" title="utils/adt/datum.c:65">datumGetSize</a>(PointerGetDatum(stup-&gt;tuple), <span class="Constant">false</span>, arg-&gt;datumTypeLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(tuplen != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; writtenlen = tuplen + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">unsigned</span> <span class="Type">int</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="logtape.c.html#L761" title="utils/sort/logtape.c:761">LogicalTapeWrite</a>(tape, &amp;writtenlen, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(writtenlen));<br/></li>
<li>&nbsp; &nbsp; <a href="logtape.c.html#L761" title="utils/sort/logtape.c:761">LogicalTapeWrite</a>(tape, waddr, tuplen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (base-&gt;sortopt &amp; TUPLESORT_RANDOMACCESS) <span class="Comment">/* need trailing length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="logtape.c.html#L761" title="utils/sort/logtape.c:761">LogicalTapeWrite</a>(tape, &amp;writtenlen, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(writtenlen));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1858">&#x200c;</a></span><span class="linkable">readtup_datum</span>(<a href="tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *stup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape, <span class="Type">unsigned</span> <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic *base = TuplesortstateGetPublic(state);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> tuplen = len - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">unsigned</span> <span class="Type">int</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tuplen == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it's NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stup-&gt;datum1 = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stup-&gt;isnull1 = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stup-&gt;tuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!base-&gt;tuples)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(tuplen == <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LogicalTapeReadExact(tape, &amp;stup-&gt;datum1, tuplen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stup-&gt;isnull1 = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stup-&gt;tuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *raddr = <a href="tuplesort.c.html#L2921" title="utils/sort/tuplesort.c:2921">tuplesort_readtup_alloc</a>(state, tuplen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LogicalTapeReadExact(tape, raddr, tuplen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stup-&gt;datum1 = PointerGetDatum(raddr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stup-&gt;isnull1 = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stup-&gt;tuple = raddr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (base-&gt;sortopt &amp; TUPLESORT_RANDOMACCESS) <span class="Comment">/* need trailing length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; LogicalTapeReadExact(tape, &amp;tuplen, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tuplen));<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
