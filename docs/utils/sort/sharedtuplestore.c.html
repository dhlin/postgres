<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/sort/sharedtuplestore.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/sort/sharedtuplestore.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L59">SharedTuplestore</a></li>
<li><a href="#L71">SharedTuplestoreAccessor</a></li>
<li><a href="#L42">SharedTuplestoreChunk</a></li>
<li><a href="#L47">SharedTuplestoreChunk</a></li>
<li><a href="#L50">SharedTuplestoreParticipant</a></li>
<li><a href="#L56">SharedTuplestoreParticipant</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L178">sts_attach</a></li>
<li><a href="#L253">sts_begin_parallel_scan</a></li>
<li><a href="#L281">sts_end_parallel_scan</a></li>
<li><a href="#L213">sts_end_write</a></li>
<li><a href="#L104">sts_estimate</a></li>
<li><a href="#L598">sts_filename</a></li>
<li><a href="#L196">sts_flush_chunk</a></li>
<li><a href="#L126">sts_initialize</a></li>
<li><a href="#L495">sts_parallel_scan_next</a></li>
<li><a href="#L300">sts_puttuple</a></li>
<li><a href="#L415">sts_read_tuple</a></li>
<li><a href="#L234">sts_reinitialize</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L39">STS_CHUNK_DATA_SIZE</a></li>
<li><a href="#L38">STS_CHUNK_HEADER_SIZE</a></li>
<li><a href="#L37">STS_CHUNK_PAGES</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * sharedtuplestore.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Simple mechanism for sharing tuples between backends.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This module contains a shared temporary tuple storage mechanism providing<br/></li>
<li></span><span class="Comment"> * a parallel-aware <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of the features of tuplestore.c.&nbsp; Multiple backends<br/></li>
<li></span><span class="Comment"> * can write to a <a href="#L59" title="utils/sort/sharedtuplestore.c:59">SharedTuplestore</a>, and then multiple backends can later scan<br/></li>
<li></span><span class="Comment"> * the stored tuples.&nbsp; Currently, the only scan type supported is a parallel<br/></li>
<li></span><span class="Comment"> * scan where each backend reads an arbitrary <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of the tuples that were<br/></li>
<li></span><span class="Comment"> * written.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/sort/sharedtuplestore.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/buffile.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lwlock.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/sharedfileset.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/sharedtuplestore.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The size of chunks, in pages.&nbsp; This is somewhat arbitrarily set to match<br/></li>
<li></span><span class="Comment"> * the size of HASH_CHUNK, so that Parallel Hash obtains new chunks of tuples<br/></li>
<li></span><span class="Comment"> * at approximately the same rate as it allocates new chunks of memory to<br/></li>
<li></span><span class="Comment"> * insert them into.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L37">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">STS_CHUNK_PAGES</span> </span><span class="Constant">4<br/></li>
<li><a id="L38">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">STS_CHUNK_HEADER_SIZE</span> offsetof(<a href="#L42" title="utils/sort/sharedtuplestore.c:42">SharedTuplestoreChunk</a>, data)<br/></li>
<li><a id="L39">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">STS_CHUNK_DATA_SIZE</span> (<a href="#L37" title="utils/sort/sharedtuplestore.c:37">STS_CHUNK_PAGES</a> * BLCKSZ - <a href="#L38" title="utils/sort/sharedtuplestore.c:38">STS_CHUNK_HEADER_SIZE</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Chunk written to disk. */<br/></li>
<li><a id="L42">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">SharedTuplestoreChunk</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntuples;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Number of tuples in this chunk. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overflow;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If overflow, how many including this one? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; data[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L47">&#x200c;</a>} <span class="linkable">SharedTuplestoreChunk</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Per-participant shared state. */<br/></li>
<li><a id="L50">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">SharedTuplestoreParticipant</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp; &nbsp; lock;<br/></li>
<li>&nbsp; &nbsp; BlockNumber read_page;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Page number for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> read. */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber npages;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Number of pages written. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; writing;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Used only for assertions. */<br/></li>
<li><a id="L56">&#x200c;</a></span>} <span class="linkable">SharedTuplestoreParticipant</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* The control object that lives in shared memory. */<br/></li>
<li><a id="L59">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">SharedTuplestore</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nparticipants;&nbsp; &nbsp; <span class="Comment">/* Number of participants that can write. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Flag bits from SHARED_TUPLESTORE_XXX */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; meta_data_size; <span class="Comment">/* Size of per-tuple header. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; name[NAMEDATALEN];&nbsp; &nbsp; <span class="Comment">/* A name for this tuplestore. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Followed by per-participant shared state. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L50" title="utils/sort/sharedtuplestore.c:50">SharedTuplestoreParticipant</a> participants[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Per-participant state that lives in backend-local memory. */<br/></li>
<li><a id="L71">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">SharedTuplestoreAccessor</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; participant;&nbsp; &nbsp; <span class="Comment">/* My participant number. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L59" title="utils/sort/sharedtuplestore.c:59">SharedTuplestore</a> *sts;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The shared state. */<br/></li>
<li></span>&nbsp; &nbsp; SharedFileSet *fileset;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The SharedFileSet holding files. */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext context;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Memory context for buffers. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* State for reading. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; read_participant;&nbsp; &nbsp; <span class="Comment">/* The current participant to read from. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a>&nbsp; &nbsp; *read_file;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The current file to read from. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; read_ntuples_available; <span class="Comment">/* The number of tuples in chunk. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; read_ntuples;&nbsp; &nbsp; <span class="Comment">/* How many tuples have we read from chunk? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; read_bytes;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* How many bytes have we read from chunk? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *read_buffer;&nbsp; &nbsp; <span class="Comment">/* A buffer for loading tuples. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; read_buffer_size;<br/></li>
<li>&nbsp; &nbsp; BlockNumber read_next_page; <span class="Comment">/* Lowest block we'll consider reading. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* State for writing. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L42" title="utils/sort/sharedtuplestore.c:42">SharedTuplestoreChunk</a> *<a href="../activity/pgstat.c.html#L1291" title="utils/activity/pgstat.c:1291">write_chunk</a>; <span class="Comment">/* Buffer for writing. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a>&nbsp; &nbsp; *write_file;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The current file to write to. */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber write_page;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page to write to. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *write_pointer;&nbsp; &nbsp; <span class="Comment">/* Current write pointer within chunk. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *write_end;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* One past the end of the current chunk. */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L598" title="utils/sort/sharedtuplestore.c:598">sts_filename</a>(<span class="Type">char</span> *name, <a href="#L71" title="utils/sort/sharedtuplestore.c:71">SharedTuplestoreAccessor</a> *accessor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> participant);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the amount of shared memory required to hold <a href="#L59" title="utils/sort/sharedtuplestore.c:59">SharedTuplestore</a> for a<br/></li>
<li></span><span class="Comment"> * given number of participants.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">size_t<br/></li>
<li><a id="L104">&#x200c;</a></span><span class="linkable">sts_estimate</span>(<span class="Type">int</span> participants)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> offsetof(<a href="#L59" title="utils/sort/sharedtuplestore.c:59">SharedTuplestore</a>, participants) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L50" title="utils/sort/sharedtuplestore.c:50">SharedTuplestoreParticipant</a>) * participants;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize a <a href="#L59" title="utils/sort/sharedtuplestore.c:59">SharedTuplestore</a> in existing shared memory.&nbsp; There must be<br/></li>
<li></span><span class="Comment"> * space for <a href="#L104" title="utils/sort/sharedtuplestore.c:104">sts_estimate</a>(participants) bytes.&nbsp; If flags includes the value<br/></li>
<li></span><span class="Comment"> * SHARED_TUPLESTORE_SINGLE_PASS, the files may in future be removed more<br/></li>
<li></span><span class="Comment"> * eagerly (but this isn't yet implemented).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Tuples that are stored may optionally carry a piece of fixed sized<br/></li>
<li></span><span class="Comment"> * meta-data which will be retrieved along with the tuple.&nbsp; This is useful for<br/></li>
<li></span><span class="Comment"> * the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> used in multi-batch <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> joins, but could have other<br/></li>
<li></span><span class="Comment"> * applications.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must supply a SharedFileSet, which is essentially a directory<br/></li>
<li></span><span class="Comment"> * that will be cleaned up automatically, and a name which must be unique<br/></li>
<li></span><span class="Comment"> * across all SharedTuplestores created in the same SharedFileSet.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L71" title="utils/sort/sharedtuplestore.c:71">SharedTuplestoreAccessor</a> *<br/></li>
<li><a id="L126">&#x200c;</a><span class="linkable">sts_initialize</span>(<a href="#L59" title="utils/sort/sharedtuplestore.c:59">SharedTuplestore</a> *sts, <span class="Type">int</span> participants,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> my_participant_number,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">size_t</span> meta_data_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SharedFileSet *fileset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="utils/sort/sharedtuplestore.c:71">SharedTuplestoreAccessor</a> *accessor;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(my_participant_number &lt; participants);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sts-&gt;nparticipants = participants;<br/></li>
<li>&nbsp; &nbsp; sts-&gt;meta_data_size = meta_data_size;<br/></li>
<li>&nbsp; &nbsp; sts-&gt;flags = flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strlen(name) &gt; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(sts-&gt;name) - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L59" title="utils/sort/sharedtuplestore.c:59">SharedTuplestore</a> name too long&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; strcpy(sts-&gt;name, name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Limit meta-data so it + tuple size always fits into a single chunk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L300" title="utils/sort/sharedtuplestore.c:300">sts_puttuple</a>() and <a href="#L415" title="utils/sort/sharedtuplestore.c:415">sts_read_tuple</a>() could be made to support scenarios<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where that's not the case, but it's not currently required. If so,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * meta-data size probably should be made variable, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (meta_data_size + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32) &gt;= <a href="#L39" title="utils/sort/sharedtuplestore.c:39">STS_CHUNK_DATA_SIZE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;meta-data too long&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; participants; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L709" title="storage/lmgr/lwlock.c:709">LWLockInitialize</a>(&amp;sts-&gt;participants[i].lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LWTRANCHE_SHARED_TUPLESTORE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sts-&gt;participants[i].read_page = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sts-&gt;participants[i].npages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sts-&gt;participants[i].writing = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; accessor = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L71" title="utils/sort/sharedtuplestore.c:71">SharedTuplestoreAccessor</a>));<br/></li>
<li>&nbsp; &nbsp; accessor-&gt;participant = my_participant_number;<br/></li>
<li>&nbsp; &nbsp; accessor-&gt;sts = sts;<br/></li>
<li>&nbsp; &nbsp; accessor-&gt;fileset = fileset;<br/></li>
<li>&nbsp; &nbsp; accessor-&gt;context = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> accessor;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attach to a <a href="#L59" title="utils/sort/sharedtuplestore.c:59">SharedTuplestore</a> that has been initialized by another backend,<br/></li>
<li></span><span class="Comment"> * so that this backend can read and write tuples.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L71" title="utils/sort/sharedtuplestore.c:71">SharedTuplestoreAccessor</a> *<br/></li>
<li><a id="L178">&#x200c;</a><span class="linkable">sts_attach</span>(<a href="#L59" title="utils/sort/sharedtuplestore.c:59">SharedTuplestore</a> *sts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> my_participant_number,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SharedFileSet *fileset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="utils/sort/sharedtuplestore.c:71">SharedTuplestoreAccessor</a> *accessor;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(my_participant_number &lt; sts-&gt;nparticipants);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; accessor = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L71" title="utils/sort/sharedtuplestore.c:71">SharedTuplestoreAccessor</a>));<br/></li>
<li>&nbsp; &nbsp; accessor-&gt;participant = my_participant_number;<br/></li>
<li>&nbsp; &nbsp; accessor-&gt;sts = sts;<br/></li>
<li>&nbsp; &nbsp; accessor-&gt;fileset = fileset;<br/></li>
<li>&nbsp; &nbsp; accessor-&gt;context = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> accessor;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L196">&#x200c;</a></span><span class="linkable">sts_flush_chunk</span>(<a href="#L71" title="utils/sort/sharedtuplestore.c:71">SharedTuplestoreAccessor</a> *accessor)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = <a href="#L37" title="utils/sort/sharedtuplestore.c:37">STS_CHUNK_PAGES</a> * BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L676" title="storage/file/buffile.c:676">BufFileWrite</a>(accessor-&gt;write_file, accessor-&gt;<a href="../activity/pgstat.c.html#L1291" title="utils/activity/pgstat.c:1291">write_chunk</a>, size);<br/></li>
<li>&nbsp; &nbsp; memset(accessor-&gt;<a href="../activity/pgstat.c.html#L1291" title="utils/activity/pgstat.c:1291">write_chunk</a>, <span class="Constant">0</span>, size);<br/></li>
<li>&nbsp; &nbsp; accessor-&gt;write_pointer = &amp;accessor-&gt;<a href="../activity/pgstat.c.html#L1291" title="utils/activity/pgstat.c:1291">write_chunk</a>-&gt;data[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; accessor-&gt;sts-&gt;participants[accessor-&gt;participant].npages +=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L37" title="utils/sort/sharedtuplestore.c:37">STS_CHUNK_PAGES</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Finish writing tuples.&nbsp; This must be called by all backends that have<br/></li>
<li></span><span class="Comment"> * written data <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> backend begins reading it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L213">&#x200c;</a></span><span class="linkable">sts_end_write</span>(<a href="#L71" title="utils/sort/sharedtuplestore.c:71">SharedTuplestoreAccessor</a> *accessor)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (accessor-&gt;write_file != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L196" title="utils/sort/sharedtuplestore.c:196">sts_flush_chunk</a>(accessor);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L412" title="storage/file/buffile.c:412">BufFileClose</a>(accessor-&gt;write_file);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(accessor-&gt;<a href="../activity/pgstat.c.html#L1291" title="utils/activity/pgstat.c:1291">write_chunk</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;<a href="../activity/pgstat.c.html#L1291" title="utils/activity/pgstat.c:1291">write_chunk</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;write_file = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;sts-&gt;participants[accessor-&gt;participant].writing = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare to rescan.&nbsp; Only one participant must call this.&nbsp; After it returns,<br/></li>
<li></span><span class="Comment"> * all participants may call <a href="#L253" title="utils/sort/sharedtuplestore.c:253">sts_begin_parallel_scan</a>() and then loop over<br/></li>
<li></span><span class="Comment"> * <a href="#L495" title="utils/sort/sharedtuplestore.c:495">sts_parallel_scan_next</a>().&nbsp; This function must not be called concurrently<br/></li>
<li></span><span class="Comment"> * with a scan, and synchronization to avoid that is the caller's<br/></li>
<li></span><span class="Comment"> * responsibility.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L234">&#x200c;</a></span><span class="linkable">sts_reinitialize</span>(<a href="#L71" title="utils/sort/sharedtuplestore.c:71">SharedTuplestoreAccessor</a> *accessor)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset the shared read head for all participants' files.&nbsp; Also set the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initial chunk size to the minimum (<a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> increases from that size will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recorded in chunk_expansion_log).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; accessor-&gt;sts-&gt;nparticipants; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;sts-&gt;participants[i].read_page = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Begin scanning the contents in parallel.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L253">&#x200c;</a></span><span class="linkable">sts_begin_parallel_scan</span>(<a href="#L71" title="utils/sort/sharedtuplestore.c:71">SharedTuplestoreAccessor</a> *accessor)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* End <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing scan that was in progress. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L281" title="utils/sort/sharedtuplestore.c:281">sts_end_parallel_scan</a>(accessor);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Any backend that might have written into this shared tuplestore must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have called <a href="#L213" title="utils/sort/sharedtuplestore.c:213">sts_end_write</a>(), so that all buffers are flushed and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * files have stopped growing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; accessor-&gt;sts-&gt;nparticipants; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!accessor-&gt;sts-&gt;participants[i].writing);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We will start out reading the file that THIS backend wrote.&nbsp; There may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be some caching locality advantage to that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; accessor-&gt;read_participant = accessor-&gt;participant;<br/></li>
<li>&nbsp; &nbsp; accessor-&gt;read_file = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; accessor-&gt;read_next_page = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Finish a parallel scan, freeing associated backend-local resources.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L281">&#x200c;</a></span><span class="linkable">sts_end_parallel_scan</span>(<a href="#L71" title="utils/sort/sharedtuplestore.c:71">SharedTuplestoreAccessor</a> *accessor)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Here we could delete all files if SHARED_TUPLESTORE_SINGLE_PASS, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we'd probably need a reference count of current parallel scanners so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could safely do it only when the reference count reaches zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (accessor-&gt;read_file != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L412" title="storage/file/buffile.c:412">BufFileClose</a>(accessor-&gt;read_file);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;read_file = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write a tuple.&nbsp; If a meta-data size was provided to <a href="#L126" title="utils/sort/sharedtuplestore.c:126">sts_initialize</a>, then a<br/></li>
<li></span><span class="Comment"> * pointer to meta data of that size must be provided.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L300">&#x200c;</a></span><span class="linkable">sts_puttuple</span>(<a href="#L71" title="utils/sort/sharedtuplestore.c:71">SharedTuplestoreAccessor</a> *accessor, <span class="Type">void</span> *meta_data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MinimalTuple tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do we have our own file yet? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (accessor-&gt;write_file == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L50" title="utils/sort/sharedtuplestore.c:50">SharedTuplestoreParticipant</a> *participant;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; name[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create one.&nbsp; Only this backend will write into it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L598" title="utils/sort/sharedtuplestore.c:598">sts_filename</a>(name, accessor, accessor-&gt;participant);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(accessor-&gt;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;write_file =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L267" title="storage/file/buffile.c:267">BufFileCreateFileSet</a>(&amp;accessor-&gt;fileset-&gt;fs, name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set up the shared state for this backend's file. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; participant = &amp;accessor-&gt;sts-&gt;participants[accessor-&gt;participant];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; participant-&gt;writing = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* for assertions only */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do we have space? */<br/></li>
<li></span>&nbsp; &nbsp; size = accessor-&gt;sts-&gt;meta_data_size + tuple-&gt;t_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (accessor-&gt;write_pointer + size &gt; accessor-&gt;write_end)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (accessor-&gt;<a href="../activity/pgstat.c.html#L1291" title="utils/activity/pgstat.c:1291">write_chunk</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First time through.&nbsp; Allocate chunk. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;<a href="../activity/pgstat.c.html#L1291" title="utils/activity/pgstat.c:1291">write_chunk</a> = (<a href="#L42" title="utils/sort/sharedtuplestore.c:42">SharedTuplestoreChunk</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(accessor-&gt;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L37" title="utils/sort/sharedtuplestore.c:37">STS_CHUNK_PAGES</a> * BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;<a href="../activity/pgstat.c.html#L1291" title="utils/activity/pgstat.c:1291">write_chunk</a>-&gt;ntuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;write_pointer = &amp;accessor-&gt;<a href="../activity/pgstat.c.html#L1291" title="utils/activity/pgstat.c:1291">write_chunk</a>-&gt;data[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;write_end = (<span class="Type">char</span> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;<a href="../activity/pgstat.c.html#L1291" title="utils/activity/pgstat.c:1291">write_chunk</a> + <a href="#L37" title="utils/sort/sharedtuplestore.c:37">STS_CHUNK_PAGES</a> * BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See if flushing helps. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L196" title="utils/sort/sharedtuplestore.c:196">sts_flush_chunk</a>(accessor);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It may still not be enough in the case of a gigantic tuple. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (accessor-&gt;write_pointer + size &gt; accessor-&gt;write_end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; written;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'll write the beginning of the oversized tuple, and then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * write the rest in some number of 'overflow' chunks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L126" title="utils/sort/sharedtuplestore.c:126">sts_initialize</a>() verifies that the size of the tuple +<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * meta-data always fits into a chunk. Because the chunk has been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * flushed above, we can be sure to have all of a chunk's usable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * space available.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(accessor-&gt;write_pointer + accessor-&gt;sts-&gt;meta_data_size +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32) &lt; accessor-&gt;write_end);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Write the meta-data as one chunk. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (accessor-&gt;sts-&gt;meta_data_size &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(accessor-&gt;write_pointer, meta_data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; accessor-&gt;sts-&gt;meta_data_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Write as much of the tuple as we can fit. This includes the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple's size at the start.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; written = accessor-&gt;write_end - accessor-&gt;write_pointer -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;sts-&gt;meta_data_size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(accessor-&gt;write_pointer + accessor-&gt;sts-&gt;meta_data_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tuple, written);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++accessor-&gt;<a href="../activity/pgstat.c.html#L1291" title="utils/activity/pgstat.c:1291">write_chunk</a>-&gt;ntuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size -= accessor-&gt;sts-&gt;meta_data_size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size -= written;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now write as many overflow chunks as we need for the rest. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (size &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; written_this_chunk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L196" title="utils/sort/sharedtuplestore.c:196">sts_flush_chunk</a>(accessor);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * How many overflow chunks to go?&nbsp; This will allow readers to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> all of them at once instead of reading each one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;<a href="../activity/pgstat.c.html#L1291" title="utils/activity/pgstat.c:1291">write_chunk</a>-&gt;overflow = (size + <a href="#L39" title="utils/sort/sharedtuplestore.c:39">STS_CHUNK_DATA_SIZE</a> - <span class="Constant">1</span>) /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L39" title="utils/sort/sharedtuplestore.c:39">STS_CHUNK_DATA_SIZE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; written_this_chunk =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(accessor-&gt;write_end - accessor-&gt;write_pointer, size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(accessor-&gt;write_pointer, (<span class="Type">char</span> *) tuple + written,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; written_this_chunk);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;write_pointer += written_this_chunk;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size -= written_this_chunk;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; written += written_this_chunk;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy meta-data and tuple into buffer. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (accessor-&gt;sts-&gt;meta_data_size &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(accessor-&gt;write_pointer, meta_data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; accessor-&gt;sts-&gt;meta_data_size);<br/></li>
<li>&nbsp; &nbsp; memcpy(accessor-&gt;write_pointer + accessor-&gt;sts-&gt;meta_data_size, tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tuple-&gt;t_len);<br/></li>
<li>&nbsp; &nbsp; accessor-&gt;write_pointer += size;<br/></li>
<li>&nbsp; &nbsp; ++accessor-&gt;<a href="../activity/pgstat.c.html#L1291" title="utils/activity/pgstat.c:1291">write_chunk</a>-&gt;ntuples;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> MinimalTuple<br/></li>
<li><a id="L415">&#x200c;</a><span class="linkable">sts_read_tuple</span>(<a href="#L71" title="utils/sort/sharedtuplestore.c:71">SharedTuplestoreAccessor</a> *accessor, <span class="Type">void</span> *meta_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MinimalTuple tuple;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; remaining_size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; this_chunk_size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *destination;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We'll keep track of bytes read from this chunk so that we can detect an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overflowing tuple and switch to reading overflow pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (accessor-&gt;sts-&gt;meta_data_size &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L654" title="storage/file/buffile.c:654">BufFileReadExact</a>(accessor-&gt;read_file, meta_data, accessor-&gt;sts-&gt;meta_data_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;read_bytes += accessor-&gt;sts-&gt;meta_data_size;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L654" title="storage/file/buffile.c:654">BufFileReadExact</a>(accessor-&gt;read_file, &amp;size, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(size));<br/></li>
<li>&nbsp; &nbsp; accessor-&gt;read_bytes += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(size);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (size &gt; accessor-&gt;read_buffer_size)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; new_read_buffer_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (accessor-&gt;read_buffer != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(accessor-&gt;read_buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_read_buffer_size = Max(size, accessor-&gt;read_buffer_size * <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;read_buffer =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(accessor-&gt;context, new_read_buffer_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;read_buffer_size = new_read_buffer_size;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; remaining_size = size - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32);<br/></li>
<li>&nbsp; &nbsp; this_chunk_size = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(remaining_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BLCKSZ * <a href="#L37" title="utils/sort/sharedtuplestore.c:37">STS_CHUNK_PAGES</a> - accessor-&gt;read_bytes);<br/></li>
<li>&nbsp; &nbsp; destination = accessor-&gt;read_buffer + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L654" title="storage/file/buffile.c:654">BufFileReadExact</a>(accessor-&gt;read_file, destination, this_chunk_size);<br/></li>
<li>&nbsp; &nbsp; accessor-&gt;read_bytes += this_chunk_size;<br/></li>
<li>&nbsp; &nbsp; remaining_size -= this_chunk_size;<br/></li>
<li>&nbsp; &nbsp; destination += this_chunk_size;<br/></li>
<li>&nbsp; &nbsp; ++accessor-&gt;read_ntuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if we need to read <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> overflow chunks. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (remaining_size &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We are <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> positioned at the start of an overflow chunk. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L42" title="utils/sort/sharedtuplestore.c:42">SharedTuplestoreChunk</a> chunk_header;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L654" title="storage/file/buffile.c:654">BufFileReadExact</a>(accessor-&gt;read_file, &amp;chunk_header, <a href="#L38" title="utils/sort/sharedtuplestore.c:38">STS_CHUNK_HEADER_SIZE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;read_bytes = <a href="#L38" title="utils/sort/sharedtuplestore.c:38">STS_CHUNK_HEADER_SIZE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (chunk_header.overflow == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected chunk in shared tuplestore temporary file&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;Expected overflow chunk.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;read_next_page += <a href="#L37" title="utils/sort/sharedtuplestore.c:37">STS_CHUNK_PAGES</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; this_chunk_size = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(remaining_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BLCKSZ * <a href="#L37" title="utils/sort/sharedtuplestore.c:37">STS_CHUNK_PAGES</a> -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L38" title="utils/sort/sharedtuplestore.c:38">STS_CHUNK_HEADER_SIZE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L654" title="storage/file/buffile.c:654">BufFileReadExact</a>(accessor-&gt;read_file, destination, this_chunk_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;read_bytes += this_chunk_size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; remaining_size -= this_chunk_size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; destination += this_chunk_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * These will be used to count regular tuples following the oversized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple that spilled into this overflow chunk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;read_ntuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;read_ntuples_available = chunk_header.ntuples;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = (MinimalTuple) accessor-&gt;read_buffer;<br/></li>
<li>&nbsp; &nbsp; tuple-&gt;t_len = size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple in the current parallel scan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MinimalTuple<br/></li>
<li><a id="L495">&#x200c;</a><span class="linkable">sts_parallel_scan_next</span>(<a href="#L71" title="utils/sort/sharedtuplestore.c:71">SharedTuplestoreAccessor</a> *accessor, <span class="Type">void</span> *meta_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="utils/sort/sharedtuplestore.c:50">SharedTuplestoreParticipant</a> *p;<br/></li>
<li>&nbsp; &nbsp; BlockNumber read_page;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; eof;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can we read more tuples from the current chunk? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (accessor-&gt;read_ntuples &lt; accessor-&gt;read_ntuples_available)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L415" title="utils/sort/sharedtuplestore.c:415">sts_read_tuple</a>(accessor, meta_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find the location of a new chunk to read. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; p = &amp;accessor-&gt;sts-&gt;participants[accessor-&gt;read_participant];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;p-&gt;lock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> directly past overflow pages we know about. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p-&gt;read_page &lt; accessor-&gt;read_next_page)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p-&gt;read_page = accessor-&gt;read_next_page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eof = p-&gt;read_page &gt;= p-&gt;npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!eof)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Claim the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> chunk. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; read_page = p-&gt;read_page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance the read head for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> reader. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p-&gt;read_page += <a href="#L37" title="utils/sort/sharedtuplestore.c:37">STS_CHUNK_PAGES</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;read_next_page = p-&gt;read_page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;p-&gt;lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!eof)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L42" title="utils/sort/sharedtuplestore.c:42">SharedTuplestoreChunk</a> chunk_header;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure we have the file open. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (accessor-&gt;read_file == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; name[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L598" title="utils/sort/sharedtuplestore.c:598">sts_filename</a>(name, accessor, accessor-&gt;read_participant);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(accessor-&gt;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;read_file =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L291" title="storage/file/buffile.c:291">BufFileOpenFileSet</a>(&amp;accessor-&gt;fileset-&gt;fs, name, O_RDONLY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Seek and load the chunk header. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/buffile.c.html#L851" title="storage/file/buffile.c:851">BufFileSeekBlock</a>(accessor-&gt;read_file, read_page) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not seek to block </span><span class="Special">%u</span><span class="Constant"> in shared tuplestore temporary file&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; read_page)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L654" title="storage/file/buffile.c:654">BufFileReadExact</a>(accessor-&gt;read_file, &amp;chunk_header, <a href="#L38" title="utils/sort/sharedtuplestore.c:38">STS_CHUNK_HEADER_SIZE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is an overflow chunk, we <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it and <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> following<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overflow chunks all at once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (chunk_header.overflow &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;read_next_page = read_page +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunk_header.overflow * <a href="#L37" title="utils/sort/sharedtuplestore.c:37">STS_CHUNK_PAGES</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;read_ntuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;read_ntuples_available = chunk_header.ntuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;read_bytes = <a href="#L38" title="utils/sort/sharedtuplestore.c:38">STS_CHUNK_HEADER_SIZE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Go around again, so we can get a tuple from this chunk. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (accessor-&gt;read_file != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L412" title="storage/file/buffile.c:412">BufFileClose</a>(accessor-&gt;read_file);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;read_file = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> participant's file.&nbsp; If we've gone full circle,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we're done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;read_participant = (accessor-&gt;read_participant + <span class="Constant">1</span>) %<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;sts-&gt;nparticipants;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (accessor-&gt;read_participant == accessor-&gt;participant)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessor-&gt;read_next_page = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Go around again, so we can get a chunk from this file. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create the name used for the <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a> that a given participant will write.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L598">&#x200c;</a></span><span class="linkable">sts_filename</span>(<span class="Type">char</span> *name, <a href="#L71" title="utils/sort/sharedtuplestore.c:71">SharedTuplestoreAccessor</a> *accessor, <span class="Type">int</span> participant)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; snprintf(name, MAXPGPATH, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.p</span><span class="Special">%d</span><span class="Constant">&quot;</span>, accessor-&gt;sts-&gt;name, participant);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
