<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/sort/tuplesort.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/sort/tuplesort.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L128">optimize_bounded_sort</a></li>
<li><a href="#L124">trace_sort</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L346">Sharedsort</a></li>
<li><a href="#L145">SlabSlot</a></li>
<li><a href="#L149">SlabSlot</a></li>
<li><a href="#L163">TupSortStatus</a></li>
<li><a href="#L186">Tuplesortstate</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L2292">beginmerge</a></li>
<li><a href="#L1341">consider_abort_common</a></li>
<li><a href="#L2339">dumptuples</a></li>
<li><a href="#L3166">free_sort_tuple</a></li>
<li><a href="#L2894">getlen</a></li>
<li><a href="#L1072">grow_memtuples</a></li>
<li><a href="#L2009">init_slab_allocator</a></li>
<li><a href="#L1891">inittapes</a></li>
<li><a href="#L1942">inittapestate</a></li>
<li><a href="#L3107">leader_takeover_tapes</a></li>
<li><a href="#L2625">make_bounded_heap</a></li>
<li><a href="#L2907">markrunend</a></li>
<li><a href="#L1859">merge_read_buffer_size</a></li>
<li><a href="#L2232">mergeonerun</a></li>
<li><a href="#L2320">mergereadnext</a></li>
<li><a href="#L2045">mergeruns</a></li>
<li><a href="#L545">qsort_tuple_int32_compare</a></li>
<li><a href="#L521">qsort_tuple_signed_compare</a></li>
<li><a href="#L498">qsort_tuple_unsigned_compare</a></li>
<li><a href="#L2876">reversedirection</a></li>
<li><a href="#L1976">selectnewtape</a></li>
<li><a href="#L2674">sort_bounded_heap</a></li>
<li><a href="#L3204">ssup_datum_int32_cmp</a></li>
<li><a href="#L3189">ssup_datum_signed_cmp</a></li>
<li><a href="#L3177">ssup_datum_unsigned_cmp</a></li>
<li><a href="#L2999">tuplesort_attach_shared</a></li>
<li><a href="#L757">tuplesort_begin_batch</a></li>
<li><a href="#L645">tuplesort_begin_common</a></li>
<li><a href="#L971">tuplesort_end</a></li>
<li><a href="#L2955">tuplesort_estimate_shared</a></li>
<li><a href="#L902">tuplesort_free</a></li>
<li><a href="#L2537">tuplesort_get_stats</a></li>
<li><a href="#L1496">tuplesort_gettuple_common</a></li>
<li><a href="#L2812">tuplesort_heap_delete_top</a></li>
<li><a href="#L2777">tuplesort_heap_insert</a></li>
<li><a href="#L2836">tuplesort_heap_replace_top</a></li>
<li><a href="#L2976">tuplesort_initialize_shared</a></li>
<li><a href="#L2473">tuplesort_markpos</a></li>
<li><a href="#L1804">tuplesort_merge_order</a></li>
<li><a href="#L2581">tuplesort_method_name</a></li>
<li><a href="#L1385">tuplesort_performsort</a></li>
<li><a href="#L1189">tuplesort_puttuple_common</a></li>
<li><a href="#L2921">tuplesort_readtup_alloc</a></li>
<li><a href="#L2440">tuplesort_rescan</a></li>
<li><a href="#L1039">tuplesort_reset</a></li>
<li><a href="#L2504">tuplesort_restorepos</a></li>
<li><a href="#L843">tuplesort_set_bound</a></li>
<li><a href="#L1736">tuplesort_skiptuples</a></li>
<li><a href="#L2714">tuplesort_sort_memtuples</a></li>
<li><a href="#L2604">tuplesort_space_type_name</a></li>
<li><a href="#L988">tuplesort_updatemax</a></li>
<li><a href="#L891">tuplesort_used_bound</a></li>
<li><a href="#L3047">worker_freeze_result_tape</a></li>
<li><a href="#L3019">worker_get_identifier</a></li>
<li><a href="#L3085">worker_nomergeruns</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L399">COMPARETUP</a></li>
<li><a href="#L405">FREEMEM</a></li>
<li><a href="#L402">FREESTATE</a></li>
<li><a href="#L119">INITIAL_MEMTUPSIZE</a></li>
<li><a href="#L378">IS_SLAB_SLOT</a></li>
<li><a href="#L403">LACKMEM</a></li>
<li><a href="#L408">LEADER</a></li>
<li><a href="#L178">MAXORDER</a></li>
<li><a href="#L180">MERGE_BUFFER_SIZE</a></li>
<li><a href="#L177">MINORDER</a></li>
<li><a href="#L401">READTUP</a></li>
<li><a href="#L386">RELEASE_SLAB_SLOT</a></li>
<li><a href="#L398">REMOVEABBREV</a></li>
<li><a href="#L406">SERIAL</a></li>
<li><a href="#L143">SLAB_SLOT_SIZE</a></li>
<li><a href="#L579">ST_CHECK_FOR_INTERRUPTS</a></li>
<li><a href="#L589">ST_CHECK_FOR_INTERRUPTS</a></li>
<li><a href="#L599">ST_CHECK_FOR_INTERRUPTS</a></li>
<li><a href="#L608">ST_CHECK_FOR_INTERRUPTS</a></li>
<li><a href="#L620">ST_CHECK_FOR_INTERRUPTS</a></li>
<li><a href="#L577">ST_COMPARE</a></li>
<li><a href="#L587">ST_COMPARE</a></li>
<li><a href="#L597">ST_COMPARE</a></li>
<li><a href="#L616">ST_COMPARE</a></li>
<li><a href="#L578">ST_COMPARE_ARG_TYPE</a></li>
<li><a href="#L588">ST_COMPARE_ARG_TYPE</a></li>
<li><a href="#L598">ST_COMPARE_ARG_TYPE</a></li>
<li><a href="#L607">ST_COMPARE_ARG_TYPE</a></li>
<li><a href="#L619">ST_COMPARE_ARG_TYPE</a></li>
<li><a href="#L606">ST_COMPARE_RUNTIME_POINTER</a></li>
<li><a href="#L610">ST_DECLARE</a></li>
<li><a href="#L581">ST_DEFINE</a></li>
<li><a href="#L591">ST_DEFINE</a></li>
<li><a href="#L601">ST_DEFINE</a></li>
<li><a href="#L611">ST_DEFINE</a></li>
<li><a href="#L622">ST_DEFINE</a></li>
<li><a href="#L576">ST_ELEMENT_TYPE</a></li>
<li><a href="#L586">ST_ELEMENT_TYPE</a></li>
<li><a href="#L596">ST_ELEMENT_TYPE</a></li>
<li><a href="#L605">ST_ELEMENT_TYPE</a></li>
<li><a href="#L615">ST_ELEMENT_TYPE</a></li>
<li><a href="#L580">ST_SCOPE</a></li>
<li><a href="#L590">ST_SCOPE</a></li>
<li><a href="#L600">ST_SCOPE</a></li>
<li><a href="#L609">ST_SCOPE</a></li>
<li><a href="#L621">ST_SCOPE</a></li>
<li><a href="#L575">ST_SORT</a></li>
<li><a href="#L585">ST_SORT</a></li>
<li><a href="#L595">ST_SORT</a></li>
<li><a href="#L604">ST_SORT</a></li>
<li><a href="#L614">ST_SORT</a></li>
<li><a href="#L179">TAPE_BUFFER_OVERHEAD</a></li>
<li><a href="#L404">USEMEM</a></li>
<li><a href="#L407">WORKER</a></li>
<li><a href="#L400">WRITETUP</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tuplesort.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Generalized tuple sorting routines.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This module provides a generalized facility for tuple sorting, which can be<br/></li>
<li></span><span class="Comment"> * applied to different kinds of sortable objects.&nbsp; Implementation of<br/></li>
<li></span><span class="Comment"> * the particular sorting variants is given in tuplesortvariants.c.<br/></li>
<li></span><span class="Comment"> * This module works efficiently for both small and large amounts<br/></li>
<li></span><span class="Comment"> * of data.&nbsp; Small amounts are sorted in-memory using qsort().&nbsp; Large<br/></li>
<li></span><span class="Comment"> * amounts are sorted using temporary files and a standard external sort<br/></li>
<li></span><span class="Comment"> * algorithm.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See Knuth, volume 3, for more than you want to know about external<br/></li>
<li></span><span class="Comment"> * sorting algorithms.&nbsp; The algorithm we use is a balanced k-way <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>.<br/></li>
<li></span><span class="Comment"> * Before PostgreSQL 15, we used the polyphase <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> algorithm (Knuth's<br/></li>
<li></span><span class="Comment"> * Algorithm 5.4.2D), but with modern hardware, a straightforward balanced<br/></li>
<li></span><span class="Comment"> * <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> is better.&nbsp; Knuth is assuming that tape drives are expensive<br/></li>
<li></span><span class="Comment"> * beasts, and in particular that there will always be many more runs than<br/></li>
<li></span><span class="Comment"> * tape drives.&nbsp; The polyphase <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> algorithm was good at keeping all the<br/></li>
<li></span><span class="Comment"> * tape drives busy, but in our implementation a &quot;tape drive&quot; doesn't cost<br/></li>
<li></span><span class="Comment"> * much more than a few Kb of memory buffers, so we can afford to have<br/></li>
<li></span><span class="Comment"> * lots of them.&nbsp; In particular, if we can have as many tape drives as<br/></li>
<li></span><span class="Comment"> * sorted runs, we can eliminate <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> repeated I/O at all.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Historically, we divided the input into sorted runs using replacement<br/></li>
<li></span><span class="Comment"> * selection, in the form of a priority tree implemented as a heap<br/></li>
<li></span><span class="Comment"> * (essentially Knuth's Algorithm 5.2.3H), but <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we always use quicksort<br/></li>
<li></span><span class="Comment"> * for run generation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The approximate amount of memory allowed for <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one sort operation<br/></li>
<li></span><span class="Comment"> * is specified in kilobytes by the caller (most pass <a href="../init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>).&nbsp; Initially,<br/></li>
<li></span><span class="Comment"> * we absorb tuples and simply store them in an unsorted array as long as<br/></li>
<li></span><span class="Comment"> * we haven't exceeded workMem.&nbsp; If we reach the end of the input without<br/></li>
<li></span><span class="Comment"> * exceeding workMem, we sort the array using qsort() and subsequently return<br/></li>
<li></span><span class="Comment"> * tuples just by scanning the tuple array sequentially.&nbsp; If we do exceed<br/></li>
<li></span><span class="Comment"> * workMem, we begin to emit tuples into sorted runs in temporary tapes.<br/></li>
<li></span><span class="Comment"> * When tuples are dumped in batch after quicksorting, we begin a new run<br/></li>
<li></span><span class="Comment"> * with a new output tape.&nbsp; If we reach the max number of tapes, we write<br/></li>
<li></span><span class="Comment"> * subsequent runs on the existing tapes in a round-robin fashion.&nbsp; We will<br/></li>
<li></span><span class="Comment"> * need multiple <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> passes to finish the <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> in that case.&nbsp; After the<br/></li>
<li></span><span class="Comment"> * end of the input is reached, we <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> out remaining tuples in memory into<br/></li>
<li></span><span class="Comment"> * a final run, then <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> the runs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When merging runs, we use a heap containing just the frontmost tuple from<br/></li>
<li></span><span class="Comment"> * each source run; we repeatedly output the smallest tuple and replace it<br/></li>
<li></span><span class="Comment"> * with the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple from its source tape (if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>).&nbsp; When the heap empties,<br/></li>
<li></span><span class="Comment"> * the <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> is complete.&nbsp; The basic <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> algorithm thus needs very little<br/></li>
<li></span><span class="Comment"> * memory --- only M tuples for an M-way <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>, and M is constrained to a<br/></li>
<li></span><span class="Comment"> * small number.&nbsp; However, we can still make good use of our full workMem<br/></li>
<li></span><span class="Comment"> * allocation by pre-reading additional blocks from each source tape.&nbsp; Without<br/></li>
<li></span><span class="Comment"> * prereading, our access pattern to the temporary file would be very erratic;<br/></li>
<li></span><span class="Comment"> * on average we'd read one block from each of M source tapes during the same<br/></li>
<li></span><span class="Comment"> * time that we're writing M blocks to the output tape, so there is no<br/></li>
<li></span><span class="Comment"> * sequentiality of access at all, defeating the read-ahead methods used by<br/></li>
<li></span><span class="Comment"> * most Unix kernels.&nbsp; Worse, the output tape gets written into a very random<br/></li>
<li></span><span class="Comment"> * sequence of blocks of the temp file, ensuring that things will be even<br/></li>
<li></span><span class="Comment"> * worse when it comes time to read that tape.&nbsp; A straightforward <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> pass<br/></li>
<li></span><span class="Comment"> * thus ends up doing a lot of <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for disk seeks.&nbsp; We can improve matters<br/></li>
<li></span><span class="Comment"> * by prereading from each source tape sequentially, loading about workMem/M<br/></li>
<li></span><span class="Comment"> * bytes from each tape in turn, and making the sequential blocks immediately<br/></li>
<li></span><span class="Comment"> * available for reuse.&nbsp; This approach helps to localize both read and write<br/></li>
<li></span><span class="Comment"> * accesses.&nbsp; The pre-reading is handled by logtape.c, we just tell it how<br/></li>
<li></span><span class="Comment"> * much memory to use for the buffers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the current code we determine the number of input tapes M on the basis<br/></li>
<li></span><span class="Comment"> * of workMem: we want workMem/M to be large enough that we read a fair<br/></li>
<li></span><span class="Comment"> * amount of data each time we read from a tape, so as to maintain the<br/></li>
<li></span><span class="Comment"> * locality of access described above.&nbsp; Nonetheless, with large workMem we<br/></li>
<li></span><span class="Comment"> * can have many tapes.&nbsp; The logical &quot;tapes&quot; are implemented by logtape.c,<br/></li>
<li></span><span class="Comment"> * which avoids space wastage by recycling disk space as soon as each block<br/></li>
<li></span><span class="Comment"> * is read from its &quot;tape&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When the caller requests random access to the sort result, we form<br/></li>
<li></span><span class="Comment"> * the final sorted run on a logical tape which is then &quot;frozen&quot;, so<br/></li>
<li></span><span class="Comment"> * that we can access it randomly.&nbsp; When the caller does not need random<br/></li>
<li></span><span class="Comment"> * access, we return from <a href="#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>() as soon as we are down<br/></li>
<li></span><span class="Comment"> * to one run per logical tape.&nbsp; The final <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> is then performed<br/></li>
<li></span><span class="Comment"> * on-the-fly as the caller repeatedly calls tuplesort_getXXX; this<br/></li>
<li></span><span class="Comment"> * saves one cycle of writing all the data out to disk and reading it in.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This module supports parallel sorting.&nbsp; Parallel sorts involve coordination<br/></li>
<li></span><span class="Comment"> * among one or more worker processes, and a leader process, each with its own<br/></li>
<li></span><span class="Comment"> * tuplesort state.&nbsp; The leader process (or, more accurately, the<br/></li>
<li></span><span class="Comment"> * <a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> associated with a leader process) creates a full tapeset<br/></li>
<li></span><span class="Comment"> * consisting of worker tapes with one run to <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>; a run for every<br/></li>
<li></span><span class="Comment"> * worker process.&nbsp; This is then merged.&nbsp; Worker processes are guaranteed to<br/></li>
<li></span><span class="Comment"> * produce exactly one output run from their partial input.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/sort/tuplesort.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;commands/tablespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pg_trace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/shmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pg_rusage.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/tuplesort.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initial size of memtuples array.&nbsp; We're trying to <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> this size so that<br/></li>
<li></span><span class="Comment"> * array doesn't exceed ALLOCSET_SEPARATE_THRESHOLD and so that the overhead of<br/></li>
<li></span><span class="Comment"> * allocation might possibly be lowered.&nbsp; However, we don't consider array sizes<br/></li>
<li></span><span class="Comment"> * less than 1024.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L119">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">INITIAL_MEMTUPSIZE</span> Max(</span><span class="Constant">1024</span><span class="PreProc">, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ALLOCSET_SEPARATE_THRESHOLD / </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(SortTuple) + </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* GUC variables */<br/></li>
<li></span><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li><a id="L124">&#x200c;</a></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">trace_sort</span> = <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef DEBUG_BOUNDED_SORT<br/></li>
<li><a id="L128">&#x200c;</a></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">optimize_bounded_sort</span> = <span class="Constant">true</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * During <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>, we use a pre-allocated set of fixed-size slots to hold<br/></li>
<li></span><span class="Comment"> * tuples.&nbsp; To avoid <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>/<a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> overhead.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Merge doesn't require a lot of memory, so we can afford to waste some,<br/></li>
<li></span><span class="Comment"> * by using gratuitously-sized slots.&nbsp; If a tuple is larger than 1 kB, the<br/></li>
<li></span><span class="Comment"> * <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>() overhead is not significant anymore.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'nextfree' is valid when this chunk is in the free list.&nbsp; When in use, the<br/></li>
<li></span><span class="Comment"> * slot holds a tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L143">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SLAB_SLOT_SIZE</span> </span><span class="Constant">1024<br/></li>
<li></span><br/></li>
<li><a id="L145">&#x200c;</a><span class="Type">typedef</span> <span class="Type">union</span> <span class="linkable">SlabSlot</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">union</span> <a href="#L145" title="utils/sort/tuplesort.c:145">SlabSlot</a> *nextfree;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buffer[<a href="#L143" title="utils/sort/tuplesort.c:143">SLAB_SLOT_SIZE</a>];<br/></li>
<li><a id="L149">&#x200c;</a>} <span class="linkable">SlabSlot</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Possible states of a Tuplesort object.&nbsp; These denote the states that<br/></li>
<li></span><span class="Comment"> * persist between calls of Tuplesort routines.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; TSS_INITIAL,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Loading tuples; still within memory limit */<br/></li>
<li></span>&nbsp; &nbsp; TSS_BOUNDED,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Loading tuples into bounded-size heap */<br/></li>
<li></span>&nbsp; &nbsp; TSS_BUILDRUNS,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Loading tuples; writing to tape */<br/></li>
<li></span>&nbsp; &nbsp; TSS_SORTEDINMEM,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sort completed entirely in memory */<br/></li>
<li></span>&nbsp; &nbsp; TSS_SORTEDONTAPE,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sort completed, final run is on tape */<br/></li>
<li></span>&nbsp; &nbsp; TSS_FINALMERGE,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Performing final <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> on-the-fly */<br/></li>
<li><a id="L163">&#x200c;</a></span>} <span class="linkable">TupSortStatus</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Parameters for calculation of number of tapes to use --- see <a href="#L1891" title="utils/sort/tuplesort.c:1891">inittapes</a>()<br/></li>
<li></span><span class="Comment"> * and <a href="#L1804" title="utils/sort/tuplesort.c:1804">tuplesort_merge_order</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In this calculation we assume that each tape will cost us about 1 blocks<br/></li>
<li></span><span class="Comment"> * worth of buffer space.&nbsp; This ignores the overhead of all the other data<br/></li>
<li></span><span class="Comment"> * structures needed for each tape, but it's probably close enough.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L180" title="utils/sort/tuplesort.c:180">MERGE_BUFFER_SIZE</a> is how much buffer space we'd like to allocate for each<br/></li>
<li></span><span class="Comment"> * input tape, for pre-reading (see discussion at top of file).&nbsp; This is *in<br/></li>
<li></span><span class="Comment"> * addition to* the 1 block already included in <a href="#L179" title="utils/sort/tuplesort.c:179">TAPE_BUFFER_OVERHEAD</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L177">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MINORDER</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">6</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* minimum <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> order */<br/></li>
<li><a id="L178">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAXORDER</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">500</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* maximum <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> order */<br/></li>
<li><a id="L179">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TAPE_BUFFER_OVERHEAD</span>&nbsp; &nbsp; &nbsp; &nbsp; BLCKSZ<br/></li>
<li><a id="L180">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MERGE_BUFFER_SIZE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (BLCKSZ * </span><span class="Constant">32</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Private state of a Tuplesort operation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L186">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">Tuplesortstate</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TuplesortPublic base;<br/></li>
<li>&nbsp; &nbsp; <a href="#L163" title="utils/sort/tuplesort.c:163">TupSortStatus</a> status;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* enumerated value as shown above */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; bounded;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* did caller specify a maximum number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples to return? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; boundUsed;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* true if we made use of a bounded heap */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bound;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if bounded, the maximum number of tuples */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; tupleMem;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* memory consumed by individual tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * storing this separately from what we track<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in availMem allows us to subtract the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memory consumed by all tuples when dumping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples to tape */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; availMem;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remaining memory available, in bytes */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; allowedMem;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* total memory allowed, in bytes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxTapes;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* max number of input tapes to <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> in each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pass */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; maxSpace;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* maximum amount of space occupied among sort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of groups, either in-memory or on-disk */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isMaxSpaceDisk; <span class="Comment">/* true when maxSpace is value for on-disk<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * space, false when it's value for in-memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * space */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L163" title="utils/sort/tuplesort.c:163">TupSortStatus</a> maxSpaceStatus;&nbsp; &nbsp; <span class="Comment">/* sort status when maxSpace was reached */<br/></li>
<li></span>&nbsp; &nbsp; <a href="logtape.c.html#L187" title="utils/sort/logtape.c:187">LogicalTapeSet</a> *tapeset;&nbsp; &nbsp; <span class="Comment">/* logtape.c object for tapes in a temp file */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This array holds the tuples <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> in sort memory.&nbsp; If we are in state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * INITIAL, the tuples are in no particular order; if we are in state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SORTEDINMEM, the tuples are in final sorted order; in states BUILDRUNS<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and FINALMERGE, the tuples are organized in &quot;heap&quot; order per Algorithm<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * H.&nbsp; In state SORTEDONTAPE, the array is not used.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SortTuple&nbsp; *memtuples;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* array of SortTuple structs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memtupcount;&nbsp; &nbsp; <span class="Comment">/* number of tuples currently present */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memtupsize;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocated length of memtuples array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; growmemtuples;&nbsp; &nbsp; <span class="Comment">/* memtuples' growth still underway? */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Memory for tuples is sometimes allocated using a simple slab allocator,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rather than with <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>().&nbsp; Currently, we switch to slab allocation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when we start merging.&nbsp; Merging only needs to keep a small, fixed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number of tuples in memory at <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> time, so we can avoid the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>/<a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> overhead by recycling a fixed number of fixed-size slots<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to hold the tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For the slab, we use one large allocation, divided into <a href="#L143" title="utils/sort/tuplesort.c:143">SLAB_SLOT_SIZE</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slots.&nbsp; The allocation is sized to have one slot per tape, plus one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * additional slot.&nbsp; We need that many slots to hold all the tuples kept<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the heap during <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>, plus the one we have last returned from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sort, with tuplesort_gettuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initially, all the slots are kept in a linked list of free slots.&nbsp; When<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a tuple is read from a tape, it is put to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> available slot, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it fits.&nbsp; If the tuple is larger than <a href="#L143" title="utils/sort/tuplesort.c:143">SLAB_SLOT_SIZE</a>, it is <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When we're done processing a tuple, we return the slot back to the free<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list, or <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>() if it was <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d.&nbsp; We know that a tuple was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocated from the slab, if its pointer value is between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slabMemoryBegin and -End.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When the slab allocator is used, the <a href="#L404" title="utils/sort/tuplesort.c:404">USEMEM</a>/<a href="#L403" title="utils/sort/tuplesort.c:403">LACKMEM</a> mechanism of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tracking memory usage is not used.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; slabAllocatorUsed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *slabMemoryBegin;&nbsp; &nbsp; <span class="Comment">/* beginning of slab memory arena */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *slabMemoryEnd;&nbsp; &nbsp; <span class="Comment">/* end of slab memory arena */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L145" title="utils/sort/tuplesort.c:145">SlabSlot</a>&nbsp;&nbsp; *slabFreeHead;&nbsp; &nbsp; <span class="Comment">/* head of free list */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Memory used for input and output tape buffers. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; tape_buffer_mem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When we return a tuple to the caller in tuplesort_gettuple_XXX, that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * came from a tape (that is, in TSS_SORTEDONTAPE or TSS_FINALMERGE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * modes), we remember the tuple in 'lastReturnedTuple', so that we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recycle the memory on <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> gettuple call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *lastReturnedTuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * While building initial runs, this is the current output run number.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Afterwards, it is the number of initial runs we made.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currentRun;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Logical tapes, for merging.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The initial runs are written in the output tapes.&nbsp; In each <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> pass,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the output tapes of the previous pass become the input tapes, and new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * output tapes are created as needed.&nbsp; When nInputTapes equals<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nInputRuns, there is only one <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> pass left.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> **inputTapes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nInputTapes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nInputRuns;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> **outputTapes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nOutputTapes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nOutputRuns;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *destTape;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* current output tape */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These variables are used after completion of sorting to keep track of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple to return.&nbsp; (In the tape case, the tape's current read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * position is also critical state.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *result_tape;&nbsp; &nbsp; <span class="Comment">/* actual tape of finished output */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* array index (only used if SORTEDINMEM) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; eof_reached;&nbsp; &nbsp; <span class="Comment">/* reached EOF (needed for cursors) */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* markpos_xxx holds marked position for mark and restore */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; markpos_block;&nbsp; &nbsp; <span class="Comment">/* tape block# (only used if SORTEDONTAPE) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; markpos_offset; <span class="Comment">/* saved &quot;current&quot;, or offset in tape block */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; markpos_eof;&nbsp; &nbsp; <span class="Comment">/* saved &quot;eof_reached&quot; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These variables are used during parallel sorting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worker is our worker identifier.&nbsp; Follows the general convention that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * -1 value relates to a leader tuplesort, and <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> &gt;= 0 worker<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuplesorts. (-1 can also be a serial tuplesort.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared is mutable shared memory state, which is used to coordinate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel sorts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nParticipants is the number of worker Tuplesortstates known by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leader to have actually been launched, which implies that they must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * finish a run that the leader needs to <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>.&nbsp; Typically includes a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worker state held by the leader process itself.&nbsp; Set in the leader<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> only.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worker;<br/></li>
<li>&nbsp; &nbsp; <a href="#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a> *shared;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nParticipants;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Additional state for managing &quot;abbreviated key&quot; sortsupport routines<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (which currently may be used by all cases except the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> index case).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Tracks the intervals at which the optimization's effectiveness is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tested.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; abbrevNext;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Tuple # at which to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * applicability */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Resource snapshot for time of sort start.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; PGRUsage&nbsp; &nbsp; ru_start;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Private mutable state of tuplesort-parallel-operation.&nbsp; This is allocated<br/></li>
<li></span><span class="Comment"> * in shared memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L346">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">Sharedsort</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* mutex protects all fields prior to tapes */<br/></li>
<li></span>&nbsp; &nbsp; slock_t&nbsp; &nbsp; &nbsp; &nbsp; mutex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * currentWorker generates ordinal identifier numbers for parallel sort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * workers.&nbsp; These start from 0, and are always gapless.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Workers increment workersFinished to indicate having finished.&nbsp; If this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to state.nParticipants within the leader, leader is ready to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> worker runs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currentWorker;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workersFinished;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Temporary file space */<br/></li>
<li></span>&nbsp; &nbsp; SharedFileSet fileset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Size of tapes flexible array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nTapes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Tapes array used by workers to report back information needed by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leader to concatenate all worker tapes into one for merging<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; TapeShare&nbsp; &nbsp; tapes[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Is the given tuple allocated from the slab memory arena?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L378">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">IS_SLAB_SLOT</span>(state, tuple) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((</span><span class="Type">char</span><span class="PreProc"> *) (tuple) &gt;= (state)-&gt;slabMemoryBegin &amp;&amp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; (</span><span class="Type">char</span><span class="PreProc"> *) (tuple) &lt; (state)-&gt;slabMemoryEnd)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the given tuple to the slab memory free list, or free it<br/></li>
<li></span><span class="Comment"> * if it was <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L386">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RELEASE_SLAB_SLOT</span>(state, tuple) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L145" title="utils/sort/tuplesort.c:145">SlabSlot</a> *buf = (<a href="#L145" title="utils/sort/tuplesort.c:145">SlabSlot</a> *) tuple; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (<a href="#L378" title="utils/sort/tuplesort.c:378">IS_SLAB_SLOT</a>((state), buf)) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf-&gt;nextfree = (state)-&gt;slabFreeHead; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (state)-&gt;slabFreeHead = buf; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; } </span><span class="Statement">else</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L398">&#x200c;</a><span class="PreProc">#define <span class="linkable">REMOVEABBREV</span>(state,stup,count)&nbsp; &nbsp; ((*(state)-&gt;base.removeabbrev) (state, stup, count))<br/></li>
<li><a id="L399">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">COMPARETUP</span>(state,a,b)&nbsp; &nbsp; ((*(state)-&gt;base.comparetup) (a, b, state))<br/></li>
<li><a id="L400">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITETUP</span>(state,tape,stup)&nbsp; &nbsp; ((*(state)-&gt;base.writetup) (state, tape, stup))<br/></li>
<li><a id="L401">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READTUP</span>(state,stup,tape,len) ((*(state)-&gt;base.readtup) (state, stup, tape, len))<br/></li>
<li><a id="L402">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FREESTATE</span>(state)&nbsp; &nbsp; ((state)-&gt;base.<a href="../../regex/regc_nfa.c.html#L242" title="regex/regc_nfa.c:242">freestate</a> ? (*(state)-&gt;base.<a href="../../regex/regc_nfa.c.html#L242" title="regex/regc_nfa.c:242">freestate</a>) (state) : (</span><span class="Type">void</span><span class="PreProc">) </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L403">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LACKMEM</span>(state)&nbsp; &nbsp; &nbsp; &nbsp; ((state)-&gt;availMem &lt; </span><span class="Constant">0</span><span class="PreProc"> &amp;&amp; !(state)-&gt;slabAllocatorUsed)<br/></li>
<li><a id="L404">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">USEMEM</span>(state,amt)&nbsp; &nbsp; ((state)-&gt;availMem -= (amt))<br/></li>
<li><a id="L405">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FREEMEM</span>(state,amt)&nbsp; &nbsp; ((state)-&gt;availMem += (amt))<br/></li>
<li><a id="L406">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SERIAL</span>(state)&nbsp; &nbsp; &nbsp; &nbsp; ((state)-&gt;shared == </span><span class="Constant">NULL</span><span class="PreProc">)<br/></li>
<li><a id="L407">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WORKER</span>(state)&nbsp; &nbsp; &nbsp; &nbsp; ((state)-&gt;shared &amp;&amp; (state)-&gt;worker != -</span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li><a id="L408">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LEADER</span>(state)&nbsp; &nbsp; &nbsp; &nbsp; ((state)-&gt;shared &amp;&amp; (state)-&gt;worker == -</span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * NOTES about on-tape representation of tuples:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We require the first &quot;unsigned int&quot; of a stored tuple to be the total size<br/></li>
<li></span><span class="Comment"> * on-tape of the tuple, including itself (so it is never zero; an all-zero<br/></li>
<li></span><span class="Comment"> * unsigned int is used to delimit runs).&nbsp; The remainder of the stored tuple<br/></li>
<li></span><span class="Comment"> * may or may not match the in-memory representation of the tuple ---<br/></li>
<li></span><span class="Comment"> * <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> conversion needed is the job of the writetup and readtup routines.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If state-&gt;sortopt contains TUPLESORT_RANDOMACCESS, then the stored<br/></li>
<li></span><span class="Comment"> * representation of the tuple must be followed by another &quot;unsigned int&quot; that<br/></li>
<li></span><span class="Comment"> * is a copy of the length --- so the total tape space used is actually<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(unsigned int) more than the stored length value.&nbsp; This allows<br/></li>
<li></span><span class="Comment"> * read-backwards.&nbsp; When the random access flag was not specified, the<br/></li>
<li></span><span class="Comment"> * write/read routines may omit the extra length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * writetup is expected to write both length words as well as the tuple<br/></li>
<li></span><span class="Comment"> * data.&nbsp; When readtup is called, the tape is positioned just after the<br/></li>
<li></span><span class="Comment"> * front length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>; readtup must read the tuple data and advance past<br/></li>
<li></span><span class="Comment"> * the back length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> (if present).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The write/read routines can make use of the tuple description data<br/></li>
<li></span><span class="Comment"> * stored in the <a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> record, if needed.&nbsp; They are also expected<br/></li>
<li></span><span class="Comment"> * to adjust state-&gt;availMem by the amount of memory space (not tape space!)<br/></li>
<li></span><span class="Comment"> * released or consumed.&nbsp; There is no error return from either writetup<br/></li>
<li></span><span class="Comment"> * or readtup; they should ereport() on failure.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES about memory consumption calculations:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We count space allocated for tuples against the workMem limit, plus<br/></li>
<li></span><span class="Comment"> * the space used by the variable-size memtuples array.&nbsp; Fixed-size space<br/></li>
<li></span><span class="Comment"> * is not counted; it's small enough to not be interesting.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we count actual space used (as shown by <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>)<br/></li>
<li></span><span class="Comment"> * rather than the originally-requested size.&nbsp; This is important since<br/></li>
<li></span><span class="Comment"> * <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> can add substantial overhead.&nbsp; It's not a complete answer since<br/></li>
<li></span><span class="Comment"> * we won't count <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> wasted space in <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> allocation blocks, but it's<br/></li>
<li></span><span class="Comment"> * a lot better than what we were doing <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> 7.3.&nbsp; As of 9.6, a<br/></li>
<li></span><span class="Comment"> * separate memory context is used for caller passed tuples.&nbsp; Resetting<br/></li>
<li></span><span class="Comment"> * it at certain key increments significantly ameliorates fragmentation.<br/></li>
<li></span><span class="Comment"> * readtup routines use the slab allocator (they cannot use<br/></li>
<li></span><span class="Comment"> * the reset context because it gets deleted at the point that merging<br/></li>
<li></span><span class="Comment"> * begins).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L757" title="utils/sort/tuplesort.c:757">tuplesort_begin_batch</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1341" title="utils/sort/tuplesort.c:1341">consider_abort_common</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1891" title="utils/sort/tuplesort.c:1891">inittapes</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2045" title="utils/sort/tuplesort.c:2045">mergeruns</a>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1942" title="utils/sort/tuplesort.c:1942">inittapestate</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <span class="Type">int</span> maxTapes);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1976" title="utils/sort/tuplesort.c:1976">selectnewtape</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2009" title="utils/sort/tuplesort.c:2009">init_slab_allocator</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <span class="Type">int</span> numSlots);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2045" title="utils/sort/tuplesort.c:2045">mergeruns</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2232" title="utils/sort/tuplesort.c:2232">mergeonerun</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2292" title="utils/sort/tuplesort.c:2292">beginmerge</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2320" title="utils/sort/tuplesort.c:2320">mergereadnext</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *srcTape, SortTuple *stup);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2339" title="utils/sort/tuplesort.c:2339">dumptuples</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> alltuples);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2625" title="utils/sort/tuplesort.c:2625">make_bounded_heap</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2674" title="utils/sort/tuplesort.c:2674">sort_bounded_heap</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2714" title="utils/sort/tuplesort.c:2714">tuplesort_sort_memtuples</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2777" title="utils/sort/tuplesort.c:2777">tuplesort_heap_insert</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *tuple);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2836" title="utils/sort/tuplesort.c:2836">tuplesort_heap_replace_top</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *tuple);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2812" title="utils/sort/tuplesort.c:2812">tuplesort_heap_delete_top</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2876" title="utils/sort/tuplesort.c:2876">reversedirection</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">unsigned</span> <span class="Type">int</span> <a href="#L2894" title="utils/sort/tuplesort.c:2894">getlen</a>(<a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> eofOK);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2907" title="utils/sort/tuplesort.c:2907">markrunend</a>(<a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L3019" title="utils/sort/tuplesort.c:3019">worker_get_identifier</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3047" title="utils/sort/tuplesort.c:3047">worker_freeze_result_tape</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3085" title="utils/sort/tuplesort.c:3085">worker_nomergeruns</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3107" title="utils/sort/tuplesort.c:3107">leader_takeover_tapes</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3166" title="utils/sort/tuplesort.c:3166">free_sort_tuple</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *stup);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L902" title="utils/sort/tuplesort.c:902">tuplesort_free</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L988" title="utils/sort/tuplesort.c:988">tuplesort_updatemax</a>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Specialized comparators that we can inline into specialized sorts.&nbsp; The goal<br/></li>
<li></span><span class="Comment"> * is to try to sort two tuples without having to follow the pointers to the<br/></li>
<li></span><span class="Comment"> * comparator or the tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment">: For <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, there is no specialization for cases where datum1 is<br/></li>
<li></span><span class="Comment"> * authoritative and we don't even need to fall back to a callback at all (that<br/></li>
<li></span><span class="Comment"> * would be true for types like int4/int8/timestamp/date, but not true for<br/></li>
<li></span><span class="Comment"> * abbreviations of text or multi-key sorts.&nbsp; There could be!&nbsp; Is it worth it?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Used if first key's comparator is <a href="#L3177" title="utils/sort/tuplesort.c:3177">ssup_datum_unsigned_cmp</a> */<br/></li>
<li></span><span class="Type">static</span> pg_attribute_always_inline <span class="Type">int<br/></li>
<li><a id="L498">&#x200c;</a></span><span class="linkable">qsort_tuple_unsigned_compare</span>(SortTuple *a, SortTuple *b, <a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> = ApplyUnsignedSortComparator(a-&gt;datum1, a-&gt;isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b-&gt;datum1, b-&gt;isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;state-&gt;base.sortKeys[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No need to waste effort calling the tiebreak function when there are no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other keys to sort on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;base.onlyKey != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state-&gt;base.comparetup_tiebreak(a, b, state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#if SIZEOF_DATUM &gt;= </span><span class="Constant">8<br/></li>
<li></span><span class="Comment">/* Used if first key's comparator is <a href="#L3189" title="utils/sort/tuplesort.c:3189">ssup_datum_signed_cmp</a> */<br/></li>
<li></span><span class="Type">static</span> pg_attribute_always_inline <span class="Type">int<br/></li>
<li><a id="L521">&#x200c;</a></span><span class="linkable">qsort_tuple_signed_compare</span>(SortTuple *a, SortTuple *b, <a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> = ApplySignedSortComparator(a-&gt;datum1, a-&gt;isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b-&gt;datum1, b-&gt;isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;state-&gt;base.sortKeys[<span class="Constant">0</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No need to waste effort calling the tiebreak function when there are no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other keys to sort on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;base.onlyKey != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state-&gt;base.comparetup_tiebreak(a, b, state);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Used if first key's comparator is <a href="#L3204" title="utils/sort/tuplesort.c:3204">ssup_datum_int32_cmp</a> */<br/></li>
<li></span><span class="Type">static</span> pg_attribute_always_inline <span class="Type">int<br/></li>
<li><a id="L545">&#x200c;</a></span><span class="linkable">qsort_tuple_int32_compare</span>(SortTuple *a, SortTuple *b, <a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> = ApplyInt32SortComparator(a-&gt;datum1, a-&gt;isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; b-&gt;datum1, b-&gt;isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;state-&gt;base.sortKeys[<span class="Constant">0</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No need to waste effort calling the tiebreak function when there are no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other keys to sort on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;base.onlyKey != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state-&gt;base.comparetup_tiebreak(a, b, state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Special versions of qsort just for SortTuple objects.&nbsp; qsort_tuple() sorts<br/></li>
<li></span><span class="Comment"> * <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> variant of SortTuples, using the appropriate comparetup function.<br/></li>
<li></span><span class="Comment"> * qsort_ssup() is specialized for the case where the comparetup function<br/></li>
<li></span><span class="Comment"> * reduces to ApplySortComparator(), that is single-key MinimalTuple sorts<br/></li>
<li></span><span class="Comment"> * and Datum sorts.&nbsp; qsort_tuple_{unsigned,signed,int32} are specialized for<br/></li>
<li></span><span class="Comment"> * common comparison <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> on pass-by-value leading datums.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L575">&#x200c;</a><span class="PreProc">#define <span class="linkable">ST_SORT</span> qsort_tuple_unsigned<br/></li>
<li><a id="L576">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_ELEMENT_TYPE</span> SortTuple<br/></li>
<li><a id="L577">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_COMPARE</span>(a, b, state) <a href="#L498" title="utils/sort/tuplesort.c:498">qsort_tuple_unsigned_compare</a>(a, b, state)<br/></li>
<li><a id="L578">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_COMPARE_ARG_TYPE</span> <a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a><br/></li>
<li><a id="L579">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_CHECK_FOR_INTERRUPTS</span><br/></li>
<li><a id="L580">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_SCOPE</span> </span><span class="Type">static<br/></li>
<li><a id="L581">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_DEFINE</span><br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/sort_template.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#if SIZEOF_DATUM &gt;= </span><span class="Constant">8<br/></li>
<li><a id="L585">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_SORT</span> qsort_tuple_signed<br/></li>
<li><a id="L586">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_ELEMENT_TYPE</span> SortTuple<br/></li>
<li><a id="L587">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_COMPARE</span>(a, b, state) <a href="#L521" title="utils/sort/tuplesort.c:521">qsort_tuple_signed_compare</a>(a, b, state)<br/></li>
<li><a id="L588">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_COMPARE_ARG_TYPE</span> <a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a><br/></li>
<li><a id="L589">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_CHECK_FOR_INTERRUPTS</span><br/></li>
<li><a id="L590">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_SCOPE</span> </span><span class="Type">static<br/></li>
<li><a id="L591">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_DEFINE</span><br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/sort_template.h&quot;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L595">&#x200c;</a><span class="PreProc">#define <span class="linkable">ST_SORT</span> qsort_tuple_int32<br/></li>
<li><a id="L596">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_ELEMENT_TYPE</span> SortTuple<br/></li>
<li><a id="L597">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_COMPARE</span>(a, b, state) <a href="#L545" title="utils/sort/tuplesort.c:545">qsort_tuple_int32_compare</a>(a, b, state)<br/></li>
<li><a id="L598">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_COMPARE_ARG_TYPE</span> <a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a><br/></li>
<li><a id="L599">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_CHECK_FOR_INTERRUPTS</span><br/></li>
<li><a id="L600">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_SCOPE</span> </span><span class="Type">static<br/></li>
<li><a id="L601">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_DEFINE</span><br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/sort_template.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L604">&#x200c;</a><span class="PreProc">#define <span class="linkable">ST_SORT</span> qsort_tuple<br/></li>
<li><a id="L605">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_ELEMENT_TYPE</span> SortTuple<br/></li>
<li><a id="L606">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_COMPARE_RUNTIME_POINTER</span><br/></li>
<li><a id="L607">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_COMPARE_ARG_TYPE</span> <a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a><br/></li>
<li><a id="L608">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_CHECK_FOR_INTERRUPTS</span><br/></li>
<li><a id="L609">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_SCOPE</span> </span><span class="Type">static<br/></li>
<li><a id="L610">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_DECLARE</span><br/></li>
<li><a id="L611">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_DEFINE</span><br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/sort_template.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L614">&#x200c;</a><span class="PreProc">#define <span class="linkable">ST_SORT</span> qsort_ssup<br/></li>
<li><a id="L615">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_ELEMENT_TYPE</span> SortTuple<br/></li>
<li><a id="L616">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_COMPARE</span>(a, b, ssup) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ApplySortComparator((a)-&gt;datum1, (a)-&gt;isnull1, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (b)-&gt;datum1, (b)-&gt;isnull1, (ssup))<br/></li>
<li><a id="L619">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_COMPARE_ARG_TYPE</span> SortSupportData<br/></li>
<li><a id="L620">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_CHECK_FOR_INTERRUPTS</span><br/></li>
<li><a id="L621">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_SCOPE</span> </span><span class="Type">static<br/></li>
<li><a id="L622">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ST_DEFINE</span><br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/sort_template.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; tuplesort_begin_xxx<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Initialize for a tuple sort operation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * After calling tuplesort_begin, the caller should call tuplesort_putXXX<br/></li>
<li></span><span class="Comment"> * zero or more times, then call <a href="#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a> when all the tuples<br/></li>
<li></span><span class="Comment"> * have been supplied.&nbsp; After performsort, retrieve the tuples in sorted<br/></li>
<li></span><span class="Comment"> * order by calling tuplesort_getXXX until it returns false/NULL.&nbsp; (If random<br/></li>
<li></span><span class="Comment"> * access was requested, rescan, markpos, and restorepos can also be called.)<br/></li>
<li></span><span class="Comment"> * Call <a href="#L971" title="utils/sort/tuplesort.c:971">tuplesort_end</a> to terminate the operation and release memory/disk space.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Each variant of tuplesort_begin has a workMem parameter specifying the<br/></li>
<li></span><span class="Comment"> * maximum number of kilobytes of RAM to use <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> spilling data to disk.<br/></li>
<li></span><span class="Comment"> * (The normal value of this parameter is <a href="../init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>, but some callers use<br/></li>
<li></span><span class="Comment"> * other <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.)&nbsp; Each variant also has a sortopt which is a bitmask of<br/></li>
<li></span><span class="Comment"> * sort options.&nbsp; See TUPLESORT_* definitions in tuplesort.h<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *<br/></li>
<li><a id="L645">&#x200c;</a><span class="linkable">tuplesort_begin_common</span>(<span class="Type">int</span> workMem, SortCoordinate coordinate, <span class="Type">int</span> sortopt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state;<br/></li>
<li>&nbsp; &nbsp; MemoryContext maincontext;<br/></li>
<li>&nbsp; &nbsp; MemoryContext sortcontext;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See <a href="#L3107" title="utils/sort/tuplesort.c:3107">leader_takeover_tapes</a>() remarks on random access support */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (coordinate &amp;&amp; (sortopt &amp; TUPLESORT_RANDOMACCESS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;random access disallowed under parallel sort&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Memory context surviving <a href="#L1039" title="utils/sort/tuplesort.c:1039">tuplesort_reset</a>.&nbsp; This memory context holds<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data which is useful to keep while sorting multiple similar batches.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; maincontext = AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;TupleSort <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a working memory context for one sort operation.&nbsp; The content of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this context is deleted by <a href="#L1039" title="utils/sort/tuplesort.c:1039">tuplesort_reset</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sortcontext = AllocSetContextCreate(maincontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;TupleSort sort&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Additionally a working memory context for tuples is setup in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L757" title="utils/sort/tuplesort.c:757">tuplesort_begin_batch</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make the <a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> within the per-sortstate context.&nbsp; This way, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't need a separate <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>() operation for it at shutdown.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(maincontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = (<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a>));<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/pg_rusage.c.html#L27" title="utils/misc/pg_rusage.c:27">pg_rusage_init</a>(&amp;state-&gt;ru_start);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; state-&gt;base.sortopt = sortopt;<br/></li>
<li>&nbsp; &nbsp; state-&gt;base.tuples = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;abbrevNext = <span class="Constant">10</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * workMem is forced to be at least 64KB, the current minimum valid value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the <a href="../init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> GUC.&nbsp; This is a defense against parallel sort callers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that divide out memory among many workers in a way that leaves each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with very little memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;allowedMem = Max(workMem, <span class="Constant">64</span>) * (int64) <span class="Constant">1024</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;base.sortcontext = sortcontext;<br/></li>
<li>&nbsp; &nbsp; state-&gt;base.maincontext = maincontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * see comments in <a href="#L1072" title="utils/sort/tuplesort.c:1072">grow_memtuples</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;memtupsize = <a href="#L119" title="utils/sort/tuplesort.c:119">INITIAL_MEMTUPSIZE</a>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;memtuples = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * After all of the other non-parallel-related state, we setup all of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state needed for each batch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L757" title="utils/sort/tuplesort.c:757">tuplesort_begin_batch</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize parallel-related state based on coordination information<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!coordinate)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Serial sort */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;shared = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;worker = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nParticipants = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (coordinate-&gt;isWorker)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Parallel worker produces exactly one final run from all input */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;shared = coordinate-&gt;sharedsort;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;worker = <a href="#L3019" title="utils/sort/tuplesort.c:3019">worker_get_identifier</a>(state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nParticipants = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Parallel leader state only used for final <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;shared = coordinate-&gt;sharedsort;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;worker = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nParticipants = coordinate-&gt;nParticipants;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;nParticipants &gt;= <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L757" title="utils/sort/tuplesort.c:757">tuplesort_begin_batch</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Setup, or reset, all state need for processing a new set of tuples with this<br/></li>
<li></span><span class="Comment"> * sort state. Called both from <a href="#L645" title="utils/sort/tuplesort.c:645">tuplesort_begin_common</a> (the first time sorting<br/></li>
<li></span><span class="Comment"> * with this sort state) and <a href="#L1039" title="utils/sort/tuplesort.c:1039">tuplesort_reset</a> (for subsequent usages).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L757">&#x200c;</a></span><span class="linkable">tuplesort_begin_batch</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(state-&gt;base.maincontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Caller tuple (e.g. IndexTuple) memory context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A dedicated child context used exclusively for caller passed tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * eases memory management.&nbsp; Resetting at key points reduces<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fragmentation. Note that the memtuples array of SortTuples is allocated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the parent context, not this context, because there is no need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * free memtuples early.&nbsp; For bounded sorts, tuples may be pfreed in <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * order, so we use a regular aset.c context so that it can make use of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * free'd memory.&nbsp; When the sort is not bounded, we make use of a bump.c<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * context as this keeps allocations more <a href="../../regex/regc_nfa.c.html#L3479" title="regex/regc_nfa.c:3479">compact</a> with less wastage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocations are also slightly more CPU efficient.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TupleSortUseBumpTupleCxt(state-&gt;base.sortopt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;base.tuplecontext = <a href="../mmgr/bump.c.html#L131" title="utils/mmgr/bump.c:131">BumpContextCreate</a>(state-&gt;base.sortcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Caller tuples&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;base.tuplecontext = AllocSetContextCreate(state-&gt;base.sortcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Caller tuples&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;status = TSS_INITIAL;<br/></li>
<li>&nbsp; &nbsp; state-&gt;bounded = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;boundUsed = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;availMem = state-&gt;allowedMem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;tapeset = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;memtupcount = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * see comments in <a href="#L1072" title="utils/sort/tuplesort.c:1072">grow_memtuples</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;growmemtuples = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;slabAllocatorUsed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;memtuples != <span class="Constant">NULL</span> &amp;&amp; state-&gt;memtupsize != <a href="#L119" title="utils/sort/tuplesort.c:119">INITIAL_MEMTUPSIZE</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state-&gt;memtuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;memtuples = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;memtupsize = <a href="#L119" title="utils/sort/tuplesort.c:119">INITIAL_MEMTUPSIZE</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;memtuples == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;memtuples = (SortTuple *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(state-&gt;memtupsize * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortTuple));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L404" title="utils/sort/tuplesort.c:404">USEMEM</a>(state, <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>(state-&gt;memtuples));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* workMem must be large enough for the minimal memtuples array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L403" title="utils/sort/tuplesort.c:403">LACKMEM</a>(state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;insufficient memory allowed for sort&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;currentRun = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Tape variables (inputTapes, outputTapes, etc.) will be initialized by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1891" title="utils/sort/tuplesort.c:1891">inittapes</a>(), if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; state-&gt;result_tape = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* flag that result tape has not been formed */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L843" title="utils/sort/tuplesort.c:843">tuplesort_set_bound</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Advise tuplesort that at most the first N result tuples are required.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Must be called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> inserting <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples.&nbsp; (Actually, we could allow it<br/></li>
<li></span><span class="Comment"> * as long as the sort hasn't spilled to disk, but there seems no need for<br/></li>
<li></span><span class="Comment"> * delayed calls at the moment.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a hint only. The tuplesort may still return more tuples than<br/></li>
<li></span><span class="Comment"> * requested.&nbsp; Parallel leader tuplesorts will always ignore the hint.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L843">&#x200c;</a></span><span class="linkable">tuplesort_set_bound</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, int64 bound)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assert we're called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> loading <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples */<br/></li>
<li></span>&nbsp; &nbsp; Assert(state-&gt;status == TSS_INITIAL &amp;&amp; state-&gt;memtupcount == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assert we allow bounded sorts */<br/></li>
<li></span>&nbsp; &nbsp; Assert(state-&gt;base.sortopt &amp; TUPLESORT_ALLOWBOUNDED);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't set the bound twice, either */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!state-&gt;bounded);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Also, this shouldn't be called in a parallel worker */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!<a href="#L407" title="utils/sort/tuplesort.c:407">WORKER</a>(state));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Parallel leader allows but ignores hint */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L408" title="utils/sort/tuplesort.c:408">LEADER</a>(state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef DEBUG_BOUNDED_SORT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Honor GUC setting that disables the feature (for easy testing) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L128" title="utils/sort/tuplesort.c:128">optimize_bounded_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We want to be able to compute bound * 2, so limit the setting */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bound &gt; (int64) (<span class="Constant">INT_MAX</span> / <span class="Constant">2</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;bounded = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;bound = (<span class="Type">int</span>) bound;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Bounded sorts are not an effective target for abbreviated key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * optimization.&nbsp; Disable by setting state to be consistent with no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * abbreviation support.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;base.sortKeys-&gt;abbrev_converter = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;base.sortKeys-&gt;abbrev_full_comparator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;base.sortKeys-&gt;comparator = state-&gt;base.sortKeys-&gt;abbrev_full_comparator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Not strictly necessary, but be tidy */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;base.sortKeys-&gt;abbrev_abort = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;base.sortKeys-&gt;abbrev_full_comparator = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L891" title="utils/sort/tuplesort.c:891">tuplesort_used_bound</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Allow callers to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out if the sort state was able to use a bound.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L891">&#x200c;</a></span><span class="linkable">tuplesort_used_bound</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state-&gt;boundUsed;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L902" title="utils/sort/tuplesort.c:902">tuplesort_free</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Internal routine for freeing resources of tuplesort.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L902">&#x200c;</a></span><span class="linkable">tuplesort_free</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* context swap probably not needed, but let's be safe */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext oldcontext = MemoryContextSwitchTo(state-&gt;base.sortcontext);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; spaceUsed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;tapeset)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; spaceUsed = <a href="logtape.c.html#L1181" title="utils/sort/logtape.c:1181">LogicalTapeSetBlocks</a>(state-&gt;tapeset);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; spaceUsed = (state-&gt;allowedMem - state-&gt;availMem + <span class="Constant">1023</span>) / <span class="Constant">1024</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> temporary &quot;tape&quot; files, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: want to include this in reported total cost of sort, hence need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for two #ifdef TRACE_SORT sections.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't bother to destroy the individual tapes here. They will go away<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with the sortcontext.&nbsp; (In TSS_FINALMERGE state, we have closed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * finished tapes already.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;tapeset)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="logtape.c.html#L667" title="utils/sort/logtape.c:667">LogicalTapeSetClose</a>(state-&gt;tapeset);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;tapeset)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> of worker </span><span class="Special">%d</span><span class="Constant"> ended, </span><span class="Special">%lld</span><span class="Constant"> disk blocks used: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L406" title="utils/sort/tuplesort.c:406">SERIAL</a>(state) ? <span class="Constant">&quot;external sort&quot;</span> : <span class="Constant">&quot;parallel external sort&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;worker, (<span class="Type">long</span> <span class="Type">long</span>) spaceUsed, <a href="../misc/pg_rusage.c.html#L40" title="utils/misc/pg_rusage.c:40">pg_rusage_show</a>(&amp;state-&gt;ru_start));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> of worker </span><span class="Special">%d</span><span class="Constant"> ended, </span><span class="Special">%lld</span><span class="Constant"> KB used: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L406" title="utils/sort/tuplesort.c:406">SERIAL</a>(state) ? <span class="Constant">&quot;<a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> sort&quot;</span> : <span class="Constant">&quot;unperformed parallel sort&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;worker, (<span class="Type">long</span> <span class="Type">long</span>) spaceUsed, <a href="../misc/pg_rusage.c.html#L40" title="utils/misc/pg_rusage.c:40">pg_rusage_show</a>(&amp;state-&gt;ru_start));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_SORT_DONE(state-&gt;tapeset != <span class="Constant">NULL</span>, spaceUsed);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If you disabled TRACE_SORT, you can still probe sort__done, but you<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ain't getting space-used stats.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; TRACE_POSTGRESQL_SORT_DONE(state-&gt;tapeset != <span class="Constant">NULL</span>, <span class="Constant">0L</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L402" title="utils/sort/tuplesort.c:402">FREESTATE</a>(state);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Free the per-sort memory context, thereby releasing all working memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(state-&gt;base.sortcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L971" title="utils/sort/tuplesort.c:971">tuplesort_end</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Release resources and clean up.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: after calling this, <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pointers returned by tuplesort_getXXX are<br/></li>
<li></span><span class="Comment"> * pointing to garbage.&nbsp; Be careful not to attempt to use or free such<br/></li>
<li></span><span class="Comment"> * pointers afterwards!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L971">&#x200c;</a></span><span class="linkable">tuplesort_end</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L902" title="utils/sort/tuplesort.c:902">tuplesort_free</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Free the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> memory context, including the <a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> struct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(state-&gt;base.maincontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L988" title="utils/sort/tuplesort.c:988">tuplesort_updatemax</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Update maximum resource usage statistics.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L988">&#x200c;</a></span><span class="linkable">tuplesort_updatemax</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; spaceUsed;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isSpaceDisk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: it might seem we should provide both memory and disk usage for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * disk-based sort.&nbsp; However, the current code doesn't track memory space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * accurately once we have begun to return tuples to the caller (since we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't account for <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>'s the caller is expected to do), so we cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rely on availMem in a disk sort.&nbsp; This does not seem worth the overhead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to fix.&nbsp; Is it worth creating an API for the memory context code to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tell us how much is actually used in sortcontext?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;tapeset)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isSpaceDisk = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; spaceUsed = <a href="logtape.c.html#L1181" title="utils/sort/logtape.c:1181">LogicalTapeSetBlocks</a>(state-&gt;tapeset) * BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isSpaceDisk = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; spaceUsed = state-&gt;allowedMem - state-&gt;availMem;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sort evicts data to the disk when it wasn't able to fit that data into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> memory.&nbsp; This is why we assume space used on the disk to be more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * important for tracking resource usage than space used in memory. Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that the amount of space occupied by some tupleset on the disk might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * less than amount of space occupied by the same tupleset in memory due<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to more <a href="../../regex/regc_nfa.c.html#L3479" title="regex/regc_nfa.c:3479">compact</a> representation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((isSpaceDisk &amp;&amp; !state-&gt;isMaxSpaceDisk) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (isSpaceDisk == state-&gt;isMaxSpaceDisk &amp;&amp; spaceUsed &gt; state-&gt;maxSpace))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;maxSpace = spaceUsed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;isMaxSpaceDisk = isSpaceDisk;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;maxSpaceStatus = state-&gt;status;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1039" title="utils/sort/tuplesort.c:1039">tuplesort_reset</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Reset the tuplesort.&nbsp; Reset all the data in the tuplesort, but leave the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; meta-information in.&nbsp; After <a href="#L1039" title="utils/sort/tuplesort.c:1039">tuplesort_reset</a>, tuplesort is ready to start<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; a new sort.&nbsp; This allows avoiding recreation of tuple sort states (and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; save resources) when sorting multiple small batches.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1039">&#x200c;</a></span><span class="linkable">tuplesort_reset</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L988" title="utils/sort/tuplesort.c:988">tuplesort_updatemax</a>(state);<br/></li>
<li>&nbsp; &nbsp; <a href="#L902" title="utils/sort/tuplesort.c:902">tuplesort_free</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * After we've freed up per-batch memory, re-setup all of the state common<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to both the first batch and <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subsequent batch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L757" title="utils/sort/tuplesort.c:757">tuplesort_begin_batch</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;lastReturnedTuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;slabMemoryBegin = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;slabMemoryEnd = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;slabFreeHead = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Grow the memtuples[] array, if possible within our memory constraint.&nbsp; We<br/></li>
<li></span><span class="Comment"> * must not exceed INT_MAX tuples in memory or the caller-provided memory<br/></li>
<li></span><span class="Comment"> * limit.&nbsp; Return true if we were able to enlarge the array, false if not.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Normally, at each increment we double the size of the array.&nbsp; When doing<br/></li>
<li></span><span class="Comment"> * that would exceed a limit, we attempt one last, smaller increase (and then<br/></li>
<li></span><span class="Comment"> * clear the growmemtuples flag so we don't try <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more).&nbsp; That allows us to<br/></li>
<li></span><span class="Comment"> * use memory as fully as permitted; sticking to the pure doubling rule could<br/></li>
<li></span><span class="Comment"> * result in almost half going unused.&nbsp; Because availMem moves around with<br/></li>
<li></span><span class="Comment"> * tuple addition/removal, we need some rule to prevent making repeated small<br/></li>
<li></span><span class="Comment"> * increases in memtupsize, which would just be useless thrashing.&nbsp; The<br/></li>
<li></span><span class="Comment"> * growmemtuples flag accomplishes that and also prevents useless<br/></li>
<li></span><span class="Comment"> * recalculations in this function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1072">&#x200c;</a></span><span class="linkable">grow_memtuples</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newmemtupsize;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memtupsize = state-&gt;memtupsize;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; memNowUsed = state-&gt;allowedMem - state-&gt;availMem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Forget it if we've already maxed out memtuples, per comment above */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!state-&gt;growmemtuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Select new value of memtupsize */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (memNowUsed &lt;= state-&gt;availMem)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We've used no more than half of allowedMem; double our usage,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clamping at INT_MAX tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (memtupsize &lt; <span class="Constant">INT_MAX</span> / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newmemtupsize = memtupsize * <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newmemtupsize = <span class="Constant">INT_MAX</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;growmemtuples = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This will be the last increment of memtupsize.&nbsp; Abandon doubling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * strategy and instead increase as much as we safely can.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To stay within allowedMem, we can't increase memtupsize by more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than availMem / <a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(SortTuple) elements.&nbsp; In practice, we want<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to increase it by considerably less, because we need to leave some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * space for the tuples to which the new array slots will refer.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assume the new tuples will be about the same size as the tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we've already seen, and thus we can extrapolate from the space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consumption so far to estimate an appropriate new size for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memtuples array.&nbsp; The optimal value might be higher or <a href="../adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this estimate, but it's hard to know that in advance.&nbsp; We again<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clamp at INT_MAX tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This calculation is safe against enlarging the array so much that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L403" title="utils/sort/tuplesort.c:403">LACKMEM</a> becomes true, because the memory currently used includes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the present array; thus, there would be enough allowedMem for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new array elements even if no other memory were currently used.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We do the arithmetic in float8, because otherwise the product of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memtupsize and allowedMem could overflow.&nbsp; Any inaccuracy in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result should be insignificant; but even if we computed a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * completely insane result, the checks below will prevent anything<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * really bad from happening.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; grow_ratio;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; grow_ratio = (<span class="Type">double</span>) state-&gt;allowedMem / (<span class="Type">double</span>) memNowUsed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (memtupsize * grow_ratio &lt; <span class="Constant">INT_MAX</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newmemtupsize = (<span class="Type">int</span>) (memtupsize * grow_ratio);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newmemtupsize = <span class="Constant">INT_MAX</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We won't make <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> further enlargement attempts */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;growmemtuples = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must enlarge array by at least one <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, else report failure */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newmemtupsize &lt;= memtupsize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> noalloc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On a 32-<a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> machine, allowedMem could exceed MaxAllocHugeSize.&nbsp; Clamp<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to ensure our request won't be rejected.&nbsp; Note that we can easily<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exhaust address space <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> facing this outcome.&nbsp; (This is presently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * impossible due to guc.c's MAX_KILOBYTES limitation on <a href="../init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't rely on that at this distance.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((Size) newmemtupsize &gt;= MaxAllocHugeSize / <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortTuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newmemtupsize = (<span class="Type">int</span>) (MaxAllocHugeSize / <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortTuple));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;growmemtuples = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* can't grow <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to be sure that we do not cause <a href="#L403" title="utils/sort/tuplesort.c:403">LACKMEM</a> to become true, else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the space management algorithm will go nuts.&nbsp; The code above should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * never generate a dangerous request, but to be safe, check explicitly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that the array growth fits within availMem.&nbsp; (We could still cause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L403" title="utils/sort/tuplesort.c:403">LACKMEM</a> if the memory chunk overhead associated with the memtuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * array were to increase.&nbsp; That shouldn't happen because we chose the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initial array size large enough to ensure that <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> will be treating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * both old and new arrays as separate chunks.&nbsp; But we'll check <a href="#L403" title="utils/sort/tuplesort.c:403">LACKMEM</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * explicitly below just in case.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;availMem &lt; (int64) ((newmemtupsize - memtupsize) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortTuple)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> noalloc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, do it */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L405" title="utils/sort/tuplesort.c:405">FREEMEM</a>(state, <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>(state-&gt;memtuples));<br/></li>
<li>&nbsp; &nbsp; state-&gt;memtupsize = newmemtupsize;<br/></li>
<li>&nbsp; &nbsp; state-&gt;memtuples = (SortTuple *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1671" title="utils/mmgr/mcxt.c:1671">repalloc_huge</a>(state-&gt;memtuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;memtupsize * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortTuple));<br/></li>
<li>&nbsp; &nbsp; <a href="#L404" title="utils/sort/tuplesort.c:404">USEMEM</a>(state, <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>(state-&gt;memtuples));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L403" title="utils/sort/tuplesort.c:403">LACKMEM</a>(state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected out-of-memory situation in tuplesort&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li><span class="Statement">noalloc</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* If for <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> reason we didn't realloc, shut off future attempts */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;growmemtuples = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Shared code for tuple and datum cases.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1189">&#x200c;</a></span><span class="linkable">tuplesort_puttuple_common</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> useAbbrev, Size tuplen)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext = MemoryContextSwitchTo(state-&gt;base.sortcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L408" title="utils/sort/tuplesort.c:408">LEADER</a>(state));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* account for the memory used for this tuple */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L404" title="utils/sort/tuplesort.c:404">USEMEM</a>(state, tuplen);<br/></li>
<li>&nbsp; &nbsp; state-&gt;tupleMem += tuplen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!useAbbrev)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Leave ordinary Datum representation, or NULL value.&nbsp; If there is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * converter it won't expect NULL <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, and cost model is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * required to account for NULL, so in that case we avoid calling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * converter and just set datum1 to zeroed representation (to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consistent, and to support cheap inequality tests for NULL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * abbreviated keys).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="#L1341" title="utils/sort/tuplesort.c:1341">consider_abort_common</a>(state))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Store abbreviated key representation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuple-&gt;datum1 = state-&gt;base.sortKeys-&gt;abbrev_converter(tuple-&gt;datum1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;base.sortKeys);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set state to be consistent with never trying abbreviation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Alter datum1 representation in already-copied tuples, so as to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ensure a consistent representation (current tuple was just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * handled).&nbsp; It does not matter if some dumped tuples are already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sorted on tape, since serialized tuples lack abbreviated keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (TSS_BUILDRUNS state prevents control reaching here in <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L398" title="utils/sort/tuplesort.c:398">REMOVEABBREV</a>(state, state-&gt;memtuples, state-&gt;memtupcount);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (state-&gt;status)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_INITIAL:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Save the tuple into the unsorted array.&nbsp; First, grow the array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as needed.&nbsp; Note that we try to grow the array when there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still one free slot remaining --- if we fail, there'll still be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * room to store the incoming tuple, and then we'll switch to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tape-based operation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;memtupcount &gt;= state-&gt;memtupsize - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1072" title="utils/sort/tuplesort.c:1072">grow_memtuples</a>(state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;memtupcount &lt; state-&gt;memtupsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;memtuples[state-&gt;memtupcount++] = *tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if it's time to switch over to a bounded heapsort. We do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so if the input tuple count exceeds twice the desired tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * count (this is a heuristic for where heapsort becomes cheaper<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than a quicksort), or if we've just filled workMem and have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * enough tuples to meet the bound.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that once we enter TSS_BOUNDED state we will always try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * complete the sort that way.&nbsp; In the worst case, if later input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples are larger than earlier ones, this might cause us to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exceed workMem significantly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;bounded &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (state-&gt;memtupcount &gt; state-&gt;bound * <span class="Constant">2</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (state-&gt;memtupcount &gt; state-&gt;bound &amp;&amp; <a href="#L403" title="utils/sort/tuplesort.c:403">LACKMEM</a>(state))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;switching to bounded heapsort at </span><span class="Special">%d</span><span class="Constant"> tuples: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;memtupcount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../misc/pg_rusage.c.html#L40" title="utils/misc/pg_rusage.c:40">pg_rusage_show</a>(&amp;state-&gt;ru_start));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2625" title="utils/sort/tuplesort.c:2625">make_bounded_heap</a>(state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Done if we still fit in available memory and have array slots.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;memtupcount &lt; state-&gt;memtupsize &amp;&amp; !<a href="#L403" title="utils/sort/tuplesort.c:403">LACKMEM</a>(state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Nope; time to switch to tape-based operation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1891" title="utils/sort/tuplesort.c:1891">inittapes</a>(state, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Dump all tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2339" title="utils/sort/tuplesort.c:2339">dumptuples</a>(state, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_BOUNDED:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't want to grow the array here, so check whether the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple can be discarded <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> putting it in.&nbsp; This should be a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * good speed optimization, too, since when there are many more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * input tuples than the bound, most input tuples can be discarded<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with just this one comparison.&nbsp; Note that because we currently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have the sort direction reversed, we must check for &lt;= not &gt;=.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L399" title="utils/sort/tuplesort.c:399">COMPARETUP</a>(state, tuple, &amp;state-&gt;memtuples[<span class="Constant">0</span>]) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* new tuple &lt;= top of the heap, so we can discard it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3166" title="utils/sort/tuplesort.c:3166">free_sort_tuple</a>(state, tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* discard top of heap, replacing it with the new tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3166" title="utils/sort/tuplesort.c:3166">free_sort_tuple</a>(state, &amp;state-&gt;memtuples[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2836" title="utils/sort/tuplesort.c:2836">tuplesort_heap_replace_top</a>(state, tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_BUILDRUNS:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Save the tuple into the unsorted array (there must be space)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;memtuples[state-&gt;memtupcount++] = *tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are over the memory limit, <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> all tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2339" title="utils/sort/tuplesort.c:2339">dumptuples</a>(state, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid tuplesort state&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1341">&#x200c;</a></span><span class="linkable">consider_abort_common</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;base.sortKeys[<span class="Constant">0</span>].abbrev_converter != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;base.sortKeys[<span class="Constant">0</span>].abbrev_abort != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;base.sortKeys[<span class="Constant">0</span>].abbrev_full_comparator != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check effectiveness of abbreviation optimization.&nbsp; Consider aborting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when still within memory limit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;status == TSS_INITIAL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;memtupcount &gt;= state-&gt;abbrevNext)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;abbrevNext *= <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check opclass-supplied abbreviation abort routine.&nbsp; It may indicate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that abbreviation should not proceed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!state-&gt;base.sortKeys-&gt;abbrev_abort(state-&gt;memtupcount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;base.sortKeys))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Finally, restore authoritative comparator, and indicate that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * abbreviation is not in play by setting abbrev_converter to NULL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;base.sortKeys[<span class="Constant">0</span>].comparator = state-&gt;base.sortKeys[<span class="Constant">0</span>].abbrev_full_comparator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;base.sortKeys[<span class="Constant">0</span>].abbrev_converter = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not strictly necessary, but be tidy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;base.sortKeys[<span class="Constant">0</span>].abbrev_abort = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;base.sortKeys[<span class="Constant">0</span>].abbrev_full_comparator = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Give up - expect original pass-by-value representation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * All tuples have been provided; finish the sort.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1385">&#x200c;</a></span><span class="linkable">tuplesort_performsort</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext = MemoryContextSwitchTo(state-&gt;base.sortcontext);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;performsort of worker </span><span class="Special">%d</span><span class="Constant"> starting: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;worker, <a href="../misc/pg_rusage.c.html#L40" title="utils/misc/pg_rusage.c:40">pg_rusage_show</a>(&amp;state-&gt;ru_start));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (state-&gt;status)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_INITIAL:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We were able to accumulate all the tuples within the allowed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * amount of memory, or leader to take over worker tapes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L406" title="utils/sort/tuplesort.c:406">SERIAL</a>(state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Just qsort 'em and we're done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2714" title="utils/sort/tuplesort.c:2714">tuplesort_sort_memtuples</a>(state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;status = TSS_SORTEDINMEM;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L407" title="utils/sort/tuplesort.c:407">WORKER</a>(state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Parallel workers must still <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> out tuples to tape.&nbsp; No<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> is required to produce single output run, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1891" title="utils/sort/tuplesort.c:1891">inittapes</a>(state, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2339" title="utils/sort/tuplesort.c:2339">dumptuples</a>(state, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3085" title="utils/sort/tuplesort.c:3085">worker_nomergeruns</a>(state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;status = TSS_SORTEDONTAPE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Leader will take over worker tapes and <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> worker runs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that <a href="#L2045" title="utils/sort/tuplesort.c:2045">mergeruns</a> sets the correct state-&gt;status.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3107" title="utils/sort/tuplesort.c:3107">leader_takeover_tapes</a>(state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2045" title="utils/sort/tuplesort.c:2045">mergeruns</a>(state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;current = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;eof_reached = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;markpos_block = <span class="Constant">0L</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;markpos_offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;markpos_eof = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_BOUNDED:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We were able to accumulate all the tuples required for output<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in memory, using a heap to eliminate excess tuples.&nbsp; Now we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have to transform the heap to a properly-sorted array. Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that <a href="#L2674" title="utils/sort/tuplesort.c:2674">sort_bounded_heap</a> sets the correct state-&gt;status.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2674" title="utils/sort/tuplesort.c:2674">sort_bounded_heap</a>(state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;current = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;eof_reached = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;markpos_offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;markpos_eof = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_BUILDRUNS:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Finish tape-based sort.&nbsp; First, flush all tuples remaining in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memory out to tape; then <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> until we have a single remaining<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * run (or, if !randomAccess and !<a href="#L407" title="utils/sort/tuplesort.c:407">WORKER</a>(), one run per tape).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that <a href="#L2045" title="utils/sort/tuplesort.c:2045">mergeruns</a> sets the correct state-&gt;status.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2339" title="utils/sort/tuplesort.c:2339">dumptuples</a>(state, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2045" title="utils/sort/tuplesort.c:2045">mergeruns</a>(state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;eof_reached = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;markpos_block = <span class="Constant">0L</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;markpos_offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;markpos_eof = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid tuplesort state&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;status == TSS_FINALMERGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;performsort of worker </span><span class="Special">%d</span><span class="Constant"> done (except </span><span class="Special">%d</span><span class="Constant">-way final <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>): </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;worker, state-&gt;nInputTapes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../misc/pg_rusage.c.html#L40" title="utils/misc/pg_rusage.c:40">pg_rusage_show</a>(&amp;state-&gt;ru_start));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;performsort of worker </span><span class="Special">%d</span><span class="Constant"> done: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;worker, <a href="../misc/pg_rusage.c.html#L40" title="utils/misc/pg_rusage.c:40">pg_rusage_show</a>(&amp;state-&gt;ru_start));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Internal routine to fetch the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple in either forward or back<br/></li>
<li></span><span class="Comment"> * direction into *stup.&nbsp; Returns false if no more tuples.<br/></li>
<li></span><span class="Comment"> * Returned tuple belongs to tuplesort memory context, and must not be freed<br/></li>
<li></span><span class="Comment"> * by caller.&nbsp; Note that fetched tuple is stored in memory that may be<br/></li>
<li></span><span class="Comment"> * recycled by <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> future fetch.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1496">&#x200c;</a></span><span class="linkable">tuplesort_gettuple_common</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forward,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortTuple *stup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> tuplen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; nmoved;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L407" title="utils/sort/tuplesort.c:407">WORKER</a>(state));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (state-&gt;status)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_SORTEDINMEM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(forward || state-&gt;base.sortopt &amp; TUPLESORT_RANDOMACCESS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!state-&gt;slabAllocatorUsed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (forward)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;current &lt; state-&gt;memtupcount)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *stup = state-&gt;memtuples[state-&gt;current++];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;eof_reached = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Complain if caller tries to retrieve more tuples than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * originally asked for in a bounded sort.&nbsp; This is because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * returning EOF here might be the wrong thing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;bounded &amp;&amp; state-&gt;current &gt;= state-&gt;bound)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;retrieved too many tuples in a bounded sort&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;current &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if all tuples are fetched already then we return last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple, else - tuple <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> last returned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;eof_reached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;eof_reached = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;current--;&nbsp; &nbsp; <span class="Comment">/* last returned tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;current &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *stup = state-&gt;memtuples[state-&gt;current - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_SORTEDONTAPE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(forward || state-&gt;base.sortopt &amp; TUPLESORT_RANDOMACCESS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;slabAllocatorUsed);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The slot that held the tuple that we returned in previous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * gettuple call can <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> be reused.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;lastReturnedTuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L386" title="utils/sort/tuplesort.c:386">RELEASE_SLAB_SLOT</a>(state, state-&gt;lastReturnedTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;lastReturnedTuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (forward)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;eof_reached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((tuplen = <a href="#L2894" title="utils/sort/tuplesort.c:2894">getlen</a>(state-&gt;result_tape, <span class="Constant">true</span>)) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L401" title="utils/sort/tuplesort.c:401">READTUP</a>(state, stup, state-&gt;result_tape, tuplen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember the tuple we return, so that we can recycle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * its memory on <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call.&nbsp; (This can be NULL, in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * !state-&gt;tuples case).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;lastReturnedTuple = stup-&gt;tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;eof_reached = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Backward.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if all tuples are fetched already then we return last tuple,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * else - tuple <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> last returned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;eof_reached)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Seek position is pointing just past the zero tuplen at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end of file; back up to fetch last tuple's ending length<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>.&nbsp; If seek fails we must have a completely empty file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmoved = <a href="logtape.c.html#L1062" title="utils/sort/logtape.c:1062">LogicalTapeBackspace</a>(state-&gt;result_tape,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">2</span> * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">unsigned</span> <span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nmoved == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (nmoved != <span class="Constant">2</span> * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">unsigned</span> <span class="Type">int</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected tape position&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;eof_reached = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Back up and fetch previously-returned tuple's ending length<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>.&nbsp; If seek fails, assume we are at start of file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmoved = <a href="logtape.c.html#L1062" title="utils/sort/logtape.c:1062">LogicalTapeBackspace</a>(state-&gt;result_tape,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">unsigned</span> <span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nmoved == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (nmoved != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">unsigned</span> <span class="Type">int</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected tape position&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuplen = <a href="#L2894" title="utils/sort/tuplesort.c:2894">getlen</a>(state-&gt;result_tape, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Back up to get ending length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> of tuple <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmoved = <a href="logtape.c.html#L1062" title="utils/sort/logtape.c:1062">LogicalTapeBackspace</a>(state-&gt;result_tape,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuplen + <span class="Constant">2</span> * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">unsigned</span> <span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nmoved == tuplen + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">unsigned</span> <span class="Type">int</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We backed up over the previous tuple, but there was no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ending length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it.&nbsp; That means that the prev<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple is the first tuple in the file.&nbsp; It is <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> to read in forward direction (not obviously right,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but that is what in-memory case does).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (nmoved != tuplen + <span class="Constant">2</span> * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">unsigned</span> <span class="Type">int</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;bogus tuple length in backward scan&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuplen = <a href="#L2894" title="utils/sort/tuplesort.c:2894">getlen</a>(state-&gt;result_tape, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now we have the length of the prior tuple, back up and read it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: <a href="#L401" title="utils/sort/tuplesort.c:401">READTUP</a> expects we are positioned after the initial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * length <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> of the tuple, so back up to that point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmoved = <a href="logtape.c.html#L1062" title="utils/sort/logtape.c:1062">LogicalTapeBackspace</a>(state-&gt;result_tape,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuplen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nmoved != tuplen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;bogus tuple length in backward scan&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L401" title="utils/sort/tuplesort.c:401">READTUP</a>(state, stup, state-&gt;result_tape, tuplen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember the tuple we return, so that we can recycle its memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call. (This can be NULL, in the Datum case).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;lastReturnedTuple = stup-&gt;tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_FINALMERGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(forward);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We are managing memory ourselves, with the slab allocator. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;slabAllocatorUsed);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The slab slot holding the tuple that we returned in previous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * gettuple call can <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> be reused.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;lastReturnedTuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L386" title="utils/sort/tuplesort.c:386">RELEASE_SLAB_SLOT</a>(state, state-&gt;lastReturnedTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;lastReturnedTuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This code should match the inner loop of <a href="#L2232" title="utils/sort/tuplesort.c:2232">mergeonerun</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;memtupcount &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srcTapeIndex = state-&gt;memtuples[<span class="Constant">0</span>].srctape;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *srcTape = state-&gt;inputTapes[srcTapeIndex];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortTuple&nbsp; &nbsp; newtup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *stup = state-&gt;memtuples[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember the tuple we return, so that we can recycle its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memory on <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call. (This can be NULL, in the Datum case).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;lastReturnedTuple = stup-&gt;tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pull <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple from tape, and replace the returned tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at top of the heap with it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2320" title="utils/sort/tuplesort.c:2320">mergereadnext</a>(state, srcTape, &amp;newtup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If no more data, we've reached end of run on this tape.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remove the top node from the heap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2812" title="utils/sort/tuplesort.c:2812">tuplesort_heap_delete_top</a>(state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nInputRuns--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Close the tape.&nbsp; It'd go away at the end of the sort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyway, but better to release the memory early.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="logtape.c.html#L733" title="utils/sort/logtape.c:733">LogicalTapeClose</a>(srcTape);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtup.srctape = srcTapeIndex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2836" title="utils/sort/tuplesort.c:2836">tuplesort_heap_replace_top</a>(state, &amp;newtup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid tuplesort state&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Advance over N tuples in either forward or back direction,<br/></li>
<li></span><span class="Comment"> * without returning <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data.&nbsp; N==0 is a no-op.<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if ran out of tuples.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1736">&#x200c;</a></span><span class="linkable">tuplesort_skiptuples</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, int64 ntuples, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forward)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't actually support backwards <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> yet, because no callers need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it.&nbsp; The API is designed to allow for that later, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(forward);<br/></li>
<li>&nbsp; &nbsp; Assert(ntuples &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L407" title="utils/sort/tuplesort.c:407">WORKER</a>(state));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (state-&gt;status)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_SORTEDINMEM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;memtupcount - state-&gt;current &gt;= ntuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;current += ntuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;current = state-&gt;memtupcount;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;eof_reached = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Complain if caller tries to retrieve more tuples than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * originally asked for in a bounded sort.&nbsp; This is because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * returning EOF here might be the wrong thing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;bounded &amp;&amp; state-&gt;current &gt;= state-&gt;bound)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;retrieved too many tuples in a bounded sort&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_SORTEDONTAPE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_FINALMERGE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We could probably <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> these cases better, but for <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not worth the trouble.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(state-&gt;base.sortcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (ntuples-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortTuple&nbsp; &nbsp; stup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1496" title="utils/sort/tuplesort.c:1496">tuplesort_gettuple_common</a>(state, forward, &amp;stup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid tuplesort state&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1804" title="utils/sort/tuplesort.c:1804">tuplesort_merge_order</a> - report <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> order we'll use for given memory<br/></li>
<li></span><span class="Comment"> * (note: &quot;<a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> order&quot; just means the number of input tapes in the <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exported for use by the <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>.&nbsp; allowedMem is in bytes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1804">&#x200c;</a></span><span class="linkable">tuplesort_merge_order</span>(int64 allowedMem)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mOrder;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In the <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> phase, we need buffer space for each input and output tape.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Each pass in the balanced <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> algorithm reads from M input tapes, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * writes to N output tapes.&nbsp; Each tape consumes <a href="#L179" title="utils/sort/tuplesort.c:179">TAPE_BUFFER_OVERHEAD</a> bytes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of memory.&nbsp; In addition to that, we want <a href="#L180" title="utils/sort/tuplesort.c:180">MERGE_BUFFER_SIZE</a> workspace per<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * input tape.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * totalMem = M * (<a href="#L179" title="utils/sort/tuplesort.c:179">TAPE_BUFFER_OVERHEAD</a> + <a href="#L180" title="utils/sort/tuplesort.c:180">MERGE_BUFFER_SIZE</a>) +<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N * <a href="#L179" title="utils/sort/tuplesort.c:179">TAPE_BUFFER_OVERHEAD</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Except for the last and <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-to-last <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> passes, where there can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fewer tapes left to process, M = N.&nbsp; We choose M so that we have the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * desired amount of memory available for the input buffers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (<a href="#L179" title="utils/sort/tuplesort.c:179">TAPE_BUFFER_OVERHEAD</a> + <a href="#L180" title="utils/sort/tuplesort.c:180">MERGE_BUFFER_SIZE</a>), given the total memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * available for the tape buffers (allowedMem).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: you might be thinking we need to account for the memtuples[]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * array in this calculation, but we effectively treat that as part of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L180" title="utils/sort/tuplesort.c:180">MERGE_BUFFER_SIZE</a> workspace.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mOrder = allowedMem /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Constant">2</span> * <a href="#L179" title="utils/sort/tuplesort.c:179">TAPE_BUFFER_OVERHEAD</a> + <a href="#L180" title="utils/sort/tuplesort.c:180">MERGE_BUFFER_SIZE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Even in minimum memory, use at least a <a href="#L177" title="utils/sort/tuplesort.c:177">MINORDER</a> <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>.&nbsp; On the other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hand, even when we have lots of memory, do not use more than a <a href="#L178" title="utils/sort/tuplesort.c:178">MAXORDER</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>.&nbsp; Tapes are pretty cheap, but they're not entirely free.&nbsp; Each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * additional tape reduces the amount of memory available to build runs,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which in turn can cause the same sort to need more runs, which makes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * merging slower even if it can still be done in a single pass.&nbsp; Also,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * high order merges are quite slow due to CPU cache effects; it can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * faster to pay the I/O cost of a multi-pass <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> than to perform a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * single <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> pass across many hundreds of tapes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mOrder = Max(mOrder, <a href="#L177" title="utils/sort/tuplesort.c:177">MINORDER</a>);<br/></li>
<li>&nbsp; &nbsp; mOrder = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(mOrder, <a href="#L178" title="utils/sort/tuplesort.c:178">MAXORDER</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> mOrder;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function to calculate how much memory to allocate for the read buffer<br/></li>
<li></span><span class="Comment"> * of each input tape in a <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> pass.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'avail_mem' is the amount of memory available for the buffers of all the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; tapes, both input and output.<br/></li>
<li></span><span class="Comment"> * 'nInputTapes' and 'nInputRuns' are the number of input tapes and runs.<br/></li>
<li></span><span class="Comment"> * 'maxOutputTapes' is the max. number of output tapes we should produce.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> int64<br/></li>
<li><a id="L1859">&#x200c;</a><span class="linkable">merge_read_buffer_size</span>(int64 avail_mem, <span class="Type">int</span> nInputTapes, <span class="Type">int</span> nInputRuns,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> maxOutputTapes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nOutputRuns;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nOutputTapes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * How many output tapes will we produce in this pass?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is nInputRuns / nInputTapes, rounded up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nOutputRuns = (nInputRuns + nInputTapes - <span class="Constant">1</span>) / nInputTapes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nOutputTapes = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(nOutputRuns, maxOutputTapes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Each output tape consumes <a href="#L179" title="utils/sort/tuplesort.c:179">TAPE_BUFFER_OVERHEAD</a> bytes of memory.&nbsp; All<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remaining memory is divided evenly between the input tapes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This also follows from the formula in <a href="#L1804" title="utils/sort/tuplesort.c:1804">tuplesort_merge_order</a>, but here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we derive the input buffer size from the amount of memory available,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and M and N.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> Max((avail_mem - <a href="#L179" title="utils/sort/tuplesort.c:179">TAPE_BUFFER_OVERHEAD</a> * nOutputTapes) / nInputTapes, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1891" title="utils/sort/tuplesort.c:1891">inittapes</a> - <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> for tape sorting.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called only if we have found we won't sort in memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1891">&#x200c;</a></span><span class="linkable">inittapes</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2045" title="utils/sort/tuplesort.c:2045">mergeruns</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L408" title="utils/sort/tuplesort.c:408">LEADER</a>(state));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2045" title="utils/sort/tuplesort.c:2045">mergeruns</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute number of input tapes to use when merging */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;maxTapes = <a href="#L1804" title="utils/sort/tuplesort.c:1804">tuplesort_merge_order</a>(state-&gt;allowedMem);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Workers can sometimes produce single run, output without <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L407" title="utils/sort/tuplesort.c:407">WORKER</a>(state));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;maxTapes = <a href="#L177" title="utils/sort/tuplesort.c:177">MINORDER</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;worker </span><span class="Special">%d</span><span class="Constant"> switching to external sort with </span><span class="Special">%d</span><span class="Constant"> tapes: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;worker, state-&gt;maxTapes, <a href="../misc/pg_rusage.c.html#L40" title="utils/misc/pg_rusage.c:40">pg_rusage_show</a>(&amp;state-&gt;ru_start));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the tape set */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1942" title="utils/sort/tuplesort.c:1942">inittapestate</a>(state, state-&gt;maxTapes);<br/></li>
<li>&nbsp; &nbsp; state-&gt;tapeset =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="logtape.c.html#L556" title="utils/sort/logtape.c:556">LogicalTapeSetCreate</a>(<span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;shared ? &amp;state-&gt;shared-&gt;fileset : <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;worker);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;currentRun = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize logical tape arrays.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;inputTapes = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;nInputTapes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;nInputRuns = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;outputTapes = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(state-&gt;maxTapes * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *));<br/></li>
<li>&nbsp; &nbsp; state-&gt;nOutputTapes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;nOutputRuns = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;status = TSS_BUILDRUNS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1976" title="utils/sort/tuplesort.c:1976">selectnewtape</a>(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1942" title="utils/sort/tuplesort.c:1942">inittapestate</a> - <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> generic tape management state<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1942">&#x200c;</a></span><span class="linkable">inittapestate</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <span class="Type">int</span> maxTapes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; tapeSpace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Decrease availMem to reflect the space needed for tape buffers; but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't decrease it to the point that we have no room for tuples. (That<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case is only likely to occur if sorting pass-by-value Datums; in all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other scenarios the memtuples[] array is unlikely to occupy more than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * half of allowedMem.&nbsp; In the pass-by-value case it's not important to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * account for tuple space, so we don't care if <a href="#L403" title="utils/sort/tuplesort.c:403">LACKMEM</a> becomes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inaccurate.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tapeSpace = (int64) maxTapes * <a href="#L179" title="utils/sort/tuplesort.c:179">TAPE_BUFFER_OVERHEAD</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tapeSpace + <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>(state-&gt;memtuples) &lt; state-&gt;allowedMem)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L404" title="utils/sort/tuplesort.c:404">USEMEM</a>(state, tapeSpace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure that the temp file(s) underlying the tape set are created in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * suitable temp tablespaces.&nbsp; For parallel sorts, this should have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * called already, but it doesn't matter if it is called a second time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../commands/tablespace.c.html#L1331" title="commands/tablespace.c:1331">PrepareTempTablespaces</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1976" title="utils/sort/tuplesort.c:1976">selectnewtape</a> -- <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tape to output to.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called after finishing a run when we know another run<br/></li>
<li></span><span class="Comment"> * must be started.&nbsp; This is used both when building the initial<br/></li>
<li></span><span class="Comment"> * runs, and during <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> passes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1976">&#x200c;</a></span><span class="linkable">selectnewtape</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At the beginning of each <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> pass, nOutputTapes and nOutputRuns are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * both zero.&nbsp; On each call, we create a new output tape to hold the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * run, until maxTapes is reached.&nbsp; After that, we assign new runs to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * existing tapes in a round robin fashion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;nOutputTapes &lt; state-&gt;maxTapes)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create a new tape to hold the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> run */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;outputTapes[state-&gt;nOutputRuns] == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;nOutputRuns == state-&gt;nOutputTapes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;destTape = <a href="logtape.c.html#L680" title="utils/sort/logtape.c:680">LogicalTapeCreate</a>(state-&gt;tapeset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;outputTapes[state-&gt;nOutputTapes] = state-&gt;destTape;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nOutputTapes++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nOutputRuns++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have reached the max number of tapes.&nbsp; Append to an existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tape.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;destTape = state-&gt;outputTapes[state-&gt;nOutputRuns % state-&gt;nOutputTapes];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nOutputRuns++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize the slab allocation arena, for the given number of slots.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2009">&#x200c;</a></span><span class="linkable">init_slab_allocator</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <span class="Type">int</span> numSlots)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numSlots &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;slabMemoryBegin = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numSlots * <a href="#L143" title="utils/sort/tuplesort.c:143">SLAB_SLOT_SIZE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;slabMemoryEnd = state-&gt;slabMemoryBegin +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numSlots * <a href="#L143" title="utils/sort/tuplesort.c:143">SLAB_SLOT_SIZE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;slabFreeHead = (<a href="#L145" title="utils/sort/tuplesort.c:145">SlabSlot</a> *) state-&gt;slabMemoryBegin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L404" title="utils/sort/tuplesort.c:404">USEMEM</a>(state, numSlots * <a href="#L143" title="utils/sort/tuplesort.c:143">SLAB_SLOT_SIZE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p = state-&gt;slabMemoryBegin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numSlots - <span class="Constant">1</span>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((<a href="#L145" title="utils/sort/tuplesort.c:145">SlabSlot</a> *) p)-&gt;nextfree = (<a href="#L145" title="utils/sort/tuplesort.c:145">SlabSlot</a> *) (p + <a href="#L143" title="utils/sort/tuplesort.c:143">SLAB_SLOT_SIZE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p += <a href="#L143" title="utils/sort/tuplesort.c:143">SLAB_SLOT_SIZE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((<a href="#L145" title="utils/sort/tuplesort.c:145">SlabSlot</a> *) p)-&gt;nextfree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;slabMemoryBegin = state-&gt;slabMemoryEnd = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;slabFreeHead = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; state-&gt;slabAllocatorUsed = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2045" title="utils/sort/tuplesort.c:2045">mergeruns</a> -- <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> all the completed initial runs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This implements the Balanced k-Way Merge Algorithm.&nbsp; All input data has<br/></li>
<li></span><span class="Comment"> * already been written to initial runs on tape (see <a href="#L2339" title="utils/sort/tuplesort.c:2339">dumptuples</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2045">&#x200c;</a></span><span class="linkable">mergeruns</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tapenum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;status == TSS_BUILDRUNS);<br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;memtupcount == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;base.sortKeys != <span class="Constant">NULL</span> &amp;&amp; state-&gt;base.sortKeys-&gt;abbrev_converter != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there are multiple runs to be merged, when we go to read back<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples from disk, abbreviated keys will not have been stored, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we don't care to regenerate them.&nbsp; Disable abbreviation from this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * point on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;base.sortKeys-&gt;abbrev_converter = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;base.sortKeys-&gt;comparator = state-&gt;base.sortKeys-&gt;abbrev_full_comparator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not strictly necessary, but be tidy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;base.sortKeys-&gt;abbrev_abort = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;base.sortKeys-&gt;abbrev_full_comparator = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset tuple memory.&nbsp; We've freed all the tuples that we previously<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocated.&nbsp; We will use the slab allocator from <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L402" title="utils/mmgr/mcxt.c:402">MemoryContextResetOnly</a>(state-&gt;base.tuplecontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We no longer need a large memtuples array.&nbsp; (We will allocate a smaller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one for the heap later.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L405" title="utils/sort/tuplesort.c:405">FREEMEM</a>(state, <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>(state-&gt;memtuples));<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state-&gt;memtuples);<br/></li>
<li>&nbsp; &nbsp; state-&gt;memtuples = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the slab allocator.&nbsp; We need one slab slot per input tape,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the tuples in the heap, plus one to hold the tuple last returned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from tuplesort_gettuple.&nbsp; (If we're sorting pass-by-val Datums,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * however, we don't need to do allocate anything.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In a multi-pass <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>, we could shrink this allocation for the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> pass, if it has fewer tapes than previous passes, but we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bother.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * From this point on, we no longer use the <a href="#L404" title="utils/sort/tuplesort.c:404">USEMEM</a>()/<a href="#L403" title="utils/sort/tuplesort.c:403">LACKMEM</a>() mechanism<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to track memory usage of individual tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;base.tuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2009" title="utils/sort/tuplesort.c:2009">init_slab_allocator</a>(state, state-&gt;nOutputTapes + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2009" title="utils/sort/tuplesort.c:2009">init_slab_allocator</a>(state, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate a new 'memtuples' array, for the heap.&nbsp; It will hold one tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from each input tape.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We could shrink this, too, between passes in a multi-pass <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>, but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't bother.&nbsp; (The initial input tapes are still in outputTapes.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number of input tapes will not increase between passes.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;memtupsize = state-&gt;nOutputTapes;<br/></li>
<li>&nbsp; &nbsp; state-&gt;memtuples = (SortTuple *) <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(state-&gt;base.maincontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nOutputTapes * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortTuple));<br/></li>
<li>&nbsp; &nbsp; <a href="#L404" title="utils/sort/tuplesort.c:404">USEMEM</a>(state, <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>(state-&gt;memtuples));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use all the remaining memory we have available for tape buffers among<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all the input tapes.&nbsp; At the beginning of each <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> pass, we will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * divide this memory between the input and output tapes in the pass.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;tape_buffer_mem = state-&gt;availMem;<br/></li>
<li>&nbsp; &nbsp; <a href="#L404" title="utils/sort/tuplesort.c:404">USEMEM</a>(state, state-&gt;tape_buffer_mem);<br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;worker </span><span class="Special">%d</span><span class="Constant"> using </span><span class="Special">%zu</span><span class="Constant"> KB of memory for tape buffers&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;worker, state-&gt;tape_buffer_mem / <span class="Constant">1024</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * On the first iteration, or if we have read all the runs from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * input tapes in a multi-pass <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>, it's time to start a new pass.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Rewind all the output tapes, and make them inputs for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pass.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;nInputRuns == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; input_buffer_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Close the old, emptied, input tapes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;nInputTapes &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (tapenum = <span class="Constant">0</span>; tapenum &lt; state-&gt;nInputTapes; tapenum++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="logtape.c.html#L733" title="utils/sort/logtape.c:733">LogicalTapeClose</a>(state-&gt;inputTapes[tapenum]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state-&gt;inputTapes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Previous pass's outputs become <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> pass's inputs. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;inputTapes = state-&gt;outputTapes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nInputTapes = state-&gt;nOutputTapes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nInputRuns = state-&gt;nOutputRuns;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset output tape variables.&nbsp; The actual LogicalTapes will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * created as needed, here we only allocate the array to hold<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;outputTapes = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(state-&gt;nInputTapes * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nOutputTapes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nOutputRuns = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Redistribute the memory allocated for tape buffers, among the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new input and output tapes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_buffer_size = <a href="#L1859" title="utils/sort/tuplesort.c:1859">merge_read_buffer_size</a>(state-&gt;tape_buffer_mem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;nInputTapes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;nInputRuns,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;maxTapes);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;starting <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> pass of </span><span class="Special">%d</span><span class="Constant"> input runs on </span><span class="Special">%d</span><span class="Constant"> tapes, &quot;</span> INT64_FORMAT <span class="Constant">&quot; KB of memory for each input tape: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;nInputRuns, state-&gt;nInputTapes, input_buffer_size / <span class="Constant">1024</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../misc/pg_rusage.c.html#L40" title="utils/misc/pg_rusage.c:40">pg_rusage_show</a>(&amp;state-&gt;ru_start));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prepare the new input tapes for <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> pass. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (tapenum = <span class="Constant">0</span>; tapenum &lt; state-&gt;nInputTapes; tapenum++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="logtape.c.html#L846" title="utils/sort/logtape.c:846">LogicalTapeRewindForRead</a>(state-&gt;inputTapes[tapenum], input_buffer_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there's just one run left on each input tape, then only one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> pass remains.&nbsp; If we don't have to produce a materialized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sorted tape, we can stop at this point and do the final <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on-the-fly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((state-&gt;base.sortopt &amp; TUPLESORT_RANDOMACCESS) == <span class="Constant">0<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; state-&gt;nInputRuns &lt;= state-&gt;nInputTapes<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; !<a href="#L407" title="utils/sort/tuplesort.c:407">WORKER</a>(state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Tell logtape.c we won't be writing anymore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="logtape.c.html#L750" title="utils/sort/logtape.c:750">LogicalTapeSetForgetFreeSpace</a>(state-&gt;tapeset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize for the final <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> pass */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2292" title="utils/sort/tuplesort.c:2292">beginmerge</a>(state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;status = TSS_FINALMERGE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Select an output tape */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1976" title="utils/sort/tuplesort.c:1976">selectnewtape</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Merge one run from each input tape. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2232" title="utils/sort/tuplesort.c:2232">mergeonerun</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the input tapes are empty, and we output only one output run,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we're done.&nbsp; The current output tape contains the final result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;nInputRuns == <span class="Constant">0</span> &amp;&amp; state-&gt;nOutputRuns &lt;= <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Done.&nbsp; The result is on a single run on a single tape.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;result_tape = state-&gt;outputTapes[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L407" title="utils/sort/tuplesort.c:407">WORKER</a>(state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="logtape.c.html#L981" title="utils/sort/logtape.c:981">LogicalTapeFreeze</a>(state-&gt;result_tape, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3047" title="utils/sort/tuplesort.c:3047">worker_freeze_result_tape</a>(state);<br/></li>
<li>&nbsp; &nbsp; state-&gt;status = TSS_SORTEDONTAPE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close all the <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-empty input tapes, to release their read buffers. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (tapenum = <span class="Constant">0</span>; tapenum &lt; state-&gt;nInputTapes; tapenum++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="logtape.c.html#L733" title="utils/sort/logtape.c:733">LogicalTapeClose</a>(state-&gt;inputTapes[tapenum]);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Merge one run from each input tape.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2232">&#x200c;</a></span><span class="linkable">mergeonerun</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srcTapeIndex;<br/></li>
<li>&nbsp; &nbsp; <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *srcTape;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start the <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> by loading one tuple from each active source tape into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the heap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2292" title="utils/sort/tuplesort.c:2292">beginmerge</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;slabAllocatorUsed);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Execute <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> by repeatedly extracting lowest tuple in heap, writing it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * out, and replacing it with <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple from same tape (if there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * another one).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (state-&gt;memtupcount &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortTuple&nbsp; &nbsp; stup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* write the tuple to destTape */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; srcTapeIndex = state-&gt;memtuples[<span class="Constant">0</span>].srctape;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; srcTape = state-&gt;inputTapes[srcTapeIndex];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L400" title="utils/sort/tuplesort.c:400">WRITETUP</a>(state, state-&gt;destTape, &amp;state-&gt;memtuples[<span class="Constant">0</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recycle the slot of the tuple we just wrote out, for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> read */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;memtuples[<span class="Constant">0</span>].tuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L386" title="utils/sort/tuplesort.c:386">RELEASE_SLAB_SLOT</a>(state, state-&gt;memtuples[<span class="Constant">0</span>].tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple from the tape, and replace the written-out tuple in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the heap with it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2320" title="utils/sort/tuplesort.c:2320">mergereadnext</a>(state, srcTape, &amp;stup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stup.srctape = srcTapeIndex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2836" title="utils/sort/tuplesort.c:2836">tuplesort_heap_replace_top</a>(state, &amp;stup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2812" title="utils/sort/tuplesort.c:2812">tuplesort_heap_delete_top</a>(state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nInputRuns--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When the heap empties, we're done.&nbsp; Write an end-of-run marker on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * output tape.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2907" title="utils/sort/tuplesort.c:2907">markrunend</a>(state-&gt;destTape);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2292" title="utils/sort/tuplesort.c:2292">beginmerge</a> - <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> for a <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> pass<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Fill the <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> heap with the first tuple from each input tape.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2292">&#x200c;</a></span><span class="linkable">beginmerge</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; activeTapes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srcTapeIndex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Heap should be empty here */<br/></li>
<li></span>&nbsp; &nbsp; Assert(state-&gt;memtupcount == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; activeTapes = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(state-&gt;nInputTapes, state-&gt;nInputRuns);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (srcTapeIndex = <span class="Constant">0</span>; srcTapeIndex &lt; activeTapes; srcTapeIndex++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortTuple&nbsp; &nbsp; tup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2320" title="utils/sort/tuplesort.c:2320">mergereadnext</a>(state, state-&gt;inputTapes[srcTapeIndex], &amp;tup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tup.srctape = srcTapeIndex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2777" title="utils/sort/tuplesort.c:2777">tuplesort_heap_insert</a>(state, &amp;tup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2320" title="utils/sort/tuplesort.c:2320">mergereadnext</a> - read <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple from one <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> input tape<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns false on EOF.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2320">&#x200c;</a></span><span class="linkable">mergereadnext</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *srcTape, SortTuple *stup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> tuplen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((tuplen = <a href="#L2894" title="utils/sort/tuplesort.c:2894">getlen</a>(srcTape, <span class="Constant">true</span>)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L401" title="utils/sort/tuplesort.c:401">READTUP</a>(state, stup, srcTape, tuplen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2339" title="utils/sort/tuplesort.c:2339">dumptuples</a> - remove tuples from memtuples and write initial run to tape<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When alltuples = true, <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> everything currently in memory.&nbsp; (This case is<br/></li>
<li></span><span class="Comment"> * only used at end of input data.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2339">&#x200c;</a></span><span class="linkable">dumptuples</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> alltuples)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memtupwrite;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Nothing to do if we still fit in available memory and have array slots,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unless this is the final call during initial run generation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;memtupcount &lt; state-&gt;memtupsize &amp;&amp; !<a href="#L403" title="utils/sort/tuplesort.c:403">LACKMEM</a>(state) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !alltuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Final call might require no sorting, in rare cases where we just so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happen to have previously <a href="#L403" title="utils/sort/tuplesort.c:403">LACKMEM</a>()'d at the point where exactly all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remaining tuples are loaded into memory, just <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> input was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exhausted.&nbsp; In general, short final runs are quite possible, but avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * creating a completely empty run.&nbsp; In a worker, though, we must produce<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at least one tape, even if it's empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;memtupcount == <span class="Constant">0</span> &amp;&amp; state-&gt;currentRun &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;status == TSS_BUILDRUNS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It seems unlikely that this limit will ever be exceeded, but take no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * chances<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;currentRun == <span class="Constant">INT_MAX</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot have more than </span><span class="Special">%d</span><span class="Constant"> runs for an external sort&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">INT_MAX</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;currentRun &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1976" title="utils/sort/tuplesort.c:1976">selectnewtape</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;currentRun++;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;worker </span><span class="Special">%d</span><span class="Constant"> starting quicksort of run </span><span class="Special">%d</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;worker, state-&gt;currentRun,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../misc/pg_rusage.c.html#L40" title="utils/misc/pg_rusage.c:40">pg_rusage_show</a>(&amp;state-&gt;ru_start));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sort all tuples accumulated within the allowed amount of memory for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this run using quicksort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2714" title="utils/sort/tuplesort.c:2714">tuplesort_sort_memtuples</a>(state);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;worker </span><span class="Special">%d</span><span class="Constant"> finished quicksort of run </span><span class="Special">%d</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;worker, state-&gt;currentRun,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../misc/pg_rusage.c.html#L40" title="utils/misc/pg_rusage.c:40">pg_rusage_show</a>(&amp;state-&gt;ru_start));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; memtupwrite = state-&gt;memtupcount;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; memtupwrite; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortTuple&nbsp; *stup = &amp;state-&gt;memtuples[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L400" title="utils/sort/tuplesort.c:400">WRITETUP</a>(state, state-&gt;destTape, stup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;memtupcount = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset tuple memory.&nbsp; We've freed all of the tuples that we previously<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocated.&nbsp; It's important to avoid fragmentation when there is a stark<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * change in the sizes of incoming tuples.&nbsp; In bounded sorts,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fragmentation due to <a href="../mmgr/aset.c.html#L1062" title="utils/mmgr/aset.c:1062">AllocSetFree</a>'s bucketing by size class might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * particularly bad if this step wasn't taken.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(state-&gt;base.tuplecontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now update the memory accounting to subtract the memory used by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L405" title="utils/sort/tuplesort.c:405">FREEMEM</a>(state, state-&gt;tupleMem);<br/></li>
<li>&nbsp; &nbsp; state-&gt;tupleMem = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2907" title="utils/sort/tuplesort.c:2907">markrunend</a>(state-&gt;destTape);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;worker </span><span class="Special">%d</span><span class="Constant"> finished writing run </span><span class="Special">%d</span><span class="Constant"> to tape </span><span class="Special">%d</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;worker, state-&gt;currentRun, (state-&gt;currentRun - <span class="Constant">1</span>) % state-&gt;nOutputTapes + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../misc/pg_rusage.c.html#L40" title="utils/misc/pg_rusage.c:40">pg_rusage_show</a>(&amp;state-&gt;ru_start));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2440" title="utils/sort/tuplesort.c:2440">tuplesort_rescan</a>&nbsp; &nbsp; &nbsp; &nbsp; - rewind and replay the scan<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2440">&#x200c;</a></span><span class="linkable">tuplesort_rescan</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext = MemoryContextSwitchTo(state-&gt;base.sortcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;base.sortopt &amp; TUPLESORT_RANDOMACCESS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (state-&gt;status)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_SORTEDINMEM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;current = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;eof_reached = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;markpos_offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;markpos_eof = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_SORTEDONTAPE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="logtape.c.html#L846" title="utils/sort/logtape.c:846">LogicalTapeRewindForRead</a>(state-&gt;result_tape, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;eof_reached = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;markpos_block = <span class="Constant">0L</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;markpos_offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;markpos_eof = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid tuplesort state&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2473" title="utils/sort/tuplesort.c:2473">tuplesort_markpos</a>&nbsp; &nbsp; - saves current position in the merged sort file<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2473">&#x200c;</a></span><span class="linkable">tuplesort_markpos</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext = MemoryContextSwitchTo(state-&gt;base.sortcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;base.sortopt &amp; TUPLESORT_RANDOMACCESS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (state-&gt;status)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_SORTEDINMEM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;markpos_offset = state-&gt;current;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;markpos_eof = state-&gt;eof_reached;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_SORTEDONTAPE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="logtape.c.html#L1162" title="utils/sort/logtape.c:1162">LogicalTapeTell</a>(state-&gt;result_tape,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;state-&gt;markpos_block,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;state-&gt;markpos_offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;markpos_eof = state-&gt;eof_reached;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid tuplesort state&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2504" title="utils/sort/tuplesort.c:2504">tuplesort_restorepos</a> - restores current position in merged sort file to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last saved position<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2504">&#x200c;</a></span><span class="linkable">tuplesort_restorepos</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext = MemoryContextSwitchTo(state-&gt;base.sortcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;base.sortopt &amp; TUPLESORT_RANDOMACCESS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (state-&gt;status)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_SORTEDINMEM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;current = state-&gt;markpos_offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;eof_reached = state-&gt;markpos_eof;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_SORTEDONTAPE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="logtape.c.html#L1133" title="utils/sort/logtape.c:1133">LogicalTapeSeek</a>(state-&gt;result_tape,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;markpos_block,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;markpos_offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;eof_reached = state-&gt;markpos_eof;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid tuplesort state&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2537" title="utils/sort/tuplesort.c:2537">tuplesort_get_stats</a> - extract summary statistics<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This can be called after <a href="#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>() finishes to obtain<br/></li>
<li></span><span class="Comment"> * printable summary information about how the sort was performed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2537">&#x200c;</a></span><span class="linkable">tuplesort_get_stats</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TuplesortInstrumentation *stats)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: it might seem we should provide both memory and disk usage for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * disk-based sort.&nbsp; However, the current code doesn't track memory space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * accurately once we have begun to return tuples to the caller (since we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't account for <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>'s the caller is expected to do), so we cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rely on availMem in a disk sort.&nbsp; This does not seem worth the overhead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to fix.&nbsp; Is it worth creating an API for the memory context code to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tell us how much is actually used in sortcontext?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L988" title="utils/sort/tuplesort.c:988">tuplesort_updatemax</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;isMaxSpaceDisk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;spaceType = SORT_SPACE_TYPE_DISK;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;spaceType = SORT_SPACE_TYPE_MEMORY;<br/></li>
<li>&nbsp; &nbsp; stats-&gt;spaceUsed = (state-&gt;maxSpace + <span class="Constant">1023</span>) / <span class="Constant">1024</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (state-&gt;maxSpaceStatus)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_SORTEDINMEM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;boundUsed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;sortMethod = SORT_TYPE_TOP_N_HEAPSORT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;sortMethod = SORT_TYPE_QUICKSORT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_SORTEDONTAPE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;sortMethod = SORT_TYPE_EXTERNAL_SORT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TSS_FINALMERGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;sortMethod = SORT_TYPE_EXTERNAL_MERGE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;sortMethod = SORT_TYPE_STILL_IN_PROGRESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert TuplesortMethod to a string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L2581">&#x200c;</a><span class="linkable">tuplesort_method_name</span>(TuplesortMethod m)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (m)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SORT_TYPE_STILL_IN_PROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;still in progress&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SORT_TYPE_TOP_N_HEAPSORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;top-N heapsort&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SORT_TYPE_QUICKSORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;quicksort&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SORT_TYPE_EXTERNAL_SORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;external sort&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SORT_TYPE_EXTERNAL_MERGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;external <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;unknown&quot;</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert TuplesortSpaceType to a string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L2604">&#x200c;</a><span class="linkable">tuplesort_space_type_name</span>(TuplesortSpaceType t)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(t == SORT_SPACE_TYPE_DISK || t == SORT_SPACE_TYPE_MEMORY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> t == SORT_SPACE_TYPE_DISK ? <span class="Constant">&quot;Disk&quot;</span> : <span class="Constant">&quot;Memory&quot;</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Heap manipulation routines, per Knuth's Algorithm 5.2.3H.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert the existing unordered array of SortTuples to a bounded heap,<br/></li>
<li></span><span class="Comment"> * discarding all but the smallest &quot;state-&gt;bound&quot; tuples.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When working with a bounded heap, we want to keep the largest entry<br/></li>
<li></span><span class="Comment"> * at the root (array entry zero), instead of the smallest as in the normal<br/></li>
<li></span><span class="Comment"> * sort case.&nbsp; This allows us to discard the largest entry cheaply.<br/></li>
<li></span><span class="Comment"> * Therefore, we temporarily reverse the sort direction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2625">&#x200c;</a></span><span class="linkable">make_bounded_heap</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupcount = state-&gt;memtupcount;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;status == TSS_INITIAL);<br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;bounded);<br/></li>
<li>&nbsp; &nbsp; Assert(tupcount &gt;= state-&gt;bound);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L406" title="utils/sort/tuplesort.c:406">SERIAL</a>(state));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reverse sort direction so largest entry will be at root */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2876" title="utils/sort/tuplesort.c:2876">reversedirection</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;memtupcount = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make the heap empty */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; tupcount; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;memtupcount &lt; state-&gt;bound)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple into heap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must copy source tuple to avoid possible overwrite */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortTuple&nbsp; &nbsp; stup = state-&gt;memtuples[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2777" title="utils/sort/tuplesort.c:2777">tuplesort_heap_insert</a>(state, &amp;stup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The heap is full.&nbsp; Replace the largest entry with the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple, or just discard it, if it's larger than anything already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the heap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L399" title="utils/sort/tuplesort.c:399">COMPARETUP</a>(state, &amp;state-&gt;memtuples[i], &amp;state-&gt;memtuples[<span class="Constant">0</span>]) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3166" title="utils/sort/tuplesort.c:3166">free_sort_tuple</a>(state, &amp;state-&gt;memtuples[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2836" title="utils/sort/tuplesort.c:2836">tuplesort_heap_replace_top</a>(state, &amp;state-&gt;memtuples[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;memtupcount == state-&gt;bound);<br/></li>
<li>&nbsp; &nbsp; state-&gt;status = TSS_BOUNDED;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert the bounded heap to a properly-sorted array<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2674">&#x200c;</a></span><span class="linkable">sort_bounded_heap</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupcount = state-&gt;memtupcount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;status == TSS_BOUNDED);<br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;bounded);<br/></li>
<li>&nbsp; &nbsp; Assert(tupcount == state-&gt;bound);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L406" title="utils/sort/tuplesort.c:406">SERIAL</a>(state));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can unheapify in place because each delete-top call will remove the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * largest entry, which we can promptly store in the newly freed slot at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the end.&nbsp; Once we're down to a single-entry heap, we're done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (state-&gt;memtupcount &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortTuple&nbsp; &nbsp; stup = state-&gt;memtuples[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this sifts-up the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-largest entry and decreases memtupcount */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2812" title="utils/sort/tuplesort.c:2812">tuplesort_heap_delete_top</a>(state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;memtuples[state-&gt;memtupcount] = stup;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; state-&gt;memtupcount = tupcount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reverse sort direction back to the original state.&nbsp; This is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * actually necessary but seems like a good idea for tidiness.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2876" title="utils/sort/tuplesort.c:2876">reversedirection</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;status = TSS_SORTEDINMEM;<br/></li>
<li>&nbsp; &nbsp; state-&gt;boundUsed = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sort all memtuples using specialized qsort() routines.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Quicksort is used for small in-memory sorts, and external sort runs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2714">&#x200c;</a></span><span class="linkable">tuplesort_sort_memtuples</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L408" title="utils/sort/tuplesort.c:408">LEADER</a>(state));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;memtupcount &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do we have the leading column's value or abbreviation in datum1,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and is there a specialization for its comparator?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;base.haveDatum1 &amp;&amp; state-&gt;base.sortKeys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;base.sortKeys[<span class="Constant">0</span>].comparator == <a href="#L3177" title="utils/sort/tuplesort.c:3177">ssup_datum_unsigned_cmp</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qsort_tuple_unsigned(state-&gt;memtuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;memtupcount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#if SIZEOF_DATUM &gt;= </span><span class="Constant">8<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (state-&gt;base.sortKeys[<span class="Constant">0</span>].comparator == <a href="#L3189" title="utils/sort/tuplesort.c:3189">ssup_datum_signed_cmp</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qsort_tuple_signed(state-&gt;memtuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;memtupcount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (state-&gt;base.sortKeys[<span class="Constant">0</span>].comparator == <a href="#L3204" title="utils/sort/tuplesort.c:3204">ssup_datum_int32_cmp</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qsort_tuple_int32(state-&gt;memtuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;memtupcount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can we use the single-key sort function? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;base.onlyKey != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qsort_ssup(state-&gt;memtuples, state-&gt;memtupcount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;base.onlyKey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qsort_tuple(state-&gt;memtuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;memtupcount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;base.comparetup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> a new tuple into an empty or existing heap, maintaining the<br/></li>
<li></span><span class="Comment"> * heap invariant.&nbsp; Caller is responsible for ensuring there's room.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: For some callers, tuple points to a memtuples[] entry above the<br/></li>
<li></span><span class="Comment"> * end of the heap.&nbsp; This is safe as long as it's not immediately adjacent<br/></li>
<li></span><span class="Comment"> * to the end of the heap (ie, in the [memtupcount] array entry) --- if it<br/></li>
<li></span><span class="Comment"> * is, it might get overwritten <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> being moved into the heap!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2777">&#x200c;</a></span><span class="linkable">tuplesort_heap_insert</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortTuple&nbsp; *memtuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memtuples = state-&gt;memtuples;<br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;memtupcount &lt; state-&gt;memtupsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sift-up the new entry, per Knuth 5.2.3 exercise 16. Note that Knuth is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using 1-based array indexes, not 0-based.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; j = state-&gt;memtupcount++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (j &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = (j - <span class="Constant">1</span>) &gt;&gt; <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L399" title="utils/sort/tuplesort.c:399">COMPARETUP</a>(state, tuple, &amp;memtuples[i]) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memtuples[j] = memtuples[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; j = i;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; memtuples[j] = *tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove the tuple at state-&gt;memtuples[0] from the heap.&nbsp; Decrement<br/></li>
<li></span><span class="Comment"> * memtupcount, and sift up to maintain the heap invariant.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller has already free'd the tuple the top node points to,<br/></li>
<li></span><span class="Comment"> * if necessary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2812">&#x200c;</a></span><span class="linkable">tuplesort_heap_delete_top</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortTuple&nbsp; *memtuples = state-&gt;memtuples;<br/></li>
<li>&nbsp; &nbsp; SortTuple&nbsp; *tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (--state-&gt;memtupcount &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove the last tuple in the heap, and re-insert it, by replacing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current top node with it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tuple = &amp;memtuples[state-&gt;memtupcount];<br/></li>
<li>&nbsp; &nbsp; <a href="#L2836" title="utils/sort/tuplesort.c:2836">tuplesort_heap_replace_top</a>(state, tuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Replace the tuple at state-&gt;memtuples[0] with a new tuple.&nbsp; Sift up to<br/></li>
<li></span><span class="Comment"> * maintain the heap invariant.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This corresponds to Knuth's &quot;sift-up&quot; algorithm (Algorithm 5.2.3H,<br/></li>
<li></span><span class="Comment"> * Heapsort, steps H3-H8).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2836">&#x200c;</a></span><span class="linkable">tuplesort_heap_replace_top</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortTuple&nbsp; *memtuples = state-&gt;memtuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;memtupcount &gt;= <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state-&gt;memtupcount is &quot;int&quot;, but we use &quot;unsigned int&quot; for i, j, n.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This prevents overflow in the &quot;2 * i + 1&quot; calculation, since at the top<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the loop we must have i &lt; n &lt;= INT_MAX &lt;= UINT_MAX/2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; n = state-&gt;memtupcount;<br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* i is where the &quot;hole&quot; is */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> j = <span class="Constant">2</span> * i + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j &gt;= n)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j + <span class="Constant">1</span> &lt; n &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L399" title="utils/sort/tuplesort.c:399">COMPARETUP</a>(state, &amp;memtuples[j], &amp;memtuples[j + <span class="Constant">1</span>]) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L399" title="utils/sort/tuplesort.c:399">COMPARETUP</a>(state, tuple, &amp;memtuples[j]) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memtuples[i] = memtuples[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i = j;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; memtuples[i] = *tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Function to reverse the sort direction from its current state<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is not safe to call this when performing <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tuplesorts<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2876">&#x200c;</a></span><span class="linkable">reversedirection</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortSupport sortKey = state-&gt;base.sortKeys;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (nkey = <span class="Constant">0</span>; nkey &lt; state-&gt;base.nKeys; nkey++, sortKey++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_reverse = !sortKey-&gt;ssup_reverse;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_nulls_first = !sortKey-&gt;ssup_nulls_first;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Tape interface routines<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">unsigned</span> <span class="Type">int<br/></li>
<li><a id="L2894">&#x200c;</a></span><span class="linkable">getlen</span>(<a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> eofOK)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="logtape.c.html#L928" title="utils/sort/logtape.c:928">LogicalTapeRead</a>(tape,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;len, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len)) != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected end of tape&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len == <span class="Constant">0</span> &amp;&amp; !eofOK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected end of data&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> len;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2907">&#x200c;</a></span><span class="linkable">markrunend</span>(<a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *tape)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> len = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="logtape.c.html#L761" title="utils/sort/logtape.c:761">LogicalTapeWrite</a>(tape, &amp;len, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get memory for tuple from within <a href="#L401" title="utils/sort/tuplesort.c:401">READTUP</a>() routine.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> free slot from the slab allocator, or <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>() if the tuple<br/></li>
<li></span><span class="Comment"> * is too large for that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L2921">&#x200c;</a><span class="linkable">tuplesort_readtup_alloc</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, Size tuplen)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L145" title="utils/sort/tuplesort.c:145">SlabSlot</a>&nbsp;&nbsp; *buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We pre-allocate enough slots in the slab arena that we should never run<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(state-&gt;slabFreeHead);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tuplen &gt; <a href="#L143" title="utils/sort/tuplesort.c:143">SLAB_SLOT_SIZE</a> || !state-&gt;slabFreeHead)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(state-&gt;base.sortcontext, tuplen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = state-&gt;slabFreeHead;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reuse this slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;slabFreeHead = buf-&gt;nextfree;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Parallel sort routines<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2955" title="utils/sort/tuplesort.c:2955">tuplesort_estimate_shared</a> - estimate required shared memory allocation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * nWorkers is an estimate of the number of workers (it's the number that<br/></li>
<li></span><span class="Comment"> * will be requested).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L2955">&#x200c;</a><span class="linkable">tuplesort_estimate_shared</span>(<span class="Type">int</span> nWorkers)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; tapesSize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(nWorkers &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure that <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a> shared state is MAXALIGN'd */<br/></li>
<li></span>&nbsp; &nbsp; tapesSize = <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TapeShare), nWorkers);<br/></li>
<li>&nbsp; &nbsp; tapesSize = MAXALIGN(<a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(tapesSize, offsetof(<a href="#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a>, tapes)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tapesSize;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2976" title="utils/sort/tuplesort.c:2976">tuplesort_initialize_shared</a> - <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> shared tuplesort state<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Must be called from leader process <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> workers are launched, to<br/></li>
<li></span><span class="Comment"> * establish state needed up-front for worker tuplesortstates.&nbsp; nWorkers<br/></li>
<li></span><span class="Comment"> * should match the argument passed to <a href="#L2955" title="utils/sort/tuplesort.c:2955">tuplesort_estimate_shared</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2976">&#x200c;</a></span><span class="linkable">tuplesort_initialize_shared</span>(<a href="#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a> *shared, <span class="Type">int</span> nWorkers, <a href="../../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(nWorkers &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockInit(&amp;shared-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; shared-&gt;currentWorker = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; shared-&gt;workersFinished = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/sharedfileset.c.html#L38" title="storage/file/sharedfileset.c:38">SharedFileSetInit</a>(&amp;shared-&gt;fileset, seg);<br/></li>
<li>&nbsp; &nbsp; shared-&gt;nTapes = nWorkers;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nWorkers; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;tapes[i].firstblocknumber = <span class="Constant">0L</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2999" title="utils/sort/tuplesort.c:2999">tuplesort_attach_shared</a> - attach to shared tuplesort state<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Must be called by all worker processes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2999">&#x200c;</a></span><span class="linkable">tuplesort_attach_shared</span>(<a href="#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a> *shared, <a href="../../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Attach to SharedFileSet */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/file/sharedfileset.c.html#L56" title="storage/file/sharedfileset.c:56">SharedFileSetAttach</a>(&amp;shared-&gt;fileset, seg);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3019" title="utils/sort/tuplesort.c:3019">worker_get_identifier</a> - Assign and return ordinal identifier for worker<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The order in which these are assigned is not well defined, and should not<br/></li>
<li></span><span class="Comment"> * matter; worker numbers across parallel sort participants need only be<br/></li>
<li></span><span class="Comment"> * distinct and gapless.&nbsp; logtape.c requires this.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the identifiers assigned from here have no relation to<br/></li>
<li></span><span class="Comment"> * <a href="../../access/transam/parallel.c.html#L112" title="access/transam/parallel.c:112">ParallelWorkerNumber</a> number, to avoid making <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> assumption about<br/></li>
<li></span><span class="Comment"> * caller's requirements.&nbsp; However, we do follow the <a href="../../access/transam/parallel.c.html#L112" title="access/transam/parallel.c:112">ParallelWorkerNumber</a><br/></li>
<li></span><span class="Comment"> * convention of representing a non-worker with worker number -1.&nbsp; This<br/></li>
<li></span><span class="Comment"> * includes the leader, as well as serial Tuplesort processes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L3019">&#x200c;</a></span><span class="linkable">worker_get_identifier</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a> *shared = state-&gt;shared;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worker;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L407" title="utils/sort/tuplesort.c:407">WORKER</a>(state));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;shared-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; worker = shared-&gt;currentWorker++;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;shared-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> worker;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3047" title="utils/sort/tuplesort.c:3047">worker_freeze_result_tape</a> - freeze worker's result tape for leader<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called by workers just after the result tape has been determined,<br/></li>
<li></span><span class="Comment"> * instead of calling <a href="logtape.c.html#L981" title="utils/sort/logtape.c:981">LogicalTapeFreeze</a>() directly.&nbsp; They do so because<br/></li>
<li></span><span class="Comment"> * workers require a few additional steps over similar serial<br/></li>
<li></span><span class="Comment"> * TSS_SORTEDONTAPE external sort cases, which also happen here.&nbsp; The extra<br/></li>
<li></span><span class="Comment"> * steps are around freeing <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> unneeded resources, and representing to<br/></li>
<li></span><span class="Comment"> * leader that worker's input run is available for its <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There should only be one final output run for each worker, which consists<br/></li>
<li></span><span class="Comment"> * of all tuples that were originally input into worker.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3047">&#x200c;</a></span><span class="linkable">worker_freeze_result_tape</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a> *shared = state-&gt;shared;<br/></li>
<li>&nbsp; &nbsp; TapeShare&nbsp; &nbsp; output;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L407" title="utils/sort/tuplesort.c:407">WORKER</a>(state));<br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;result_tape != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;memtupcount == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Free most remaining memory, in case caller is sensitive to our holding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on to it.&nbsp; memtuples may not be a tiny <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> heap at this point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state-&gt;memtuples);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Be tidy */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;memtuples = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;memtupsize = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Parallel worker requires result tape metadata, which is to be stored in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared memory for leader<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="logtape.c.html#L981" title="utils/sort/logtape.c:981">LogicalTapeFreeze</a>(state-&gt;result_tape, &amp;output);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store properties of output tape, and update finished worker count */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;shared-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; shared-&gt;tapes[state-&gt;worker] = output;<br/></li>
<li>&nbsp; &nbsp; shared-&gt;workersFinished++;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;shared-&gt;mutex);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3085" title="utils/sort/tuplesort.c:3085">worker_nomergeruns</a> - <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> memtuples in worker, without merging<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This called as an alternative to <a href="#L2045" title="utils/sort/tuplesort.c:2045">mergeruns</a>() with a worker when no<br/></li>
<li></span><span class="Comment"> * merging is required.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3085">&#x200c;</a></span><span class="linkable">worker_nomergeruns</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L407" title="utils/sort/tuplesort.c:407">WORKER</a>(state));<br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;result_tape == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;nOutputRuns == <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;result_tape = state-&gt;destTape;<br/></li>
<li>&nbsp; &nbsp; <a href="#L3047" title="utils/sort/tuplesort.c:3047">worker_freeze_result_tape</a>(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3107" title="utils/sort/tuplesort.c:3107">leader_takeover_tapes</a> - create tapeset for leader from worker tapes<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * So far, leader <a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> has performed no actual sorting.&nbsp; By <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, all<br/></li>
<li></span><span class="Comment"> * sorting has occurred in workers, all of which must have already returned<br/></li>
<li></span><span class="Comment"> * from <a href="#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When this returns, leader process is left in a state that is virtually<br/></li>
<li></span><span class="Comment"> * indistinguishable from it having generated runs as a serial external sort<br/></li>
<li></span><span class="Comment"> * might have.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3107">&#x200c;</a></span><span class="linkable">leader_takeover_tapes</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a> *shared = state-&gt;shared;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nParticipants = state-&gt;nParticipants;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workersFinished;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L408" title="utils/sort/tuplesort.c:408">LEADER</a>(state));<br/></li>
<li>&nbsp; &nbsp; Assert(nParticipants &gt;= <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;shared-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; workersFinished = shared-&gt;workersFinished;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;shared-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nParticipants != workersFinished)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot take over tapes <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> all workers finish&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the tapeset from worker tapes, including a leader-owned tape at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the end.&nbsp; Parallel workers are far more expensive than logical tapes,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so the number of tapes allocated here should never be excessive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1942" title="utils/sort/tuplesort.c:1942">inittapestate</a>(state, nParticipants);<br/></li>
<li>&nbsp; &nbsp; state-&gt;tapeset = <a href="logtape.c.html#L556" title="utils/sort/logtape.c:556">LogicalTapeSetCreate</a>(<span class="Constant">false</span>, &amp;shared-&gt;fileset, -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set currentRun to reflect the number of runs we will <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> (it's not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used for anything, this is just pro forma)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;currentRun = nParticipants;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the state to look the same as after building the initial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * runs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There will always be exactly 1 run per worker, and exactly one input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tape per run, because workers always output exactly 1 run, even when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there were no input tuples for workers to sort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;inputTapes = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;nInputTapes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;nInputRuns = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;outputTapes = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(nParticipants * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="logtape.c.html#L137" title="utils/sort/logtape.c:137">LogicalTape</a> *));<br/></li>
<li>&nbsp; &nbsp; state-&gt;nOutputTapes = nParticipants;<br/></li>
<li>&nbsp; &nbsp; state-&gt;nOutputRuns = nParticipants;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; nParticipants; j++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;outputTapes[j] = <a href="logtape.c.html#L609" title="utils/sort/logtape.c:609">LogicalTapeImport</a>(state-&gt;tapeset, j, &amp;shared-&gt;tapes[j]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;status = TSS_BUILDRUNS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convenience routine to free a tuple previously loaded into sort memory<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3166">&#x200c;</a></span><span class="linkable">free_sort_tuple</span>(<a href="#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *state, SortTuple *stup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stup-&gt;tuple)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L405" title="utils/sort/tuplesort.c:405">FREEMEM</a>(state, <a href="../mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>(stup-&gt;tuple));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(stup-&gt;tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stup-&gt;tuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">int<br/></li>
<li><a id="L3177">&#x200c;</a></span><span class="linkable">ssup_datum_unsigned_cmp</span>(Datum x, Datum y, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (x &lt; y)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (x &gt; y)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#if SIZEOF_DATUM &gt;= </span><span class="Constant">8<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L3189">&#x200c;</a></span><span class="linkable">ssup_datum_signed_cmp</span>(Datum x, Datum y, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; xx = DatumGetInt64(x);<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; yy = DatumGetInt64(y);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xx &lt; yy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (xx &gt; yy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Type">int<br/></li>
<li><a id="L3204">&#x200c;</a></span><span class="linkable">ssup_datum_int32_cmp</span>(Datum x, Datum y, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; xx = DatumGetInt32(x);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; yy = DatumGetInt32(y);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xx &lt; yy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (xx &gt; yy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
