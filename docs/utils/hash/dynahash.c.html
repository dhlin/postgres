<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/hash/dynahash.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/hash/dynahash.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L288">CurrentDynaHashCxt</a></li>
<li><a href="#L258">hash_accesses</a></li>
<li><a href="#L259">hash_collisions</a></li>
<li><a href="#L260">hash_expansions</a></li>
<li><a href="#L1817">num_seq_scans</a></li>
<li><a href="#L1816">seq_scan_level</a></li>
<li><a href="#L1815">seq_scan_tables</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L158">FreeListData</a></li>
<li><a href="#L131">HASHBUCKET</a></li>
<li><a href="#L168">HASHHDR</a></li>
<li><a href="#L134">HASHSEGMENT</a></li>
<li><a href="#L219">HTAB</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1895">AtEOSubXact_HashTables</a></li>
<li><a href="#L1869">AtEOXact_HashTables</a></li>
<li><a href="#L291">DynaHashAlloc</a></li>
<li><a href="#L918">calc_bucket</a></li>
<li><a href="#L656">choose_nelem_alloc</a></li>
<li><a href="#L1834">deregister_seq_scan</a></li>
<li><a href="#L1605">dir_realloc</a></li>
<li><a href="#L1663">element_alloc</a></li>
<li><a href="#L1508">expand_table</a></li>
<li><a href="#L1256">get_hash_entry</a></li>
<li><a href="#L911">get_hash_value</a></li>
<li><a href="#L1855">has_seq_scans</a></li>
<li><a href="#L1737">hash_corrupted</a></li>
<li><a href="#L352">hash_create</a></li>
<li><a href="#L865">hash_destroy</a></li>
<li><a href="#L783">hash_estimate_size</a></li>
<li><a href="#L1491">hash_freeze</a></li>
<li><a href="#L1341">hash_get_num_entries</a></li>
<li><a href="#L854">hash_get_shared_size</a></li>
<li><a href="#L1713">hash_initial_lookup</a></li>
<li><a href="#L955">hash_search</a></li>
<li><a href="#L968">hash_search_with_hash_value</a></li>
<li><a href="#L830">hash_select_dirsize</a></li>
<li><a href="#L1385">hash_seq_init</a></li>
<li><a href="#L1395">hash_seq_search</a></li>
<li><a href="#L1471">hash_seq_term</a></li>
<li><a href="#L884">hash_stats</a></li>
<li><a href="#L1145">hash_update_hash_key</a></li>
<li><a href="#L629">hdefault</a></li>
<li><a href="#L689">init_htab</a></li>
<li><a href="#L1751">my_log2</a></li>
<li><a href="#L1777">next_pow2_int</a></li>
<li><a href="#L1769">next_pow2_long</a></li>
<li><a href="#L1822">register_seq_scan</a></li>
<li><a href="#L1644">seg_alloc</a></li>
<li><a href="#L307">string_compare</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L125">DEF_DIRSIZE</a></li>
<li><a href="#L123">DEF_SEGSIZE</a></li>
<li><a href="#L124">DEF_SEGSIZE_SHIFT</a></li>
<li><a href="#L244">ELEMENTKEY</a></li>
<li><a href="#L249">ELEMENT_FROM_KEY</a></li>
<li><a href="#L212">FREELIST_IDX</a></li>
<li><a href="#L210">IS_PARTITIONED</a></li>
<li><a href="#L1813">MAX_SEQ_SCANS</a></li>
<li><a href="#L255">MOD</a></li>
<li><a href="#L128">NUM_FREELISTS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * dynahash.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; dynamic chained <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * dynahash.c supports both local-to-a-backend <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables and <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables in<br/></li>
<li></span><span class="Comment"> * shared memory.&nbsp; For shared <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables, it is the caller's responsibility<br/></li>
<li></span><span class="Comment"> * to provide appropriate access interlocking.&nbsp; The simplest convention is<br/></li>
<li></span><span class="Comment"> * that a single LWLock protects the whole <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.&nbsp; Searches (HASH_FIND or<br/></li>
<li></span><span class="Comment"> * <a href="#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>) need only shared lock, but <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> update requires exclusive<br/></li>
<li></span><span class="Comment"> * lock.&nbsp; For heavily-used shared tables, the single-lock approach creates a<br/></li>
<li></span><span class="Comment"> * concurrency bottleneck, so we also support &quot;partitioned&quot; locking wherein<br/></li>
<li></span><span class="Comment"> * there are multiple LWLocks guarding distinct subsets of the table.&nbsp; To use<br/></li>
<li></span><span class="Comment"> * a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table in partitioned mode, the HASH_PARTITION flag must be given<br/></li>
<li></span><span class="Comment"> * to <a href="#L352" title="utils/hash/dynahash.c:352">hash_create</a>.&nbsp; This prevents <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> attempt to split buckets on-the-fly.<br/></li>
<li></span><span class="Comment"> * Therefore, each <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> bucket chain operates independently, and no fields<br/></li>
<li></span><span class="Comment"> * of the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> header change after init except nentries and freeList.<br/></li>
<li></span><span class="Comment"> * (A partitioned table uses multiple copies of those fields, guarded by<br/></li>
<li></span><span class="Comment"> * spinlocks, for additional concurrency.)<br/></li>
<li></span><span class="Comment"> * This lets <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> buckets be treated as a separately<br/></li>
<li></span><span class="Comment"> * lockable partition.&nbsp; We expect callers to use the low-order bits of a<br/></li>
<li></span><span class="Comment"> * lookup key's <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value as a partition number --- this will work because<br/></li>
<li></span><span class="Comment"> * of the way <a href="#L918" title="utils/hash/dynahash.c:918">calc_bucket</a>() <a href="../mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to bucket numbers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables in shared memory, the memory allocator function should<br/></li>
<li></span><span class="Comment"> * match malloc's semantics of returning NULL on failure.&nbsp; For <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables<br/></li>
<li></span><span class="Comment"> * in local memory, we typically use <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>() which will throw error on<br/></li>
<li></span><span class="Comment"> * failure.&nbsp; The code in this file has to cope with both cases.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * dynahash.c provides support for these types of lookup keys:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 1. Null-terminated C strings (truncated if necessary to fit in keysize),<br/></li>
<li></span><span class="Comment"> * compared as though by strcmp().&nbsp; This is selected by specifying the<br/></li>
<li></span><span class="Comment"> * HASH_STRINGS flag to <a href="#L352" title="utils/hash/dynahash.c:352">hash_create</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 2. Arbitrary binary data of size keysize, compared as though by memcmp().<br/></li>
<li></span><span class="Comment"> * (Caller must ensure there are no undefined padding bits in the keys!)<br/></li>
<li></span><span class="Comment"> * This is selected by specifying the HASH_BLOBS flag to <a href="#L352" title="utils/hash/dynahash.c:352">hash_create</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 3. More complex key behavior can be selected by specifying user-supplied<br/></li>
<li></span><span class="Comment"> * hashing, comparison, and/or key-copying <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; At least a hashing<br/></li>
<li></span><span class="Comment"> * function must be supplied; comparison defaults to memcmp() and key copying<br/></li>
<li></span><span class="Comment"> * to memcpy() when a user-defined hashing function is selected.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Compared to simplehash, dynahash has the following benefits:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * - It supports partitioning, which is useful for shared memory access using<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; locks.<br/></li>
<li></span><span class="Comment"> * - Shared memory hashes are allocated in a fixed size area at startup and<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; are discoverable by name from other processes.<br/></li>
<li></span><span class="Comment"> * - Because entries don't need to be moved in the case of <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> conflicts,<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; dynahash has better performance for large entries.<br/></li>
<li></span><span class="Comment"> * - Guarantees stable pointers to entries.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>/dynahash.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Original comments:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Dynamic hashing, after CACM April 1988 pp 446-457, by Per-Ake Larson.<br/></li>
<li></span><span class="Comment"> * Coded into C, with minor code improvements, and with hsearch(3) interface,<br/></li>
<li></span><span class="Comment"> * by ejp@ausmelb.oz, Jul 26, 1988: 13:16;<br/></li>
<li></span><span class="Comment"> * also, hcreate/hdestroy routines added to simulate hsearch(3).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These routines simulate hsearch(3) and family, with the important<br/></li>
<li></span><span class="Comment"> * difference that the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table is dynamic - can grow indefinitely<br/></li>
<li></span><span class="Comment"> * beyond its original size (as supplied to hcreate()).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Performance appears to be comparable to that of hsearch(3).<br/></li>
<li></span><span class="Comment"> * The 'source-code' options referred to in hsearch(3)'s 'man' page<br/></li>
<li></span><span class="Comment"> * are not implemented; otherwise functionality is identical.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Compilation controls:<br/></li>
<li></span><span class="Comment"> * HASH_DEBUG controls some informative traces, mainly for debugging.<br/></li>
<li></span><span class="Comment"> * HASH_STATISTICS causes HashAccesses and HashCollisions to be maintained;<br/></li>
<li></span><span class="Comment"> * when combined with HASH_DEBUG, these are displayed by hdestroy().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Problems &amp; fixes to ejp@ausmelb.oz. WARNING: relies on pre-processor<br/></li>
<li></span><span class="Comment"> * concatenation property, in probably unnecessary code 'optimization'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Modified margo@postgres.berkeley.edu February 1990<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; added multiple table interface<br/></li>
<li></span><span class="Comment"> * Modified by sullivan@postgres.berkeley.edu April 1990<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; changed ctl structure for shared memory<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/hashfn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/shmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/spin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/dynahash.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Constants<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table has a top-level &quot;directory&quot;, each of whose entries points<br/></li>
<li></span><span class="Comment"> * to a &quot;segment&quot; of ssize bucket headers.&nbsp; The maximum number of <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment"> * buckets is thus dsize * ssize (but dsize may be expansible).&nbsp; Of course,<br/></li>
<li></span><span class="Comment"> * the number of <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> in the table can be larger, but we don't want a<br/></li>
<li></span><span class="Comment"> * whole lot of <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> per bucket or performance goes down.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table allocated in shared memory, the directory cannot be<br/></li>
<li></span><span class="Comment"> * expanded because it must stay at a fixed address.&nbsp; The directory size<br/></li>
<li></span><span class="Comment"> * should be selected using <a href="#L830" title="utils/hash/dynahash.c:830">hash_select_dirsize</a> (and you'd better have<br/></li>
<li></span><span class="Comment"> * a good idea of the maximum number of entries!).&nbsp; For non-shared <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment"> * tables, the initial directory size can be left at the default.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L123">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DEF_SEGSIZE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Constant">256<br/></li>
<li><a id="L124">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DEF_SEGSIZE_SHIFT</span>&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Constant">8</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* must be log2(<a href="#L123" title="utils/hash/dynahash.c:123">DEF_SEGSIZE</a>) */<br/></li>
<li><a id="L125">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DEF_DIRSIZE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Constant">256<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Number of freelists to be used for a partitioned <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table. */<br/></li>
<li><a id="L128">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUM_FREELISTS</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">32<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* A <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> bucket is a linked list of HASHELEMENTs */<br/></li>
<li><a id="L131">&#x200c;</a></span><span class="Type">typedef</span> HASHELEMENT *<span class="linkable">HASHBUCKET</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* A <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> segment is an array of bucket headers */<br/></li>
<li><a id="L134">&#x200c;</a></span><span class="Type">typedef</span> <a href="#L131" title="utils/hash/dynahash.c:131">HASHBUCKET</a> *<span class="linkable">HASHSEGMENT</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Per-freelist data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In a partitioned <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table, each freelist is associated with a specific<br/></li>
<li></span><span class="Comment"> * set of hashcodes, as determined by the <a href="#L212" title="utils/hash/dynahash.c:212">FREELIST_IDX</a>() macro below.<br/></li>
<li></span><span class="Comment"> * nentries tracks the number of live hashtable entries having those hashcodes<br/></li>
<li></span><span class="Comment"> * (NOT the number of entries in the freelist, as you might expect).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The coverage of a freelist might be more or less than one partition, so it<br/></li>
<li></span><span class="Comment"> * needs its own lock rather than relying on caller locking.&nbsp; Relying on that<br/></li>
<li></span><span class="Comment"> * wouldn't work even if the coverage was the same, because of the occasional<br/></li>
<li></span><span class="Comment"> * need to &quot;borrow&quot; entries from another freelist; see <a href="#L1256" title="utils/hash/dynahash.c:1256">get_hash_entry</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Using an array of <a href="#L158" title="utils/hash/dynahash.c:158">FreeListData</a> instead of separate arrays of mutexes,<br/></li>
<li></span><span class="Comment"> * nentries and freeLists helps to reduce sharing of cache lines between<br/></li>
<li></span><span class="Comment"> * different mutexes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; slock_t&nbsp; &nbsp; &nbsp; &nbsp; mutex;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* spinlock for this freelist */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; nentries;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of entries in associated buckets */<br/></li>
<li></span>&nbsp; &nbsp; HASHELEMENT *freeList;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* chain of free elements */<br/></li>
<li><a id="L158">&#x200c;</a></span>} <span class="linkable">FreeListData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Header structure for a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table --- contains all changeable info<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In a shared-memory <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table, the <a href="#L168" title="utils/hash/dynahash.c:168">HASHHDR</a> is in shared memory, while<br/></li>
<li></span><span class="Comment"> * each backend has a local <a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> struct.&nbsp; For a non-shared table, there isn't<br/></li>
<li></span><span class="Comment"> * <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> functional difference between <a href="#L168" title="utils/hash/dynahash.c:168">HASHHDR</a> and <a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a>, but we separate them<br/></li>
<li></span><span class="Comment"> * anyway to share code between shared and non-shared tables.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L168">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">HASHHDR</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The freelist can become a point of contention in high-concurrency <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tables, so we use an array of freelists, each with its own mutex and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nentries count, instead of just a single one.&nbsp; Although the freelists<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * normally operate independently, we will scavenge entries from freelists<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other than a hashcode's default freelist when necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table is not partitioned, only freeList[0] is used and its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * spinlock is not used at all; callers' locking is assumed sufficient.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L158" title="utils/hash/dynahash.c:158">FreeListData</a> freeList[<a href="#L128" title="utils/hash/dynahash.c:128">NUM_FREELISTS</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* These fields can change, but not in a partitioned table */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Also, dsize can't change in a shared table, even if unpartitioned */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; dsize;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* directory size */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; nsegs;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of allocated segments (&lt;= dsize) */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; max_bucket;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ID of maximum bucket in use */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; high_mask;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mask to modulo into entire table */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; low_mask;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mask to modulo into <a href="../adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> half of table */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* These fields are fixed at hashtable creation */<br/></li>
<li></span>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; keysize;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key length in bytes */<br/></li>
<li></span>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; entrysize;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* total user <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> size in bytes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; num_partitions; <span class="Comment">/* # partitions (must be power of 2), or 0 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; max_dsize;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* 'dsize' limit if directory is fixed size */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; ssize;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* segment size --- must be power of 2 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sshift;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* segment shift = log2(ssize) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelem_alloc;&nbsp; &nbsp; <span class="Comment">/* number of entries to allocate at once */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef HASH_STATISTICS<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Count statistics here.&nbsp; NB: stats code doesn't bother with mutex, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * counts could be corrupted a <a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> in a partitioned table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; accesses;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; collisions;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><a id="L210">&#x200c;</a><span class="PreProc">#define <span class="linkable">IS_PARTITIONED</span>(hctl)&nbsp; ((hctl)-&gt;num_partitions != </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L212">&#x200c;</a><span class="PreProc">#define <span class="linkable">FREELIST_IDX</span>(hctl, hashcode) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (<a href="#L210" title="utils/hash/dynahash.c:210">IS_PARTITIONED</a>(hctl) ? (hashcode) % <a href="#L128" title="utils/hash/dynahash.c:128">NUM_FREELISTS</a> : </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Top control structure for a hashtable --- in a shared table, each backend<br/></li>
<li></span><span class="Comment"> * has its own copy (OK since no fields change at runtime)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L219">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">HTAB</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="utils/hash/dynahash.c:168">HASHHDR</a>&nbsp; &nbsp; *hctl;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* =&gt; shared control information */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L134" title="utils/hash/dynahash.c:134">HASHSEGMENT</a> *dir;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* directory of segment starts */<br/></li>
<li></span>&nbsp; &nbsp; HashValueFunc <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function */<br/></li>
<li></span>&nbsp; &nbsp; HashCompareFunc match;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* key comparison function */<br/></li>
<li></span>&nbsp; &nbsp; HashCopyFunc keycopy;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* key copying function */<br/></li>
<li></span>&nbsp; &nbsp; HashAllocFunc alloc;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* memory allocator */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext hcxt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* memory context if default allocator used */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tabname;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* table name (for error messages) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isshared;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* true if table is in shared memory */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isfixed;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if true, don't enlarge */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* freezing a shared table isn't allowed, so we can keep state here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; frozen;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* true = no more inserts allowed */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We keep local copies of these fixed <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to reduce contention */<br/></li>
<li></span>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; keysize;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key length in bytes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; ssize;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* segment size --- must be power of 2 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sshift;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* segment shift = log2(ssize) */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Key (also entry) part of a HASHELEMENT<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L244">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ELEMENTKEY</span>(helem)&nbsp; (((</span><span class="Type">char</span><span class="PreProc"> *)(helem)) + MAXALIGN(</span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(HASHELEMENT)))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Obtain <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> pointer given pointer to key<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L249">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ELEMENT_FROM_KEY</span>(key)&nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((HASHELEMENT *) (((</span><span class="Type">char</span><span class="PreProc"> *) (key)) - MAXALIGN(</span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(HASHELEMENT))))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fast <a href="#L255" title="utils/hash/dynahash.c:255">MOD</a> arithmetic, assuming that y is a power of 2 !<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L255">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MOD</span>(x,y)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((x) &amp; ((y)-</span><span class="Constant">1</span><span class="PreProc">))<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef HASH_STATISTICS<br/></li>
<li><a id="L258">&#x200c;</a></span><span class="Type">static</span> <span class="Type">long</span> <span class="linkable">hash_accesses</span>,<br/></li>
<li><a id="L259">&#x200c;</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">hash_collisions</span>,<br/></li>
<li><a id="L260">&#x200c;</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">hash_expansions</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Private function prototypes<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> *<a href="#L291" title="utils/hash/dynahash.c:291">DynaHashAlloc</a>(Size size);<br/></li>
<li><span class="Type">static</span> <a href="#L134" title="utils/hash/dynahash.c:134">HASHSEGMENT</a> <a href="#L1644" title="utils/hash/dynahash.c:1644">seg_alloc</a>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1663" title="utils/hash/dynahash.c:1663">element_alloc</a>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp, <span class="Type">int</span> nelem, <span class="Type">int</span> freelist_idx);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1605" title="utils/hash/dynahash.c:1605">dir_realloc</a>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1508" title="utils/hash/dynahash.c:1508">expand_table</a>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp);<br/></li>
<li><span class="Type">static</span> <a href="#L131" title="utils/hash/dynahash.c:131">HASHBUCKET</a> <a href="#L1256" title="utils/hash/dynahash.c:1256">get_hash_entry</a>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp, <span class="Type">int</span> freelist_idx);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L629" title="utils/hash/dynahash.c:629">hdefault</a>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L656" title="utils/hash/dynahash.c:656">choose_nelem_alloc</a>(Size entrysize);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L689" title="utils/hash/dynahash.c:689">init_htab</a>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp, <span class="Type">long</span> nelem);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1737" title="utils/hash/dynahash.c:1737">hash_corrupted</a>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp) pg_attribute_noreturn();<br/></li>
<li><span class="Type">static</span> uint32 <a href="#L1713" title="utils/hash/dynahash.c:1713">hash_initial_lookup</a>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp, uint32 hashvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="utils/hash/dynahash.c:131">HASHBUCKET</a> **bucketptr);<br/></li>
<li><span class="Type">static</span> <span class="Type">long</span> <a href="#L1769" title="utils/hash/dynahash.c:1769">next_pow2_long</a>(<span class="Type">long</span> num);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1777" title="utils/hash/dynahash.c:1777">next_pow2_int</a>(<span class="Type">long</span> num);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1822" title="utils/hash/dynahash.c:1822">register_seq_scan</a>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1834" title="utils/hash/dynahash.c:1834">deregister_seq_scan</a>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1855" title="utils/hash/dynahash.c:1855">has_seq_scans</a>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * memory allocation support<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L288">&#x200c;</a></span><span class="Type">static</span> MemoryContext <span class="linkable">CurrentDynaHashCxt</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> *<br/></li>
<li><a id="L291">&#x200c;</a><span class="linkable">DynaHashAlloc</span>(Size size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(MemoryContextIsValid(<a href="#L288" title="utils/hash/dynahash.c:288">CurrentDynaHashCxt</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../mmgr/mcxt.c.html#L1237" title="utils/mmgr/mcxt.c:1237">MemoryContextAllocExtended</a>(<a href="#L288" title="utils/hash/dynahash.c:288">CurrentDynaHashCxt</a>, size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MCXT_ALLOC_NO_OOM);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * HashCompareFunc for string keys<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Because we copy keys with strlcpy(), they will be truncated at keysize-1<br/></li>
<li></span><span class="Comment"> * bytes, so we can only <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> that many ... hence strncmp is almost but<br/></li>
<li></span><span class="Comment"> * not quite the right thing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L307">&#x200c;</a></span><span class="linkable">string_compare</span>(<span class="Type">const</span> <span class="Type">char</span> *key1, <span class="Type">const</span> <span class="Type">char</span> *key2, Size keysize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> strncmp(key1, key2, keysize - <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/************************** CREATE ROUTINES **********************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L352" title="utils/hash/dynahash.c:352">hash_create</a> -- create a new dynamic <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; tabname: a name for the table (for debugging purposes)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; nelem: maximum number of elements expected<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *info: additional table parameters, as indicated by flags<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; flags: bitmask indicating which parameters to take from *info<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The flags value *must* include HASH_ELEM.&nbsp; (Formerly, this was nominally<br/></li>
<li></span><span class="Comment"> * optional, but the default keysize and entrysize <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> were useless.)<br/></li>
<li></span><span class="Comment"> * The flags value must also include exactly one of HASH_STRINGS, HASH_BLOBS,<br/></li>
<li></span><span class="Comment"> * or HASH_FUNCTION, to define the key hashing semantics (C strings,<br/></li>
<li></span><span class="Comment"> * binary blobs, or custom, respectively).&nbsp; Callers specifying a custom<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function will likely also want to use HASH_COMPARE, and perhaps<br/></li>
<li></span><span class="Comment"> * also HASH_KEYCOPY, to control key comparison and copying.<br/></li>
<li></span><span class="Comment"> * Another often-used flag is HASH_CONTEXT, to allocate the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table<br/></li>
<li></span><span class="Comment"> * under info-&gt;hcxt rather than under <a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>; the default<br/></li>
<li></span><span class="Comment"> * behavior is only suitable for session-lifespan <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables.<br/></li>
<li></span><span class="Comment"> * Other flags bits are special-purpose and seldom used, except for those<br/></li>
<li></span><span class="Comment"> * associated with shared-memory <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables, for which see <a href="../../storage/ipc/shmem.c.html#L332" title="storage/ipc/shmem.c:332">ShmemInitHash</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Fields in *info are read only when the associated flags <a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is set.<br/></li>
<li></span><span class="Comment"> * It is not necessary to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> other fields of *info.<br/></li>
<li></span><span class="Comment"> * Neither tabname nor *info need persist after the <a href="#L352" title="utils/hash/dynahash.c:352">hash_create</a>() call.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: It is deprecated for callers of <a href="#L352" title="utils/hash/dynahash.c:352">hash_create</a>() to explicitly specify<br/></li>
<li></span><span class="Comment"> * string_hash, tag_hash, uint32_hash, or oid_hash.&nbsp; Just set HASH_STRINGS or<br/></li>
<li></span><span class="Comment"> * HASH_BLOBS.&nbsp; Use HASH_FUNCTION only when you want something other than<br/></li>
<li></span><span class="Comment"> * one of these.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: for a shared-memory hashtable, nelem needs to be a pretty good<br/></li>
<li></span><span class="Comment"> * estimate, since we can't expand the table on the fly.&nbsp; But an unshared<br/></li>
<li></span><span class="Comment"> * hashtable can be expanded on-the-fly, so it's better for nelem to be<br/></li>
<li></span><span class="Comment"> * on the small side and let the table grow if it's exceeded.&nbsp; An overly<br/></li>
<li></span><span class="Comment"> * large nelem will penalize <a href="#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a> speed without buying much.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<br/></li>
<li><a id="L352">&#x200c;</a><span class="linkable">hash_create</span>(<span class="Type">const</span> <span class="Type">char</span> *tabname, <span class="Type">long</span> nelem, <span class="Type">const</span> HASHCTL *info, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *hashp;<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="utils/hash/dynahash.c:168">HASHHDR</a>&nbsp; &nbsp; *hctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Hash tables <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> allocate space for key and data, but you have to say<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * how much space to allocate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(flags &amp; HASH_ELEM);<br/></li>
<li>&nbsp; &nbsp; Assert(info-&gt;keysize &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(info-&gt;entrysize &gt;= info-&gt;keysize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For shared <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables, we have a local <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> header (<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> struct) that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we allocate in <a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>; all else is in shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For non-shared <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables, everything including the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> header is in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a memory context created specially for the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table --- this makes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L865" title="utils/hash/dynahash.c:865">hash_destroy</a> very simple.&nbsp; The memory context is made a child of either<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a context specified by the caller, or <a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a> if nothing is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * specified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; HASH_SHARED_MEM)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set up to allocate the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> header */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L288" title="utils/hash/dynahash.c:288">CurrentDynaHashCxt</a> = <a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table's private memory context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; HASH_CONTEXT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L288" title="utils/hash/dynahash.c:288">CurrentDynaHashCxt</a> = info-&gt;hcxt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L288" title="utils/hash/dynahash.c:288">CurrentDynaHashCxt</a> = <a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L288" title="utils/hash/dynahash.c:288">CurrentDynaHashCxt</a> = AllocSetContextCreate(<a href="#L288" title="utils/hash/dynahash.c:288">CurrentDynaHashCxt</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;dynahash&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> header, plus a copy of the table name */<br/></li>
<li></span>&nbsp; &nbsp; hashp = (<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *) <a href="#L291" title="utils/hash/dynahash.c:291">DynaHashAlloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a>) + strlen(tabname) + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; MemSet(hashp, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hashp-&gt;tabname = (<span class="Type">char</span> *) (hashp + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; strcpy(hashp-&gt;tabname, tabname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we have a private context, label it with hashtable's name */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(flags &amp; HASH_SHARED_MEM))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L612" title="utils/mmgr/mcxt.c:612">MemoryContextSetIdentifier</a>(<a href="#L288" title="utils/hash/dynahash.c:288">CurrentDynaHashCxt</a>, hashp-&gt;tabname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Select the appropriate <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function (see comments at head of file).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; HASH_FUNCTION)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!(flags &amp; (HASH_BLOBS | HASH_STRINGS)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = info-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (flags &amp; HASH_BLOBS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!(flags &amp; HASH_STRINGS));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> hashing for common key sizes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (info-&gt;keysize == <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = uint32_hash;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = tag_hash;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * string_hash used to be considered the default <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> method, and in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-assert build it effectively still is.&nbsp; But we <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> consider it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an assertion error to not say HASH_STRINGS explicitly.&nbsp; To <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * catch mistaken usage of HASH_STRINGS, we also insist on a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reasonably long string length: if the keysize is only 4 or 8 bytes,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's almost certainly an integer or pointer not a string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(flags &amp; HASH_STRINGS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(info-&gt;keysize &gt; <span class="Constant">8</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = string_hash;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If you don't specify a match function, it defaults to <a href="#L307" title="utils/hash/dynahash.c:307">string_compare</a> if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * you used string_hash, and to memcmp otherwise.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: explicitly specifying string_hash is deprecated, because this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might not work for callers in loadable modules on some platforms due to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * referencing a trampoline instead of the string_hash function proper.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Specify HASH_STRINGS instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; HASH_COMPARE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;match = info-&gt;match;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (hashp-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> == string_hash)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;match = (HashCompareFunc) <a href="#L307" title="utils/hash/dynahash.c:307">string_compare</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;match = memcmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Similarly, the key-copying function defaults to strlcpy or memcpy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; HASH_KEYCOPY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;keycopy = info-&gt;keycopy;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (hashp-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> == string_hash)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The signature of keycopy is meant for memcpy(), which returns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * void*, but strlcpy() returns size_t.&nbsp; Since we never use the return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * value of keycopy, and size_t is pretty much always the same size as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * void *, this should be safe.&nbsp; The extra cast in the middle is to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * avoid warnings from -Wcast-function-type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;keycopy = (HashCopyFunc) (pg_funcptr_t) strlcpy;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;keycopy = memcpy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> the entry allocation function, too. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; HASH_ALLOC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;alloc = info-&gt;alloc;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;alloc = <a href="#L291" title="utils/hash/dynahash.c:291">DynaHashAlloc</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; HASH_SHARED_MEM)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ctl structure and directory are preallocated for shared memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tables.&nbsp; Note that HASH_DIRSIZE and HASH_ALLOC had better be set as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;hctl = info-&gt;hctl;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;dir = (<a href="#L134" title="utils/hash/dynahash.c:134">HASHSEGMENT</a> *) (((<span class="Type">char</span> *) info-&gt;hctl) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L168" title="utils/hash/dynahash.c:168">HASHHDR</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;hcxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;isshared = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table already exists, we're just attaching to it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; HASH_ATTACH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make local copies of some heavily-used <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hctl = hashp-&gt;hctl;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;keysize = hctl-&gt;keysize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;ssize = hctl-&gt;ssize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;sshift = hctl-&gt;sshift;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> hashp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* setup <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table defaults */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;hctl = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;dir = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;hcxt = <a href="#L288" title="utils/hash/dynahash.c:288">CurrentDynaHashCxt</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;isshared = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!hashp-&gt;hctl)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;hctl = (<a href="#L168" title="utils/hash/dynahash.c:168">HASHHDR</a> *) hashp-&gt;alloc(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L168" title="utils/hash/dynahash.c:168">HASHHDR</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!hashp-&gt;hctl)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hashp-&gt;frozen = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L629" title="utils/hash/dynahash.c:629">hdefault</a>(hashp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hctl = hashp-&gt;hctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; HASH_PARTITION)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Doesn't make sense to partition a local <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(flags &amp; HASH_SHARED_MEM);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The number of partitions had better be a power of 2. Also, it must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be less than INT_MAX (see <a href="#L689" title="utils/hash/dynahash.c:689">init_htab</a>()), so call the int version of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * next_pow2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(info-&gt;num_partitions == <a href="#L1777" title="utils/hash/dynahash.c:1777">next_pow2_int</a>(info-&gt;num_partitions));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hctl-&gt;num_partitions = info-&gt;num_partitions;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; HASH_SEGMENT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hctl-&gt;ssize = info-&gt;ssize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hctl-&gt;sshift = <a href="#L1751" title="utils/hash/dynahash.c:1751">my_log2</a>(info-&gt;ssize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ssize had better be a power of 2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(hctl-&gt;ssize == (<span class="Constant">1L</span> &lt;&lt; hctl-&gt;sshift));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SHM <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables have fixed directory size passed by the caller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; HASH_DIRSIZE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hctl-&gt;max_dsize = info-&gt;max_dsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hctl-&gt;dsize = info-&gt;dsize;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remember the entry sizes, too */<br/></li>
<li></span>&nbsp; &nbsp; hctl-&gt;keysize = info-&gt;keysize;<br/></li>
<li>&nbsp; &nbsp; hctl-&gt;entrysize = info-&gt;entrysize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make local copies of heavily-used constant fields */<br/></li>
<li></span>&nbsp; &nbsp; hashp-&gt;keysize = hctl-&gt;keysize;<br/></li>
<li>&nbsp; &nbsp; hashp-&gt;ssize = hctl-&gt;ssize;<br/></li>
<li>&nbsp; &nbsp; hashp-&gt;sshift = hctl-&gt;sshift;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> directory structure */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L689" title="utils/hash/dynahash.c:689">init_htab</a>(hashp, nelem))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, hashp-&gt;tabname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For a shared <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table, preallocate the requested number of elements.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This reduces problems with run-time out-of-shared-memory conditions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For a non-shared <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table, preallocate the requested number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * elements if it's less than our chosen nelem_alloc.&nbsp; This avoids wasting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * space if the caller correctly estimates a small table size.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; HASH_SHARED_MEM) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nelem &lt; hctl-&gt;nelem_alloc)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freelist_partitions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelem_alloc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelem_alloc_first;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table is partitioned, give each freelist an <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> share of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the initial allocation.&nbsp; Otherwise only freeList[0] is used.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L210" title="utils/hash/dynahash.c:210">IS_PARTITIONED</a>(hashp-&gt;hctl))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freelist_partitions = <a href="#L128" title="utils/hash/dynahash.c:128">NUM_FREELISTS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freelist_partitions = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nelem_alloc = nelem / freelist_partitions;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nelem_alloc &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelem_alloc = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure we'll allocate all the requested elements; freeList[0]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * gets the excess if the request isn't divisible by <a href="#L128" title="utils/hash/dynahash.c:128">NUM_FREELISTS</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nelem_alloc * freelist_partitions &lt; nelem)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelem_alloc_first =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelem - nelem_alloc * (freelist_partitions - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelem_alloc_first = nelem_alloc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; freelist_partitions; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp = (i == <span class="Constant">0</span>) ? nelem_alloc_first : nelem_alloc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1663" title="utils/hash/dynahash.c:1663">element_alloc</a>(hashp, temp, i))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; HASH_FIXED_SIZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;isfixed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> hashp;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set default <a href="#L168" title="utils/hash/dynahash.c:168">HASHHDR</a> parameters.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L629">&#x200c;</a></span><span class="linkable">hdefault</span>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="utils/hash/dynahash.c:168">HASHHDR</a>&nbsp; &nbsp; *hctl = hashp-&gt;hctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemSet(hctl, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L168" title="utils/hash/dynahash.c:168">HASHHDR</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hctl-&gt;dsize = <a href="#L125" title="utils/hash/dynahash.c:125">DEF_DIRSIZE</a>;<br/></li>
<li>&nbsp; &nbsp; hctl-&gt;nsegs = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hctl-&gt;num_partitions = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* not partitioned */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* table has no fixed maximum size */<br/></li>
<li></span>&nbsp; &nbsp; hctl-&gt;max_dsize = NO_MAX_DSIZE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hctl-&gt;ssize = <a href="#L123" title="utils/hash/dynahash.c:123">DEF_SEGSIZE</a>;<br/></li>
<li>&nbsp; &nbsp; hctl-&gt;sshift = <a href="#L124" title="utils/hash/dynahash.c:124">DEF_SEGSIZE_SHIFT</a>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HASH_STATISTICS<br/></li>
<li></span>&nbsp; &nbsp; hctl-&gt;accesses = hctl-&gt;collisions = <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given the user-specified entry size, choose nelem_alloc, ie, how many<br/></li>
<li></span><span class="Comment"> * elements to add to the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table when we need more.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L656">&#x200c;</a></span><span class="linkable">choose_nelem_alloc</span>(Size entrysize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelem_alloc;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; elementSize;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; allocSize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Each <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> has a HASHELEMENT header plus user data. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* NB: this had better match <a href="#L1663" title="utils/hash/dynahash.c:1663">element_alloc</a>() */<br/></li>
<li></span>&nbsp; &nbsp; elementSize = MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HASHELEMENT)) + MAXALIGN(entrysize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The idea here is to choose nelem_alloc at least 32, but round up so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that the allocation request will be a power of 2 or just less. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * makes little difference for <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables in shared memory, but for <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tables managed by <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>, the allocation request will be rounded up to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a power of 2 anyway.&nbsp; If we fail to take this into account, we'll waste<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as much as half the allocated space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; allocSize = <span class="Constant">32</span> * <span class="Constant">4</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* assume elementSize at least 8 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; allocSize &lt;&lt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nelem_alloc = allocSize / elementSize;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (nelem_alloc &lt; <span class="Constant">32</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nelem_alloc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute derived fields of hctl and build the initial directory/segment<br/></li>
<li></span><span class="Comment"> * arrays<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L689">&#x200c;</a></span><span class="linkable">init_htab</span>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp, <span class="Type">long</span> nelem)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="utils/hash/dynahash.c:168">HASHHDR</a>&nbsp; &nbsp; *hctl = hashp-&gt;hctl;<br/></li>
<li>&nbsp; &nbsp; <a href="#L134" title="utils/hash/dynahash.c:134">HASHSEGMENT</a> *segp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbuckets;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nsegs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> mutexes if it's a partitioned table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L210" title="utils/hash/dynahash.c:210">IS_PARTITIONED</a>(hctl))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L128" title="utils/hash/dynahash.c:128">NUM_FREELISTS</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockInit(&amp;(hctl-&gt;freeList[i].mutex));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate space for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> greater power of two number of buckets,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assuming a desired maximum load factor of 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nbuckets = <a href="#L1777" title="utils/hash/dynahash.c:1777">next_pow2_int</a>(nelem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In a partitioned table, nbuckets must be at least <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * num_partitions; were it less, keys with apparently different partition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * numbers would map to the same bucket, breaking partition independence.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Normally nbuckets will be much bigger; this is just a safety check.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (nbuckets &lt; hctl-&gt;num_partitions)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbuckets &lt;&lt;= <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hctl-&gt;max_bucket = hctl-&gt;low_mask = nbuckets - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; hctl-&gt;high_mask = (nbuckets &lt;&lt; <span class="Constant">1</span>) - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Figure number of directory segments needed, round up to a power of 2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nsegs = (nbuckets - <span class="Constant">1</span>) / hctl-&gt;ssize + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; nsegs = <a href="#L1777" title="utils/hash/dynahash.c:1777">next_pow2_int</a>(nsegs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure directory is big enough. If pre-allocated directory is too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * small, choke (caller screwed up).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nsegs &gt; hctl-&gt;dsize)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(hashp-&gt;dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hctl-&gt;dsize = nsegs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate a directory */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(hashp-&gt;dir))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L288" title="utils/hash/dynahash.c:288">CurrentDynaHashCxt</a> = hashp-&gt;hcxt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;dir = (<a href="#L134" title="utils/hash/dynahash.c:134">HASHSEGMENT</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;alloc(hctl-&gt;dsize * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L134" title="utils/hash/dynahash.c:134">HASHSEGMENT</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!hashp-&gt;dir)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate initial segments */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (segp = hashp-&gt;dir; hctl-&gt;nsegs &lt; nsegs; hctl-&gt;nsegs++, segp++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *segp = <a href="#L1644" title="utils/hash/dynahash.c:1644">seg_alloc</a>(hashp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*segp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Choose number of entries to allocate at a time */<br/></li>
<li></span>&nbsp; &nbsp; hctl-&gt;nelem_alloc = <a href="#L656" title="utils/hash/dynahash.c:656">choose_nelem_alloc</a>(hctl-&gt;entrysize);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HASH_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;<a href="#L689" title="utils/hash/dynahash.c:689">init_htab</a>:</span><span class="Special">\n%s%p\n%s%ld\n%s%ld\n%s%d\n%s%ld\n%s%u\n%s%x\n%s%x\n%s%ld\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;TABLE POINTER&nbsp;&nbsp; &quot;</span>, hashp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;DIRECTORY SIZE&nbsp; &quot;</span>, hctl-&gt;dsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;SEGMENT SIZE&nbsp; &nbsp; &quot;</span>, hctl-&gt;ssize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;SEGMENT SHIFT&nbsp;&nbsp; &quot;</span>, hctl-&gt;sshift,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;MAX BUCKET&nbsp; &nbsp; &nbsp; &quot;</span>, hctl-&gt;max_bucket,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;HIGH MASK&nbsp; &nbsp; &nbsp;&nbsp; &quot;</span>, hctl-&gt;high_mask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;LOW&nbsp; MASK&nbsp; &nbsp; &nbsp;&nbsp; &quot;</span>, hctl-&gt;low_mask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;NSEGS&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &quot;</span>, hctl-&gt;nsegs);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Estimate the space needed for a hashtable containing the given number<br/></li>
<li></span><span class="Comment"> * of entries of given size.<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: this is used to estimate the footprint of hashtables in shared<br/></li>
<li></span><span class="Comment"> * memory; therefore it does not count <a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> which is in local memory.<br/></li>
<li></span><span class="Comment"> * NB: assumes that all <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> structure parameters have default <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L783">&#x200c;</a><span class="linkable">hash_estimate_size</span>(<span class="Type">long</span> num_entries, Size entrysize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; nBuckets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nSegments,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nDirEntries,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nElementAllocs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elementSize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elementAllocCnt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* estimate number of buckets wanted */<br/></li>
<li></span>&nbsp; &nbsp; nBuckets = <a href="#L1769" title="utils/hash/dynahash.c:1769">next_pow2_long</a>(num_entries);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* # of segments needed for nBuckets */<br/></li>
<li></span>&nbsp; &nbsp; nSegments = <a href="#L1769" title="utils/hash/dynahash.c:1769">next_pow2_long</a>((nBuckets - <span class="Constant">1</span>) / <a href="#L123" title="utils/hash/dynahash.c:123">DEF_SEGSIZE</a> + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* directory entries */<br/></li>
<li></span>&nbsp; &nbsp; nDirEntries = <a href="#L125" title="utils/hash/dynahash.c:125">DEF_DIRSIZE</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (nDirEntries &lt; nSegments)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nDirEntries &lt;&lt;= <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dir_alloc doubles dsize at each call */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fixed control info */<br/></li>
<li></span>&nbsp; &nbsp; size = MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L168" title="utils/hash/dynahash.c:168">HASHHDR</a>));&nbsp; &nbsp; <span class="Comment">/* but not <a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a>, per above */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* directory */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(nDirEntries, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L134" title="utils/hash/dynahash.c:134">HASHSEGMENT</a>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* segments */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(nSegments,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAXALIGN(<a href="#L123" title="utils/hash/dynahash.c:123">DEF_SEGSIZE</a> * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L131" title="utils/hash/dynahash.c:131">HASHBUCKET</a>))));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* elements --- allocated in groups of <a href="#L656" title="utils/hash/dynahash.c:656">choose_nelem_alloc</a>() entries */<br/></li>
<li></span>&nbsp; &nbsp; elementAllocCnt = <a href="#L656" title="utils/hash/dynahash.c:656">choose_nelem_alloc</a>(entrysize);<br/></li>
<li>&nbsp; &nbsp; nElementAllocs = (num_entries - <span class="Constant">1</span>) / elementAllocCnt + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; elementSize = MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HASHELEMENT)) + MAXALIGN(entrysize);<br/></li>
<li>&nbsp; &nbsp; size = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(nElementAllocs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(elementAllocCnt, elementSize)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Select an appropriate directory size for a hashtable with the given<br/></li>
<li></span><span class="Comment"> * maximum number of entries.<br/></li>
<li></span><span class="Comment"> * This is only needed for hashtables in shared memory, whose directories<br/></li>
<li></span><span class="Comment"> * cannot be expanded dynamically.<br/></li>
<li></span><span class="Comment"> * NB: assumes that all <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> structure parameters have default <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> this had better agree with the behavior of <a href="#L689" title="utils/hash/dynahash.c:689">init_htab</a>()...<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">long<br/></li>
<li><a id="L830">&#x200c;</a></span><span class="linkable">hash_select_dirsize</span>(<span class="Type">long</span> num_entries)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; nBuckets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nSegments,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nDirEntries;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* estimate number of buckets wanted */<br/></li>
<li></span>&nbsp; &nbsp; nBuckets = <a href="#L1769" title="utils/hash/dynahash.c:1769">next_pow2_long</a>(num_entries);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* # of segments needed for nBuckets */<br/></li>
<li></span>&nbsp; &nbsp; nSegments = <a href="#L1769" title="utils/hash/dynahash.c:1769">next_pow2_long</a>((nBuckets - <span class="Constant">1</span>) / <a href="#L123" title="utils/hash/dynahash.c:123">DEF_SEGSIZE</a> + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* directory entries */<br/></li>
<li></span>&nbsp; &nbsp; nDirEntries = <a href="#L125" title="utils/hash/dynahash.c:125">DEF_DIRSIZE</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (nDirEntries &lt; nSegments)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nDirEntries &lt;&lt;= <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dir_alloc doubles dsize at each call */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nDirEntries;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the required initial memory allocation for a shared-memory<br/></li>
<li></span><span class="Comment"> * hashtable with the given parameters.&nbsp; We need space for the <a href="#L168" title="utils/hash/dynahash.c:168">HASHHDR</a><br/></li>
<li></span><span class="Comment"> * and for the (non expansible) directory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L854">&#x200c;</a><span class="linkable">hash_get_shared_size</span>(HASHCTL *info, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(flags &amp; HASH_DIRSIZE);<br/></li>
<li>&nbsp; &nbsp; Assert(info-&gt;dsize == info-&gt;max_dsize);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L168" title="utils/hash/dynahash.c:168">HASHHDR</a>) + info-&gt;dsize * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L134" title="utils/hash/dynahash.c:134">HASHSEGMENT</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/********************** DESTROY ROUTINES ************************/<br/></li>
<li></span><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L865">&#x200c;</a></span><span class="linkable">hash_destroy</span>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hashp != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocation method must be one we know how to free, too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(hashp-&gt;alloc == <a href="#L291" title="utils/hash/dynahash.c:291">DynaHashAlloc</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* so this hashtable must have its own context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(hashp-&gt;hcxt != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L884" title="utils/hash/dynahash.c:884">hash_stats</a>(<span class="Constant">&quot;destroy&quot;</span>, hashp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Free everything by destroying the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table's memory context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(hashp-&gt;hcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L884">&#x200c;</a></span><span class="linkable">hash_stats</span>(<span class="Type">const</span> <span class="Type">char</span> *where, <a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef HASH_STATISTICS<br/></li>
<li></span>&nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: this <a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> -- accesses </span><span class="Special">%ld</span><span class="Constant"> collisions </span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; where, hashp-&gt;hctl-&gt;accesses, hashp-&gt;hctl-&gt;collisions);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;<a href="#L884" title="utils/hash/dynahash.c:884">hash_stats</a>: entries </span><span class="Special">%ld</span><span class="Constant"> keysize </span><span class="Special">%ld</span><span class="Constant"> maxp </span><span class="Special">%u</span><span class="Constant"> segmentcount </span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1341" title="utils/hash/dynahash.c:1341">hash_get_num_entries</a>(hashp), (<span class="Type">long</span>) hashp-&gt;hctl-&gt;keysize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;hctl-&gt;max_bucket, hashp-&gt;hctl-&gt;nsegs);<br/></li>
<li>&nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: total accesses </span><span class="Special">%ld</span><span class="Constant"> total collisions </span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; where, <a href="#L258" title="utils/hash/dynahash.c:258">hash_accesses</a>, <a href="#L259" title="utils/hash/dynahash.c:259">hash_collisions</a>);<br/></li>
<li>&nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;<a href="#L884" title="utils/hash/dynahash.c:884">hash_stats</a>: total expansions </span><span class="Special">%ld\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L260" title="utils/hash/dynahash.c:260">hash_expansions</a>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*******************************SEARCH ROUTINES *****************************/<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L911" title="utils/hash/dynahash.c:911">get_hash_value</a> -- exported routine to calculate a key's <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We export this because for partitioned tables, callers need to compute<br/></li>
<li></span><span class="Comment"> * the partition number (from the low-order bits of the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value) <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * searching.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint32<br/></li>
<li><a id="L911">&#x200c;</a><span class="linkable">get_hash_value</span>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp, <span class="Type">const</span> <span class="Type">void</span> *keyPtr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> hashp-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>(keyPtr, hashp-&gt;keysize);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Convert a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value to a bucket number */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> uint32<br/></li>
<li><a id="L918">&#x200c;</a><span class="linkable">calc_bucket</span>(<a href="#L168" title="utils/hash/dynahash.c:168">HASHHDR</a> *hctl, uint32 hash_val)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; bucket;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bucket = hash_val &amp; hctl-&gt;high_mask;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bucket &gt; hctl-&gt;max_bucket)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bucket = bucket &amp; hctl-&gt;low_mask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> bucket;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L955" title="utils/hash/dynahash.c:955">hash_search</a> -- look up key in table and perform action<br/></li>
<li></span><span class="Comment"> * <a href="#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a> -- same, with key's <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value already computed<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * action is one of:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND: look up key in table<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER: look up key in table, creating entry if not present<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER_NULL: same, but return NULL if out of memory<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; HASH_REMOVE: look up key in table, remove entry if present<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value is a pointer to the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> found/entered/removed if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>,<br/></li>
<li></span><span class="Comment"> * or NULL if no match was found.&nbsp; (NB: in the case of the REMOVE action,<br/></li>
<li></span><span class="Comment"> * the result is a dangling pointer that shouldn't be dereferenced!)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * HASH_ENTER will normally ereport a generic &quot;out of memory&quot; error if<br/></li>
<li></span><span class="Comment"> * it is unable to create a new entry.&nbsp; The HASH_ENTER_NULL operation is<br/></li>
<li></span><span class="Comment"> * the same except it will return NULL if out of memory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If foundPtr isn't NULL, then *foundPtr is set true if we found an<br/></li>
<li></span><span class="Comment"> * existing entry in the table, false otherwise.&nbsp; This is needed in the<br/></li>
<li></span><span class="Comment"> * HASH_ENTER case, but is redundant with the return value otherwise.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For <a href="#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>, the hashvalue parameter must have been<br/></li>
<li></span><span class="Comment"> * calculated with <a href="#L911" title="utils/hash/dynahash.c:911">get_hash_value</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L955">&#x200c;</a><span class="linkable">hash_search</span>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">void</span> *keyPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASHACTION action,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *foundPtr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L968" title="utils/hash/dynahash.c:968">hash_search_with_hash_value</a>(hashp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; keyPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hashp-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>(keyPtr, hashp-&gt;keysize),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; action,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; foundPtr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void</span> *<br/></li>
<li><a id="L968">&#x200c;</a><span class="linkable">hash_search_with_hash_value</span>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">void</span> *keyPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 hashvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASHACTION action,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *foundPtr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="utils/hash/dynahash.c:168">HASHHDR</a>&nbsp; &nbsp; *hctl = hashp-&gt;hctl;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freelist_idx = <a href="#L212" title="utils/hash/dynahash.c:212">FREELIST_IDX</a>(hctl, hashvalue);<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; keysize;<br/></li>
<li>&nbsp; &nbsp; <a href="#L131" title="utils/hash/dynahash.c:131">HASHBUCKET</a>&nbsp; &nbsp; currBucket;<br/></li>
<li>&nbsp; &nbsp; <a href="#L131" title="utils/hash/dynahash.c:131">HASHBUCKET</a> *prevBucketPtr;<br/></li>
<li>&nbsp; &nbsp; HashCompareFunc match;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HASH_STATISTICS<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L258" title="utils/hash/dynahash.c:258">hash_accesses</a>++;<br/></li>
<li>&nbsp; &nbsp; hctl-&gt;accesses++;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If inserting, check if it is time to split a bucket.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: failure to expand table is not a fatal error, it just means we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have to run at higher fill factor than we wanted.&nbsp; However, if we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using the <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> allocator then it will throw error anyway on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * out-of-memory, so we must do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> modifying the table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (action == HASH_ENTER || action == HASH_ENTER_NULL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Can't split if running in partitioned mode, nor if frozen, nor if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * table is the subject of <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> active <a href="#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a> scans.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hctl-&gt;freeList[<span class="Constant">0</span>].nentries &gt; (<span class="Type">long</span>) hctl-&gt;max_bucket &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L210" title="utils/hash/dynahash.c:210">IS_PARTITIONED</a>(hctl) &amp;&amp; !hashp-&gt;frozen &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L1855" title="utils/hash/dynahash.c:1855">has_seq_scans</a>(hashp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1508" title="utils/hash/dynahash.c:1508">expand_table</a>(hashp);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do the initial lookup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1713" title="utils/hash/dynahash.c:1713">hash_initial_lookup</a>(hashp, hashvalue, &amp;prevBucketPtr);<br/></li>
<li>&nbsp; &nbsp; currBucket = *prevBucketPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Follow collision chain looking for matching key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; match = hashp-&gt;match;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* save one fetch in inner loop */<br/></li>
<li></span>&nbsp; &nbsp; keysize = hashp-&gt;keysize;&nbsp; &nbsp; <span class="Comment">/* ditto */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (currBucket != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (currBucket-&gt;hashvalue == hashvalue &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match(<a href="#L244" title="utils/hash/dynahash.c:244">ELEMENTKEY</a>(currBucket), keyPtr, keysize) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prevBucketPtr = &amp;(currBucket-&gt;link);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; currBucket = *prevBucketPtr;<br/></li>
<li><span class="PreProc">#ifdef HASH_STATISTICS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L259" title="utils/hash/dynahash.c:259">hash_collisions</a>++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hctl-&gt;collisions++;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (foundPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *foundPtr = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) (currBucket != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK, <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> what?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (action)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HASH_FIND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (currBucket != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">void</span> *) <a href="#L244" title="utils/hash/dynahash.c:244">ELEMENTKEY</a>(currBucket);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HASH_REMOVE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (currBucket != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if partitioned, must lock to touch nentries and freeList */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L210" title="utils/hash/dynahash.c:210">IS_PARTITIONED</a>(hctl))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;(hctl-&gt;freeList[freelist_idx].mutex));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* delete the record from the appropriate nentries counter. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(hctl-&gt;freeList[freelist_idx].nentries &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hctl-&gt;freeList[freelist_idx].nentries--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remove record from <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> bucket's chain. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *prevBucketPtr = currBucket-&gt;link;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* add the record to the appropriate freelist. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currBucket-&gt;link = hctl-&gt;freeList[freelist_idx].freeList;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hctl-&gt;freeList[freelist_idx].freeList = currBucket;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L210" title="utils/hash/dynahash.c:210">IS_PARTITIONED</a>(hctl))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;hctl-&gt;freeList[freelist_idx].mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * better hope the caller is synchronizing access to this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, because someone else is going to reuse it the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time something is added to the table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">void</span> *) <a href="#L244" title="utils/hash/dynahash.c:244">ELEMENTKEY</a>(currBucket);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HASH_ENTER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HASH_ENTER_NULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Return existing <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> if found, else create one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (currBucket != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">void</span> *) <a href="#L244" title="utils/hash/dynahash.c:244">ELEMENTKEY</a>(currBucket);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* disallow inserts if frozen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hashp-&gt;frozen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot insert into frozen hashtable </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hashp-&gt;tabname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currBucket = <a href="#L1256" title="utils/hash/dynahash.c:1256">get_hash_entry</a>(hashp, freelist_idx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (currBucket == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* out of memory */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (action == HASH_ENTER_NULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* report a generic message */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hashp-&gt;isshared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of shared memory&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* link into hashbucket chain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *prevBucketPtr = currBucket;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currBucket-&gt;link = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy key into record */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currBucket-&gt;hashvalue = hashvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;keycopy(<a href="#L244" title="utils/hash/dynahash.c:244">ELEMENTKEY</a>(currBucket), keyPtr, keysize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Caller is expected to fill the data field on return.&nbsp; DO NOT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * insert <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> code that could possibly throw error here, as doing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so would leave the table entry incomplete and hence corrupt the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caller's data structure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">void</span> *) <a href="#L244" title="utils/hash/dynahash.c:244">ELEMENTKEY</a>(currBucket);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> action code: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) action);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1145" title="utils/hash/dynahash.c:1145">hash_update_hash_key</a> -- change the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key of an existing table entry<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is equivalent to removing the entry, making a new entry, and copying<br/></li>
<li></span><span class="Comment"> * over its data, except that the entry never goes to the table's freelist.<br/></li>
<li></span><span class="Comment"> * Therefore this cannot suffer an out-of-memory failure, even if there are<br/></li>
<li></span><span class="Comment"> * other processes operating in other partitions of the hashtable.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if the requested new <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key is already<br/></li>
<li></span><span class="Comment"> * present.&nbsp; Throws error if the specified entry pointer isn't actually a<br/></li>
<li></span><span class="Comment"> * table member.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: currently, there is no special case for old and new <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> keys being<br/></li>
<li></span><span class="Comment"> * identical, which means we'll report false for that situation.&nbsp; This is<br/></li>
<li></span><span class="Comment"> * preferable for existing uses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: for a partitioned hashtable, caller must hold lock on both relevant<br/></li>
<li></span><span class="Comment"> * partitions, if the new <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key would belong to a different partition.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1145">&#x200c;</a></span><span class="linkable">hash_update_hash_key</span>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *existingEntry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">void</span> *newKeyPtr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASHELEMENT *existingElement = <a href="#L249" title="utils/hash/dynahash.c:249">ELEMENT_FROM_KEY</a>(existingEntry);<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; newhashvalue;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; keysize;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; bucket;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; newbucket;<br/></li>
<li>&nbsp; &nbsp; <a href="#L131" title="utils/hash/dynahash.c:131">HASHBUCKET</a>&nbsp; &nbsp; currBucket;<br/></li>
<li>&nbsp; &nbsp; <a href="#L131" title="utils/hash/dynahash.c:131">HASHBUCKET</a> *prevBucketPtr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L131" title="utils/hash/dynahash.c:131">HASHBUCKET</a> *oldPrevPtr;<br/></li>
<li>&nbsp; &nbsp; HashCompareFunc match;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HASH_STATISTICS<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L258" title="utils/hash/dynahash.c:258">hash_accesses</a>++;<br/></li>
<li>&nbsp; &nbsp; hctl-&gt;accesses++;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* disallow updates if frozen */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (hashp-&gt;frozen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot update in frozen hashtable </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hashp-&gt;tabname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lookup the existing <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> using its saved <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value.&nbsp; We need to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this to be able to unlink it from its <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> chain, but as a side benefit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we can verify the validity of the passed existingEntry pointer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bucket = <a href="#L1713" title="utils/hash/dynahash.c:1713">hash_initial_lookup</a>(hashp, existingElement-&gt;hashvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;prevBucketPtr);<br/></li>
<li>&nbsp; &nbsp; currBucket = *prevBucketPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (currBucket != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (currBucket == existingElement)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prevBucketPtr = &amp;(currBucket-&gt;link);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; currBucket = *prevBucketPtr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (currBucket == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L1145" title="utils/hash/dynahash.c:1145">hash_update_hash_key</a> argument is not in hashtable </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hashp-&gt;tabname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldPrevPtr = prevBucketPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now perform the equivalent of a HASH_ENTER operation to locate the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * chain we want to put the entry into.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newhashvalue = hashp-&gt;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>(newKeyPtr, hashp-&gt;keysize);<br/></li>
<li>&nbsp; &nbsp; newbucket = <a href="#L1713" title="utils/hash/dynahash.c:1713">hash_initial_lookup</a>(hashp, newhashvalue, &amp;prevBucketPtr);<br/></li>
<li>&nbsp; &nbsp; currBucket = *prevBucketPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Follow collision chain looking for matching key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; match = hashp-&gt;match;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* save one fetch in inner loop */<br/></li>
<li></span>&nbsp; &nbsp; keysize = hashp-&gt;keysize;&nbsp; &nbsp; <span class="Comment">/* ditto */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (currBucket != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (currBucket-&gt;hashvalue == newhashvalue &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match(<a href="#L244" title="utils/hash/dynahash.c:244">ELEMENTKEY</a>(currBucket), newKeyPtr, keysize) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prevBucketPtr = &amp;(currBucket-&gt;link);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; currBucket = *prevBucketPtr;<br/></li>
<li><span class="PreProc">#ifdef HASH_STATISTICS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L259" title="utils/hash/dynahash.c:259">hash_collisions</a>++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hctl-&gt;collisions++;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (currBucket != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* collision with an existing entry */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; currBucket = existingElement;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If old and new <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> belong to the same bucket, we need not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * change <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> chain links, and indeed should not since this simplistic<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * update will corrupt the list if currBucket is the last <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.&nbsp; (We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cannot fall out earlier, however, since we need to scan the bucket to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check for duplicate keys.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bucket != newbucket)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK to remove record from old <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> bucket's chain. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *oldPrevPtr = currBucket-&gt;link;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* link into new hashbucket chain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *prevBucketPtr = currBucket;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; currBucket-&gt;link = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy new key into record */<br/></li>
<li></span>&nbsp; &nbsp; currBucket-&gt;hashvalue = newhashvalue;<br/></li>
<li>&nbsp; &nbsp; hashp-&gt;keycopy(<a href="#L244" title="utils/hash/dynahash.c:244">ELEMENTKEY</a>(currBucket), newKeyPtr, keysize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* rest of record is untouched */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate a new hashtable entry if possible; return NULL if out of memory.<br/></li>
<li></span><span class="Comment"> * (Or, if the underlying space allocator throws error for out-of-memory,<br/></li>
<li></span><span class="Comment"> * we won't return at all.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L131" title="utils/hash/dynahash.c:131">HASHBUCKET</a><br/></li>
<li><a id="L1256">&#x200c;</a><span class="linkable">get_hash_entry</span>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp, <span class="Type">int</span> freelist_idx)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="utils/hash/dynahash.c:168">HASHHDR</a>&nbsp; &nbsp; *hctl = hashp-&gt;hctl;<br/></li>
<li>&nbsp; &nbsp; <a href="#L131" title="utils/hash/dynahash.c:131">HASHBUCKET</a>&nbsp; &nbsp; newElement;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if partitioned, must lock to touch nentries and freeList */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L210" title="utils/hash/dynahash.c:210">IS_PARTITIONED</a>(hctl))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;hctl-&gt;freeList[freelist_idx].mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* try to get an entry from the freelist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newElement = hctl-&gt;freeList[freelist_idx].freeList;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newElement != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L210" title="utils/hash/dynahash.c:210">IS_PARTITIONED</a>(hctl))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;hctl-&gt;freeList[freelist_idx].mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No free elements in this freelist.&nbsp; In a partitioned table, there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might be entries in other freelists, but to reduce contention we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prefer to first try to get another chunk of buckets from the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shmem allocator.&nbsp; If that fails, though, we *MUST* root through all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the other freelists <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> giving up.&nbsp; There are multiple callers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that assume that they can allocate every <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> in the initially<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * requested table size, or that deleting an <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> guarantees they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can insert a new <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, even if shared memory is entirely full.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Failing because the needed <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is in a different freelist is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not acceptable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1663" title="utils/hash/dynahash.c:1663">element_alloc</a>(hashp, hctl-&gt;nelem_alloc, freelist_idx))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; borrow_from_idx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L210" title="utils/hash/dynahash.c:210">IS_PARTITIONED</a>(hctl))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* out of memory */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* try to borrow <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> from another freelist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; borrow_from_idx = freelist_idx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; borrow_from_idx = (borrow_from_idx + <span class="Constant">1</span>) % <a href="#L128" title="utils/hash/dynahash.c:128">NUM_FREELISTS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (borrow_from_idx == freelist_idx)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* examined all freelists, fail */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;(hctl-&gt;freeList[borrow_from_idx].mutex));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newElement = hctl-&gt;freeList[borrow_from_idx].freeList;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newElement != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hctl-&gt;freeList[borrow_from_idx].freeList = newElement-&gt;link;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;(hctl-&gt;freeList[borrow_from_idx].mutex));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* careful: count the new <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> in its proper freelist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;hctl-&gt;freeList[freelist_idx].mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hctl-&gt;freeList[freelist_idx].nentries++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;hctl-&gt;freeList[freelist_idx].mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> newElement;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;(hctl-&gt;freeList[borrow_from_idx].mutex));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no elements available to borrow either, so out of memory */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remove entry from freelist, bump nentries */<br/></li>
<li></span>&nbsp; &nbsp; hctl-&gt;freeList[freelist_idx].freeList = newElement-&gt;link;<br/></li>
<li>&nbsp; &nbsp; hctl-&gt;freeList[freelist_idx].nentries++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L210" title="utils/hash/dynahash.c:210">IS_PARTITIONED</a>(hctl))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;hctl-&gt;freeList[freelist_idx].mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newElement;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1341" title="utils/hash/dynahash.c:1341">hash_get_num_entries</a> -- get the number of entries in a hashtable<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">long<br/></li>
<li><a id="L1341">&#x200c;</a></span><span class="linkable">hash_get_num_entries</span>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; sum = hashp-&gt;hctl-&gt;freeList[<span class="Constant">0</span>].nentries;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We currently don't bother with acquiring the mutexes; it's only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sensible to call this function if you've got lock on all partitions of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L210" title="utils/hash/dynahash.c:210">IS_PARTITIONED</a>(hashp-&gt;hctl))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; <a href="#L128" title="utils/hash/dynahash.c:128">NUM_FREELISTS</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sum += hashp-&gt;hctl-&gt;freeList[i].nentries;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> sum;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>/_search/_term<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sequentially search through <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table and return<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all the elements one by one, return NULL when no more.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L1471" title="utils/hash/dynahash.c:1471">hash_seq_term</a> should be called if and only if the scan is abandoned <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * completion; if <a href="#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a> returns NULL then it has already done the<br/></li>
<li></span><span class="Comment"> * end-of-scan <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: caller may delete the returned <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> continuing the scan.<br/></li>
<li></span><span class="Comment"> * However, deleting <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> while the scan is in progress is<br/></li>
<li></span><span class="Comment"> * UNDEFINED (it might be the one that curIndex is pointing at!).&nbsp; Also,<br/></li>
<li></span><span class="Comment"> * if elements are added to the table while the scan is in progress, it is<br/></li>
<li></span><span class="Comment"> * unspecified whether they will be visited by the scan or not.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: it is possible to use <a href="#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>/<a href="#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a> without <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * worry about <a href="#L1471" title="utils/hash/dynahash.c:1471">hash_seq_term</a> <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>, if the hashtable is first locked against<br/></li>
<li></span><span class="Comment"> * further insertions by calling <a href="#L1491" title="utils/hash/dynahash.c:1491">hash_freeze</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: to use this with a partitioned hashtable, caller had better hold<br/></li>
<li></span><span class="Comment"> * at least shared lock on all partitions of the table throughout the scan!<br/></li>
<li></span><span class="Comment"> * We can cope with insertions or deletions by our own backend, but *not*<br/></li>
<li></span><span class="Comment"> * with concurrent insertions or deletions by another.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1385">&#x200c;</a></span><span class="linkable">hash_seq_init</span>(HASH_SEQ_STATUS *status, <a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; status-&gt;hashp = hashp;<br/></li>
<li>&nbsp; &nbsp; status-&gt;curBucket = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; status-&gt;curEntry = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!hashp-&gt;frozen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1822" title="utils/hash/dynahash.c:1822">register_seq_scan</a>(hashp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void</span> *<br/></li>
<li><a id="L1395">&#x200c;</a><span class="linkable">hash_seq_search</span>(HASH_SEQ_STATUS *status)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *hashp;<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="utils/hash/dynahash.c:168">HASHHDR</a>&nbsp; &nbsp; *hctl;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; max_bucket;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; ssize;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; segment_num;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; segment_ndx;<br/></li>
<li>&nbsp; &nbsp; <a href="#L134" title="utils/hash/dynahash.c:134">HASHSEGMENT</a> segp;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; curBucket;<br/></li>
<li>&nbsp; &nbsp; HASHELEMENT *curElem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((curElem = status-&gt;curEntry) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Continuing scan of curBucket... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; status-&gt;curEntry = curElem-&gt;link;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (status-&gt;curEntry == <span class="Constant">NULL</span>)&nbsp; &nbsp; <span class="Comment">/* end of this bucket */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++status-&gt;curBucket;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">void</span> *) <a href="#L244" title="utils/hash/dynahash.c:244">ELEMENTKEY</a>(curElem);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Search for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> nonempty bucket starting at curBucket.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; curBucket = status-&gt;curBucket;<br/></li>
<li>&nbsp; &nbsp; hashp = status-&gt;hashp;<br/></li>
<li>&nbsp; &nbsp; hctl = hashp-&gt;hctl;<br/></li>
<li>&nbsp; &nbsp; ssize = hashp-&gt;ssize;<br/></li>
<li>&nbsp; &nbsp; max_bucket = hctl-&gt;max_bucket;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (curBucket &gt; max_bucket)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1471" title="utils/hash/dynahash.c:1471">hash_seq_term</a>(status);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* search is done */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the right segment in the table directory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; segment_num = curBucket &gt;&gt; hashp-&gt;sshift;<br/></li>
<li>&nbsp; &nbsp; segment_ndx = <a href="#L255" title="utils/hash/dynahash.c:255">MOD</a>(curBucket, ssize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; segp = hashp-&gt;dir[segment_num];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Pick up the first item in this bucket's chain.&nbsp; If chain is not empty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we can begin searching it.&nbsp; Otherwise we have to advance to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> nonempty bucket.&nbsp; We try to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> that case since searching a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * near-empty hashtable has to iterate this loop a lot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> ((curElem = segp[segment_ndx]) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* empty bucket, advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (++curBucket &gt; max_bucket)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status-&gt;curBucket = curBucket;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1471" title="utils/hash/dynahash.c:1471">hash_seq_term</a>(status);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* search is done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (++segment_ndx &gt;= ssize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment_num++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment_ndx = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segp = hashp-&gt;dir[segment_num];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Begin scan of curBucket... */<br/></li>
<li></span>&nbsp; &nbsp; status-&gt;curEntry = curElem-&gt;link;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (status-&gt;curEntry == <span class="Constant">NULL</span>)&nbsp; &nbsp; <span class="Comment">/* end of this bucket */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ++curBucket;<br/></li>
<li>&nbsp; &nbsp; status-&gt;curBucket = curBucket;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">void</span> *) <a href="#L244" title="utils/hash/dynahash.c:244">ELEMENTKEY</a>(curElem);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1471">&#x200c;</a></span><span class="linkable">hash_seq_term</span>(HASH_SEQ_STATUS *status)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!status-&gt;hashp-&gt;frozen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1834" title="utils/hash/dynahash.c:1834">deregister_seq_scan</a>(status-&gt;hashp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1491" title="utils/hash/dynahash.c:1491">hash_freeze</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Freeze a hashtable against future insertions (deletions are<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; still allowed)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The reason for doing this is that by preventing <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more bucket splits,<br/></li>
<li></span><span class="Comment"> * we no longer need to worry about registering <a href="#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a> scans,<br/></li>
<li></span><span class="Comment"> * and thus caller need not be careful about ensuring <a href="#L1471" title="utils/hash/dynahash.c:1471">hash_seq_term</a> gets<br/></li>
<li></span><span class="Comment"> * called at the right times.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Multiple calls to <a href="#L1491" title="utils/hash/dynahash.c:1491">hash_freeze</a>() are allowed, but you can't freeze a table<br/></li>
<li></span><span class="Comment"> * with active scans (since <a href="#L1471" title="utils/hash/dynahash.c:1471">hash_seq_term</a> would then do the wrong thing).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1491">&#x200c;</a></span><span class="linkable">hash_freeze</span>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hashp-&gt;isshared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot freeze shared hashtable </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, hashp-&gt;tabname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!hashp-&gt;frozen &amp;&amp; <a href="#L1855" title="utils/hash/dynahash.c:1855">has_seq_scans</a>(hashp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot freeze hashtable </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> because it has active scans&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hashp-&gt;tabname);<br/></li>
<li>&nbsp; &nbsp; hashp-&gt;frozen = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/********************************* UTILITIES ************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Expand the table by adding one more <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> bucket.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1508">&#x200c;</a></span><span class="linkable">expand_table</span>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="utils/hash/dynahash.c:168">HASHHDR</a>&nbsp; &nbsp; *hctl = hashp-&gt;hctl;<br/></li>
<li>&nbsp; &nbsp; <a href="#L134" title="utils/hash/dynahash.c:134">HASHSEGMENT</a> old_seg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_seg;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; old_bucket,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_bucket;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; new_segnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_segndx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; old_segnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_segndx;<br/></li>
<li>&nbsp; &nbsp; <a href="#L131" title="utils/hash/dynahash.c:131">HASHBUCKET</a> *oldlink,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *newlink;<br/></li>
<li>&nbsp; &nbsp; <a href="#L131" title="utils/hash/dynahash.c:131">HASHBUCKET</a>&nbsp; &nbsp; currElement,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextElement;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L210" title="utils/hash/dynahash.c:210">IS_PARTITIONED</a>(hctl));<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HASH_STATISTICS<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L260" title="utils/hash/dynahash.c:260">hash_expansions</a>++;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; new_bucket = hctl-&gt;max_bucket + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; new_segnum = new_bucket &gt;&gt; hashp-&gt;sshift;<br/></li>
<li>&nbsp; &nbsp; new_segndx = <a href="#L255" title="utils/hash/dynahash.c:255">MOD</a>(new_bucket, hashp-&gt;ssize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (new_segnum &gt;= hctl-&gt;nsegs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allocate new segment if necessary -- could fail if dir full */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_segnum &gt;= hctl-&gt;dsize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1605" title="utils/hash/dynahash.c:1605">dir_realloc</a>(hashp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(hashp-&gt;dir[new_segnum] = <a href="#L1644" title="utils/hash/dynahash.c:1644">seg_alloc</a>(hashp)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hctl-&gt;nsegs++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, we created a new bucket */<br/></li>
<li></span>&nbsp; &nbsp; hctl-&gt;max_bucket++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * *Before* changing masks, <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> old bucket corresponding to same <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in that bucket may need to be relocated to new bucket.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that new_bucket is certainly larger than low_mask at this point,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the first step of the regular <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> mask calc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; old_bucket = (new_bucket &amp; hctl-&gt;low_mask);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we crossed a power of 2, readjust masks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((uint32) new_bucket &gt; hctl-&gt;high_mask)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hctl-&gt;low_mask = hctl-&gt;high_mask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hctl-&gt;high_mask = (uint32) new_bucket | hctl-&gt;low_mask;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Relocate <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> to the new bucket.&nbsp; <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: because of the way the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * masking is done in <a href="#L918" title="utils/hash/dynahash.c:918">calc_bucket</a>, only one old bucket can need to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * split at this point.&nbsp; With a different way of reducing the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that might not be true!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; old_segnum = old_bucket &gt;&gt; hashp-&gt;sshift;<br/></li>
<li>&nbsp; &nbsp; old_segndx = <a href="#L255" title="utils/hash/dynahash.c:255">MOD</a>(old_bucket, hashp-&gt;ssize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; old_seg = hashp-&gt;dir[old_segnum];<br/></li>
<li>&nbsp; &nbsp; new_seg = hashp-&gt;dir[new_segnum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldlink = &amp;old_seg[old_segndx];<br/></li>
<li>&nbsp; &nbsp; newlink = &amp;new_seg[new_segndx];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (currElement = *oldlink;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; currElement != <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; currElement = nextElement)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nextElement = currElement-&gt;link;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((<span class="Type">long</span>) <a href="#L918" title="utils/hash/dynahash.c:918">calc_bucket</a>(hctl, currElement-&gt;hashvalue) == old_bucket)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *oldlink = currElement;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldlink = &amp;currElement-&gt;link;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *newlink = currElement;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newlink = &amp;currElement-&gt;link;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't forget to terminate the rebuilt <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> chains... */<br/></li>
<li></span>&nbsp; &nbsp; *oldlink = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; *newlink = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1605">&#x200c;</a></span><span class="linkable">dir_realloc</span>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L134" title="utils/hash/dynahash.c:134">HASHSEGMENT</a> *p;<br/></li>
<li>&nbsp; &nbsp; <a href="#L134" title="utils/hash/dynahash.c:134">HASHSEGMENT</a> *old_p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; new_dsize;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; old_dirsize;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; new_dirsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hashp-&gt;hctl-&gt;max_dsize != NO_MAX_DSIZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reallocate directory */<br/></li>
<li></span>&nbsp; &nbsp; new_dsize = hashp-&gt;hctl-&gt;dsize &lt;&lt; <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; old_dirsize = hashp-&gt;hctl-&gt;dsize * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L134" title="utils/hash/dynahash.c:134">HASHSEGMENT</a>);<br/></li>
<li>&nbsp; &nbsp; new_dirsize = new_dsize * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L134" title="utils/hash/dynahash.c:134">HASHSEGMENT</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; old_p = hashp-&gt;dir;<br/></li>
<li>&nbsp; &nbsp; <a href="#L288" title="utils/hash/dynahash.c:288">CurrentDynaHashCxt</a> = hashp-&gt;hcxt;<br/></li>
<li>&nbsp; &nbsp; p = (<a href="#L134" title="utils/hash/dynahash.c:134">HASHSEGMENT</a> *) hashp-&gt;alloc((Size) new_dirsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (p != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(p, old_p, old_dirsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(((<span class="Type">char</span> *) p) + old_dirsize, <span class="Constant">0</span>, new_dirsize - old_dirsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;dir = p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashp-&gt;hctl-&gt;dsize = new_dsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> assume the allocator is <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>, so we know how to free */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(hashp-&gt;alloc == <a href="#L291" title="utils/hash/dynahash.c:291">DynaHashAlloc</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(old_p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L134" title="utils/hash/dynahash.c:134">HASHSEGMENT</a><br/></li>
<li><a id="L1644">&#x200c;</a><span class="linkable">seg_alloc</span>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L134" title="utils/hash/dynahash.c:134">HASHSEGMENT</a> segp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L288" title="utils/hash/dynahash.c:288">CurrentDynaHashCxt</a> = hashp-&gt;hcxt;<br/></li>
<li>&nbsp; &nbsp; segp = (<a href="#L134" title="utils/hash/dynahash.c:134">HASHSEGMENT</a>) hashp-&gt;alloc(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L131" title="utils/hash/dynahash.c:131">HASHBUCKET</a>) * hashp-&gt;ssize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!segp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemSet(segp, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L131" title="utils/hash/dynahash.c:131">HASHBUCKET</a>) * hashp-&gt;ssize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> segp;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * allocate some new elements and link them into the indicated free list<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1663">&#x200c;</a></span><span class="linkable">element_alloc</span>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp, <span class="Type">int</span> nelem, <span class="Type">int</span> freelist_idx)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="utils/hash/dynahash.c:168">HASHHDR</a>&nbsp; &nbsp; *hctl = hashp-&gt;hctl;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; elementSize;<br/></li>
<li>&nbsp; &nbsp; HASHELEMENT *firstElement;<br/></li>
<li>&nbsp; &nbsp; HASHELEMENT *tmpElement;<br/></li>
<li>&nbsp; &nbsp; HASHELEMENT *prevElement;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hashp-&gt;isfixed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Each <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> has a HASHELEMENT header plus user data. */<br/></li>
<li></span>&nbsp; &nbsp; elementSize = MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HASHELEMENT)) + MAXALIGN(hctl-&gt;entrysize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L288" title="utils/hash/dynahash.c:288">CurrentDynaHashCxt</a> = hashp-&gt;hcxt;<br/></li>
<li>&nbsp; &nbsp; firstElement = (HASHELEMENT *) hashp-&gt;alloc(nelem * elementSize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!firstElement)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prepare to link all the new entries into the freelist */<br/></li>
<li></span>&nbsp; &nbsp; prevElement = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; tmpElement = firstElement;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nelem; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmpElement-&gt;link = prevElement;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prevElement = tmpElement;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmpElement = (HASHELEMENT *) (((<span class="Type">char</span> *) tmpElement) + elementSize);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if partitioned, must lock to touch freeList */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L210" title="utils/hash/dynahash.c:210">IS_PARTITIONED</a>(hctl))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;hctl-&gt;freeList[freelist_idx].mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* freelist could be nonempty if two backends did this concurrently */<br/></li>
<li></span>&nbsp; &nbsp; firstElement-&gt;link = hctl-&gt;freeList[freelist_idx].freeList;<br/></li>
<li>&nbsp; &nbsp; hctl-&gt;freeList[freelist_idx].freeList = prevElement;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L210" title="utils/hash/dynahash.c:210">IS_PARTITIONED</a>(hctl))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;hctl-&gt;freeList[freelist_idx].mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Do initial lookup of a bucket for the given <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value, retrieving its<br/></li>
<li></span><span class="Comment"> * bucket number and its <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> bucket.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> uint32<br/></li>
<li><a id="L1713">&#x200c;</a><span class="linkable">hash_initial_lookup</span>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp, uint32 hashvalue, <a href="#L131" title="utils/hash/dynahash.c:131">HASHBUCKET</a> **bucketptr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="utils/hash/dynahash.c:168">HASHHDR</a>&nbsp; &nbsp; *hctl = hashp-&gt;hctl;<br/></li>
<li>&nbsp; &nbsp; <a href="#L134" title="utils/hash/dynahash.c:134">HASHSEGMENT</a> segp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; segment_num;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; segment_ndx;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; bucket;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bucket = <a href="#L918" title="utils/hash/dynahash.c:918">calc_bucket</a>(hctl, hashvalue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; segment_num = bucket &gt;&gt; hashp-&gt;sshift;<br/></li>
<li>&nbsp; &nbsp; segment_ndx = <a href="#L255" title="utils/hash/dynahash.c:255">MOD</a>(bucket, hashp-&gt;ssize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; segp = hashp-&gt;dir[segment_num];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (segp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1737" title="utils/hash/dynahash.c:1737">hash_corrupted</a>(hashp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *bucketptr = &amp;segp[segment_ndx];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> bucket;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* complain when we have detected a corrupted hashtable */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1737">&#x200c;</a></span><span class="linkable">hash_corrupted</span>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the corruption is in a shared hashtable, we'd better force a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * systemwide restart.&nbsp; Otherwise, just shut down this one backend.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (hashp-&gt;isshared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> corrupted&quot;</span>, hashp-&gt;tabname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> corrupted&quot;</span>, hashp-&gt;tabname);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* calculate ceil(log base 2) of num */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1751">&#x200c;</a></span><span class="linkable">my_log2</span>(<span class="Type">long</span> num)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * guard against too-large input, which would be invalid for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_ceil_log2_*()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (num &gt; <span class="Constant">LONG_MAX</span> / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; num = <span class="Constant">LONG_MAX</span> / <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#if SIZEOF_LONG &lt; </span><span class="Constant">8<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> pg_ceil_log2_32(num);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> pg_ceil_log2_64(num);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* calculate first power of 2 &gt;= num, bounded to what will fit in a long */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">long<br/></li>
<li><a id="L1769">&#x200c;</a></span><span class="linkable">next_pow2_long</span>(<span class="Type">long</span> num)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L1751" title="utils/hash/dynahash.c:1751">my_log2</a>'s <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> check is sufficient */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1L</span> &lt;&lt; <a href="#L1751" title="utils/hash/dynahash.c:1751">my_log2</a>(num);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* calculate first power of 2 &gt;= num, bounded to what will fit in an int */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1777">&#x200c;</a></span><span class="linkable">next_pow2_int</span>(<span class="Type">long</span> num)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (num &gt; <span class="Constant">INT_MAX</span> / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; num = <span class="Constant">INT_MAX</span> / <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span> &lt;&lt; <a href="#L1751" title="utils/hash/dynahash.c:1751">my_log2</a>(num);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/************************* SEQ SCAN TRACKING ************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We track active <a href="#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a> scans here.&nbsp; The need for this mechanism<br/></li>
<li></span><span class="Comment"> * comes from the fact that a scan will get confused if a bucket split occurs<br/></li>
<li></span><span class="Comment"> * while it's in progress: it might visit entries twice, or even <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> some<br/></li>
<li></span><span class="Comment"> * entirely (if it's partway through the same bucket that splits).&nbsp; Hence<br/></li>
<li></span><span class="Comment"> * we want to inhibit bucket splits if there are <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> active scans on the<br/></li>
<li></span><span class="Comment"> * table being inserted into.&nbsp; This is a fairly rare case in current usage,<br/></li>
<li></span><span class="Comment"> * so just postponing the split until the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> insertion seems sufficient.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given present usages of the function, only a few scans are likely to be<br/></li>
<li></span><span class="Comment"> * open concurrently; so a finite-size stack of open scans seems sufficient,<br/></li>
<li></span><span class="Comment"> * and we don't worry that linear search is too slow.&nbsp; Note that we do<br/></li>
<li></span><span class="Comment"> * allow multiple scans of the same hashtable to be open concurrently.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This mechanism can support concurrent scan and insertion in a shared<br/></li>
<li></span><span class="Comment"> * hashtable if it's the same backend doing both.&nbsp; It would fail otherwise,<br/></li>
<li></span><span class="Comment"> * but locking reasons seem to preclude <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such scenario anyway, so we don't<br/></li>
<li></span><span class="Comment"> * worry.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This arrangement is reasonably robust if a transient hashtable is deleted<br/></li>
<li></span><span class="Comment"> * without notifying us.&nbsp; The absolute worst case is we might inhibit splits<br/></li>
<li></span><span class="Comment"> * in another table created later at exactly the same address.&nbsp; We will give<br/></li>
<li></span><span class="Comment"> * a warning at transaction end for reference leaks, so <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> bugs leading to<br/></li>
<li></span><span class="Comment"> * lack of notification should be easy to catch.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L1813">&#x200c;</a><span class="PreProc">#define <span class="linkable">MAX_SEQ_SCANS</span> </span><span class="Constant">100<br/></li>
<li></span><br/></li>
<li><a id="L1815">&#x200c;</a><span class="Type">static</span> <a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">seq_scan_tables</span>[<a href="#L1813" title="utils/hash/dynahash.c:1813">MAX_SEQ_SCANS</a>];&nbsp; &nbsp; <span class="Comment">/* tables being scanned */<br/></li>
<li><a id="L1816">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">seq_scan_level</span>[<a href="#L1813" title="utils/hash/dynahash.c:1813">MAX_SEQ_SCANS</a>];&nbsp; &nbsp; <span class="Comment">/* subtransaction nest level */<br/></li>
<li><a id="L1817">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">num_seq_scans</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* Register a table as having an active <a href="#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a> scan */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1822">&#x200c;</a></span><span class="linkable">register_seq_scan</span>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1817" title="utils/hash/dynahash.c:1817">num_seq_scans</a> &gt;= <a href="#L1813" title="utils/hash/dynahash.c:1813">MAX_SEQ_SCANS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;too many active <a href="#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a> scans, cannot start one on </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hashp-&gt;tabname);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1815" title="utils/hash/dynahash.c:1815">seq_scan_tables</a>[<a href="#L1817" title="utils/hash/dynahash.c:1817">num_seq_scans</a>] = hashp;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1816" title="utils/hash/dynahash.c:1816">seq_scan_level</a>[<a href="#L1817" title="utils/hash/dynahash.c:1817">num_seq_scans</a>] = <a href="../../access/transam/xact.c.html#L926" title="access/transam/xact.c:926">GetCurrentTransactionNestLevel</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L1817" title="utils/hash/dynahash.c:1817">num_seq_scans</a>++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Deregister an active scan */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1834">&#x200c;</a></span><span class="linkable">deregister_seq_scan</span>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Search backward since it's most likely at the stack top */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <a href="#L1817" title="utils/hash/dynahash.c:1817">num_seq_scans</a> - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1815" title="utils/hash/dynahash.c:1815">seq_scan_tables</a>[i] == hashp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1815" title="utils/hash/dynahash.c:1815">seq_scan_tables</a>[i] = <a href="#L1815" title="utils/hash/dynahash.c:1815">seq_scan_tables</a>[<a href="#L1817" title="utils/hash/dynahash.c:1817">num_seq_scans</a> - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1816" title="utils/hash/dynahash.c:1816">seq_scan_level</a>[i] = <a href="#L1816" title="utils/hash/dynahash.c:1816">seq_scan_level</a>[<a href="#L1817" title="utils/hash/dynahash.c:1817">num_seq_scans</a> - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1817" title="utils/hash/dynahash.c:1817">num_seq_scans</a>--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no <a href="#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a> scan for <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hashp-&gt;tabname);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Check if a table has <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> active scan */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1855">&#x200c;</a></span><span class="linkable">has_seq_scans</span>(<a href="#L219" title="utils/hash/dynahash.c:219">HTAB</a> *hashp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L1817" title="utils/hash/dynahash.c:1817">num_seq_scans</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1815" title="utils/hash/dynahash.c:1815">seq_scan_tables</a>[i] == hashp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Clean up <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> open scans at end of transaction */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1869">&#x200c;</a></span><span class="linkable">AtEOXact_HashTables</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During abort <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>, open scans are expected; just silently clean 'em<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * out.&nbsp; An open scan at commit means someone forgot a <a href="#L1471" title="utils/hash/dynahash.c:1471">hash_seq_term</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * call, so complain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: it's tempting to try to <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> the tabname here, but refrain for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fear of touching deallocated memory.&nbsp; This isn't a user-facing message<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anyway, so it needn't be pretty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isCommit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L1817" title="utils/hash/dynahash.c:1817">num_seq_scans</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;leaked <a href="#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a> scan for <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1815" title="utils/hash/dynahash.c:1815">seq_scan_tables</a>[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L1817" title="utils/hash/dynahash.c:1817">num_seq_scans</a> = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Clean up <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> open scans at end of subtransaction */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1895">&#x200c;</a></span><span class="linkable">AtEOSubXact_HashTables</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit, <span class="Type">int</span> nestDepth)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Search backward to make <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> easy.&nbsp; Note we must check all entries,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not only those at the end of the array, because deletion technique<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't keep them in order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <a href="#L1817" title="utils/hash/dynahash.c:1817">num_seq_scans</a> - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1816" title="utils/hash/dynahash.c:1816">seq_scan_level</a>[i] &gt;= nestDepth)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isCommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;leaked <a href="#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a> scan for <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1815" title="utils/hash/dynahash.c:1815">seq_scan_tables</a>[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1815" title="utils/hash/dynahash.c:1815">seq_scan_tables</a>[i] = <a href="#L1815" title="utils/hash/dynahash.c:1815">seq_scan_tables</a>[<a href="#L1817" title="utils/hash/dynahash.c:1817">num_seq_scans</a> - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1816" title="utils/hash/dynahash.c:1816">seq_scan_level</a>[i] = <a href="#L1816" title="utils/hash/dynahash.c:1816">seq_scan_level</a>[<a href="#L1817" title="utils/hash/dynahash.c:1817">num_seq_scans</a> - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1817" title="utils/hash/dynahash.c:1817">num_seq_scans</a>--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
