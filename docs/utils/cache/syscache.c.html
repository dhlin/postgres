<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/cache/syscache.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/cache/syscache.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L85">CacheInitialized</a></li>
<li><a href="#L83">SysCache</a></li>
<li><a href="#L88">SysCacheRelationOid</a></li>
<li><a href="#L89">SysCacheRelationOidSize</a></li>
<li><a href="#L80">SysCacheSize</a></li>
<li><a href="#L92">SysCacheSupportingRelOid</a></li>
<li><a href="#L93">SysCacheSupportingRelOidSize</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L66">cachedesc</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L540">GetSysCacheHashValue</a></li>
<li><a href="#L327">GetSysCacheOid</a></li>
<li><a href="#L107">InitCatalogCache</a></li>
<li><a href="#L177">InitCatalogCachePhase2</a></li>
<li><a href="#L624">RelationHasSysCache</a></li>
<li><a href="#L601">RelationInvalidatesSnapshotsOnly</a></li>
<li><a href="#L649">RelationSupportsSysCache</a></li>
<li><a href="#L266">ReleaseSysCache</a></li>
<li><a href="#L205">SearchSysCache</a></li>
<li><a href="#L218">SearchSysCache1</a></li>
<li><a href="#L229">SearchSysCache2</a></li>
<li><a href="#L240">SearchSysCache3</a></li>
<li><a href="#L251">SearchSysCache4</a></li>
<li><a href="#L359">SearchSysCacheAttName</a></li>
<li><a href="#L422">SearchSysCacheAttNum</a></li>
<li><a href="#L280">SearchSysCacheCopy</a></li>
<li><a href="#L382">SearchSysCacheCopyAttName</a></li>
<li><a href="#L445">SearchSysCacheCopyAttNum</a></li>
<li><a href="#L304">SearchSysCacheExists</a></li>
<li><a href="#L401">SearchSysCacheExistsAttName</a></li>
<li><a href="#L557">SearchSysCacheList</a></li>
<li><a href="#L479">SysCacheGetAttr</a></li>
<li><a href="#L510">SysCacheGetAttrNotNull</a></li>
<li><a href="#L577">SysCacheInvalidate</a></li>
<li><a href="#L674">oid_compare</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L76">KEY</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * syscache.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; System cache management routines<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/cache/syscache.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; These routines allow the parser/<a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>/executor to perform<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; rapid lookups on the contents of the system catalogs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; see utils/syscache.h for a list of the cache IDs<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_db_role_setting_d.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_depend_d.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_description_d.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_seclabel_d.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_shdepend_d.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_shdescription_d.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_shseclabel_d.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/int.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/qunique.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/catcache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*---------------------------------------------------------------------------<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Adding system caches:<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; There must be a unique index underlying each syscache (ie, an index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; whose key is the same as that of the cache).&nbsp; If there is not one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; already, add the definition for it to include/catalog/pg_*.h using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; DECLARE_UNIQUE_INDEX.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; (Adding an index requires a catversion.h update, while simply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; adding/deleting caches only requires a recompile.)<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Add a MAKE_SYSCACHE call to the same pg_*.h file specifying the name of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; your cache, the underlying index, and the initial number of <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> buckets.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; The number of <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> buckets must be a power of 2.&nbsp; It's reasonable to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; set this to the number of entries that might be in the particular cache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; in a medium-size database.<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; Finally, <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> place your relation gets <a href="../../access/heap/heapam.c.html#L1990" title="access/heap/heapam.c:1990">heap_insert</a>() or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="../../access/heap/heapam.c.html#L3146" title="access/heap/heapam.c:3146">heap_update</a>() calls, use <a href="../../catalog/indexing.c.html#L233" title="catalog/indexing.c:233">CatalogTupleInsert</a>() or <a href="../../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; instead, which also update indexes.&nbsp; The heap_* calls do not do that.<br/></li>
<li></span><br/></li>
<li><span class="Comment">*---------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; struct <a href="#L66" title="utils/cache/syscache.c:66">cachedesc</a>: information defining a single syscache<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L66">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">cachedesc</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reloid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OID of the relation being cached */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indoid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OID of index relation for this cache */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nkeys;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* # of keys needed for cache lookup */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key[<span class="Constant">4</span>];&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* attribute numbers of key attrs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbuckets;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> buckets for this cache */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Macro to provide nkeys and key array with convenient syntax. */<br/></li>
<li><a id="L76">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">KEY</span>(...) VA_ARGS_NARGS(</span><span class="Constant">__VA_ARGS__</span><span class="PreProc">), { </span><span class="Constant">__VA_ARGS__</span><span class="PreProc"> }<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;catalog/syscache_info.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L80">&#x200c;</a>StaticAssertDecl(lengthof(cacheinfo) == <span class="linkable">SysCacheSize</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="#L80" title="utils/cache/syscache.c:80">SysCacheSize</a> does not match syscache.c's array&quot;</span>);<br/></li>
<li><br/></li>
<li><a id="L83">&#x200c;</a><span class="Type">static</span> CatCache *<span class="linkable">SysCache</span>[<a href="#L80" title="utils/cache/syscache.c:80">SysCacheSize</a>];<br/></li>
<li><br/></li>
<li><a id="L85">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">CacheInitialized</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Sorted array of OIDs of tables that have caches on them */<br/></li>
<li><a id="L88">&#x200c;</a></span><span class="Type">static</span> Oid&nbsp; &nbsp; <span class="linkable">SysCacheRelationOid</span>[<a href="#L80" title="utils/cache/syscache.c:80">SysCacheSize</a>];<br/></li>
<li><a id="L89">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">SysCacheRelationOidSize</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Sorted array of OIDs of tables and indexes used by caches */<br/></li>
<li><a id="L92">&#x200c;</a></span><span class="Type">static</span> Oid&nbsp; &nbsp; <span class="linkable">SysCacheSupportingRelOid</span>[<a href="#L80" title="utils/cache/syscache.c:80">SysCacheSize</a> * <span class="Constant">2</span>];<br/></li>
<li><a id="L93">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">SysCacheSupportingRelOidSize</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L674" title="utils/cache/syscache.c:674">oid_compare</a>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L107" title="utils/cache/syscache.c:107">InitCatalogCache</a> - <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the caches<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that no database access is done here; we only allocate memory<br/></li>
<li></span><span class="Comment"> * and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the cache structure.&nbsp; Interrogation of the database<br/></li>
<li></span><span class="Comment"> * to complete initialization of a cache happens upon first use<br/></li>
<li></span><span class="Comment"> * of that cache.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L107">&#x200c;</a></span><span class="linkable">InitCatalogCache</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cacheId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L85" title="utils/cache/syscache.c:85">CacheInitialized</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L89" title="utils/cache/syscache.c:89">SysCacheRelationOidSize</a> = <a href="#L93" title="utils/cache/syscache.c:93">SysCacheSupportingRelOidSize</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (cacheId = <span class="Constant">0</span>; cacheId &lt; <a href="#L80" title="utils/cache/syscache.c:80">SysCacheSize</a>; cacheId++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Assert that every enumeration value defined in syscache.h has been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * populated in the cacheinfo array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(cacheinfo[cacheId].reloid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(cacheinfo[cacheId].indoid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* .nbuckets and .key[] are checked by <a href="catcache.c.html#L827" title="utils/cache/catcache.c:827">InitCatCache</a>() */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId] = <a href="catcache.c.html#L827" title="utils/cache/catcache.c:827">InitCatCache</a>(cacheId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cacheinfo[cacheId].reloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cacheinfo[cacheId].indoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cacheinfo[cacheId].nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cacheinfo[cacheId].key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cacheinfo[cacheId].nbuckets);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!PointerIsValid(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> cache </span><span class="Special">%u</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cacheinfo[cacheId].reloid, cacheId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Accumulate data for OID lists, too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="utils/cache/syscache.c:88">SysCacheRelationOid</a>[<a href="#L89" title="utils/cache/syscache.c:89">SysCacheRelationOidSize</a>++] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cacheinfo[cacheId].reloid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L92" title="utils/cache/syscache.c:92">SysCacheSupportingRelOid</a>[<a href="#L93" title="utils/cache/syscache.c:93">SysCacheSupportingRelOidSize</a>++] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cacheinfo[cacheId].reloid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L92" title="utils/cache/syscache.c:92">SysCacheSupportingRelOid</a>[<a href="#L93" title="utils/cache/syscache.c:93">SysCacheSupportingRelOidSize</a>++] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cacheinfo[cacheId].indoid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see comments for <a href="#L601" title="utils/cache/syscache.c:601">RelationInvalidatesSnapshotsOnly</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="#L601" title="utils/cache/syscache.c:601">RelationInvalidatesSnapshotsOnly</a>(cacheinfo[cacheId].reloid));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L89" title="utils/cache/syscache.c:89">SysCacheRelationOidSize</a> &lt;= lengthof(<a href="#L88" title="utils/cache/syscache.c:88">SysCacheRelationOid</a>));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L93" title="utils/cache/syscache.c:93">SysCacheSupportingRelOidSize</a> &lt;= lengthof(<a href="#L92" title="utils/cache/syscache.c:92">SysCacheSupportingRelOid</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort and de-dup OID arrays, so we can use binary search. */<br/></li>
<li></span>&nbsp; &nbsp; qsort(<a href="#L88" title="utils/cache/syscache.c:88">SysCacheRelationOid</a>, <a href="#L89" title="utils/cache/syscache.c:89">SysCacheRelationOidSize</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid), <a href="#L674" title="utils/cache/syscache.c:674">oid_compare</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L89" title="utils/cache/syscache.c:89">SysCacheRelationOidSize</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qunique(<a href="#L88" title="utils/cache/syscache.c:88">SysCacheRelationOid</a>, <a href="#L89" title="utils/cache/syscache.c:89">SysCacheRelationOidSize</a>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L674" title="utils/cache/syscache.c:674">oid_compare</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qsort(<a href="#L92" title="utils/cache/syscache.c:92">SysCacheSupportingRelOid</a>, <a href="#L93" title="utils/cache/syscache.c:93">SysCacheSupportingRelOidSize</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid), <a href="#L674" title="utils/cache/syscache.c:674">oid_compare</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L93" title="utils/cache/syscache.c:93">SysCacheSupportingRelOidSize</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qunique(<a href="#L92" title="utils/cache/syscache.c:92">SysCacheSupportingRelOid</a>, <a href="#L93" title="utils/cache/syscache.c:93">SysCacheSupportingRelOidSize</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid), <a href="#L674" title="utils/cache/syscache.c:674">oid_compare</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L85" title="utils/cache/syscache.c:85">CacheInitialized</a> = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L177" title="utils/cache/syscache.c:177">InitCatalogCachePhase2</a> - finish initializing the caches<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Finish initializing all the caches, including necessary database<br/></li>
<li></span><span class="Comment"> * access.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is *not* essential; normally we allow syscaches to be initialized<br/></li>
<li></span><span class="Comment"> * on first use.&nbsp; However, it is useful as a mechanism to preload the<br/></li>
<li></span><span class="Comment"> * relcache with entries for the most-commonly-used system catalogs.<br/></li>
<li></span><span class="Comment"> * Therefore, we invoke this routine when we need to write a new relcache<br/></li>
<li></span><span class="Comment"> * init file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L177">&#x200c;</a></span><span class="linkable">InitCatalogCachePhase2</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cacheId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L85" title="utils/cache/syscache.c:85">CacheInitialized</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (cacheId = <span class="Constant">0</span>; cacheId &lt; <a href="#L80" title="utils/cache/syscache.c:80">SysCacheSize</a>; cacheId++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="catcache.c.html#L1144" title="utils/cache/catcache.c:1144">InitCatCachePhase2</a>(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId], <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L205" title="utils/cache/syscache.c:205">SearchSysCache</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; A layer on top of <a href="catcache.c.html#L1261" title="utils/cache/catcache.c:1261">SearchCatCache</a> that does the initialization and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; key-setting for you.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Returns the cache copy of the tuple if one is found, NULL if not.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The tuple is the 'cache' copy and must NOT be modified!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; When the caller is done using the tuple, call <a href="#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; to release the reference count grabbed by <a href="#L205" title="utils/cache/syscache.c:205">SearchSysCache</a>().&nbsp; If this<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; is not done, the tuple will remain locked in cache until end of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; transaction, which is tolerable but not desirable.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; CAUTION: The tuple that is returned must NOT be freed by the caller!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>HeapTuple<br/></li>
<li><a id="L205">&#x200c;</a><span class="linkable">SearchSysCache</span>(<span class="Type">int</span> cacheId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum key1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum key2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum key3,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum key4)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(cacheId &gt;= <span class="Constant">0</span> &amp;&amp; cacheId &lt; <a href="#L80" title="utils/cache/syscache.c:80">SysCacheSize</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerIsValid(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId]));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="catcache.c.html#L1261" title="utils/cache/catcache.c:1261">SearchCatCache</a>(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId], key1, key2, key3, key4);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>HeapTuple<br/></li>
<li><a id="L218">&#x200c;</a><span class="linkable">SearchSysCache1</span>(<span class="Type">int</span> cacheId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum key1)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(cacheId &gt;= <span class="Constant">0</span> &amp;&amp; cacheId &lt; <a href="#L80" title="utils/cache/syscache.c:80">SysCacheSize</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerIsValid(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId]));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId]-&gt;cc_nkeys == <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="catcache.c.html#L1278" title="utils/cache/catcache.c:1278">SearchCatCache1</a>(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId], key1);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>HeapTuple<br/></li>
<li><a id="L229">&#x200c;</a><span class="linkable">SearchSysCache2</span>(<span class="Type">int</span> cacheId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum key1, Datum key2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(cacheId &gt;= <span class="Constant">0</span> &amp;&amp; cacheId &lt; <a href="#L80" title="utils/cache/syscache.c:80">SysCacheSize</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerIsValid(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId]));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId]-&gt;cc_nkeys == <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="catcache.c.html#L1286" title="utils/cache/catcache.c:1286">SearchCatCache2</a>(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId], key1, key2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>HeapTuple<br/></li>
<li><a id="L240">&#x200c;</a><span class="linkable">SearchSysCache3</span>(<span class="Type">int</span> cacheId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum key1, Datum key2, Datum key3)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(cacheId &gt;= <span class="Constant">0</span> &amp;&amp; cacheId &lt; <a href="#L80" title="utils/cache/syscache.c:80">SysCacheSize</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerIsValid(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId]));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId]-&gt;cc_nkeys == <span class="Constant">3</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="catcache.c.html#L1294" title="utils/cache/catcache.c:1294">SearchCatCache3</a>(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId], key1, key2, key3);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>HeapTuple<br/></li>
<li><a id="L251">&#x200c;</a><span class="linkable">SearchSysCache4</span>(<span class="Type">int</span> cacheId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum key1, Datum key2, Datum key3, Datum key4)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(cacheId &gt;= <span class="Constant">0</span> &amp;&amp; cacheId &lt; <a href="#L80" title="utils/cache/syscache.c:80">SysCacheSize</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerIsValid(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId]));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId]-&gt;cc_nkeys == <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="catcache.c.html#L1302" title="utils/cache/catcache.c:1302">SearchCatCache4</a>(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId], key1, key2, key3, key4);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Release previously grabbed reference count on a tuple<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L266">&#x200c;</a></span><span class="linkable">ReleaseSysCache</span>(HeapTuple tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="catcache.c.html#L1573" title="utils/cache/catcache.c:1573">ReleaseCatCache</a>(tuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L280" title="utils/cache/syscache.c:280">SearchSysCacheCopy</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A convenience routine that does <a href="#L205" title="utils/cache/syscache.c:205">SearchSysCache</a> and (if successful)<br/></li>
<li></span><span class="Comment"> * returns a modifiable copy of the syscache entry.&nbsp; The original<br/></li>
<li></span><span class="Comment"> * syscache entry is released <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning.&nbsp; The caller should<br/></li>
<li></span><span class="Comment"> * <a href="../../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>() the result when done with it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>HeapTuple<br/></li>
<li><a id="L280">&#x200c;</a><span class="linkable">SearchSysCacheCopy</span>(<span class="Type">int</span> cacheId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum key1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum key2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum key3,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum key4)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="#L205" title="utils/cache/syscache.c:205">SearchSysCache</a>(cacheId, key1, key2, key3, key4);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> tuple;<br/></li>
<li>&nbsp; &nbsp; newtuple = <a href="../../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <a href="#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newtuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L304" title="utils/cache/syscache.c:304">SearchSysCacheExists</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A convenience routine that just probes to see if a tuple can be found.<br/></li>
<li></span><span class="Comment"> * No lock is retained on the syscache entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L304">&#x200c;</a></span><span class="linkable">SearchSysCacheExists</span>(<span class="Type">int</span> cacheId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum key1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum key2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum key3,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum key4)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="#L205" title="utils/cache/syscache.c:205">SearchSysCache</a>(cacheId, key1, key2, key3, key4);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L327" title="utils/cache/syscache.c:327">GetSysCacheOid</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A convenience routine that does <a href="#L205" title="utils/cache/syscache.c:205">SearchSysCache</a> and returns the OID in the<br/></li>
<li></span><span class="Comment"> * oidcol column of the found tuple, or InvalidOid if no tuple could be found.<br/></li>
<li></span><span class="Comment"> * No lock is retained on the syscache entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L327">&#x200c;</a><span class="linkable">GetSysCacheOid</span>(<span class="Type">int</span> cacheId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AttrNumber oidcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum key1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum key2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum key3,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum key4)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNull;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="#L205" title="utils/cache/syscache.c:205">SearchSysCache</a>(cacheId, key1, key2, key3, key4);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>&nbsp; &nbsp; result = heap_getattr(tuple, oidcol,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId]-&gt;cc_tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isNull);<br/></li>
<li>&nbsp; &nbsp; Assert(!isNull);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* columns used as oids should never be NULL */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L359" title="utils/cache/syscache.c:359">SearchSysCacheAttName</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine is equivalent to <a href="#L205" title="utils/cache/syscache.c:205">SearchSysCache</a> on the ATTNAME cache,<br/></li>
<li></span><span class="Comment"> * except that it will return NULL if the found attribute is marked<br/></li>
<li></span><span class="Comment"> * attisdropped.&nbsp; This is convenient for callers that want to act as<br/></li>
<li></span><span class="Comment"> * though dropped attributes don't exist.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>HeapTuple<br/></li>
<li><a id="L359">&#x200c;</a><span class="linkable">SearchSysCacheAttName</span>(Oid relid, <span class="Type">const</span> <span class="Type">char</span> *attname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="#L229" title="utils/cache/syscache.c:229">SearchSysCache2</a>(ATTNAME,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(relid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum(attname));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (((Form_pg_attribute) GETSTRUCT(tuple))-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L382" title="utils/cache/syscache.c:382">SearchSysCacheCopyAttName</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As above, an attisdropped-aware version of <a href="#L280" title="utils/cache/syscache.c:280">SearchSysCacheCopy</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>HeapTuple<br/></li>
<li><a id="L382">&#x200c;</a><span class="linkable">SearchSysCacheCopyAttName</span>(Oid relid, <span class="Type">const</span> <span class="Type">char</span> *attname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="#L359" title="utils/cache/syscache.c:359">SearchSysCacheAttName</a>(relid, attname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> tuple;<br/></li>
<li>&nbsp; &nbsp; newtuple = <a href="../../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <a href="#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newtuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L401" title="utils/cache/syscache.c:401">SearchSysCacheExistsAttName</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As above, an attisdropped-aware version of <a href="#L304" title="utils/cache/syscache.c:304">SearchSysCacheExists</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L401">&#x200c;</a></span><span class="linkable">SearchSysCacheExistsAttName</span>(Oid relid, <span class="Type">const</span> <span class="Type">char</span> *attname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="#L359" title="utils/cache/syscache.c:359">SearchSysCacheAttName</a>(relid, attname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L422" title="utils/cache/syscache.c:422">SearchSysCacheAttNum</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine is equivalent to <a href="#L205" title="utils/cache/syscache.c:205">SearchSysCache</a> on the ATTNUM cache,<br/></li>
<li></span><span class="Comment"> * except that it will return NULL if the found attribute is marked<br/></li>
<li></span><span class="Comment"> * attisdropped.&nbsp; This is convenient for callers that want to act as<br/></li>
<li></span><span class="Comment"> * though dropped attributes don't exist.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>HeapTuple<br/></li>
<li><a id="L422">&#x200c;</a><span class="linkable">SearchSysCacheAttNum</span>(Oid relid, int16 attnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="#L229" title="utils/cache/syscache.c:229">SearchSysCache2</a>(ATTNUM,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(relid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int16GetDatum(attnum));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (((Form_pg_attribute) GETSTRUCT(tuple))-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L445" title="utils/cache/syscache.c:445">SearchSysCacheCopyAttNum</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As above, an attisdropped-aware version of <a href="#L280" title="utils/cache/syscache.c:280">SearchSysCacheCopy</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>HeapTuple<br/></li>
<li><a id="L445">&#x200c;</a><span class="linkable">SearchSysCacheCopyAttNum</span>(Oid relid, int16 attnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="#L422" title="utils/cache/syscache.c:422">SearchSysCacheAttNum</a>(relid, attnum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; newtuple = <a href="../../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <a href="#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newtuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given a tuple previously fetched by <a href="#L205" title="utils/cache/syscache.c:205">SearchSysCache</a>(),<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; extract a specific attribute.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is equivalent to using heap_getattr() on a tuple fetched<br/></li>
<li></span><span class="Comment"> * from a non-cached relation.&nbsp; Usually, this is only used for attributes<br/></li>
<li></span><span class="Comment"> * that could be NULL or variable length; the fixed-size attributes in<br/></li>
<li></span><span class="Comment"> * a system table are accessed just by mapping the tuple onto the C struct<br/></li>
<li></span><span class="Comment"> * declarations from include/catalog/.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As with heap_getattr(), if the attribute is of a pass-by-reference type<br/></li>
<li></span><span class="Comment"> * then a pointer into the tuple data area is returned --- the caller must<br/></li>
<li></span><span class="Comment"> * not modify or <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> the datum!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: it is legal to use <a href="#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>() with a cacheId referencing<br/></li>
<li></span><span class="Comment"> * a different cache for the same catalog the tuple was fetched from.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L479">&#x200c;</a><span class="linkable">SysCacheGetAttr</span>(<span class="Type">int</span> cacheId, HeapTuple tup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber attributeNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isNull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We just need to get the TupleDesc out of the cache entry, and then we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can apply heap_getattr().&nbsp; Normally the cache control data is already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * valid (because the caller recently fetched the tuple via this same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cache), but there are cases where we have to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the cache here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cacheId &lt; <span class="Constant">0</span> || cacheId &gt;= <a href="#L80" title="utils/cache/syscache.c:80">SysCacheSize</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !PointerIsValid(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid cache ID: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, cacheId);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PointerIsValid(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId]-&gt;cc_tupdesc))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="catcache.c.html#L1144" title="utils/cache/catcache.c:1144">InitCatCachePhase2</a>(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId], <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(PointerIsValid(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId]-&gt;cc_tupdesc));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> heap_getattr(tup, attributeNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId]-&gt;cc_tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isNull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As above, a version of <a href="#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a> which knows that the attr cannot<br/></li>
<li></span><span class="Comment"> * be NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L510">&#x200c;</a><span class="linkable">SysCacheGetAttrNotNull</span>(<span class="Type">int</span> cacheId, HeapTuple tup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AttrNumber attributeNumber)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; attr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attr = <a href="#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(cacheId, tup, attributeNumber, &amp;isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;unexpected null value in cached tuple for catalog </span><span class="Special">%s</span><span class="Constant"> column </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(cacheinfo[cacheId].reloid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(TupleDescAttr(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId]-&gt;cc_tupdesc, attributeNumber - <span class="Constant">1</span>)-&gt;attname));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> attr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L540" title="utils/cache/syscache.c:540">GetSysCacheHashValue</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Get the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value that would be used for a tuple in the specified cache<br/></li>
<li></span><span class="Comment"> * with the given search keys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The reason for exposing this as part of the API is that the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value is<br/></li>
<li></span><span class="Comment"> * exposed in cache invalidation operations, so there are places outside the<br/></li>
<li></span><span class="Comment"> * catcache code that need to be able to compute the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint32<br/></li>
<li><a id="L540">&#x200c;</a><span class="linkable">GetSysCacheHashValue</span>(<span class="Type">int</span> cacheId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum key1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum key2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum key3,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum key4)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cacheId &lt; <span class="Constant">0</span> || cacheId &gt;= <a href="#L80" title="utils/cache/syscache.c:80">SysCacheSize</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !PointerIsValid(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid cache ID: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, cacheId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="catcache.c.html#L1612" title="utils/cache/catcache.c:1612">GetCatCacheHashValue</a>(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId], key1, key2, key3, key4);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * List-search interface<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">struct</span> catclist *<br/></li>
<li><a id="L557">&#x200c;</a><span class="linkable">SearchSysCacheList</span>(<span class="Type">int</span> cacheId, <span class="Type">int</span> nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum key1, Datum key2, Datum key3)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cacheId &lt; <span class="Constant">0</span> || cacheId &gt;= <a href="#L80" title="utils/cache/syscache.c:80">SysCacheSize</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !PointerIsValid(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid cache ID: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, cacheId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="catcache.c.html#L1646" title="utils/cache/catcache.c:1646">SearchCatCacheList</a>(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId], nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key1, key2, key3);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L577" title="utils/cache/syscache.c:577">SysCacheInvalidate</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Invalidate entries in the specified cache, given a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; See <a href="catcache.c.html#L606" title="utils/cache/catcache.c:606">CatCacheInvalidate</a>() for more info.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This routine is only quasi-public: it should only be used by inval.c.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L577">&#x200c;</a></span><span class="linkable">SysCacheInvalidate</span>(<span class="Type">int</span> cacheId, uint32 hashValue)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cacheId &lt; <span class="Constant">0</span> || cacheId &gt;= <a href="#L80" title="utils/cache/syscache.c:80">SysCacheSize</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid cache ID: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, cacheId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if this cache isn't initialized yet, no need to do anything */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!PointerIsValid(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="catcache.c.html#L606" title="utils/cache/catcache.c:606">CatCacheInvalidate</a>(<a href="#L83" title="utils/cache/syscache.c:83">SysCache</a>[cacheId], hashValue);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Certain relations that do not have system caches <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> snapshot invalidation<br/></li>
<li></span><span class="Comment"> * messages in lieu of catcache messages.&nbsp; This is for the benefit of<br/></li>
<li></span><span class="Comment"> * <a href="../time/snapmgr.c.html#L352" title="utils/time/snapmgr.c:352">GetCatalogSnapshot</a>(), which can then reuse its existing MVCC snapshot<br/></li>
<li></span><span class="Comment"> * for scanning one of those catalogs, rather than taking a new one, if no<br/></li>
<li></span><span class="Comment"> * invalidation has been received.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Relations that have syscaches need not (and must not) be listed here.&nbsp; The<br/></li>
<li></span><span class="Comment"> * catcache invalidation messages will also flush the snapshot.&nbsp; If you add a<br/></li>
<li></span><span class="Comment"> * syscache for one of these relations, remove it from this list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L601">&#x200c;</a></span><span class="linkable">RelationInvalidatesSnapshotsOnly</span>(Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (relid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DbRoleSettingRelationId:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DependRelationId:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SharedDependRelationId:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DescriptionRelationId:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SharedDescriptionRelationId:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SecLabelRelationId:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SharedSecLabelRelationId:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test whether a relation has a system cache.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L624">&#x200c;</a></span><span class="linkable">RelationHasSysCache</span>(Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high = <a href="#L89" title="utils/cache/syscache.c:89">SysCacheRelationOidSize</a> - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (low &lt;= high)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; middle = low + (high - low) / <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L88" title="utils/cache/syscache.c:88">SysCacheRelationOid</a>[middle] == relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L88" title="utils/cache/syscache.c:88">SysCacheRelationOid</a>[middle] &lt; relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low = middle + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high = middle - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test whether a relation supports a system cache, ie it is either a<br/></li>
<li></span><span class="Comment"> * cached table or the index used for a cache.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L649">&#x200c;</a></span><span class="linkable">RelationSupportsSysCache</span>(Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high = <a href="#L93" title="utils/cache/syscache.c:93">SysCacheSupportingRelOidSize</a> - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (low &lt;= high)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; middle = low + (high - low) / <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L92" title="utils/cache/syscache.c:92">SysCacheSupportingRelOid</a>[middle] == relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L92" title="utils/cache/syscache.c:92">SysCacheSupportingRelOid</a>[middle] &lt; relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low = middle + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high = middle - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * OID comparator for qsort<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L674">&#x200c;</a></span><span class="linkable">oid_compare</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oa = *((<span class="Type">const</span> Oid *) a);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ob = *((<span class="Type">const</span> Oid *) b);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_cmp_u32(oa, ob);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
