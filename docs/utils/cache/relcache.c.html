<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/cache/relcache.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/cache/relcache.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L112">Desc_pg_attribute</a></li>
<li><a href="#L117">Desc_pg_auth_members</a></li>
<li><a href="#L116">Desc_pg_authid</a></li>
<li><a href="#L111">Desc_pg_class</a></li>
<li><a href="#L115">Desc_pg_database</a></li>
<li><a href="#L118">Desc_pg_index</a></li>
<li><a href="#L113">Desc_pg_proc</a></li>
<li><a href="#L119">Desc_pg_shseclabel</a></li>
<li><a href="#L120">Desc_pg_subscription</a></li>
<li><a href="#L114">Desc_pg_type</a></li>
<li><a href="#L202">EOXactTupleDescArray</a></li>
<li><a href="#L204">EOXactTupleDescArrayLen</a></li>
<li><a href="#L203">NextEOXactTupleDescNum</a></li>
<li><a href="#L271">OpClassCache</a></li>
<li><a href="#L134">RelationIdCache</a></li>
<li><a href="#L140">criticalRelcachesBuilt</a></li>
<li><a href="#L146">criticalSharedRelcachesBuilt</a></li>
<li><a href="#L185">eoxact_list</a></li>
<li><a href="#L186">eoxact_list_len</a></li>
<li><a href="#L187">eoxact_list_overflowed</a></li>
<li><a href="#L170">in_progress_list</a></li>
<li><a href="#L171">in_progress_list_len</a></li>
<li><a href="#L172">in_progress_list_maxlen</a></li>
<li><a href="#L154">relcacheInvalsReceived</a></li>
<li><a href="#L2130">relref_resowner_desc</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L168">InProgressEnt</a></li>
<li><a href="#L269">OpClassCacheEnt</a></li>
<li><a href="#L132">RelIdCacheEnt</a></li>
<li><a href="#L164">inprogressent</a></li>
<li><a href="#L261">opclasscacheent</a></li>
<li><a href="#L128">relidcacheent</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L408">AllocateRelationDesc</a></li>
<li><a href="#L3101">AssertPendingSyncConsistency</a></li>
<li><a href="#L3123">AssertPendingSyncs_RelationCache</a></li>
<li><a href="#L3346">AtEOSubXact_RelationCache</a></li>
<li><a href="#L3401">AtEOSubXact_cleanup</a></li>
<li><a href="#L3194">AtEOXact_RelationCache</a></li>
<li><a href="#L3264">AtEOXact_cleanup</a></li>
<li><a href="#L4524">AttrDefaultCmp</a></li>
<li><a href="#L4444">AttrDefaultFetch</a></li>
<li><a href="#L4379">BuildHardcodedDescriptor</a></li>
<li><a href="#L4628">CheckConstraintCmp</a></li>
<li><a href="#L4539">CheckConstraintFetch</a></li>
<li><a href="#L5864">CopyIndexAttOptions</a></li>
<li><a href="#L4409">GetPgClassDescriptor</a></li>
<li><a href="#L4422">GetPgIndexDescriptor</a></li>
<li><a href="#L1596">IndexSupportInitialize</a></li>
<li><a href="#L1401">InitIndexAmRoutine</a></li>
<li><a href="#L1800">InitTableAmRoutine</a></li>
<li><a href="#L1647">LookupOpclassInfo</a></li>
<li><a href="#L3925">RelationAssumeNewRelfilelocator</a></li>
<li><a href="#L1039">RelationBuildDesc</a></li>
<li><a href="#L3483">RelationBuildLocalRelation</a></li>
<li><a href="#L5716">RelationBuildPublicationDesc</a></li>
<li><a href="#L732">RelationBuildRuleLock</a></li>
<li><a href="#L520">RelationBuildTupleDesc</a></li>
<li><a href="#L6779">RelationCacheInitFilePostInvalidate</a></li>
<li><a href="#L6754">RelationCacheInitFilePreInvalidate</a></li>
<li><a href="#L6794">RelationCacheInitFileRemove</a></li>
<li><a href="#L6827">RelationCacheInitFileRemoveInDir</a></li>
<li><a href="#L3951">RelationCacheInitialize</a></li>
<li><a href="#L3997">RelationCacheInitializePhase2</a></li>
<li><a href="#L4056">RelationCacheInitializePhase3</a></li>
<li><a href="#L2973">RelationCacheInvalidate</a></li>
<li><a href="#L2917">RelationCacheInvalidateEntry</a></li>
<li><a href="#L2535">RelationClearRelation</a></li>
<li><a href="#L2193">RelationClose</a></li>
<li><a href="#L2202">RelationCloseCleanup</a></li>
<li><a href="#L2173">RelationDecrementReferenceCount</a></li>
<li><a href="#L2442">RelationDestroyRelation</a></li>
<li><a href="#L2840">RelationFlushRelation</a></li>
<li><a href="#L2873">RelationForgetRelation</a></li>
<li><a href="#L5084">RelationGetDummyIndexExpressions</a></li>
<li><a href="#L5581">RelationGetExclusionInfo</a></li>
<li><a href="#L4651">RelationGetFKeyList</a></li>
<li><a href="#L5504">RelationGetIdentityKeyBitmap</a></li>
<li><a href="#L5884">RelationGetIndexAttOptions</a></li>
<li><a href="#L5231">RelationGetIndexAttrBitmap</a></li>
<li><a href="#L5025">RelationGetIndexExpressions</a></li>
<li><a href="#L4760">RelationGetIndexList</a></li>
<li><a href="#L5138">RelationGetIndexPredicate</a></li>
<li><a href="#L4979">RelationGetPrimaryKeyIndex</a></li>
<li><a href="#L5000">RelationGetReplicaIndex</a></li>
<li><a href="#L4909">RelationGetStatExtList</a></li>
<li><a href="#L2062">RelationIdGetRelation</a></li>
<li><a href="#L6714">RelationIdIsInInitFile</a></li>
<li><a href="#L2160">RelationIncrementReferenceCount</a></li>
<li><a href="#L1425">RelationInitIndexAccessInfo</a></li>
<li><a href="#L1319">RelationInitPhysicalAddr</a></li>
<li><a href="#L1809">RelationInitTableAccessMethod</a></li>
<li><a href="#L463">RelationParseRelOptions</a></li>
<li><a href="#L2256">RelationReloadIndexInfo</a></li>
<li><a href="#L2370">RelationReloadNailed</a></li>
<li><a href="#L3726">RelationSetNewRelfilenumber</a></li>
<li><a href="#L3072">RememberToFreeTupleDescAtEOX</a></li>
<li><a href="#L6868">ResOwnerPrintRelCache</a></li>
<li><a href="#L6876">ResOwnerReleaseRelation</a></li>
<li><a href="#L2146">ResourceOwnerForgetRelationRef</a></li>
<li><a href="#L2141">ResourceOwnerRememberRelationRef</a></li>
<li><a href="#L338">ScanPgRelation</a></li>
<li><a href="#L952">equalPolicy</a></li>
<li><a href="#L998">equalRSDesc</a></li>
<li><a href="#L907">equalRuleLocks</a></li>
<li><a href="#L5945">errtable</a></li>
<li><a href="#L5962">errtablecol</a></li>
<li><a href="#L5986">errtablecolname</a></li>
<li><a href="#L5999">errtableconstraint</a></li>
<li><a href="#L1874">formrdesc</a></li>
<li><a href="#L4341">load_critical_index</a></li>
<li><a href="#L6063">load_relcache_init_file</a></li>
<li><a href="#L6851">unlink_initfile</a></li>
<li><a href="#L6691">write_item</a></li>
<li><a href="#L6479">write_relcache_init_file</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L189">EOXactListAdd</a></li>
<li><a href="#L3948">INITRELCACHESIZE</a></li>
<li><a href="#L184">MAX_EOXACT_LIST</a></li>
<li><a href="#L100">MAYBE_RECOVER_RELATION_BUILD_MEMORY</a></li>
<li><a href="#L104">MAYBE_RECOVER_RELATION_BUILD_MEMORY</a></li>
<li><a href="#L4143">NUM_CRITICAL_LOCAL_INDEXES</a></li>
<li><a href="#L4092">NUM_CRITICAL_LOCAL_RELS</a></li>
<li><a href="#L4175">NUM_CRITICAL_SHARED_INDEXES</a></li>
<li><a href="#L4035">NUM_CRITICAL_SHARED_RELS</a></li>
<li><a href="#L102">RECOVER_RELATION_BUILD_MEMORY</a></li>
<li><a href="#L93">RELCACHE_INIT_FILEMAGIC</a></li>
<li><a href="#L243">RelationCacheDelete</a></li>
<li><a href="#L209">RelationCacheInsert</a></li>
<li><a href="#L231">RelationIdCacheLookup</a></li>
<li><a href="#L2728">SWAPFIELD</a></li>
<li><a href="#L2826">SWAPFIELD</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * relcache.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; POSTGRES relation descriptor cache code<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/cache/relcache.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * INTERFACE ROUTINES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3951" title="utils/cache/relcache.c:3951">RelationCacheInitialize</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> relcache (to empty)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3997" title="utils/cache/relcache.c:3997">RelationCacheInitializePhase2</a>&nbsp; &nbsp; - <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> shared-catalog entries<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4056" title="utils/cache/relcache.c:4056">RelationCacheInitializePhase3</a>&nbsp; &nbsp; - finish initializing relcache<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2062" title="utils/cache/relcache.c:2062">RelationIdGetRelation</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - get a reldesc by relation id<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2193" title="utils/cache/relcache.c:2193">RelationClose</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - close an open relation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The following code contains many undocumented hacks.&nbsp; Please be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; careful....<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;sys/file.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/multixact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/parallel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/reloptions.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/sysattr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tableam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tupdesc_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/binary_upgrade.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/catalog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/indexing.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/partition.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_am.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_amproc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_attrdef.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_auth_members.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_authid.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_constraint.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_database.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_opclass.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_publication.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_rewrite.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_shseclabel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_statistic_ext.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_subscription.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_tablespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_trigger.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/schemapg.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/storage.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/policy.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/publicationcmds.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/int.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteDefine.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rowsecurity.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/smgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/catcache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgroids.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/relmapper.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/resowner.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L93">&#x200c;</a><span class="PreProc">#define <span class="linkable">RELCACHE_INIT_FILEMAGIC</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x573266</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* version ID value */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Whether to bother checking if relation cache memory needs to be freed<br/></li>
<li></span><span class="Comment"> * eagerly.&nbsp; See also <a href="#L1039" title="utils/cache/relcache.c:1039">RelationBuildDesc</a>() and pg_config_manual.h.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#if defined(<a href="#L102" title="utils/cache/relcache.c:102">RECOVER_RELATION_BUILD_MEMORY</a>) &amp;&amp; (<a href="#L102" title="utils/cache/relcache.c:102">RECOVER_RELATION_BUILD_MEMORY</a> != </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L100">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAYBE_RECOVER_RELATION_BUILD_MEMORY</span> </span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li><a id="L102">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RECOVER_RELATION_BUILD_MEMORY</span> </span><span class="Constant">0<br/></li>
<li></span><span class="PreProc">#ifdef DISCARD_CACHES_ENABLED<br/></li>
<li><a id="L104">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAYBE_RECOVER_RELATION_BUILD_MEMORY</span> </span><span class="Constant">1<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; hardcoded tuple descriptors, contents generated by genbki.pl<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L111">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> FormData_pg_attribute <span class="linkable">Desc_pg_class</span>[Natts_pg_class] = {Schema_pg_class};<br/></li>
<li><a id="L112">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> FormData_pg_attribute <span class="linkable">Desc_pg_attribute</span>[Natts_pg_attribute] = {Schema_pg_attribute};<br/></li>
<li><a id="L113">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> FormData_pg_attribute <span class="linkable">Desc_pg_proc</span>[Natts_pg_proc] = {Schema_pg_proc};<br/></li>
<li><a id="L114">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> FormData_pg_attribute <span class="linkable">Desc_pg_type</span>[Natts_pg_type] = {Schema_pg_type};<br/></li>
<li><a id="L115">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> FormData_pg_attribute <span class="linkable">Desc_pg_database</span>[Natts_pg_database] = {Schema_pg_database};<br/></li>
<li><a id="L116">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> FormData_pg_attribute <span class="linkable">Desc_pg_authid</span>[Natts_pg_authid] = {Schema_pg_authid};<br/></li>
<li><a id="L117">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> FormData_pg_attribute <span class="linkable">Desc_pg_auth_members</span>[Natts_pg_auth_members] = {Schema_pg_auth_members};<br/></li>
<li><a id="L118">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> FormData_pg_attribute <span class="linkable">Desc_pg_index</span>[Natts_pg_index] = {Schema_pg_index};<br/></li>
<li><a id="L119">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> FormData_pg_attribute <span class="linkable">Desc_pg_shseclabel</span>[Natts_pg_shseclabel] = {Schema_pg_shseclabel};<br/></li>
<li><a id="L120">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> FormData_pg_attribute <span class="linkable">Desc_pg_subscription</span>[Natts_pg_subscription] = {Schema_pg_subscription};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Hash tables that index the relation cache<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We used to index the cache by both name and OID, but <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> there<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; is only an index by OID.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L128">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">relidcacheent</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reloid;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; reldesc;<br/></li>
<li><a id="L132">&#x200c;</a>} <span class="linkable">RelIdCacheEnt</span>;<br/></li>
<li><br/></li>
<li><a id="L134">&#x200c;</a><span class="Type">static</span> <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">RelationIdCache</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This flag is false until we have prepared the critical relcache entries<br/></li>
<li></span><span class="Comment"> * that are needed to do indexscans on the tables read by relcache building.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L140">&#x200c;</a></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">criticalRelcachesBuilt</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This flag is false until we have prepared the critical relcache entries<br/></li>
<li></span><span class="Comment"> * for shared catalogs (which are the tables needed for login).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L146">&#x200c;</a></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">criticalSharedRelcachesBuilt</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This counter counts relcache inval events received since backend startup<br/></li>
<li></span><span class="Comment"> * (but only for rels that are actually in cache).&nbsp; Presently, we use it only<br/></li>
<li></span><span class="Comment"> * to detect whether data about to be written by <a href="#L6479" title="utils/cache/relcache.c:6479">write_relcache_init_file</a>()<br/></li>
<li></span><span class="Comment"> * might already be obsolete.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L154">&#x200c;</a></span><span class="Type">static</span> <span class="Type">long</span> <span class="linkable">relcacheInvalsReceived</span> = <span class="Constant">0L</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L170" title="utils/cache/relcache.c:170">in_progress_list</a> is a stack of ongoing <a href="#L1039" title="utils/cache/relcache.c:1039">RelationBuildDesc</a>() calls.&nbsp; CREATE<br/></li>
<li></span><span class="Comment"> * INDEX CONCURRENTLY makes catalog changes under ShareUpdateExclusiveLock.<br/></li>
<li></span><span class="Comment"> * It critically relies on each backend absorbing those changes no later than<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> transaction start.&nbsp; Hence, <a href="#L1039" title="utils/cache/relcache.c:1039">RelationBuildDesc</a>() loops until it finishes<br/></li>
<li></span><span class="Comment"> * without accepting a relevant invalidation.&nbsp; (Most invalidation consumers<br/></li>
<li></span><span class="Comment"> * don't do this.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L164">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">inprogressent</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reloid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OID of relation being built */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; invalidated;&nbsp; &nbsp; <span class="Comment">/* whether an invalidation arrived for it */<br/></li>
<li><a id="L168">&#x200c;</a></span>} <span class="linkable">InProgressEnt</span>;<br/></li>
<li><br/></li>
<li><a id="L170">&#x200c;</a><span class="Type">static</span> <a href="#L168" title="utils/cache/relcache.c:168">InProgressEnt</a> *<span class="linkable">in_progress_list</span>;<br/></li>
<li><a id="L171">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">in_progress_list_len</span>;<br/></li>
<li><a id="L172">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">in_progress_list_maxlen</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L185" title="utils/cache/relcache.c:185">eoxact_list</a>[] stores the OIDs of relations that (might) need AtEOXact<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> work.&nbsp; This list intentionally has limited size; if it overflows,<br/></li>
<li></span><span class="Comment"> * we fall back to scanning the whole hashtable.&nbsp; There is no value in a very<br/></li>
<li></span><span class="Comment"> * large list because (1) at some point, a <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a> scan is faster than<br/></li>
<li></span><span class="Comment"> * retail lookups, and (2) the value of this is to reduce EOXact work for<br/></li>
<li></span><span class="Comment"> * short transactions, which can't have dirtied all that many tables anyway.<br/></li>
<li></span><span class="Comment"> * <a href="#L189" title="utils/cache/relcache.c:189">EOXactListAdd</a>() does not bother to prevent duplicate list entries, so the<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> processing must be idempotent.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L184">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_EOXACT_LIST</span> </span><span class="Constant">32<br/></li>
<li><a id="L185">&#x200c;</a></span><span class="Type">static</span> Oid&nbsp; &nbsp; <span class="linkable">eoxact_list</span>[<a href="#L184" title="utils/cache/relcache.c:184">MAX_EOXACT_LIST</a>];<br/></li>
<li><a id="L186">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">eoxact_list_len</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L187">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">eoxact_list_overflowed</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><a id="L189">&#x200c;</a><span class="PreProc">#define <span class="linkable">EOXactListAdd</span>(rel) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (<a href="#L186" title="utils/cache/relcache.c:186">eoxact_list_len</a> &lt; <a href="#L184" title="utils/cache/relcache.c:184">MAX_EOXACT_LIST</a>) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L185" title="utils/cache/relcache.c:185">eoxact_list</a>[<a href="#L186" title="utils/cache/relcache.c:186">eoxact_list_len</a>++] = (rel)-&gt;rd_id; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">else</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L187" title="utils/cache/relcache.c:187">eoxact_list_overflowed</a> = </span><span class="Constant">true</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L202" title="utils/cache/relcache.c:202">EOXactTupleDescArray</a> stores TupleDescs that (might) need AtEOXact<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> work.&nbsp; The array expands as needed; there is no hashtable because<br/></li>
<li></span><span class="Comment"> * we don't need to access individual items except at EOXact.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L202">&#x200c;</a></span><span class="Type">static</span> TupleDesc *<span class="linkable">EOXactTupleDescArray</span>;<br/></li>
<li><a id="L203">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">NextEOXactTupleDescNum</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L204">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">EOXactTupleDescArrayLen</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; macros to manipulate the lookup hashtable<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L209">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RelationCacheInsert</span>(RELATION, replace_allowed)&nbsp; &nbsp; \<br/></li>
<li></span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="#L132" title="utils/cache/relcache.c:132">RelIdCacheEnt</a> *hentry; </span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span><span class="PreProc"> found; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; hentry = (<a href="#L132" title="utils/cache/relcache.c:132">RelIdCacheEnt</a> *) <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L134" title="utils/cache/relcache.c:134">RelationIdCache</a>, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;((RELATION)-&gt;rd_id), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ENTER, &amp;found); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (found) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* see comments in <a href="#L1039" title="utils/cache/relcache.c:1039">RelationBuildDesc</a> and <a href="#L3483" title="utils/cache/relcache.c:3483">RelationBuildLocalRelation</a> */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; Relation _old_rel = hentry-&gt;reldesc; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; Assert(replace_allowed); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; hentry-&gt;reldesc = (RELATION); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (RelationHasReferenceCountZero(_old_rel)) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2442" title="utils/cache/relcache.c:2442">RelationDestroyRelation</a>(_old_rel, </span><span class="Constant">false</span><span class="PreProc">); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">else</span><span class="PreProc"> </span><span class="Statement">if</span><span class="PreProc"> (!IsBootstrapProcessingMode()) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, </span><span class="Constant">&quot;leaking still-referenced relcache entry for </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span><span class="PreProc">, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(_old_rel)); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">else</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; hentry-&gt;reldesc = (RELATION); \<br/></li>
<li></span><span class="PreProc">} </span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L231">&#x200c;</a><span class="PreProc">#define <span class="linkable">RelationIdCacheLookup</span>(ID, RELATION) \<br/></li>
<li></span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="#L132" title="utils/cache/relcache.c:132">RelIdCacheEnt</a> *hentry; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; hentry = (<a href="#L132" title="utils/cache/relcache.c:132">RelIdCacheEnt</a> *) <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L134" title="utils/cache/relcache.c:134">RelationIdCache</a>, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;(ID), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_FIND, </span><span class="Constant">NULL</span><span class="PreProc">); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (hentry) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; RELATION = hentry-&gt;reldesc; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">else</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; RELATION = </span><span class="Constant">NULL</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">} </span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L243">&#x200c;</a><span class="PreProc">#define <span class="linkable">RelationCacheDelete</span>(RELATION) \<br/></li>
<li></span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="#L132" title="utils/cache/relcache.c:132">RelIdCacheEnt</a> *hentry; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; hentry = (<a href="#L132" title="utils/cache/relcache.c:132">RelIdCacheEnt</a> *) <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L134" title="utils/cache/relcache.c:134">RelationIdCache</a>, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;((RELATION)-&gt;rd_id), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_REMOVE, </span><span class="Constant">NULL</span><span class="PreProc">); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (hentry == </span><span class="Constant">NULL</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, </span><span class="Constant">&quot;failed to delete relcache entry for OID </span><span class="Special">%u</span><span class="Constant">&quot;</span><span class="PreProc">, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (RELATION)-&gt;rd_id); \<br/></li>
<li></span><span class="PreProc">} </span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Special cache for opclass-related information<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: only default support procs get cached, ie, those with<br/></li>
<li></span><span class="Comment"> * lefttype = righttype = opcintype.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L261">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">opclasscacheent</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opclassoid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lookup key: OID of opclass */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; valid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set true after successful fill-in */<br/></li>
<li></span>&nbsp; &nbsp; StrategyNumber numSupport;&nbsp; &nbsp; <span class="Comment">/* max # of support procs (from pg_am) */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcfamily;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OID of opclass's family */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcintype;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OID of opclass's declared input type */<br/></li>
<li></span>&nbsp; &nbsp; RegProcedure *supportProcs; <span class="Comment">/* OIDs of support procedures */<br/></li>
<li><a id="L269">&#x200c;</a></span>} <span class="linkable">OpClassCacheEnt</span>;<br/></li>
<li><br/></li>
<li><a id="L271">&#x200c;</a><span class="Type">static</span> <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">OpClassCache</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* non-export function prototypes */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2202" title="utils/cache/relcache.c:2202">RelationCloseCleanup</a>(Relation relation);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2442" title="utils/cache/relcache.c:2442">RelationDestroyRelation</a>(Relation relation, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> remember_tupdesc);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2535" title="utils/cache/relcache.c:2535">RelationClearRelation</a>(Relation relation, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> rebuild);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2256" title="utils/cache/relcache.c:2256">RelationReloadIndexInfo</a>(Relation relation);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2370" title="utils/cache/relcache.c:2370">RelationReloadNailed</a>(Relation relation);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2840" title="utils/cache/relcache.c:2840">RelationFlushRelation</a>(Relation relation);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3072" title="utils/cache/relcache.c:3072">RememberToFreeTupleDescAtEOX</a>(TupleDesc td);<br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L3101" title="utils/cache/relcache.c:3101">AssertPendingSyncConsistency</a>(Relation relation);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L3264" title="utils/cache/relcache.c:3264">AtEOXact_cleanup</a>(Relation relation, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3401" title="utils/cache/relcache.c:3401">AtEOSubXact_cleanup</a>(Relation relation, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SubTransactionId mySubid, SubTransactionId parentSubid);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L6063" title="utils/cache/relcache.c:6063">load_relcache_init_file</a>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> shared);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L6479" title="utils/cache/relcache.c:6479">write_relcache_init_file</a>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> shared);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L6691" title="utils/cache/relcache.c:6691">write_item</a>(<span class="Type">const</span> <span class="Type">void</span> *data, Size len, <span class="Type">FILE</span> *fp);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1874" title="utils/cache/relcache.c:1874">formrdesc</a>(<span class="Type">const</span> <span class="Type">char</span> *relationName, Oid relationReltype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isshared, <span class="Type">int</span> natts, <span class="Type">const</span> FormData_pg_attribute *attrs);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> HeapTuple <a href="#L338" title="utils/cache/relcache.c:338">ScanPgRelation</a>(Oid targetRelId, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> indexOK, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> force_non_historic);<br/></li>
<li><span class="Type">static</span> Relation <a href="#L408" title="utils/cache/relcache.c:408">AllocateRelationDesc</a>(Form_pg_class relp);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L463" title="utils/cache/relcache.c:463">RelationParseRelOptions</a>(Relation relation, HeapTuple tuple);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L520" title="utils/cache/relcache.c:520">RelationBuildTupleDesc</a>(Relation relation);<br/></li>
<li><span class="Type">static</span> Relation <a href="#L1039" title="utils/cache/relcache.c:1039">RelationBuildDesc</a>(Oid targetRelId, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> insertIt);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1319" title="utils/cache/relcache.c:1319">RelationInitPhysicalAddr</a>(Relation relation);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4341" title="utils/cache/relcache.c:4341">load_critical_index</a>(Oid indexoid, Oid heapoid);<br/></li>
<li><span class="Type">static</span> TupleDesc <a href="#L4409" title="utils/cache/relcache.c:4409">GetPgClassDescriptor</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> TupleDesc <a href="#L4422" title="utils/cache/relcache.c:4422">GetPgIndexDescriptor</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4444" title="utils/cache/relcache.c:4444">AttrDefaultFetch</a>(Relation relation, <span class="Type">int</span> ndef);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L4524" title="utils/cache/relcache.c:4524">AttrDefaultCmp</a>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4539" title="utils/cache/relcache.c:4539">CheckConstraintFetch</a>(Relation relation);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L4628" title="utils/cache/relcache.c:4628">CheckConstraintCmp</a>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1401" title="utils/cache/relcache.c:1401">InitIndexAmRoutine</a>(Relation relation);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1596" title="utils/cache/relcache.c:1596">IndexSupportInitialize</a>(oidvector *indclass,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RegProcedure *indexSupport,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *opFamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *opcInType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; StrategyNumber maxSupportNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AttrNumber maxAttributeNumber);<br/></li>
<li><span class="Type">static</span> <a href="#L269" title="utils/cache/relcache.c:269">OpClassCacheEnt</a> *<a href="#L1647" title="utils/cache/relcache.c:1647">LookupOpclassInfo</a>(Oid operatorClassOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StrategyNumber numSupport);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L6827" title="utils/cache/relcache.c:6827">RelationCacheInitFileRemoveInDir</a>(<span class="Type">const</span> <span class="Type">char</span> *tblspcpath);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L6851" title="utils/cache/relcache.c:6851">unlink_initfile</a>(<span class="Type">const</span> <span class="Type">char</span> *initfilename, <span class="Type">int</span> elevel);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L338" title="utils/cache/relcache.c:338">ScanPgRelation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is used by <a href="#L1039" title="utils/cache/relcache.c:1039">RelationBuildDesc</a> to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a pg_class<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; tuple matching targetRelId.&nbsp; The caller must hold at least<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; AccessShareLock on the target relid to prevent concurrent-update<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; scenarios; it isn't guaranteed that all scans used to build the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; relcache entry will use the same snapshot.&nbsp; If, for example,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; an attribute were to be added after scanning pg_class and <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; scanning pg_attribute, relnatts wouldn't match.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; NB: the returned tuple has been copied into <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d storage<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and must eventually be freed with <a href="../../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> HeapTuple<br/></li>
<li><a id="L338">&#x200c;</a><span class="linkable">ScanPgRelation</span>(Oid targetRelId, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> indexOK, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> force_non_historic)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; pg_class_tuple;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pg_class_desc;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc pg_class_scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If something goes wrong during backend startup, we might <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> ourselves<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trying to read pg_class <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we've selected a database.&nbsp; That ain't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * gonna work, so bail out with a useful error message.&nbsp; If this happens,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it probably means a relcache entry that needs to be nailed isn't.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(<a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;cannot read pg_class without having selected a database&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * form a scan key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_class_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(targetRelId));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open pg_class and fetch a tuple.&nbsp; Force heap scan if we haven't yet<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * built the critical relcache entries (this includes initdb and startup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * without a pg_internal.init file).&nbsp; The caller can also force a heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan by setting indexOK == false.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_class_desc = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The caller might need a tuple that's newer than the one the historic<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot; currently the only case requiring to do so is looking up the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relfilenumber of non mapped system relations during decoding. That<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot can't change in the midst of a relcache build, so there's no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to register the snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (force_non_historic)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snapshot = <a href="../time/snapmgr.c.html#L374" title="utils/time/snapmgr.c:374">GetNonHistoricCatalogSnapshot</a>(RelationRelationId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_class_scan = <a href="../../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(pg_class_desc, ClassOidIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexOK &amp;&amp; <a href="#L140" title="utils/cache/relcache.c:140">criticalRelcachesBuilt</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_class_tuple = <a href="../../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(pg_class_scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must copy tuple <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(pg_class_tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_class_tuple = <a href="../../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(pg_class_tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* all done */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(pg_class_scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_class_desc, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_class_tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L408" title="utils/cache/relcache.c:408">AllocateRelationDesc</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is used to allocate memory for a new relation descriptor<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the rd_rel field from the given pg_class tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Relation<br/></li>
<li><a id="L408">&#x200c;</a><span class="linkable">AllocateRelationDesc</span>(Form_pg_class relp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; relation;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; Form_pg_class relationForm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Relcache entries must live in <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a> */<br/></li>
<li></span>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocate and zero space for new relation descriptor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relation = (Relation) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelationData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure relation is marked as having no open file yet */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_smgr = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy the relation tuple form<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We only allocate space for the fixed fields, ie, CLASS_TUPLE_SIZE. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * variable-length fields (relacl, reloptions) are NOT stored in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relcache --- there'd be little point in it, since we don't copy the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple's nulls bitmap and hence wouldn't know if the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are valid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Bottom line is that relacl *cannot* be retrieved from the relcache. Get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it from the syscache if you need it.&nbsp; The same goes for the original<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * form of reloptions (however, we do store the parsed form of reloptions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in rd_options).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relationForm = (Form_pg_class) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(CLASS_TUPLE_SIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(relationForm, relp, CLASS_TUPLE_SIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> relation tuple form */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_rel = relationForm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and allocate attribute tuple form storage */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_att = <a href="../../access/common/tupdesc.c.html#L67" title="access/common/tupdesc.c:67">CreateTemplateTupleDesc</a>(relationForm-&gt;relnatts);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* which we mark as a reference-counted tupdesc */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_att-&gt;tdrefcount = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> relation;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L463" title="utils/cache/relcache.c:463">RelationParseRelOptions</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Convert pg_class.reloptions into pre-parsed rd_options<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tuple is the real pg_class tuple (not rd_rel!) for relation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: rd_rel and (if an index) rd_indam must be valid already<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L463">&#x200c;</a></span><span class="linkable">RelationParseRelOptions</span>(Relation relation, HeapTuple tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *options;<br/></li>
<li>&nbsp; &nbsp; amoptions_function amoptsfn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_options = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> AM-specific <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> function; fall out if relkind should not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have options.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (relation-&gt;rd_rel-&gt;relkind)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_TOASTVALUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_VIEW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_MATVIEW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_PARTITIONED_TABLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; amoptsfn = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_INDEX:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_PARTITIONED_INDEX:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; amoptsfn = relation-&gt;rd_indam-&gt;amoptions;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch reloptions from tuple; have to use a hardwired descriptor because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we might not have <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other for pg_class yet (consider executing this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * code for pg_class itself)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; options = <a href="../../access/common/reloptions.c.html#L1379" title="access/common/reloptions.c:1379">extractRelOptions</a>(tuple, <a href="#L4409" title="utils/cache/relcache.c:4409">GetPgClassDescriptor</a>(), amoptsfn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy parsed data into <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>.&nbsp; To guard against the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possibility of leaks in the reloptions code, we want to do the actual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parsing in the caller's memory context and copy the results into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a> after the fact.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (options)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_options = <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARSIZE(options));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(relation-&gt;rd_options, options, VARSIZE(options));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(options);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L520" title="utils/cache/relcache.c:520">RelationBuildTupleDesc</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Form the relation's tuple descriptor from information in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the pg_attribute, pg_attrdef &amp; pg_constraint system catalogs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L520">&#x200c;</a></span><span class="linkable">RelationBuildTupleDesc</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; pg_attribute_tuple;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pg_attribute_desc;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc pg_attribute_scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData skey[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; need;<br/></li>
<li>&nbsp; &nbsp; TupleConstr *constr;<br/></li>
<li>&nbsp; &nbsp; AttrMissing *attrmiss = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndef = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fill rd_att's type ID fields (<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> heap.c's <a href="../../catalog/heap.c.html#L968" title="catalog/heap.c:968">AddNewRelationTuple</a>) */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_att-&gt;tdtypeid =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;reltype ? relation-&gt;rd_rel-&gt;reltype : RECORDOID;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_att-&gt;tdtypmod = -<span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* just to be sure */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; constr = (TupleConstr *) <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TupleConstr));<br/></li>
<li>&nbsp; &nbsp; constr-&gt;has_not_null = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; constr-&gt;has_generated_stored = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Form a scan key that selects only user attributes (attnum &gt; 0).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Eliminating system attribute rows at the index level is lots faster<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than fetching them.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_attribute_attrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(relation)));<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_attribute_attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTGreaterStrategyNumber, F_INT2GT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int16GetDatum(<span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open pg_attribute and begin a scan.&nbsp; Force heap scan if we haven't yet<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * built the critical relcache entries (this includes initdb and startup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * without a pg_internal.init file).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_attribute_desc = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttributeRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; pg_attribute_scan = <a href="../../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(pg_attribute_desc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AttributeRelidNumIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L140" title="utils/cache/relcache.c:140">criticalRelcachesBuilt</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">2</span>, skey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * add attribute data to relation-&gt;rd_att<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; need = RelationGetNumberOfAttributes(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(pg_attribute_tuple = <a href="../../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(pg_attribute_scan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attp = (Form_pg_attribute) GETSTRUCT(pg_attribute_tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attnum = attp-&gt;attnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attnum &lt;= <span class="Constant">0</span> || attnum &gt; RelationGetNumberOfAttributes(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid attribute number </span><span class="Special">%d</span><span class="Constant"> for relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attp-&gt;attnum, RelationGetRelationName(relation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(TupleDescAttr(relation-&gt;rd_att, attnum - <span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTRIBUTE_FIXED_PART_SIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update constraint/default info */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attp-&gt;attnotnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constr-&gt;has_not_null = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attp-&gt;attgenerated == ATTRIBUTE_GENERATED_STORED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constr-&gt;has_generated_stored = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attp-&gt;atthasdef)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndef++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If the column has a &quot;missing&quot; value, put it in the attrmiss array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attp-&gt;atthasmissing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; missingval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; missingNull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do we have a missing value? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; missingval = heap_getattr(pg_attribute_tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_attribute_attmissingval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_attribute_desc-&gt;rd_att,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;missingNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!missingNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Yes, fetch from the array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_null;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; one = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; missval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attrmiss == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrmiss = (AttrMissing *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_rel-&gt;relnatts *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrMissing));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; missval = <a href="../adt/arrayfuncs.c.html#L1820" title="utils/adt/arrayfuncs.c:1820">array_get_element</a>(missingval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;one,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attp-&gt;attlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attp-&gt;attbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attp-&gt;attalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;is_null);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!is_null);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attp-&gt;attbyval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for copy by val just copy the datum direct */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrmiss[attnum - <span class="Constant">1</span>].am_value = missval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise copy in the correct context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrmiss[attnum - <span class="Constant">1</span>].am_value = <a href="../adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(missval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attp-&gt;attbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attp-&gt;attlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrmiss[attnum - <span class="Constant">1</span>].am_present = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; need--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (need == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end the scan and close the attribute relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(pg_attribute_scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_attribute_desc, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (need != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;pg_attribute catalog is missing </span><span class="Special">%d</span><span class="Constant"> attribute(s) for relation OID </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; need, RelationGetRelid(relation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The attcacheoff <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> we read from pg_attribute should all be -1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (&quot;unknown&quot;).&nbsp; Verify this if assert checking is on.&nbsp; They will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * computed when and if needed during tuple access.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; RelationGetNumberOfAttributes(relation); i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(TupleDescAttr(relation-&gt;rd_att, i)-&gt;attcacheoff == -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, we can easily set the attcacheoff value for the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attribute: it must be zero.&nbsp; This eliminates the need for special cases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for attnum=1 that used to exist in fastgetattr() and index_getattr().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationGetNumberOfAttributes(relation) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDescAttr(relation-&gt;rd_att, <span class="Constant">0</span>)-&gt;attcacheoff = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up constraint/default info<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (constr-&gt;has_not_null ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constr-&gt;has_generated_stored ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndef &gt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attrmiss ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;relchecks &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_att-&gt;constr = constr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndef &gt; <span class="Constant">0</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* DEFAULTs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4444" title="utils/cache/relcache.c:4444">AttrDefaultFetch</a>(relation, ndef);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constr-&gt;num_defval = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constr-&gt;missing = attrmiss;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relchecks &gt; <span class="Constant">0</span>)&nbsp; &nbsp; <span class="Comment">/* CHECKs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4539" title="utils/cache/relcache.c:4539">CheckConstraintFetch</a>(relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constr-&gt;num_check = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(constr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_att-&gt;constr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L732" title="utils/cache/relcache.c:732">RelationBuildRuleLock</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Form the relation's rewrite rules from information in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the pg_rewrite system catalog.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: The rule parsetrees are potentially very complex node structures.<br/></li>
<li></span><span class="Comment"> * To allow these trees to be freed when the relcache entry is flushed,<br/></li>
<li></span><span class="Comment"> * we make a private memory context to hold the RuleLock information for<br/></li>
<li></span><span class="Comment"> * each relcache entry that has associated rules.&nbsp; The context is used<br/></li>
<li></span><span class="Comment"> * just for rule info, not for <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other subsidiary data of the relcache<br/></li>
<li></span><span class="Comment"> * entry, because that keeps the update logic in <a href="#L2535" title="utils/cache/relcache.c:2535">RelationClearRelation</a>()<br/></li>
<li></span><span class="Comment"> * manageable.&nbsp; The other subsidiary data structures are simple enough<br/></li>
<li></span><span class="Comment"> * to be easy to free explicitly, anyway.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: The relation's reloptions must have been extracted first.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L732">&#x200c;</a></span><span class="linkable">RelationBuildRuleLock</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext rulescxt;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; rewrite_tuple;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rewrite_desc;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; rewrite_tupdesc;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc rewrite_scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key;<br/></li>
<li>&nbsp; &nbsp; RuleLock&nbsp;&nbsp; *rulelock;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numlocks;<br/></li>
<li>&nbsp; &nbsp; RewriteRule **rules;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxlocks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make the private context.&nbsp; Assume it'll not contain much data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rulescxt = AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;relation rules&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_SMALL_SIZES);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_rulescxt = rulescxt;<br/></li>
<li>&nbsp; &nbsp; MemoryContextCopyAndSetIdentifier(rulescxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(relation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocate an array to hold the rewrite rules (the array is extended if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessary)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; maxlocks = <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; rules = (RewriteRule **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(rulescxt, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RewriteRule *) * maxlocks);<br/></li>
<li>&nbsp; &nbsp; numlocks = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * form a scan key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_rewrite_ev_class,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(relation)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * open pg_rewrite and begin a scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: since we scan the rules using RewriteRelRulenameIndexId, we will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be reading the rules in name order, except possibly during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * emergency-recovery operations (ie, <a href="../init/miscinit.c.html#L80" title="utils/init/miscinit.c:80">IgnoreSystemIndexes</a>). This in turn<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensures that rules will be fired in name order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rewrite_desc = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RewriteRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; rewrite_tupdesc = RelationGetDescr(rewrite_desc);<br/></li>
<li>&nbsp; &nbsp; rewrite_scan = <a href="../../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(rewrite_desc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RewriteRelRulenameIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span>, &amp;key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(rewrite_tuple = <a href="../../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(rewrite_scan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_rewrite rewrite_form = (Form_pg_rewrite) GETSTRUCT(rewrite_tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; rule_datum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *rule_str;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RewriteRule *rule;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; check_as_user;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rule = (RewriteRule *) <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(rulescxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RewriteRule));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rule-&gt;ruleId = rewrite_form-&gt;oid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rule-&gt;event = rewrite_form-&gt;ev_type - <span class="Constant">'0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rule-&gt;enabled = rewrite_form-&gt;ev_enabled;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rule-&gt;isInstead = rewrite_form-&gt;is_instead;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Must use heap_getattr to fetch ev_action and ev_qual.&nbsp; Also, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rule strings are often large enough to be toasted.&nbsp; To avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leaking memory in the caller's context, do the detoasting here so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we can free the detoasted version.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rule_datum = heap_getattr(rewrite_tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_rewrite_ev_action,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rewrite_tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rule_str = TextDatumGetCString(rule_datum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(rulescxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rule-&gt;actions = (List *) <a href="../../nodes/read.c.html#L90" title="nodes/read.c:90">stringToNode</a>(rule_str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rule_str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rule_datum = heap_getattr(rewrite_tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_rewrite_ev_qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rewrite_tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rule_str = TextDatumGetCString(rule_datum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(rulescxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rule-&gt;qual = (Node *) <a href="../../nodes/read.c.html#L90" title="nodes/read.c:90">stringToNode</a>(rule_str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rule_str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is a SELECT rule defining a view, and the view has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;security_invoker&quot; set, we must perform all permissions checks on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relations referred to by the rule as the invoking user.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In all other cases (including non-SELECT rules on security invoker<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * views), perform the permissions checks as the relation owner.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rule-&gt;event == CMD_SELECT &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;relkind == RELKIND_VIEW &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationHasSecurityInvoker(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; check_as_user = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; check_as_user = relation-&gt;rd_rel-&gt;relowner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Scan through the rule's actions and set the checkAsUser field on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all RTEPermissionInfos. We have to look at the qual as well, in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case it contains sublinks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The reason for doing this when the rule is loaded, rather than when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it is stored, is that otherwise ALTER TABLE OWNER would have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * grovel through stored rules to update checkAsUser fields. Scanning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the rule tree during load is relatively cheap (compared to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constructing it in the first place), so we do it here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../rewrite/rewriteDefine.c.html#L631" title="rewrite/rewriteDefine.c:631">setRuleCheckAsUser</a>((Node *) rule-&gt;actions, check_as_user);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../rewrite/rewriteDefine.c.html#L631" title="rewrite/rewriteDefine.c:631">setRuleCheckAsUser</a>(rule-&gt;qual, check_as_user);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (numlocks &gt;= maxlocks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxlocks *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rules = (RewriteRule **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(rules, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RewriteRule *) * maxlocks);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rules[numlocks++] = rule;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end the scan and close the attribute relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(rewrite_scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rewrite_desc, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there might not be <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> rules (if relhasrules is out-of-date)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (numlocks == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rules = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rulescxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(rulescxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * form a RuleLock and insert into relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rulelock = (RuleLock *) <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(rulescxt, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RuleLock));<br/></li>
<li>&nbsp; &nbsp; rulelock-&gt;numLocks = numlocks;<br/></li>
<li>&nbsp; &nbsp; rulelock-&gt;rules = rules;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_rules = rulelock;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L907" title="utils/cache/relcache.c:907">equalRuleLocks</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Determine whether two RuleLocks are equivalent<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Probably this should be in the rules code someplace...<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L907">&#x200c;</a></span><span class="linkable">equalRuleLocks</span>(RuleLock *rlock1, RuleLock *rlock2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As of 7.3 we assume the rule ordering is repeatable, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L732" title="utils/cache/relcache.c:732">RelationBuildRuleLock</a> should read 'em in a consistent order.&nbsp; So just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> corresponding slots.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rlock1 != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rlock2 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rlock1-&gt;numLocks != rlock2-&gt;numLocks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; rlock1-&gt;numLocks; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RewriteRule *rule1 = rlock1-&gt;rules[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RewriteRule *rule2 = rlock2-&gt;rules[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rule1-&gt;ruleId != rule2-&gt;ruleId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rule1-&gt;event != rule2-&gt;event)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rule1-&gt;enabled != rule2-&gt;enabled)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rule1-&gt;isInstead != rule2-&gt;isInstead)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(rule1-&gt;qual, rule2-&gt;qual))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(rule1-&gt;actions, rule2-&gt;actions))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rlock2 != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L952" title="utils/cache/relcache.c:952">equalPolicy</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Determine whether two policies are equivalent<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L952">&#x200c;</a></span><span class="linkable">equalPolicy</span>(RowSecurityPolicy *policy1, RowSecurityPolicy *policy2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *r1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *r2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (policy1 != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (policy2 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (policy1-&gt;polcmd != policy2-&gt;polcmd)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (policy1-&gt;hassublinks != policy2-&gt;hassublinks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(policy1-&gt;policy_name, policy2-&gt;policy_name) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ARR_DIMS(policy1-&gt;roles)[<span class="Constant">0</span>] != ARR_DIMS(policy2-&gt;roles)[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r1 = (Oid *) ARR_DATA_PTR(policy1-&gt;roles);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r2 = (Oid *) ARR_DATA_PTR(policy2-&gt;roles);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ARR_DIMS(policy1-&gt;roles)[<span class="Constant">0</span>]; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r1[i] != r2[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(policy1-&gt;qual, policy2-&gt;qual))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(policy1-&gt;with_check_qual, policy2-&gt;with_check_qual))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (policy2 != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L998" title="utils/cache/relcache.c:998">equalRSDesc</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Determine whether two RowSecurityDesc's are equivalent<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L998">&#x200c;</a></span><span class="linkable">equalRSDesc</span>(RowSecurityDesc *rsdesc1, RowSecurityDesc *rsdesc2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rsdesc1 == <span class="Constant">NULL</span> &amp;&amp; rsdesc2 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((rsdesc1 != <span class="Constant">NULL</span> &amp;&amp; rsdesc2 == <span class="Constant">NULL</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (rsdesc1 == <span class="Constant">NULL</span> &amp;&amp; rsdesc2 != <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(rsdesc1-&gt;policies) != list_length(rsdesc2-&gt;policies))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../commands/policy.c.html#L193" title="commands/policy.c:193">RelationBuildRowSecurity</a> should build policies in order */<br/></li>
<li></span>&nbsp; &nbsp; forboth(lc, rsdesc1-&gt;policies, rc, rsdesc2-&gt;policies)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RowSecurityPolicy *l = (RowSecurityPolicy *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RowSecurityPolicy *r = (RowSecurityPolicy *) lfirst(rc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L952" title="utils/cache/relcache.c:952">equalPolicy</a>(l, r))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1039" title="utils/cache/relcache.c:1039">RelationBuildDesc</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Build a relation descriptor.&nbsp; The caller must hold at least<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; AccessShareLock on the target relid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The new descriptor is inserted into the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table if insertIt is true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns NULL if no pg_class row could be found for the given relid<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (suggesting we are trying to access a just-deleted relation).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Any other error is reported via elog.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Relation<br/></li>
<li><a id="L1039">&#x200c;</a><span class="linkable">RelationBuildDesc</span>(Oid targetRelId, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> insertIt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in_progress_offset;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; relation;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; pg_class_tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_class relp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This function and its subroutines can allocate a good deal of transient<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data in <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>.&nbsp; Traditionally we've just leaked that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data, reasoning that the caller's context is at worst of transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scope, and relcache loads shouldn't happen so often that it's essential<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to recover transient data <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> end of statement/transaction.&nbsp; However<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that's definitely not true when <a href="inval.c.html#L240" title="utils/cache/inval.c:240">debug_discard_caches</a> is active, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * perhaps it's not true in other cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When <a href="inval.c.html#L240" title="utils/cache/inval.c:240">debug_discard_caches</a> is active or when forced to by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L102" title="utils/cache/relcache.c:102">RECOVER_RELATION_BUILD_MEMORY</a>=1, arrange to allocate the junk in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * temporary context that we'll free <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning.&nbsp; Make it a child of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * caller's context so that it will get cleaned up appropriately if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * error out partway through.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef <a href="#L100" title="utils/cache/relcache.c:100">MAYBE_RECOVER_RELATION_BUILD_MEMORY</a><br/></li>
<li></span>&nbsp; &nbsp; MemoryContext tmpcxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L102" title="utils/cache/relcache.c:102">RECOVER_RELATION_BUILD_MEMORY</a> || <a href="inval.c.html#L240" title="utils/cache/inval.c:240">debug_discard_caches</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmpcxt = AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="#L1039" title="utils/cache/relcache.c:1039">RelationBuildDesc</a> workspace&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(tmpcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Register to catch invalidation messages */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L171" title="utils/cache/relcache.c:171">in_progress_list_len</a> &gt;= <a href="#L172" title="utils/cache/relcache.c:172">in_progress_list_maxlen</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allocsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; allocsize = <a href="#L172" title="utils/cache/relcache.c:172">in_progress_list_maxlen</a> * <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L170" title="utils/cache/relcache.c:170">in_progress_list</a> = <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(<a href="#L170" title="utils/cache/relcache.c:170">in_progress_list</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allocsize * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*<a href="#L170" title="utils/cache/relcache.c:170">in_progress_list</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L172" title="utils/cache/relcache.c:172">in_progress_list_maxlen</a> = allocsize;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; in_progress_offset = <a href="#L171" title="utils/cache/relcache.c:171">in_progress_list_len</a>++;<br/></li>
<li>&nbsp; &nbsp; <a href="#L170" title="utils/cache/relcache.c:170">in_progress_list</a>[in_progress_offset].reloid = targetRelId;<br/></li>
<li><span class="Statement">retry</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L170" title="utils/cache/relcache.c:170">in_progress_list</a>[in_progress_offset].invalidated = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the tuple in pg_class corresponding to the given relation id<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_class_tuple = <a href="#L338" title="utils/cache/relcache.c:338">ScanPgRelation</a>(targetRelId, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if no such tuple exists, return NULL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(pg_class_tuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef <a href="#L100" title="utils/cache/relcache.c:100">MAYBE_RECOVER_RELATION_BUILD_MEMORY</a><br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tmpcxt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Return to caller's context, and blow away the temporary context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(tmpcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(in_progress_offset + <span class="Constant">1</span> == <a href="#L171" title="utils/cache/relcache.c:171">in_progress_list_len</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L171" title="utils/cache/relcache.c:171">in_progress_list_len</a>--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get information from the pg_class_tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relp = (Form_pg_class) GETSTRUCT(pg_class_tuple);<br/></li>
<li>&nbsp; &nbsp; relid = relp-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; Assert(relid == targetRelId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocate storage for the relation descriptor, and copy pg_class_tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to relation-&gt;rd_rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relation = <a href="#L408" title="utils/cache/relcache.c:408">AllocateRelationDesc</a>(relp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the relation's relation id (relation-&gt;rd_id)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; RelationGetRelid(relation) = relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normal relations are not nailed into the cache.&nbsp; Since we don't flush<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new relations, it won't be new.&nbsp; It could be temp though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_refcnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_isnailed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_createSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_newRelfilelocatorSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_firstRelfilelocatorSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_droppedSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (relation-&gt;rd_rel-&gt;relpersistence)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELPERSISTENCE_UNLOGGED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELPERSISTENCE_PERMANENT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_backend = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_islocaltemp = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELPERSISTENCE_TEMP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../catalog/namespace.c.html#L3658" title="catalog/namespace.c:3658">isTempOrTempToastNamespace</a>(relation-&gt;rd_rel-&gt;relnamespace))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_backend = ProcNumberForTempRelations();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_islocaltemp = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's a temp table, but not one of ours, we have to use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the slow, grotty method to figure out the owning backend.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: it's possible that rd_backend gets set to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a> here, in case we are looking at a pg_class<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry left over from a crashed backend that coincidentally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * had the same ProcNumber we're using.&nbsp; We should *not*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consider such a table to be &quot;ours&quot;; this is why we need the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * separate rd_islocaltemp flag.&nbsp; The pg_class entry will get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * flushed if/when we clean out the corresponding temp table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * namespace in preparation for using it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_backend =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/namespace.c.html#L3751" title="catalog/namespace.c:3751">GetTempNamespaceProcNumber</a>(relation-&gt;rd_rel-&gt;relnamespace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(relation-&gt;rd_backend != INVALID_PROC_NUMBER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_islocaltemp = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid relpersistence: </span><span class="Special">%c</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_rel-&gt;relpersistence);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the tuple descriptor (relation-&gt;rd_att).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L520" title="utils/cache/relcache.c:520">RelationBuildTupleDesc</a>(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* foreign key data is not loaded till asked for */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_fkeylist = NIL;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_fkeyvalid = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* partitioning data is not loaded till asked for */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_partkey = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_partkeycxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_partdesc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_partdesc_nodetached = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_partdesc_nodetached_xmin = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_pdcxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_pddcxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_partcheck = NIL;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_partcheckvalid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_partcheckcxt = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> access method information<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relkind == RELKIND_INDEX ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_INDEX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1425" title="utils/cache/relcache.c:1425">RelationInitIndexAccessInfo</a>(relation);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (RELKIND_HAS_TABLE_AM(relation-&gt;rd_rel-&gt;relkind) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_rel-&gt;relkind == RELKIND_SEQUENCE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1809" title="utils/cache/relcache.c:1809">RelationInitTableAccessMethod</a>(relation);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do nothing: access methods are a setting that partitions can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inherit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(relation-&gt;rd_rel-&gt;relam == InvalidOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* extract reloptions if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L463" title="utils/cache/relcache.c:463">RelationParseRelOptions</a>(relation, pg_class_tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch rules and triggers that affect this relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that <a href="#L732" title="utils/cache/relcache.c:732">RelationBuildRuleLock</a>() relies on this being done after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extracting the relation's reloptions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relhasrules)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L732" title="utils/cache/relcache.c:732">RelationBuildRuleLock</a>(relation);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rules = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rulescxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relhastriggers)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/trigger.c.html#L1856" title="commands/trigger.c:1856">RelationBuildTriggers</a>(relation);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;trigdesc = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relrowsecurity)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/policy.c.html#L193" title="commands/policy.c:193">RelationBuildRowSecurity</a>(relation);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rsdesc = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the relation lock manager information<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L71" title="storage/lmgr/lmgr.c:71">RelationInitLockInfo</a>(relation); <span class="Comment">/* see lmgr.c */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> physical addressing information for the relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1319" title="utils/cache/relcache.c:1319">RelationInitPhysicalAddr</a>(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure relation is marked as having no open file yet */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_smgr = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we can free the memory allocated for pg_class_tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(pg_class_tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If an invalidation arrived mid-build, start over.&nbsp; Between here and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end of this function, don't add code that does or reasonably could read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * system catalogs.&nbsp; That <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> must be free from invalidation processing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the !insertIt case.&nbsp; For the insertIt case, <a href="#L209" title="utils/cache/relcache.c:209">RelationCacheInsert</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will enroll this relation in ordinary relcache invalidation processing,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L170" title="utils/cache/relcache.c:170">in_progress_list</a>[in_progress_offset].invalidated)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2442" title="utils/cache/relcache.c:2442">RelationDestroyRelation</a>(relation, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> retry;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(in_progress_offset + <span class="Constant">1</span> == <a href="#L171" title="utils/cache/relcache.c:171">in_progress_list_len</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L171" title="utils/cache/relcache.c:171">in_progress_list_len</a>--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> newly created relation into relcache <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table, if requested.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There is one scenario in which we might <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a hashtable entry already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * present, even though our caller failed to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it: if the relation is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * system catalog or index that's used during relcache load, we might have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recursively created the same relcache entry during the preceding steps.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * So allow <a href="#L209" title="utils/cache/relcache.c:209">RelationCacheInsert</a> to delete <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> already-present relcache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entry for the same OID.&nbsp; The already-present entry should have refcount<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * zero (else somebody forgot to close it); in the event that it doesn't,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we'll elog a WARNING and leak the already-present entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (insertIt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="utils/cache/relcache.c:209">RelationCacheInsert</a>(relation, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* It's fully valid */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_isvalid = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef <a href="#L100" title="utils/cache/relcache.c:100">MAYBE_RECOVER_RELATION_BUILD_MEMORY</a><br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tmpcxt)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Return to caller's context, and blow away the temporary context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(tmpcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> relation;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize the physical addressing info (RelFileLocator) for a relcache entry<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: at the physical level, relations in the pg_global tablespace must<br/></li>
<li></span><span class="Comment"> * be treated as shared, even if relisshared isn't set.&nbsp; Hence we do not<br/></li>
<li></span><span class="Comment"> * look at relisshared here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1319">&#x200c;</a></span><span class="linkable">RelationInitPhysicalAddr</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelFileNumber oldnumber = relation-&gt;rd_locator.relNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* these relations kinds never have storage */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!RELKIND_HAS_STORAGE(relation-&gt;rd_rel-&gt;relkind))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;reltablespace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_locator.spcOid = relation-&gt;rd_rel-&gt;reltablespace;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_locator.spcOid = <a href="../init/globals.c.html#L93" title="utils/init/globals.c:93">MyDatabaseTableSpace</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_locator.spcOid == GLOBALTABLESPACE_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_locator.dbOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_locator.dbOid = <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relfilenode)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Even if we are using a decoding snapshot that doesn't represent the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current state of the catalog we need to make sure the filenode<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * points to the current file since the older file will be gone (or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * truncated). The new file will still contain older rows so lookups<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in them will work correctly. This wouldn't work correctly if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rewrites were allowed to change the schema in an incompatible way,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but those are prevented both on catalog tables and on user tables<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * declared as additional catalog tables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../time/snapmgr.c.html#L1672" title="utils/time/snapmgr.c:1672">HistoricSnapshotActive</a>()<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; RelationIsAccessibleInLogicalDecoding(relation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; <a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; phys_tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class physrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phys_tuple = <a href="#L338" title="utils/cache/relcache.c:338">ScanPgRelation</a>(RelationGetRelid(relation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(relation) != ClassOidIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(phys_tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> pg_class entry for </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(relation));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; physrel = (Form_pg_class) GETSTRUCT(phys_tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;reltablespace = physrel-&gt;reltablespace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;relfilenode = physrel-&gt;relfilenode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(phys_tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_locator.relNumber = relation-&gt;rd_rel-&gt;relfilenode;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Consult the relation mapper */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_locator.relNumber =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="relmapper.c.html#L165" title="utils/cache/relmapper.c:165">RelationMapOidToFilenumber</a>(relation-&gt;rd_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_rel-&gt;relisshared);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!RelFileNumberIsValid(relation-&gt;rd_locator.relNumber))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> relation mapping for relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, OID </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(relation), relation-&gt;rd_id);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For RelationNeedsWAL() to answer correctly on parallel workers, restore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rd_firstRelfilelocatorSubid.&nbsp; No subtransactions start or end while in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel mode, so the specific SubTransactionId does not matter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsParallelWorker() &amp;&amp; oldnumber != relation-&gt;rd_locator.relNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../catalog/storage.c.html#L532" title="catalog/storage.c:532">RelFileLocatorSkippingWAL</a>(relation-&gt;rd_locator))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_firstRelfilelocatorSubid = TopSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_firstRelfilelocatorSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fill in the IndexAmRoutine for an index relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * relation's rd_amhandler and rd_indexcxt must be valid already.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1401">&#x200c;</a></span><span class="linkable">InitIndexAmRoutine</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexAmRoutine *cached,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call the amhandler in current, short-lived memory context, just in case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it leaks anything (it probably won't, but let's be paranoid).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tmp = <a href="../../access/index/amapi.c.html#L33" title="access/index/amapi.c:33">GetIndexAmRoutine</a>(relation-&gt;rd_amhandler);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> transfer the data into relation's rd_indexcxt. */<br/></li>
<li></span>&nbsp; &nbsp; cached = (IndexAmRoutine *) <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(relation-&gt;rd_indexcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexAmRoutine));<br/></li>
<li>&nbsp; &nbsp; memcpy(cached, tmp, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexAmRoutine));<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_indam = cached;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tmp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize index-access-method support data for an index relation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1425">&#x200c;</a></span><span class="linkable">RelationInitIndexAccessInfo</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_am&nbsp; &nbsp; aform;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; indcollDatum;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; indclassDatum;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; indoptionDatum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; oidvector&nbsp; *indcoll;<br/></li>
<li>&nbsp; &nbsp; oidvector&nbsp; *indclass;<br/></li>
<li>&nbsp; &nbsp; int2vector *indoption;<br/></li>
<li>&nbsp; &nbsp; MemoryContext indexcxt;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indnatts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indnkeyatts;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; amsupport;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make a copy of the pg_index entry for the index.&nbsp; Since pg_index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contains variable-length and possibly-null fields, we have to do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * honestly rather than just treating it as a Form_pg_index struct.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tuple = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(INDEXRELID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(relation)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for index </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(relation));<br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_indextuple = <a href="../../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_index = (Form_pg_index) GETSTRUCT(relation-&gt;rd_indextuple);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up the index's access method, save the OID of its handler function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(relation-&gt;rd_rel-&gt;relam != InvalidOid);<br/></li>
<li>&nbsp; &nbsp; tuple = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(AMOID, ObjectIdGetDatum(relation-&gt;rd_rel-&gt;relam));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for access method </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_rel-&gt;relam);<br/></li>
<li>&nbsp; &nbsp; aform = (Form_pg_am) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_amhandler = aform-&gt;amhandler;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indnatts = RelationGetNumberOfAttributes(relation);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (indnatts != IndexRelationGetNumberOfAttributes(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;relnatts disagrees with indnatts for index </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(relation));<br/></li>
<li>&nbsp; &nbsp; indnkeyatts = IndexRelationGetNumberOfKeyAttributes(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make the private context to hold index access info.&nbsp; The reason we need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a context, and not just a couple of pallocs, is so that we won't leak<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subsidiary info attached to fmgr lookup <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexcxt = AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;index info&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_SMALL_SIZES);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_indexcxt = indexcxt;<br/></li>
<li>&nbsp; &nbsp; MemoryContextCopyAndSetIdentifier(indexcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(relation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we can fetch the index AM's API struct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1401" title="utils/cache/relcache.c:1401">InitIndexAmRoutine</a>(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate arrays to hold data. Opclasses are not used for included<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * columns, so allocate them for indnkeyatts only.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_opfamily = (Oid *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(indexcxt, indnkeyatts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_opcintype = (Oid *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(indexcxt, indnkeyatts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; amsupport = relation-&gt;rd_indam-&gt;amsupport;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (amsupport &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nsupport = indnatts * amsupport;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_support = (RegProcedure *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(indexcxt, nsupport * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RegProcedure));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_supportinfo = (FmgrInfo *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(indexcxt, nsupport * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FmgrInfo));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_support = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_supportinfo = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_indcollation = (Oid *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(indexcxt, indnkeyatts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_indoption = (int16 *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(indexcxt, indnkeyatts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int16));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indcollation cannot be referenced directly through the C struct,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because it comes after the variable-width indkey field.&nbsp; Must extract<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the datum the hard way...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indcollDatum = fastgetattr(relation-&gt;rd_indextuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Anum_pg_index_indcollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L4422" title="utils/cache/relcache.c:4422">GetPgIndexDescriptor</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; Assert(!isnull);<br/></li>
<li>&nbsp; &nbsp; indcoll = (oidvector *) DatumGetPointer(indcollDatum);<br/></li>
<li>&nbsp; &nbsp; memcpy(relation-&gt;rd_indcollation, indcoll-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, indnkeyatts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indclass cannot be referenced directly through the C struct, because it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comes after the variable-width indkey field.&nbsp; Must extract the datum<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the hard way...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indclassDatum = fastgetattr(relation-&gt;rd_indextuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_index_indclass,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4422" title="utils/cache/relcache.c:4422">GetPgIndexDescriptor</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; Assert(!isnull);<br/></li>
<li>&nbsp; &nbsp; indclass = (oidvector *) DatumGetPointer(indclassDatum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill the support procedure OID array, as well as the info about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * opfamilies and opclass input types.&nbsp; (aminfo and supportinfo are left<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as zeroes, and are filled on-the-fly when used)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1596" title="utils/cache/relcache.c:1596">IndexSupportInitialize</a>(indclass, relation-&gt;rd_support,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_opfamily, relation-&gt;rd_opcintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; amsupport, indnkeyatts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Similarly extract indoption and copy it to the cache entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indoptionDatum = fastgetattr(relation-&gt;rd_indextuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Anum_pg_index_indoption,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L4422" title="utils/cache/relcache.c:4422">GetPgIndexDescriptor</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; Assert(!isnull);<br/></li>
<li>&nbsp; &nbsp; indoption = (int2vector *) DatumGetPointer(indoptionDatum);<br/></li>
<li>&nbsp; &nbsp; memcpy(relation-&gt;rd_indoption, indoption-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, indnkeyatts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int16));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L5884" title="utils/cache/relcache.c:5884">RelationGetIndexAttOptions</a>(relation, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expressions, predicate, exclusion caches will be filled later<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_indexprs = NIL;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_indpred = NIL;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_exclops = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_exclprocs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_exclstrats = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_amcache = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1596" title="utils/cache/relcache.c:1596">IndexSupportInitialize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Initializes an index's cached opclass information,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; given the index's pg_index.indclass entry.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Data is returned into *indexSupport, *opFamily, and *opcInType,<br/></li>
<li></span><span class="Comment"> * which are arrays allocated by the caller.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller also passes maxSupportNumber and maxAttributeNumber, since these<br/></li>
<li></span><span class="Comment"> * indicate the size of the arrays it has allocated --- but in practice these<br/></li>
<li></span><span class="Comment"> * numbers must always match those obtainable from the system catalog entries<br/></li>
<li></span><span class="Comment"> * for the index and access method.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1596">&#x200c;</a></span><span class="linkable">IndexSupportInitialize</span>(oidvector *indclass,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RegProcedure *indexSupport,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *opFamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *opcInType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; StrategyNumber maxSupportNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AttrNumber maxAttributeNumber)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attIndex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (attIndex = <span class="Constant">0</span>; attIndex &lt; maxAttributeNumber; attIndex++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="utils/cache/relcache.c:269">OpClassCacheEnt</a> *opcentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(indclass-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[attIndex]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;bogus pg_index tuple&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* look up the info for this opclass, using a cache */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; opcentry = <a href="#L1647" title="utils/cache/relcache.c:1647">LookupOpclassInfo</a>(indclass-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[attIndex],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; maxSupportNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy cached data into relcache entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; opFamily[attIndex] = opcentry-&gt;opcfamily;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opcInType[attIndex] = opcentry-&gt;opcintype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (maxSupportNumber &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;indexSupport[attIndex * maxSupportNumber],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; opcentry-&gt;supportProcs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; maxSupportNumber * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RegProcedure));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1647" title="utils/cache/relcache.c:1647">LookupOpclassInfo</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine maintains a per-opclass cache of the information needed<br/></li>
<li></span><span class="Comment"> * by <a href="#L1596" title="utils/cache/relcache.c:1596">IndexSupportInitialize</a>().&nbsp; This is more efficient than relying on<br/></li>
<li></span><span class="Comment"> * the catalog cache, because we can load all the info about a particular<br/></li>
<li></span><span class="Comment"> * opclass in a single indexscan of pg_amproc.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The information from pg_am about expected <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of support function<br/></li>
<li></span><span class="Comment"> * numbers is passed in, rather than being looked up, mainly because the<br/></li>
<li></span><span class="Comment"> * caller will have it already.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note there is no provision for flushing the cache.&nbsp; This is OK at the<br/></li>
<li></span><span class="Comment"> * moment because there is no way to ALTER <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> interesting properties of an<br/></li>
<li></span><span class="Comment"> * existing opclass --- all you can do is drop it, which will result in<br/></li>
<li></span><span class="Comment"> * a useless but harmless dead entry in the cache.&nbsp; To support altering<br/></li>
<li></span><span class="Comment"> * opclass membership (not the same as opfamily membership!), we'd need to<br/></li>
<li></span><span class="Comment"> * be able to flush this cache as well as the contents of relcache entries<br/></li>
<li></span><span class="Comment"> * for indexes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L269" title="utils/cache/relcache.c:269">OpClassCacheEnt</a> *<br/></li>
<li><a id="L1647">&#x200c;</a><span class="linkable">LookupOpclassInfo</span>(Oid operatorClassOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StrategyNumber numSupport)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L269" title="utils/cache/relcache.c:269">OpClassCacheEnt</a> *opcentry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData skey[<span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; htup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; indexOK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L271" title="utils/cache/relcache.c:271">OpClassCache</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First time through: <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the opclass cache */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Also make sure <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a> exists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="catcache.c.html#L679" title="utils/cache/catcache.c:679">CreateCacheMemoryContext</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L269" title="utils/cache/relcache.c:269">OpClassCacheEnt</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L271" title="utils/cache/relcache.c:271">OpClassCache</a> = <a href="../hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;Operator class cache&quot;</span>, <span class="Constant">64</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;ctl, HASH_ELEM | HASH_BLOBS);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opcentry = (<a href="#L269" title="utils/cache/relcache.c:269">OpClassCacheEnt</a> *) <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L271" title="utils/cache/relcache.c:271">OpClassCache</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;operatorClassOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ENTER, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize new entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; opcentry-&gt;valid = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* until known OK */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; opcentry-&gt;numSupport = numSupport;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opcentry-&gt;supportProcs = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* filled below */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(numSupport == opcentry-&gt;numSupport);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When aggressively testing cache-flush hazards, we disable the operator<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * class cache and force reloading of the info on each call.&nbsp; This models<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no real-world behavior, since the cache entries are never invalidated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise.&nbsp; However it can be helpful for detecting bugs in the cache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loading logic itself, such as reliance on a non-nailed index.&nbsp; Given<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the limited use-case and the fact that this adds a great deal of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expense, we enable it only for high <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of <a href="inval.c.html#L240" title="utils/cache/inval.c:240">debug_discard_caches</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef DISCARD_CACHES_ENABLED<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="inval.c.html#L240" title="utils/cache/inval.c:240">debug_discard_caches</a> &gt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opcentry-&gt;valid = <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (opcentry-&gt;valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> opcentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Need to fill in new entry.&nbsp; First allocate space, unless we already did<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so in some previous attempt.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (opcentry-&gt;supportProcs == <span class="Constant">NULL</span> &amp;&amp; numSupport &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opcentry-&gt;supportProcs = (RegProcedure *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numSupport * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RegProcedure));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To avoid infinite recursion during startup, force heap scans if we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * looking up info for the opclasses used by the indexes we would like to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reference here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexOK = <a href="#L140" title="utils/cache/relcache.c:140">criticalRelcachesBuilt</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (operatorClassOid != OID_BTREE_OPS_OID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operatorClassOid != INT2_BTREE_OPS_OID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have to fetch the pg_opclass row to determine its opfamily and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * opcintype, which are needed to look up related operators and <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It'd be convenient to use the syscache here, but that probably doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * work while bootstrapping.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_opclass_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(operatorClassOid));<br/></li>
<li>&nbsp; &nbsp; rel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(OperatorClassRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(rel, OpclassOidIndexId, indexOK,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">1</span>, skey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(htup = <a href="../../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_opclass opclassform = (Form_pg_opclass) GETSTRUCT(htup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opcentry-&gt;opcfamily = opclassform-&gt;opcfamily;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opcentry-&gt;opcintype = opclassform-&gt;opcintype;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> tuple for opclass </span><span class="Special">%u</span><span class="Constant">&quot;</span>, operatorClassOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan pg_amproc to obtain support procs for the opclass.&nbsp; We only fetch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the default ones (those with lefttype = righttype = opcintype).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (numSupport &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_amproc_amprocfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(opcentry-&gt;opcfamily));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_amproc_amproclefttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(opcentry-&gt;opcintype));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">2</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_amproc_amprocrighttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(opcentry-&gt;opcintype));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AccessMethodProcedureRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan = <a href="../../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(rel, AccessMethodProcedureIndexId, indexOK,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">3</span>, skey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(htup = <a href="../../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_amproc amprocform = (Form_pg_amproc) GETSTRUCT(htup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (amprocform-&gt;amprocnum &lt;= <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (StrategyNumber) amprocform-&gt;amprocnum &gt; numSupport)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid amproc number </span><span class="Special">%d</span><span class="Constant"> for opclass </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; amprocform-&gt;amprocnum, operatorClassOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcentry-&gt;supportProcs[amprocform-&gt;amprocnum - <span class="Constant">1</span>] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; amprocform-&gt;amproc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opcentry-&gt;valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> opcentry;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fill in the TableAmRoutine for a relation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * relation's rd_amhandler must be valid already.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1800">&#x200c;</a></span><span class="linkable">InitTableAmRoutine</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_tableam = <a href="../../access/table/tableamapi.c.html#L28" title="access/table/tableamapi.c:28">GetTableAmRoutine</a>(relation-&gt;rd_amhandler);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize table access method support for a table like relation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1809">&#x200c;</a></span><span class="linkable">RelationInitTableAccessMethod</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_am&nbsp; &nbsp; aform;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relkind == RELKIND_SEQUENCE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sequences are currently accessed like heap tables, but it doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * seem prudent to show that in the catalog. So just overwrite it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(relation-&gt;rd_rel-&gt;relam == InvalidOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_amhandler = F_HEAP_TABLEAM_HANDLER;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../catalog/catalog.c.html#L103" title="catalog/catalog.c:103">IsCatalogRelation</a>(relation))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Avoid doing a syscache lookup for catalog tables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(relation-&gt;rd_rel-&gt;relam == HEAP_TABLE_AM_OID);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_amhandler = F_HEAP_TABLEAM_HANDLER;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Look up the table access method, save the OID of its handler<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(relation-&gt;rd_rel-&gt;relam != InvalidOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(AMOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(relation-&gt;rd_rel-&gt;relam));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for access method </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_rel-&gt;relam);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aform = (Form_pg_am) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_amhandler = aform-&gt;amhandler;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we can fetch the table AM's API struct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1800" title="utils/cache/relcache.c:1800">InitTableAmRoutine</a>(relation);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1874" title="utils/cache/relcache.c:1874">formrdesc</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is a special cut-down version of <a href="#L1039" title="utils/cache/relcache.c:1039">RelationBuildDesc</a>(),<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; used while initializing the relcache.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The relation descriptor is built just from the supplied parameters,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; without actually looking at <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> system table entries.&nbsp; We cheat<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; quite a lot since we only need to work for a few basic system<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; catalogs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The catalogs this is used for can't have constraints (except attnotnull),<br/></li>
<li></span><span class="Comment"> * default <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, rules, or triggers, since we don't cope with <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of that.<br/></li>
<li></span><span class="Comment"> * (Well, actually, this only matters for properties that need to be valid<br/></li>
<li></span><span class="Comment"> * during bootstrap or <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="#L4056" title="utils/cache/relcache.c:4056">RelationCacheInitializePhase3</a> runs, and <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of<br/></li>
<li></span><span class="Comment"> * these properties matter then...)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: we assume we are already switched into <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1874">&#x200c;</a></span><span class="linkable">formrdesc</span>(<span class="Type">const</span> <span class="Type">char</span> *relationName, Oid relationReltype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isshared,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> natts, <span class="Type">const</span> FormData_pg_attribute *attrs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; relation;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_not_null;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocate new relation desc, clear all fields of reldesc<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relation = (Relation) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelationData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure relation is marked as having no open file yet */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_smgr = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> reference count: 1 because it is nailed in cache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_refcnt = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all entries built with this routine are nailed-in-cache; <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> are for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new or temp relations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_isnailed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_createSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_newRelfilelocatorSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_firstRelfilelocatorSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_droppedSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_backend = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_islocaltemp = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> relation tuple form<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The data we insert here is pretty incomplete/bogus, but it'll serve to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get us launched.&nbsp; <a href="#L4056" title="utils/cache/relcache.c:4056">RelationCacheInitializePhase3</a>() will read the real<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data from pg_class and replace what we've done here.&nbsp; Note in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * particular that relowner is left as zero; this cues<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L4056" title="utils/cache/relcache.c:4056">RelationCacheInitializePhase3</a> that the real data isn't there yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_rel = (Form_pg_class) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(CLASS_TUPLE_SIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../adt/name.c.html#L233" title="utils/adt/name.c:233">namestrcpy</a>(&amp;relation-&gt;rd_rel-&gt;relname, relationName);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_rel-&gt;relnamespace = PG_CATALOG_NAMESPACE;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_rel-&gt;reltype = relationReltype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's important to distinguish between shared and non-shared relations,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * even at bootstrap time, to make sure we know where they are stored.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_rel-&gt;relisshared = isshared;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isshared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;reltablespace = GLOBALTABLESPACE_OID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L1874" title="utils/cache/relcache.c:1874">formrdesc</a> is used only for permanent relations */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_rel-&gt;relpersistence = RELPERSISTENCE_PERMANENT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and they're always populated, too */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_rel-&gt;relispopulated = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_rel-&gt;relreplident = REPLICA_IDENTITY_NOTHING;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_rel-&gt;relpages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_rel-&gt;reltuples = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_rel-&gt;relallvisible = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_rel-&gt;relkind = RELKIND_RELATION;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_rel-&gt;relnatts = (int16) natts;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_rel-&gt;relam = HEAP_TABLE_AM_OID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> attribute tuple form<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unlike the case with the relation tuple, this data had better be right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because it will never be replaced.&nbsp; The data comes from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * src/include/catalog/ headers via genbki.pl.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_att = <a href="../../access/common/tupdesc.c.html#L67" title="access/common/tupdesc.c:67">CreateTemplateTupleDesc</a>(natts);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_att-&gt;tdrefcount = <span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* mark as refcounted */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_att-&gt;tdtypeid = relationReltype;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_att-&gt;tdtypmod = -<span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* just to be sure */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> tuple desc info<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; has_not_null = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(TupleDescAttr(relation-&gt;rd_att, i),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;attrs[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTRIBUTE_FIXED_PART_SIZE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; has_not_null |= attrs[i].attnotnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure attcacheoff is valid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; TupleDescAttr(relation-&gt;rd_att, i)-&gt;attcacheoff = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> first attribute's attcacheoff, cf <a href="#L520" title="utils/cache/relcache.c:520">RelationBuildTupleDesc</a> */<br/></li>
<li></span>&nbsp; &nbsp; TupleDescAttr(relation-&gt;rd_att, <span class="Constant">0</span>)-&gt;attcacheoff = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* mark not-null status */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (has_not_null)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleConstr *constr = (TupleConstr *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TupleConstr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constr-&gt;has_not_null = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_att-&gt;constr = constr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> relation id from info in att array (my, this is ugly)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; RelationGetRelid(relation) = TupleDescAttr(relation-&gt;rd_att, <span class="Constant">0</span>)-&gt;attrelid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All relations made with <a href="#L1874" title="utils/cache/relcache.c:1874">formrdesc</a> are mapped.&nbsp; This is necessarily so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because there is no other way to know what filenumber they currently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have.&nbsp; In bootstrap mode, add them to the initial relation mapper data,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * specifying that the initial filenumber is the same as the OID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_rel-&gt;relfilenode = InvalidRelFileNumber;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="relmapper.c.html#L325" title="utils/cache/relmapper.c:325">RelationMapUpdateMap</a>(RelationGetRelid(relation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(relation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isshared, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the relation lock manager information<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L71" title="storage/lmgr/lmgr.c:71">RelationInitLockInfo</a>(relation); <span class="Comment">/* see lmgr.c */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> physical addressing information for the relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1319" title="utils/cache/relcache.c:1319">RelationInitPhysicalAddr</a>(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the table am handler<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_rel-&gt;relam = HEAP_TABLE_AM_OID;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_tableam = <a href="../../access/heap/heapam_handler.c.html#L2653" title="access/heap/heapam_handler.c:2653">GetHeapamTableAmRoutine</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the rel-has-index flag, using hardwired knowledge<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In bootstrap mode, we have no indexes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;relhasindex = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise, all the rels <a href="#L1874" title="utils/cache/relcache.c:1874">formrdesc</a> is used for have indexes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;relhasindex = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * add new reldesc to relcache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L209" title="utils/cache/relcache.c:209">RelationCacheInsert</a>(relation, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* It's fully valid */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_isvalid = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation Descriptor Lookup Interface<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2062" title="utils/cache/relcache.c:2062">RelationIdGetRelation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Lookup a reldesc by OID; make one if not already in cache.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns NULL if no pg_class row could be found for the given relid<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (suggesting we are trying to access a just-deleted relation).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Any other error is reported via elog.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; NB: caller should already have at least AccessShareLock on the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; relation ID, else there are nasty race conditions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; NB: relation ref count is incremented, or set to 1 if new entry.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Caller should eventually decrement count.&nbsp; (Usually,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; that happens by calling <a href="#L2193" title="utils/cache/relcache.c:2193">RelationClose</a>().)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Relation<br/></li>
<li><a id="L2062">&#x200c;</a><span class="linkable">RelationIdGetRelation</span>(Oid relationId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we're in an xact, even if this ends up being a cache hit */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first try to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> reldesc in the cache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L231" title="utils/cache/relcache.c:231">RelationIdCacheLookup</a>(relationId, rd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RelationIsValid(rd))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return NULL for dropped relations */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rd-&gt;rd_droppedSubid != InvalidSubTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!rd-&gt;rd_isvalid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2160" title="utils/cache/relcache.c:2160">RelationIncrementReferenceCount</a>(rd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* revalidate cache entry if necessary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rd-&gt;rd_isvalid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Indexes only have a limited number of possible schema changes,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and we don't want to use the full-blown procedure because it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a headache for indexes that reload itself depends on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rd-&gt;rd_rel-&gt;relkind == RELKIND_INDEX ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rd-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_INDEX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2256" title="utils/cache/relcache.c:2256">RelationReloadIndexInfo</a>(rd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2535" title="utils/cache/relcache.c:2535">RelationClearRelation</a>(rd, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Normally entries need to be valid here, but <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the relcache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * has been initialized, not enough infrastructure exists to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * perform pg_class lookups. The structure of such entries doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * change, but we still want to update the rd_rel entry. So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rd_isvalid = false is left in place for a later lookup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rd-&gt;rd_isvalid ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (rd-&gt;rd_isnailed &amp;&amp; !<a href="#L140" title="utils/cache/relcache.c:140">criticalRelcachesBuilt</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> rd;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no reldesc in the cache, so have <a href="#L1039" title="utils/cache/relcache.c:1039">RelationBuildDesc</a>() build one and add<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rd = <a href="#L1039" title="utils/cache/relcache.c:1039">RelationBuildDesc</a>(relationId, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RelationIsValid(rd))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2160" title="utils/cache/relcache.c:2160">RelationIncrementReferenceCount</a>(rd);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rd;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache invalidation support routines<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* ResourceOwner callbacks to track relcache references */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L6876" title="utils/cache/relcache.c:6876">ResOwnerReleaseRelation</a>(Datum res);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L6868" title="utils/cache/relcache.c:6868">ResOwnerPrintRelCache</a>(Datum res);<br/></li>
<li><br/></li>
<li><a id="L2130">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> ResourceOwnerDesc <span class="linkable">relref_resowner_desc</span> =<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; .name = <span class="Constant">&quot;relcache reference&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; .release_phase = RESOURCE_RELEASE_BEFORE_LOCKS,<br/></li>
<li>&nbsp; &nbsp; .release_priority = RELEASE_PRIO_RELCACHE_REFS,<br/></li>
<li>&nbsp; &nbsp; .ReleaseResource = <a href="#L6876" title="utils/cache/relcache.c:6876">ResOwnerReleaseRelation</a>,<br/></li>
<li>&nbsp; &nbsp; .DebugPrint = <a href="#L6868" title="utils/cache/relcache.c:6868">ResOwnerPrintRelCache</a><br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Convenience wrappers over <a href="../resowner/resowner.c.html#L514" title="utils/resowner/resowner.c:514">ResourceOwnerRemember</a>/Forget */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L2141">&#x200c;</a></span><span class="linkable">ResourceOwnerRememberRelationRef</span>(ResourceOwner owner, Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../resowner/resowner.c.html#L514" title="utils/resowner/resowner.c:514">ResourceOwnerRemember</a>(owner, PointerGetDatum(rel), &amp;<a href="#L2130" title="utils/cache/relcache.c:2130">relref_resowner_desc</a>);<br/></li>
<li>}<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L2146">&#x200c;</a></span><span class="linkable">ResourceOwnerForgetRelationRef</span>(ResourceOwner owner, Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../resowner/resowner.c.html#L554" title="utils/resowner/resowner.c:554">ResourceOwnerForget</a>(owner, PointerGetDatum(rel), &amp;<a href="#L2130" title="utils/cache/relcache.c:2130">relref_resowner_desc</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2160" title="utils/cache/relcache.c:2160">RelationIncrementReferenceCount</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Increments relation reference count.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: bootstrap mode has its own weird ideas about relation refcount<br/></li>
<li></span><span class="Comment"> * behavior; we ought to fix it someday, but for <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, just disable<br/></li>
<li></span><span class="Comment"> * reference count ownership tracking in bootstrap mode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2160">&#x200c;</a></span><span class="linkable">RelationIncrementReferenceCount</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(<a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li>&nbsp; &nbsp; rel-&gt;rd_refcnt += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2141" title="utils/cache/relcache.c:2141">ResourceOwnerRememberRelationRef</a>(<a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>, rel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2173" title="utils/cache/relcache.c:2173">RelationDecrementReferenceCount</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Decrements relation reference count.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2173">&#x200c;</a></span><span class="linkable">RelationDecrementReferenceCount</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(rel-&gt;rd_refcnt &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; rel-&gt;rd_refcnt -= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2146" title="utils/cache/relcache.c:2146">ResourceOwnerForgetRelationRef</a>(<a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>, rel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2193" title="utils/cache/relcache.c:2193">RelationClose</a> - close an open relation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Actually, we just decrement the refcount.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: if compiled with -DRELCACHE_FORCE_RELEASE then relcache entries<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; will be freed as soon as their refcount goes to zero.&nbsp; In combination<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; with aset.c's CLOBBER_FREED_MEMORY option, this provides a good test<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; to catch references to already-released relcache entries.&nbsp; It slows<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; things down quite a <a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>, however.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2193">&#x200c;</a></span><span class="linkable">RelationClose</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note: no locking manipulations needed */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2173" title="utils/cache/relcache.c:2173">RelationDecrementReferenceCount</a>(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2202" title="utils/cache/relcache.c:2202">RelationCloseCleanup</a>(relation);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2202">&#x200c;</a></span><span class="linkable">RelationCloseCleanup</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the relation is no longer open in this session, we can clean up <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stale partition descriptors it has.&nbsp; This is unlikely, so check to see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if there are child contexts <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> expending a call to mcxt.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationHasReferenceCountZero(relation))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_pdcxt != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_pdcxt-&gt;firstchild != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L539" title="utils/mmgr/mcxt.c:539">MemoryContextDeleteChildren</a>(relation-&gt;rd_pdcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_pddcxt != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_pddcxt-&gt;firstchild != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L539" title="utils/mmgr/mcxt.c:539">MemoryContextDeleteChildren</a>(relation-&gt;rd_pddcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef RELCACHE_FORCE_RELEASE<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationHasReferenceCountZero(relation) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_createSubid == InvalidSubTransactionId &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_firstRelfilelocatorSubid == InvalidSubTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2535" title="utils/cache/relcache.c:2535">RelationClearRelation</a>(relation, <span class="Constant">false</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2256" title="utils/cache/relcache.c:2256">RelationReloadIndexInfo</a> - reload minimal information for an open index<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This function is used only for indexes.&nbsp; A relcache inval on an index<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; can mean that its pg_class or pg_index row changed.&nbsp; There are only<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; very limited changes that are allowed to an existing index's schema,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; so we can update the relcache entry without a complete rebuild; which<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; is fortunate because we can't rebuild an index entry that is &quot;nailed&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; and/or in active use.&nbsp; We support full replacement of the pg_class row,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; as well as updates of a few simple fields of the pg_index row.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; We can't necessarily reread the catalog rows right away; we might be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; in a failed transaction when we receive the SI notification.&nbsp; If so,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2535" title="utils/cache/relcache.c:2535">RelationClearRelation</a> just marks the entry as invalid by setting<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rd_isvalid to false.&nbsp; This routine is called to fix the entry when it<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; is <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; We assume that at the time we are called, we have at least AccessShareLock<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; on the target index.&nbsp; (Note: in the calls from <a href="#L2535" title="utils/cache/relcache.c:2535">RelationClearRelation</a>,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; this is legitimate because we know the rel has positive refcount.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If the target index is an index on pg_class or pg_index, we'd better have<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; previously gotten at least AccessShareLock on its underlying catalog,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; else we are at risk of deadlock against someone trying to exclusive-lock<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the heap and index in that order.&nbsp; This is ensured in current usage by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; only applying this to indexes being opened or having positive refcount.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2256">&#x200c;</a></span><span class="linkable">RelationReloadIndexInfo</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; indexOK;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; pg_class_tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_class relp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should be called only for invalidated, live indexes */<br/></li>
<li></span>&nbsp; &nbsp; Assert((relation-&gt;rd_rel-&gt;relkind == RELKIND_INDEX ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_INDEX) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !relation-&gt;rd_isvalid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_droppedSubid == InvalidSubTransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure it's closed at smgr level */<br/></li>
<li></span>&nbsp; &nbsp; RelationCloseSmgr(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must free <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> AM cached data upon relcache flush */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_amcache)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(relation-&gt;rd_amcache);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_amcache = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's a shared index, we might be called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> backend startup has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * finished selecting a database, in which case we have no way to read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_class yet.&nbsp; However, a shared index can never have <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> significant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * schema updates, so it's okay to ignore the invalidation signal.&nbsp; Just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mark it valid and return without doing anything more.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relisshared &amp;&amp; !<a href="#L140" title="utils/cache/relcache.c:140">criticalRelcachesBuilt</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_isvalid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read the pg_class row<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't try to use an indexscan of pg_class_oid_index to reload the info<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for pg_class_oid_index ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexOK = (RelationGetRelid(relation) != ClassOidIndexId);<br/></li>
<li>&nbsp; &nbsp; pg_class_tuple = <a href="#L338" title="utils/cache/relcache.c:338">ScanPgRelation</a>(RelationGetRelid(relation), indexOK, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(pg_class_tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> pg_class tuple for index </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(relation));<br/></li>
<li>&nbsp; &nbsp; relp = (Form_pg_class) GETSTRUCT(pg_class_tuple);<br/></li>
<li>&nbsp; &nbsp; memcpy(relation-&gt;rd_rel, relp, CLASS_TUPLE_SIZE);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reload reloptions in case they changed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_options)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(relation-&gt;rd_options);<br/></li>
<li>&nbsp; &nbsp; <a href="#L463" title="utils/cache/relcache.c:463">RelationParseRelOptions</a>(relation, pg_class_tuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* done with pg_class tuple */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(pg_class_tuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We must recalculate physical address in case it changed */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1319" title="utils/cache/relcache.c:1319">RelationInitPhysicalAddr</a>(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For a non-system index, there are fields of the pg_index row that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allowed to change, so re-read that row and update the relcache entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Most of the info derived from pg_index (such as support function lookup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * info) cannot change, and indeed the whole point of this routine is to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * update the relcache entry without clobbering that data; so wholesale<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replacement is not appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../catalog/catalog.c.html#L73" title="catalog/catalog.c:73">IsSystemRelation</a>(relation))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_index index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(INDEXRELID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(relation)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for index </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(relation));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; index = (Form_pg_index) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Basically, let's just copy all the <a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> fields.&nbsp; There are one or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * two of these that can't actually change in the current code, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's not worth it to track exactly which ones they are.&nbsp; None of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the array fields are allowed to change, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_index-&gt;indisunique = index-&gt;indisunique;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_index-&gt;indnullsnotdistinct = index-&gt;indnullsnotdistinct;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_index-&gt;indisprimary = index-&gt;indisprimary;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_index-&gt;indisexclusion = index-&gt;indisexclusion;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_index-&gt;indimmediate = index-&gt;indimmediate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_index-&gt;indisclustered = index-&gt;indisclustered;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_index-&gt;indisvalid = index-&gt;indisvalid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_index-&gt;indcheckxmin = index-&gt;indcheckxmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_index-&gt;indisready = index-&gt;indisready;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_index-&gt;indislive = index-&gt;indislive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_index-&gt;indisreplident = index-&gt;indisreplident;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy xmin too, as that is needed to make sense of indcheckxmin */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetXmin(relation-&gt;rd_indextuple-&gt;t_data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTupleHeaderGetXmin(tuple-&gt;t_data));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Okay, <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> it's valid again */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_isvalid = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2370" title="utils/cache/relcache.c:2370">RelationReloadNailed</a> - reload minimal information for nailed relations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The structure of a nailed relation can never change (which is good, because<br/></li>
<li></span><span class="Comment"> * we rely on knowing their structure to be able to read catalog content). But<br/></li>
<li></span><span class="Comment"> * some parts, e.g. pg_class.relfrozenxid, are still important to have<br/></li>
<li></span><span class="Comment"> * accurate content for. Therefore those need to be reloaded after the arrival<br/></li>
<li></span><span class="Comment"> * of invalidations.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2370">&#x200c;</a></span><span class="linkable">RelationReloadNailed</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(relation-&gt;rd_isnailed);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Redo <a href="#L1319" title="utils/cache/relcache.c:1319">RelationInitPhysicalAddr</a> in case it is a mapped relation whose<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mapping changed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1319" title="utils/cache/relcache.c:1319">RelationInitPhysicalAddr</a>(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* flag as needing to be revalidated */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_isvalid = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Can only reread catalog contents if in a transaction.&nbsp; If the relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is currently open (not counting the nailed refcount), do so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * immediately. Otherwise we've already marked the entry as possibly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * invalid, and it'll be fixed when <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> opened.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>() || relation-&gt;rd_refcnt &lt;= <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relkind == RELKIND_INDEX)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's a nailed-but-not-mapped index, then we need to re-read the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_class row to see if its relfilenumber changed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2256" title="utils/cache/relcache.c:2256">RelationReloadIndexInfo</a>(relation);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reload a non-index entry.&nbsp; We can't easily do so if relcaches<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aren't yet built, but that's fine because at that stage the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attributes that need to be current (like relfrozenxid) aren't yet<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * accessed.&nbsp; To ensure the entry will later be revalidated, we leave<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it in invalid state, but allow use (cf. <a href="#L2062" title="utils/cache/relcache.c:2062">RelationIdGetRelation</a>()).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L140" title="utils/cache/relcache.c:140">criticalRelcachesBuilt</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; pg_class_tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class relp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NB: Mark the entry as valid <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> starting to scan, to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * self-recursion when re-building pg_class.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_isvalid = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_class_tuple = <a href="#L338" title="utils/cache/relcache.c:338">ScanPgRelation</a>(RelationGetRelid(relation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relp = (Form_pg_class) GETSTRUCT(pg_class_tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(relation-&gt;rd_rel, relp, CLASS_TUPLE_SIZE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(pg_class_tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Again mark as valid, to protect against concurrently arriving<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * invalidations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_isvalid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2442" title="utils/cache/relcache.c:2442">RelationDestroyRelation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Physically delete a relation cache entry and all subsidiary data.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Caller must already have unhooked the entry from the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2442">&#x200c;</a></span><span class="linkable">RelationDestroyRelation</span>(Relation relation, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> remember_tupdesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(RelationHasReferenceCountZero(relation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure smgr and <a href="../adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> levels close the relation's files, if they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * weren't closed already.&nbsp; (This was probably done by caller, but let's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just be real sure.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; RelationCloseSmgr(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* break mutual link with stats entry */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../activity/pgstat_relation.c.html#L153" title="utils/activity/pgstat_relation.c:153">pgstat_unlink_relation</a>(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Free all the subsidiary data structures of the relcache entry, then the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entry itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(relation-&gt;rd_rel);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* can't use <a href="../../access/common/tupdesc.c.html#L406" title="access/common/tupdesc.c:406">DecrTupleDescRefCount</a> here */<br/></li>
<li></span>&nbsp; &nbsp; Assert(relation-&gt;rd_att-&gt;tdrefcount &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (--relation-&gt;rd_att-&gt;tdrefcount == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we Rebuilt a relcache entry during a transaction then its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible we did that because the TupDesc changed as the result of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an ALTER TABLE that ran at less than AccessExclusiveLock. It's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible someone copied that TupDesc, in which case the copy would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * point to free'd memory. So if we rebuild an entry we keep the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TupDesc around until end of transaction, to be safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (remember_tupdesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3072" title="utils/cache/relcache.c:3072">RememberToFreeTupleDescAtEOX</a>(relation-&gt;rd_att);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L331" title="access/common/tupdesc.c:331">FreeTupleDesc</a>(relation-&gt;rd_att);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../commands/trigger.c.html#L2140" title="commands/trigger.c:2140">FreeTriggerDesc</a>(relation-&gt;trigdesc);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1560" title="nodes/list.c:1560">list_free_deep</a>(relation-&gt;rd_fkeylist);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(relation-&gt;rd_indexlist);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(relation-&gt;rd_statlist);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(relation-&gt;rd_keyattr);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(relation-&gt;rd_pkattr);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(relation-&gt;rd_idattr);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(relation-&gt;rd_hotblockingattr);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(relation-&gt;rd_summarizedattr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_pubdesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(relation-&gt;rd_pubdesc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_options)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(relation-&gt;rd_options);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_indextuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(relation-&gt;rd_indextuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_amcache)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(relation-&gt;rd_amcache);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_fdwroutine)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(relation-&gt;rd_fdwroutine);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_indexcxt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(relation-&gt;rd_indexcxt);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rulescxt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(relation-&gt;rd_rulescxt);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rsdesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(relation-&gt;rd_rsdesc-&gt;rscxt);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_partkeycxt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(relation-&gt;rd_partkeycxt);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_pdcxt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(relation-&gt;rd_pdcxt);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_pddcxt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(relation-&gt;rd_pddcxt);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_partcheckcxt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(relation-&gt;rd_partcheckcxt);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(relation);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2535" title="utils/cache/relcache.c:2535">RelationClearRelation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Physically blow away a relation cache entry, or reset it and rebuild<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; it from scratch (that is, from catalog entries).&nbsp; The latter path is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; used when we are notified of a change to an open relation (one with<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; refcount &gt; 0).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; NB: when rebuilding, we'd better hold some lock on the relation,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; else the catalog data we need to read could be changing under us.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Also, a rel to be rebuilt had better have refcnt &gt; 0.&nbsp; This is because<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; a sinval reset could happen while we're accessing the catalogs, and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; the rel would get blown away underneath us by <a href="#L2973" title="utils/cache/relcache.c:2973">RelationCacheInvalidate</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; if it has zero refcnt.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; The &quot;rebuild&quot; parameter is redundant in current usage because it has<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; to match the relation's refcnt status, but we keep it as a crosscheck<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; that we're doing what the caller expects.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2535">&#x200c;</a></span><span class="linkable">RelationClearRelation</span>(Relation relation, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> rebuild)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As per notes above, a rel to be rebuilt MUST have refcnt &gt; 0; while of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * course it would be an equally bad idea to blow away one with nonzero<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * refcnt, since that would leave someone somewhere with a dangling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pointer.&nbsp; All callers are expected to have verified that this holds.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rebuild ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !RelationHasReferenceCountZero(relation) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationHasReferenceCountZero(relation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure smgr and <a href="../adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> levels close the relation's files, if they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * weren't closed already.&nbsp; If the relation is not getting deleted, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> smgr access should reopen the files automatically.&nbsp; This ensures<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that the low-level file access state is updated after, say, a <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * truncation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; RelationCloseSmgr(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Free AM cached data, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_amcache)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(relation-&gt;rd_amcache);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_amcache = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Treat nailed-in system relations separately, they always need to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * accessible, so we can't blow them away.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_isnailed)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2370" title="utils/cache/relcache.c:2370">RelationReloadNailed</a>(relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark it invalid until we've finished rebuild */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_isvalid = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See <a href="#L2873" title="utils/cache/relcache.c:2873">RelationForgetRelation</a>(). */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_droppedSubid != InvalidSubTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Even non-system indexes should not be blown away if they are open and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have valid index support information.&nbsp; This avoids problems with active<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use of the index support information.&nbsp; As with nailed indexes, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * re-read the pg_class row to handle possible physical relocation of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index, and we check for pg_index updates too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((relation-&gt;rd_rel-&gt;relkind == RELKIND_INDEX ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_INDEX) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_refcnt &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_indexcxt != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2256" title="utils/cache/relcache.c:2256">RelationReloadIndexInfo</a>(relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're really done with the relcache entry, blow it away. But if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * someone is still using it, reconstruct the whole deal without moving<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the physical RelationData record (so that the someone's pointer is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * still valid).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!rebuild)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remove it from the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L243" title="utils/cache/relcache.c:243">RelationCacheDelete</a>(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And release storage */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2442" title="utils/cache/relcache.c:2442">RelationDestroyRelation</a>(relation, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're not inside a valid transaction, we can't do <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> catalog<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * access so it's not possible to rebuild yet.&nbsp; Just exit, leaving<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rd_isvalid = false so that the rebuild will occur when the entry is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> opened.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: it's possible that we come here during subtransaction abort,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and the reason for wanting to rebuild is that the rel is open in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the outer transaction.&nbsp; In that case it might seem unsafe to not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rebuild immediately, since whatever code has the rel already open<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will keep on using the relcache entry as-is.&nbsp; However, in such a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case the outer transaction should be holding a lock that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sufficient to prevent <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> significant change in the rel's schema,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so the existing entry contents should be good enough for its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * purposes; at worst we might be behind on statistics updates or the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * like.&nbsp; (See also <a href="../../commands/tablecmds.c.html#L4346" title="commands/tablecmds.c:4346">CheckTableNotInUse</a>() and its callers.)&nbsp; &nbsp; These same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remarks also apply to the cases above where we exit without having<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * done <a href="#L2256" title="utils/cache/relcache.c:2256">RelationReloadIndexInfo</a>() yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Our strategy for rebuilding an open relcache entry is to build a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new entry from scratch, swap its contents with the old entry, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * finally delete the new entry (along with <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> infrastructure swapped<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * over from the old entry).&nbsp; This is to avoid trouble in case an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error causes us to lose control partway through.&nbsp; The old entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will still be marked !rd_isvalid, so we'll try to rebuild it again<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> access.&nbsp; Meanwhile it's not <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> less valid than it was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>, so <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> code that might expect to continue accessing it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * isn't hurt by the rebuild failure.&nbsp; (Consider for example a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subtransaction that ALTERs a table and then gets canceled partway<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * through the cache entry rebuild.&nbsp; The outer transaction should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still see the not-modified cache entry as valid.)&nbsp; The worst<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consequence of an error is leaking the necessarily-unreferenced new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry, and this shouldn't happen often enough for that to be a big<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * problem.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When rebuilding an open relcache entry, we must preserve ref count,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rd_*Subid, and rd_toastoid state.&nbsp; Also attempt to preserve the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_class entry (rd_rel), tupledesc, rewrite-rule, partition key,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and partition descriptor substructures in place, because various<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * places assume that these structures won't move while they are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * working with an open relcache entry.&nbsp; (Note:&nbsp; the refcount<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mechanism for tupledescs might someday allow us to remove this hack<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for the tupledesc.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that this process does not touch <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>; which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is good because whatever ref counts the entry may have do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * necessarily belong to that resource owner.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; newrel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_relid = RelationGetRelid(relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; keep_tupdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; keep_rules;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; keep_policies;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; keep_partkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Build temporary entry, but don't link it into hashtable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newrel = <a href="#L1039" title="utils/cache/relcache.c:1039">RelationBuildDesc</a>(save_relid, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Between here and the end of the swap, don't add code that does or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reasonably could read system catalogs.&nbsp; That <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> must be free<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from invalidation processing.&nbsp; See <a href="#L1039" title="utils/cache/relcache.c:1039">RelationBuildDesc</a>() manipulation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of <a href="#L170" title="utils/cache/relcache.c:170">in_progress_list</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newrel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can validly get here, if we're using a historic snapshot in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which a relation, accessed from outside logical decoding, is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still invisible. In that case it's fine to just mark the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation as invalid and return - it'll fully get reloaded by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the cache reset at the end of logical decoding (or at the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * access).&nbsp; During normal processing we don't want to ignore this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case as it shouldn't happen there, as explained below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../time/snapmgr.c.html#L1672" title="utils/time/snapmgr.c:1672">HistoricSnapshotActive</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This shouldn't happen as dropping a relation is intended to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * impossible if still referenced (cf. <a href="../../commands/tablecmds.c.html#L4346" title="commands/tablecmds.c:4346">CheckTableNotInUse</a>()). But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if we get here anyway, we can't just delete the relcache entry,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as it possibly could get accessed later (as e.g. the error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might get trapped and handled via a subtransaction rollback).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;relation </span><span class="Special">%u</span><span class="Constant"> deleted while still in use&quot;</span>, save_relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we were to, again, have cases of the relkind of a relcache entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changing, we would need to ensure that pgstats does not get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * confused.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(relation-&gt;rd_rel-&gt;relkind == newrel-&gt;rd_rel-&gt;relkind);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; keep_tupdesc = <a href="../../access/common/tupdesc.c.html#L419" title="access/common/tupdesc.c:419">equalTupleDescs</a>(relation-&gt;rd_att, newrel-&gt;rd_att);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; keep_rules = <a href="#L907" title="utils/cache/relcache.c:907">equalRuleLocks</a>(relation-&gt;rd_rules, newrel-&gt;rd_rules);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; keep_policies = <a href="#L998" title="utils/cache/relcache.c:998">equalRSDesc</a>(relation-&gt;rd_rsdesc, newrel-&gt;rd_rsdesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* partkey is immutable once set up, so we can always keep it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; keep_partkey = (relation-&gt;rd_partkey != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Perform swapping of the relcache entry contents.&nbsp; Within this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * process the old entry is momentarily invalid, so there *must* be no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possibility of CHECK_FOR_INTERRUPTS within this sequence. Do it in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all-in-line code for safety.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since the vast majority of fields should be swapped, our method is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to swap the whole structures and then re-swap those few fields we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * didn't want swapped.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li><a id="L2728">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SWAPFIELD</span>(fldtype, fldname) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fldtype _tmp = newrel-&gt;fldname; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newrel-&gt;fldname = relation-&gt;fldname; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;fldname = _tmp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* swap all Relation struct fields */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationData tmpstruct;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;tmpstruct, newrel, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelationData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(newrel, relation, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelationData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(relation, &amp;tmpstruct, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelationData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rd_smgr must not be swapped, due to back-links from smgr level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2728" title="utils/cache/relcache.c:2728">SWAPFIELD</a>(SMgrRelation, rd_smgr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rd_refcnt must be preserved */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2728" title="utils/cache/relcache.c:2728">SWAPFIELD</a>(<span class="Type">int</span>, rd_refcnt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* isnailed shouldn't change */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(newrel-&gt;rd_isnailed == relation-&gt;rd_isnailed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* creation sub-XIDs must be preserved */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2728" title="utils/cache/relcache.c:2728">SWAPFIELD</a>(SubTransactionId, rd_createSubid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2728" title="utils/cache/relcache.c:2728">SWAPFIELD</a>(SubTransactionId, rd_newRelfilelocatorSubid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2728" title="utils/cache/relcache.c:2728">SWAPFIELD</a>(SubTransactionId, rd_firstRelfilelocatorSubid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2728" title="utils/cache/relcache.c:2728">SWAPFIELD</a>(SubTransactionId, rd_droppedSubid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* un-swap rd_rel pointers, swap contents instead */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2728" title="utils/cache/relcache.c:2728">SWAPFIELD</a>(Form_pg_class, rd_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... but actually, we don't have to update newrel-&gt;rd_rel */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(relation-&gt;rd_rel, newrel-&gt;rd_rel, CLASS_TUPLE_SIZE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* preserve old tupledesc, rules, policies if no logical change */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (keep_tupdesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2728" title="utils/cache/relcache.c:2728">SWAPFIELD</a>(TupleDesc, rd_att);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (keep_rules)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2728" title="utils/cache/relcache.c:2728">SWAPFIELD</a>(RuleLock *, rd_rules);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2728" title="utils/cache/relcache.c:2728">SWAPFIELD</a>(MemoryContext, rd_rulescxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (keep_policies)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2728" title="utils/cache/relcache.c:2728">SWAPFIELD</a>(RowSecurityDesc *, rd_rsdesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* toast OID override must be preserved */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2728" title="utils/cache/relcache.c:2728">SWAPFIELD</a>(Oid, rd_toastoid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pgstat_info / enabled must be preserved */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2728" title="utils/cache/relcache.c:2728">SWAPFIELD</a>(<span class="Type">struct</span> PgStat_TableStatus *, pgstat_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2728" title="utils/cache/relcache.c:2728">SWAPFIELD</a>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>, pgstat_enabled);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* preserve old partition key if we have one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (keep_partkey)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2728" title="utils/cache/relcache.c:2728">SWAPFIELD</a>(PartitionKey, rd_partkey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2728" title="utils/cache/relcache.c:2728">SWAPFIELD</a>(MemoryContext, rd_partkeycxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newrel-&gt;rd_pdcxt != <span class="Constant">NULL</span> || newrel-&gt;rd_pddcxt != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are rebuilding a partitioned relation with a non-zero<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reference count, so we must keep the old partition descriptor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * around, in case there's a PartitionDirectory with a pointer to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it.&nbsp; This means we can't free the old rd_pdcxt yet.&nbsp; (This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * necessary because <a href="../../partitioning/partdesc.c.html#L70" title="partitioning/partdesc.c:70">RelationGetPartitionDesc</a> hands out direct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pointers to the relcache's data structure, unlike our usual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * practice which is to hand out copies.&nbsp; We'd have the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * problem with rd_partkey, except that we always preserve that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * once created.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To ensure that it's not leaked completely, re-attach it to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new reldesc, or make it a child of the new reldesc's rd_pdcxt<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the unlikely event that there is one already.&nbsp; (Compare hack<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in <a href="../../partitioning/partdesc.c.html#L133" title="partitioning/partdesc.c:133">RelationBuildPartitionDesc</a>.)&nbsp; <a href="#L2193" title="utils/cache/relcache.c:2193">RelationClose</a> will clean up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such contexts once the reference count reaches zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the case where the reference count is zero, this code is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reached, which should be OK because in that case there should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be no PartitionDirectory with a pointer to the old entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that newrel and relation have already been swapped, so the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;old&quot; partition descriptor is actually the one hanging off of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * newrel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_partdesc = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* ensure rd_partdesc is invalid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_partdesc_nodetached = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_partdesc_nodetached_xmin = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_pdcxt != <span class="Constant">NULL</span>) <span class="Comment">/* probably never happens */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L637" title="utils/mmgr/mcxt.c:637">MemoryContextSetParent</a>(newrel-&gt;rd_pdcxt, relation-&gt;rd_pdcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_pdcxt = newrel-&gt;rd_pdcxt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_pddcxt != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L637" title="utils/mmgr/mcxt.c:637">MemoryContextSetParent</a>(newrel-&gt;rd_pddcxt, relation-&gt;rd_pddcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_pddcxt = newrel-&gt;rd_pddcxt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* drop newrel's pointers so we don't destroy it below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newrel-&gt;rd_partdesc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newrel-&gt;rd_partdesc_nodetached = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newrel-&gt;rd_partdesc_nodetached_xmin = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newrel-&gt;rd_pdcxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newrel-&gt;rd_pddcxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><a id="L2826">&#x200c;</a><span class="PreProc">#undef <span class="linkable">SWAPFIELD</span><br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we can throw away the temporary entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2442" title="utils/cache/relcache.c:2442">RelationDestroyRelation</a>(newrel, !keep_tupdesc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2840" title="utils/cache/relcache.c:2840">RelationFlushRelation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Rebuild the relation if it is open (refcount &gt; 0), else blow it away.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; This is used when we receive a cache invalidation event for the rel.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2840">&#x200c;</a></span><span class="linkable">RelationFlushRelation</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_createSubid != InvalidSubTransactionId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_firstRelfilelocatorSubid != InvalidSubTransactionId)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * New relcache entries are always rebuilt, not flushed; else we'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * forget the &quot;new&quot; status of the relation.&nbsp; Ditto for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new-relfilenumber status.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The rel could have zero refcnt here, so temporarily increment the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * refcnt to ensure it's safe to rebuild it.&nbsp; We can assume that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current transaction has some lock on the rel already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2160" title="utils/cache/relcache.c:2160">RelationIncrementReferenceCount</a>(relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2535" title="utils/cache/relcache.c:2535">RelationClearRelation</a>(relation, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2173" title="utils/cache/relcache.c:2173">RelationDecrementReferenceCount</a>(relation);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pre-existing rels can be dropped from the relcache if not open.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; rebuild = !RelationHasReferenceCountZero(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2535" title="utils/cache/relcache.c:2535">RelationClearRelation</a>(relation, rebuild);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2873" title="utils/cache/relcache.c:2873">RelationForgetRelation</a> - caller reports that it dropped the relation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2873">&#x200c;</a></span><span class="linkable">RelationForgetRelation</span>(Oid rid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; relation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L231" title="utils/cache/relcache.c:231">RelationIdCacheLookup</a>(rid, relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PointerIsValid(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not in cache, nothing to do */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!RelationHasReferenceCountZero(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;relation </span><span class="Special">%u</span><span class="Constant"> is still open&quot;</span>, rid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(relation-&gt;rd_droppedSubid == InvalidSubTransactionId);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_createSubid != InvalidSubTransactionId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_firstRelfilelocatorSubid != InvalidSubTransactionId)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the event of subtransaction rollback, we must not forget<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rd_*Subid.&nbsp; Mark the entry &quot;dropped&quot; so <a href="#L2535" title="utils/cache/relcache.c:2535">RelationClearRelation</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * invalidates it in lieu of destroying it.&nbsp; (If we're in a top<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction, we could opt to destroy the entry.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_droppedSubid = <a href="../../access/transam/xact.c.html#L788" title="access/transam/xact.c:788">GetCurrentSubTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2535" title="utils/cache/relcache.c:2535">RelationClearRelation</a>(relation, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2917" title="utils/cache/relcache.c:2917">RelationCacheInvalidateEntry</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This routine is invoked for SI cache flush messages.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Any relcache entry matching the relid must be flushed.&nbsp; (Note: caller has<br/></li>
<li></span><span class="Comment"> * already determined that the relid belongs to our database or is a shared<br/></li>
<li></span><span class="Comment"> * relation.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We used to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> local relations, on the grounds that they could<br/></li>
<li></span><span class="Comment"> * not be targets of cross-backend SI update messages; but it seems<br/></li>
<li></span><span class="Comment"> * safer to process them, so that our *own* SI update messages will<br/></li>
<li></span><span class="Comment"> * have the same effects during <a href="../../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a> for both<br/></li>
<li></span><span class="Comment"> * local and nonlocal relations.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2917">&#x200c;</a></span><span class="linkable">RelationCacheInvalidateEntry</span>(Oid relationId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; relation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L231" title="utils/cache/relcache.c:231">RelationIdCacheLookup</a>(relationId, relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PointerIsValid(relation))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L154" title="utils/cache/relcache.c:154">relcacheInvalsReceived</a>++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2840" title="utils/cache/relcache.c:2840">RelationFlushRelation</a>(relation);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L171" title="utils/cache/relcache.c:171">in_progress_list_len</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L170" title="utils/cache/relcache.c:170">in_progress_list</a>[i].reloid == relationId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L170" title="utils/cache/relcache.c:170">in_progress_list</a>[i].invalidated = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2973" title="utils/cache/relcache.c:2973">RelationCacheInvalidate</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Blow away cached relation descriptors that have zero reference counts,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; and rebuild those with positive reference counts.&nbsp; Also reset the smgr<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; relation cache and re-read relation mapping data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Apart from <a href="inval.c.html#L240" title="utils/cache/inval.c:240">debug_discard_caches</a>, this is currently used only to recover<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; from SI message buffer overflow, so we do not touch relations having<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; new-in-transaction relfilenumbers; they cannot be targets of cross-backend<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; SI updates (and our own updates <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> go through a separate linked list<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; that isn't limited by the SI message buffer size).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; We do this in two phases: the first pass deletes deletable items, and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; the second one rebuilds the rebuildable items.&nbsp; This is essential for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; safety, because <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a> only copes with concurrent deletion of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> it is currently visiting.&nbsp; If a second SI overflow were to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; occur while we are walking the table, resulting in recursive entry to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; this routine, we could crash because the inner invocation blows away<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; the entry <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> to be visited by the outer scan.&nbsp; But this way is OK,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; because (a) during the first pass we won't process <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more SI messages,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; so <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a> will complete safely; (b) during the second pass we<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; only hold onto pointers to nondeletable entries.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; The two-phase approach also makes it easy to update relfilenumbers for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; mapped relations <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we do anything else, and to ensure that the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; second pass processes nailed-in-cache items <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> other nondeletable<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; items.&nbsp; This should ensure that system catalogs are up to date <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; we attempt to use them to reload information about other open relations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; After those two phases of work having immediate effects, we normally<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; signal <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="#L1039" title="utils/cache/relcache.c:1039">RelationBuildDesc</a>() on the stack to start over.&nbsp; However, we<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; don't do this if called as part of <a href="inval.c.html#L240" title="utils/cache/inval.c:240">debug_discard_caches</a>.&nbsp; Otherwise,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; <a href="#L1039" title="utils/cache/relcache.c:1039">RelationBuildDesc</a>() would become an infinite loop.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2973">&#x200c;</a></span><span class="linkable">RelationCacheInvalidate</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> debug_discard)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L132" title="utils/cache/relcache.c:132">RelIdCacheEnt</a> *idhentry;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; relation;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rebuildFirstList = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rebuildList = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reload relation mapping data <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> starting to reconstruct cache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="relmapper.c.html#L490" title="utils/cache/relmapper.c:490">RelationMapInvalidateAll</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Phase 1 */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L134" title="utils/cache/relcache.c:134">RelationIdCache</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((idhentry = (<a href="#L132" title="utils/cache/relcache.c:132">RelIdCacheEnt</a> *) <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation = idhentry-&gt;reldesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore new relations; no other backend will manipulate them <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we commit.&nbsp; Likewise, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> replacing a relation's relfilelocator,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we shall have acquired AccessExclusiveLock and drained <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * applicable pending invalidations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_createSubid != InvalidSubTransactionId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_firstRelfilelocatorSubid != InvalidSubTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L154" title="utils/cache/relcache.c:154">relcacheInvalsReceived</a>++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationHasReferenceCountZero(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> this entry immediately */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!relation-&gt;rd_isnailed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2535" title="utils/cache/relcache.c:2535">RelationClearRelation</a>(relation, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's a mapped relation, immediately update its rd_locator in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case its relfilenumber changed.&nbsp; We must do this during phase 1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in case the relation is consulted during rebuild of other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relcache entries in phase 2.&nbsp; It's safe since consulting the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * map doesn't involve <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> access to relcache entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationIsMapped(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1319" title="utils/cache/relcache.c:1319">RelationInitPhysicalAddr</a>(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add this entry to list of stuff to rebuild in second pass.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_class goes to the front of rebuildFirstList while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_class_oid_index goes to the back of rebuildFirstList, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * they are done first and second respectively.&nbsp; Other nailed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relations go to the front of rebuildList, so they'll be done<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> in no particular order; and everything else goes to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * back of rebuildList.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationGetRelid(relation) == RelationRelationId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rebuildFirstList = <a href="../../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(relation, rebuildFirstList);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (RelationGetRelid(relation) == ClassOidIndexId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rebuildFirstList = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rebuildFirstList, relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (relation-&gt;rd_isnailed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rebuildList = <a href="../../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(relation, rebuildList);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rebuildList = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rebuildList, relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We cannot destroy the SMgrRelations as there might still be references<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to them, but close the underlying file descriptors.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/smgr/smgr.c.html#L353" title="storage/smgr/smgr.c:353">smgrreleaseall</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Phase 2: rebuild the items found to need rebuild in phase 1 */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, rebuildFirstList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation = (Relation) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2535" title="utils/cache/relcache.c:2535">RelationClearRelation</a>(relation, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(rebuildFirstList);<br/></li>
<li>&nbsp; &nbsp; foreach(l, rebuildList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation = (Relation) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2535" title="utils/cache/relcache.c:2535">RelationClearRelation</a>(relation, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(rebuildList);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!debug_discard)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Any <a href="#L1039" title="utils/cache/relcache.c:1039">RelationBuildDesc</a>() on the stack must start over. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L171" title="utils/cache/relcache.c:171">in_progress_list_len</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L170" title="utils/cache/relcache.c:170">in_progress_list</a>[i].invalidated = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3072">&#x200c;</a></span><span class="linkable">RememberToFreeTupleDescAtEOX</span>(TupleDesc td)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L202" title="utils/cache/relcache.c:202">EOXactTupleDescArray</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L202" title="utils/cache/relcache.c:202">EOXactTupleDescArray</a> = (TupleDesc *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Constant">16</span> * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TupleDesc));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L204" title="utils/cache/relcache.c:204">EOXactTupleDescArrayLen</a> = <span class="Constant">16</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L203" title="utils/cache/relcache.c:203">NextEOXactTupleDescNum</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L203" title="utils/cache/relcache.c:203">NextEOXactTupleDescNum</a> &gt;= <a href="#L204" title="utils/cache/relcache.c:204">EOXactTupleDescArrayLen</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; newlen = <a href="#L204" title="utils/cache/relcache.c:204">EOXactTupleDescArrayLen</a> * <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L204" title="utils/cache/relcache.c:204">EOXactTupleDescArrayLen</a> &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L202" title="utils/cache/relcache.c:202">EOXactTupleDescArray</a> = (TupleDesc *) <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(<a href="#L202" title="utils/cache/relcache.c:202">EOXactTupleDescArray</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newlen * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TupleDesc));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L204" title="utils/cache/relcache.c:204">EOXactTupleDescArrayLen</a> = newlen;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L202" title="utils/cache/relcache.c:202">EOXactTupleDescArray</a>[<a href="#L203" title="utils/cache/relcache.c:203">NextEOXactTupleDescNum</a>++] = td;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3101">&#x200c;</a></span><span class="linkable">AssertPendingSyncConsistency</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; relcache_verdict =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelationIsPermanent(relation) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((relation-&gt;rd_createSubid != InvalidSubTransactionId &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RELKIND_HAS_STORAGE(relation-&gt;rd_rel-&gt;relkind)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_firstRelfilelocatorSubid != InvalidSubTransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(relcache_verdict == <a href="../../catalog/storage.c.html#L532" title="catalog/storage.c:532">RelFileLocatorSkippingWAL</a>(relation-&gt;rd_locator));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_droppedSubid != InvalidSubTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!relation-&gt;rd_isvalid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (relation-&gt;rd_createSubid != InvalidSubTransactionId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_firstRelfilelocatorSubid != InvalidSubTransactionId));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3123" title="utils/cache/relcache.c:3123">AssertPendingSyncs_RelationCache</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Assert that relcache.c and storage.c agree on whether to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> WAL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3123">&#x200c;</a></span><span class="linkable">AssertPendingSyncs_RelationCache</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; LOCALLOCK&nbsp; *locallock;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp;&nbsp; *rels;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxrels;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrels;<br/></li>
<li>&nbsp; &nbsp; <a href="#L132" title="utils/cache/relcache.c:132">RelIdCacheEnt</a> *idhentry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open every relation that this transaction has locked.&nbsp; If, for some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation, storage.c is skipping WAL and relcache.c is not skipping WAL,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a <a href="../../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>() typically yields a local invalidation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * message that destroys the relcache entry.&nbsp; By recreating such entries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here, we detect the problem.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../time/snapmgr.c.html#L648" title="utils/time/snapmgr.c:648">PushActiveSnapshot</a>(<a href="../time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>());<br/></li>
<li>&nbsp; &nbsp; maxrels = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; rels = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(maxrels * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*rels));<br/></li>
<li>&nbsp; &nbsp; nrels = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="../../storage/lmgr/lock.c.html#L610" title="storage/lmgr/lock.c:610">GetLockMethodLocalHash</a>());<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((locallock = (LOCALLOCK *) <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locallock-&gt;nLocks &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((LockTagType) locallock-&gt;tag.lock.locktag_type !=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKTAG_RELATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relid = ObjectIdGetDatum(locallock-&gt;tag.lock.locktag_field2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r = <a href="#L2062" title="utils/cache/relcache.c:2062">RelationIdGetRelation</a>(relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!RelationIsValid(r))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nrels &gt;= maxrels)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxrels *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rels = <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(rels, maxrels * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*rels));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rels[nrels++] = r;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L134" title="utils/cache/relcache.c:134">RelationIdCache</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((idhentry = (<a href="#L132" title="utils/cache/relcache.c:132">RelIdCacheEnt</a> *) <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3101" title="utils/cache/relcache.c:3101">AssertPendingSyncConsistency</a>(idhentry-&gt;reldesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nrels; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2193" title="utils/cache/relcache.c:2193">RelationClose</a>(rels[i]);<br/></li>
<li>&nbsp; &nbsp; <a href="../time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3194" title="utils/cache/relcache.c:3194">AtEOXact_RelationCache</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Clean up the relcache at <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a>-transaction commit or abort.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this must be called *<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>* processing invalidation messages.<br/></li>
<li></span><span class="Comment"> * In the case of abort, we don't want to try to rebuild <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> invalidated<br/></li>
<li></span><span class="Comment"> * cache entries (since we can't safely do database accesses).&nbsp; Therefore<br/></li>
<li></span><span class="Comment"> * we must reset refcnts <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> handling pending invalidations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As of PostgreSQL 8.1, relcache refcnts should get released by the<br/></li>
<li></span><span class="Comment"> * ResourceOwner mechanism.&nbsp; This routine just does a debugging<br/></li>
<li></span><span class="Comment"> * cross-check that no pins remain.&nbsp; However, we also need to do special<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> when the current transaction created <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> relations or made use<br/></li>
<li></span><span class="Comment"> * of forced index lists.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3194">&#x200c;</a></span><span class="linkable">AtEOXact_RelationCache</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L132" title="utils/cache/relcache.c:132">RelIdCacheEnt</a> *idhentry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Forget <a href="#L170" title="utils/cache/relcache.c:170">in_progress_list</a>.&nbsp; This is relevant when we're aborting due to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an error during <a href="#L1039" title="utils/cache/relcache.c:1039">RelationBuildDesc</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L171" title="utils/cache/relcache.c:171">in_progress_list_len</a> == <span class="Constant">0</span> || !isCommit);<br/></li>
<li>&nbsp; &nbsp; <a href="#L171" title="utils/cache/relcache.c:171">in_progress_list_len</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unless the <a href="#L185" title="utils/cache/relcache.c:185">eoxact_list</a>[] overflowed, we only need to examine the rels<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * listed in it.&nbsp; Otherwise fall back on a <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a> scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For simplicity, <a href="#L185" title="utils/cache/relcache.c:185">eoxact_list</a>[] entries are not deleted till end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * top-level transaction, even though we could remove them at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subtransaction end in some cases, or remove relations from the list if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they are cleared for other reasons.&nbsp; Therefore we should expect the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case that list entries are not found in the hashtable; if not, there's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nothing to do for them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L187" title="utils/cache/relcache.c:187">eoxact_list_overflowed</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L134" title="utils/cache/relcache.c:134">RelationIdCache</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((idhentry = (<a href="#L132" title="utils/cache/relcache.c:132">RelIdCacheEnt</a> *) <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3264" title="utils/cache/relcache.c:3264">AtEOXact_cleanup</a>(idhentry-&gt;reldesc, isCommit);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L186" title="utils/cache/relcache.c:186">eoxact_list_len</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idhentry = (<a href="#L132" title="utils/cache/relcache.c:132">RelIdCacheEnt</a> *) <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L134" title="utils/cache/relcache.c:134">RelationIdCache</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="#L185" title="utils/cache/relcache.c:185">eoxact_list</a>[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_FIND,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (idhentry != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3264" title="utils/cache/relcache.c:3264">AtEOXact_cleanup</a>(idhentry-&gt;reldesc, isCommit);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L204" title="utils/cache/relcache.c:204">EOXactTupleDescArrayLen</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L202" title="utils/cache/relcache.c:202">EOXactTupleDescArray</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L203" title="utils/cache/relcache.c:203">NextEOXactTupleDescNum</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L331" title="access/common/tupdesc.c:331">FreeTupleDesc</a>(<a href="#L202" title="utils/cache/relcache.c:202">EOXactTupleDescArray</a>[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="#L202" title="utils/cache/relcache.c:202">EOXactTupleDescArray</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L202" title="utils/cache/relcache.c:202">EOXactTupleDescArray</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we're out of the transaction and can clear the lists */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L186" title="utils/cache/relcache.c:186">eoxact_list_len</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L187" title="utils/cache/relcache.c:187">eoxact_list_overflowed</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L203" title="utils/cache/relcache.c:203">NextEOXactTupleDescNum</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L204" title="utils/cache/relcache.c:204">EOXactTupleDescArrayLen</a> = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3264" title="utils/cache/relcache.c:3264">AtEOXact_cleanup</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Clean up a single rel at <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a>-transaction commit or abort<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: this processing must be idempotent, because <a href="#L189" title="utils/cache/relcache.c:189">EOXactListAdd</a>() doesn't<br/></li>
<li></span><span class="Comment"> * bother to prevent duplicate entries in <a href="#L185" title="utils/cache/relcache.c:185">eoxact_list</a>[].<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3264">&#x200c;</a></span><span class="linkable">AtEOXact_cleanup</span>(Relation relation, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; clear_relcache = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The relcache entry's ref count should be back to its normal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not-in-a-transaction state: 0 unless it's nailed in cache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In bootstrap mode, this is NOT true, so don't check it --- the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bootstrap code expects relations to stay open across start/commit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction calls.&nbsp; (That seems bogus, but it's not worth fixing.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: ideally this check would be applied to every relcache entry, not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just those that have eoxact work to do.&nbsp; But it's not worth forcing a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan of the whole relcache just for this.&nbsp; (Moreover, doing so would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mean that assert-enabled testing never tests the <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a> code path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * above, which seems a bad idea.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expected_refcnt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expected_refcnt = relation-&gt;rd_isnailed ? <span class="Constant">1</span> : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(relation-&gt;rd_refcnt == expected_refcnt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Is the relation live after this transaction ends?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During commit, clear the relcache entry if it is preserved after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation drop, in order not to orphan the entry.&nbsp; During rollback,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clear the relcache entry if the relation is created in the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction since it isn't interesting <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> longer once we are out of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; clear_relcache =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (isCommit ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_droppedSubid != InvalidSubTransactionId :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_createSubid != InvalidSubTransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we are <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> out of the transaction, reset the subids to zero. That<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * also lets <a href="#L2535" title="utils/cache/relcache.c:2535">RelationClearRelation</a>() drop the relcache entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_createSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_newRelfilelocatorSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_firstRelfilelocatorSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_droppedSubid = InvalidSubTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (clear_relcache)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationHasReferenceCountZero(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2535" title="utils/cache/relcache.c:2535">RelationClearRelation</a>(relation, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Hmm, somewhere there's a (leaked?) reference to the relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We daren't remove the entry for fear of dereferencing a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dangling pointer later.&nbsp; Bleat, and mark it as not belonging to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the current transaction.&nbsp; Hopefully it'll get cleaned up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * eventually.&nbsp; This must be just a WARNING to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error-during-error-recovery loops.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;cannot remove relcache entry for </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> because it has nonzero refcount&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(relation));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3346" title="utils/cache/relcache.c:3346">AtEOSubXact_RelationCache</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Clean up the relcache at sub-transaction commit or abort.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this must be called *<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>* processing invalidation messages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3346">&#x200c;</a></span><span class="linkable">AtEOSubXact_RelationCache</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit, SubTransactionId mySubid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SubTransactionId parentSubid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L132" title="utils/cache/relcache.c:132">RelIdCacheEnt</a> *idhentry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Forget <a href="#L170" title="utils/cache/relcache.c:170">in_progress_list</a>.&nbsp; This is relevant when we're aborting due to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an error during <a href="#L1039" title="utils/cache/relcache.c:1039">RelationBuildDesc</a>().&nbsp; We don't commit subtransactions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during <a href="#L1039" title="utils/cache/relcache.c:1039">RelationBuildDesc</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L171" title="utils/cache/relcache.c:171">in_progress_list_len</a> == <span class="Constant">0</span> || !isCommit);<br/></li>
<li>&nbsp; &nbsp; <a href="#L171" title="utils/cache/relcache.c:171">in_progress_list_len</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unless the <a href="#L185" title="utils/cache/relcache.c:185">eoxact_list</a>[] overflowed, we only need to examine the rels<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * listed in it.&nbsp; Otherwise fall back on a <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a> scan.&nbsp; Same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * logic as in <a href="#L3194" title="utils/cache/relcache.c:3194">AtEOXact_RelationCache</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L187" title="utils/cache/relcache.c:187">eoxact_list_overflowed</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L134" title="utils/cache/relcache.c:134">RelationIdCache</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((idhentry = (<a href="#L132" title="utils/cache/relcache.c:132">RelIdCacheEnt</a> *) <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3401" title="utils/cache/relcache.c:3401">AtEOSubXact_cleanup</a>(idhentry-&gt;reldesc, isCommit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mySubid, parentSubid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L186" title="utils/cache/relcache.c:186">eoxact_list_len</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idhentry = (<a href="#L132" title="utils/cache/relcache.c:132">RelIdCacheEnt</a> *) <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L134" title="utils/cache/relcache.c:134">RelationIdCache</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="#L185" title="utils/cache/relcache.c:185">eoxact_list</a>[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_FIND,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (idhentry != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3401" title="utils/cache/relcache.c:3401">AtEOSubXact_cleanup</a>(idhentry-&gt;reldesc, isCommit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mySubid, parentSubid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't reset the list; we still need more <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> later */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3401" title="utils/cache/relcache.c:3401">AtEOSubXact_cleanup</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Clean up a single rel at subtransaction commit or abort<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: this processing must be idempotent, because <a href="#L189" title="utils/cache/relcache.c:189">EOXactListAdd</a>() doesn't<br/></li>
<li></span><span class="Comment"> * bother to prevent duplicate entries in <a href="#L185" title="utils/cache/relcache.c:185">eoxact_list</a>[].<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3401">&#x200c;</a></span><span class="linkable">AtEOSubXact_cleanup</span>(Relation relation, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SubTransactionId mySubid, SubTransactionId parentSubid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Is it a relation created in the current subtransaction?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During subcommit, mark it as belonging to the parent, instead, as long<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as it has not been dropped. Otherwise simply delete the relcache entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * --- it isn't interesting <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> longer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_createSubid == mySubid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Valid rd_droppedSubid means the corresponding relation is dropped<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but the relcache entry is preserved for at-commit pending sync. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to drop it explicitly here not to make the entry orphan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(relation-&gt;rd_droppedSubid == mySubid ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_droppedSubid == InvalidSubTransactionId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isCommit &amp;&amp; relation-&gt;rd_droppedSubid == InvalidSubTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_createSubid = parentSubid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (RelationHasReferenceCountZero(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allow the entry to be removed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_createSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_newRelfilelocatorSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_firstRelfilelocatorSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_droppedSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2535" title="utils/cache/relcache.c:2535">RelationClearRelation</a>(relation, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Hmm, somewhere there's a (leaked?) reference to the relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We daren't remove the entry for fear of dereferencing a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dangling pointer later.&nbsp; Bleat, and transfer it to the parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subtransaction so we can try again later.&nbsp; This must be just a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WARNING to avoid error-during-error-recovery loops.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_createSubid = parentSubid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;cannot remove relcache entry for </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> because it has nonzero refcount&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(relation));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likewise, update or drop <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new-relfilenumber-in-subtransaction record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or drop record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_newRelfilelocatorSubid == mySubid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isCommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_newRelfilelocatorSubid = parentSubid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_newRelfilelocatorSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_firstRelfilelocatorSubid == mySubid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isCommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_firstRelfilelocatorSubid = parentSubid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_firstRelfilelocatorSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_droppedSubid == mySubid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isCommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_droppedSubid = parentSubid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_droppedSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3483" title="utils/cache/relcache.c:3483">RelationBuildLocalRelation</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Build a relcache entry for an about-to-be-created relation,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and enter it into the relcache.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Relation<br/></li>
<li><a id="L3483">&#x200c;</a><span class="linkable">RelationBuildLocalRelation</span>(<span class="Type">const</span> <span class="Type">char</span> *relname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid relnamespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleDesc tupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid accessmtd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelFileNumber relfilenumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid reltablespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> shared_relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> mapped_relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> relpersistence,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> relkind)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; natts = tupDesc-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_not_null;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nailit;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(natts &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check for creation of a rel that must be nailed in cache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> this list had better match the relations specially handled in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L3997" title="utils/cache/relcache.c:3997">RelationCacheInitializePhase2</a>/3.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (relid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DatabaseRelationId:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AuthIdRelationId:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AuthMemRelationId:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RelationRelationId:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AttributeRelationId:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ProcedureRelationId:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TypeRelationId:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nailit = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nailit = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check that hardwired list of shared rels matches what's in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bootstrap .bki file.&nbsp; If you get a failure here during initdb, you<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * probably need to fix <a href="../../catalog/catalog.c.html#L243" title="catalog/catalog.c:243">IsSharedRelation</a>() to match whatever you've done<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the set of shared relations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (shared_relation != <a href="../../catalog/catalog.c.html#L243" title="catalog/catalog.c:243">IsSharedRelation</a>(relid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;shared_relation flag for </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not match <a href="../../catalog/catalog.c.html#L243" title="catalog/catalog.c:243">IsSharedRelation</a>(</span><span class="Special">%u</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relname, relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shared relations had better be mapped, too */<br/></li>
<li></span>&nbsp; &nbsp; Assert(mapped_relation || !shared_relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * switch to the cache context to create the relcache entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="catcache.c.html#L679" title="utils/cache/catcache.c:679">CreateCacheMemoryContext</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocate a new relation descriptor and fill in basic state fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rel = (Relation) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelationData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure relation is marked as having no open file yet */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;rd_smgr = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* mark it nailed if appropriate */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;rd_isnailed = nailit;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel-&gt;rd_refcnt = nailit ? <span class="Constant">1</span> : <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* it's being created in this transaction */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;rd_createSubid = <a href="../../access/transam/xact.c.html#L788" title="access/transam/xact.c:788">GetCurrentSubTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; rel-&gt;rd_newRelfilelocatorSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;rd_firstRelfilelocatorSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;rd_droppedSubid = InvalidSubTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create a new tuple descriptor from the one passed in.&nbsp; We do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partly to copy it into the cache context, and partly because the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation can't have <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> defaults or constraints yet; they have to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * added in later steps, because they require additions to multiple system<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catalogs.&nbsp; We can copy attnotnull constraints here, however.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;rd_att = <a href="../../access/common/tupdesc.c.html#L133" title="access/common/tupdesc.c:133">CreateTupleDescCopy</a>(tupDesc);<br/></li>
<li>&nbsp; &nbsp; rel-&gt;rd_att-&gt;tdrefcount = <span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* mark as refcounted */<br/></li>
<li></span>&nbsp; &nbsp; has_not_null = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute satt = TupleDescAttr(tupDesc, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute datt = TupleDescAttr(rel-&gt;rd_att, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datt-&gt;attidentity = satt-&gt;attidentity;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datt-&gt;attgenerated = satt-&gt;attgenerated;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datt-&gt;attnotnull = satt-&gt;attnotnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; has_not_null |= satt-&gt;attnotnull;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (has_not_null)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleConstr *constr = (TupleConstr *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TupleConstr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constr-&gt;has_not_null = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_att-&gt;constr = constr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> relation tuple form (caller may add/override data later)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;rd_rel = (Form_pg_class) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(CLASS_TUPLE_SIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../adt/name.c.html#L233" title="utils/adt/name.c:233">namestrcpy</a>(&amp;rel-&gt;rd_rel-&gt;relname, relname);<br/></li>
<li>&nbsp; &nbsp; rel-&gt;rd_rel-&gt;relnamespace = relnamespace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel-&gt;rd_rel-&gt;relkind = relkind;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;rd_rel-&gt;relnatts = natts;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;rd_rel-&gt;reltype = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* needed when bootstrapping: */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;rd_rel-&gt;relowner = BOOTSTRAP_SUPERUSERID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set up persistence and relcache fields dependent on it */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;rd_rel-&gt;relpersistence = relpersistence;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (relpersistence)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELPERSISTENCE_UNLOGGED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELPERSISTENCE_PERMANENT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_backend = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_islocaltemp = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELPERSISTENCE_TEMP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../catalog/namespace.c.html#L3658" title="catalog/namespace.c:3658">isTempOrTempToastNamespace</a>(relnamespace));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_backend = ProcNumberForTempRelations();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_islocaltemp = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid relpersistence: </span><span class="Special">%c</span><span class="Constant">&quot;</span>, relpersistence);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if it's a materialized view, it's not populated initially */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relkind == RELKIND_MATVIEW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relispopulated = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relispopulated = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set replica identity -- system catalogs and non-tables don't have one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../catalog/catalog.c.html#L182" title="catalog/catalog.c:182">IsCatalogNamespace</a>(relnamespace) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (relkind == RELKIND_RELATION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relkind == RELKIND_MATVIEW ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relkind == RELKIND_PARTITIONED_TABLE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relreplident = REPLICA_IDENTITY_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relreplident = REPLICA_IDENTITY_NOTHING;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> relation physical and logical identifiers (OIDs) into the right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * places.&nbsp; For a mapped relation, we set relfilenumber to zero and rely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on <a href="#L1319" title="utils/cache/relcache.c:1319">RelationInitPhysicalAddr</a> to consult the map.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;rd_rel-&gt;relisshared = shared_relation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; RelationGetRelid(rel) = relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; natts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDescAttr(rel-&gt;rd_att, i)-&gt;attrelid = relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel-&gt;rd_rel-&gt;reltablespace = reltablespace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mapped_relation)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relfilenode = InvalidRelFileNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add it to the active mapping information */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="relmapper.c.html#L325" title="utils/cache/relmapper.c:325">RelationMapUpdateMap</a>(relid, relfilenumber, shared_relation, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relfilenode = relfilenumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L71" title="storage/lmgr/lmgr.c:71">RelationInitLockInfo</a>(rel);&nbsp; &nbsp; <span class="Comment">/* see lmgr.c */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L1319" title="utils/cache/relcache.c:1319">RelationInitPhysicalAddr</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel-&gt;rd_rel-&gt;relam = accessmtd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1809" title="utils/cache/relcache.c:1809">RelationInitTableAccessMethod</a> will do syscache lookups, so we mustn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * run it in <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>.&nbsp; Fortunately, the remaining steps don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * require a long-lived current context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RELKIND_HAS_TABLE_AM(relkind) || relkind == RELKIND_SEQUENCE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1809" title="utils/cache/relcache.c:1809">RelationInitTableAccessMethod</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Okay to insert into the relcache <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ordinarily, there should certainly not be an existing <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> entry for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same OID; but during bootstrap, when we create a &quot;real&quot; relcache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entry for one of the bootstrap relations, we'll be overwriting the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * phony one created with <a href="#L1874" title="utils/cache/relcache.c:1874">formrdesc</a>.&nbsp; So allow that to happen for nailed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L209" title="utils/cache/relcache.c:209">RelationCacheInsert</a>(rel, nailit);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Flag relation as needing eoxact <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> (to clear rd_createSubid). We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> storing relid in it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L189" title="utils/cache/relcache.c:189">EOXactListAdd</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* It's fully valid */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;rd_isvalid = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Caller expects us to pin the returned entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2160" title="utils/cache/relcache.c:2160">RelationIncrementReferenceCount</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3726" title="utils/cache/relcache.c:3726">RelationSetNewRelfilenumber</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Assign a new relfilenumber (physical file name), and possibly a new<br/></li>
<li></span><span class="Comment"> * persistence setting, to the relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This allows a full rewrite of the relation to be done with transactional<br/></li>
<li></span><span class="Comment"> * safety (since the filenumber assignment can be rolled back).&nbsp; Note however<br/></li>
<li></span><span class="Comment"> * that there is no simple way to access the relation's old data for the<br/></li>
<li></span><span class="Comment"> * remainder of the current transaction.&nbsp; This limits the usefulness to cases<br/></li>
<li></span><span class="Comment"> * such as TRUNCATE or rebuilding an index from scratch.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must already hold exclusive lock on the relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3726">&#x200c;</a></span><span class="linkable">RelationSetNewRelfilenumber</span>(Relation relation, <span class="Type">char</span> persistence)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelFileNumber newrelfilenumber;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pg_class;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_class classform;<br/></li>
<li>&nbsp; &nbsp; MultiXactId minmulti = InvalidMultiXactId;<br/></li>
<li>&nbsp; &nbsp; TransactionId freezeXid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator newrlocator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../init/globals.c.html#L118" title="utils/init/globals.c:118">IsBinaryUpgrade</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allocate a new relfilenumber */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newrelfilenumber = <a href="../../catalog/catalog.c.html#L500" title="catalog/catalog.c:500">GetNewRelFileNumber</a>(relation-&gt;rd_rel-&gt;reltablespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, persistence);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relkind == RELKIND_INDEX)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(<a href="../../catalog/index.c.html#L85" title="catalog/index.c:85">binary_upgrade_next_index_pg_class_relfilenumber</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index relfilenumber value not set when in binary upgrade mode&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newrelfilenumber = <a href="../../catalog/index.c.html#L85" title="catalog/index.c:85">binary_upgrade_next_index_pg_class_relfilenumber</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/index.c.html#L85" title="catalog/index.c:85">binary_upgrade_next_index_pg_class_relfilenumber</a> = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relkind == RELKIND_RELATION)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(<a href="../../catalog/heap.c.html#L82" title="catalog/heap.c:82">binary_upgrade_next_heap_pg_class_relfilenumber</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;heap relfilenumber value not set when in binary upgrade mode&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newrelfilenumber = <a href="../../catalog/heap.c.html#L82" title="catalog/heap.c:82">binary_upgrade_next_heap_pg_class_relfilenumber</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L82" title="catalog/heap.c:82">binary_upgrade_next_heap_pg_class_relfilenumber</a> = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected request for new relfilenumber in binary upgrade mode&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get a writable copy of the pg_class tuple for the given relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_class = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = SearchSysCacheCopy1(RELOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(relation)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> tuple for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(relation));<br/></li>
<li>&nbsp; &nbsp; classform = (Form_pg_class) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Schedule unlinking of the old storage at transaction commit, except<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when performing a binary upgrade, when we must do it immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../init/globals.c.html#L118" title="utils/init/globals.c:118">IsBinaryUpgrade</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SMgrRelation srel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * During a binary upgrade, we use this code path to ensure that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_largeobject and its index have the same relfilenumbers as in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * old <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>. This is necessary because pg_upgrade treats<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_largeobject like a user table, not a system table. It is however<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible that a table or index may need to end up with the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relfilenumber in the new <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> as what it had in the old <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Hence, we can't wait until commit time to remove the old storage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In general, this function needs to have transactional semantics,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and removing the old storage <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> commit time surely isn't.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, it doesn't really matter, because if a binary upgrade<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fails at this stage, the new <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> will need to be recreated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; srel = <a href="../../storage/smgr/smgr.c.html#L198" title="storage/smgr/smgr.c:198">smgropen</a>(relation-&gt;rd_locator, relation-&gt;rd_backend);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/smgr/smgr.c.html#L462" title="storage/smgr/smgr.c:462">smgrdounlinkall</a>(&amp;srel, <span class="Constant">1</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/smgr/smgr.c.html#L320" title="storage/smgr/smgr.c:320">smgrclose</a>(srel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not a binary upgrade, so just schedule it to happen later. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/storage.c.html#L206" title="catalog/storage.c:206">RelationDropStorage</a>(relation);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create storage for the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> fork of the new relfilenumber.&nbsp; If it's a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table-like object, call into the table AM to do so, which'll also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create the table's init fork if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: If relevant for the AM, <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> conflict in relfilenumber value will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be caught here, if <a href="../../catalog/catalog.c.html#L500" title="catalog/catalog.c:500">GetNewRelFileNumber</a> messes up for <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> reason.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newrlocator = relation-&gt;rd_locator;<br/></li>
<li>&nbsp; &nbsp; newrlocator.relNumber = newrelfilenumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RELKIND_HAS_TABLE_AM(relation-&gt;rd_rel-&gt;relkind))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; table_relation_set_new_filelocator(relation, &amp;newrlocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; persistence,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;freezeXid, &amp;minmulti);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (RELKIND_HAS_STORAGE(relation-&gt;rd_rel-&gt;relkind))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* handle these directly, at least for <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SMgrRelation srel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; srel = <a href="../../catalog/storage.c.html#L121" title="catalog/storage.c:121">RelationCreateStorage</a>(newrlocator, persistence, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/smgr/smgr.c.html#L320" title="storage/smgr/smgr.c:320">smgrclose</a>(srel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we shouldn't be called for anything else */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not have storage&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(relation));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're dealing with a mapped index, pg_class.relfilenode doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * change; instead we have to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the update to the relation mapper.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For mapped indexes, we don't actually change the pg_class entry at all;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this is essential when reindexing pg_class itself.&nbsp; That leaves us with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possibly-inaccurate <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of relpages etc, but those will be fixed up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationIsMapped(relation))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This case is only supported for indexes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(relation-&gt;rd_rel-&gt;relkind == RELKIND_INDEX);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Since we're not updating pg_class, these had better not change */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(classform-&gt;relfrozenxid == freezeXid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(classform-&gt;relminmxid == minmulti);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(classform-&gt;relpersistence == persistence);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In some code paths it's possible that the tuple update we'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise do here is the only thing that would assign an XID for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the current transaction.&nbsp; However, we must have an XID to delete<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * files, so make sure one is assigned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../access/transam/xact.c.html#L451" title="access/transam/xact.c:451">GetCurrentTransactionId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do the deed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="relmapper.c.html#L325" title="utils/cache/relmapper.c:325">RelationMapUpdateMap</a>(RelationGetRelid(relation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newrelfilenumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_rel-&gt;relisshared,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Since we're not updating pg_class, must <a href="../adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> inval manually */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="inval.c.html#L1360" title="utils/cache/inval.c:1360">CacheInvalidateRelcache</a>(relation);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Normal case, update the pg_class entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; classform-&gt;relfilenode = newrelfilenumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* relpages etc. never change for sequences */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relkind != RELKIND_SEQUENCE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classform-&gt;relpages = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* it's empty until further notice */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classform-&gt;reltuples = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classform-&gt;relallvisible = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; classform-&gt;relfrozenxid = freezeXid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; classform-&gt;relminmxid = minmulti;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; classform-&gt;relpersistence = persistence;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(pg_class, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_class, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make the pg_class row change or relation map change visible.&nbsp; This will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cause the relcache entry to get updated, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3925" title="utils/cache/relcache.c:3925">RelationAssumeNewRelfilelocator</a>(relation);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3925" title="utils/cache/relcache.c:3925">RelationAssumeNewRelfilelocator</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Code that modifies pg_class.reltablespace or pg_class.relfilenode must call<br/></li>
<li></span><span class="Comment"> * this.&nbsp; The call shall precede <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> code that might insert WAL <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> whose<br/></li>
<li></span><span class="Comment"> * replay would modify bytes in the new RelFileLocator, and the call shall follow<br/></li>
<li></span><span class="Comment"> * <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WAL modifying bytes in the prior RelFileLocator.&nbsp; See struct RelationData.<br/></li>
<li></span><span class="Comment"> * Ideally, call this as near as possible to the <a href="../../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>()<br/></li>
<li></span><span class="Comment"> * that makes the pg_class change visible (<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it or after it); that<br/></li>
<li></span><span class="Comment"> * minimizes the chance of future development adding a forbidden WAL insertion<br/></li>
<li></span><span class="Comment"> * between <a href="#L3925" title="utils/cache/relcache.c:3925">RelationAssumeNewRelfilelocator</a>() and <a href="../../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3925">&#x200c;</a></span><span class="linkable">RelationAssumeNewRelfilelocator</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_newRelfilelocatorSubid = <a href="../../access/transam/xact.c.html#L788" title="access/transam/xact.c:788">GetCurrentSubTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_firstRelfilelocatorSubid == InvalidSubTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_firstRelfilelocatorSubid = relation-&gt;rd_newRelfilelocatorSubid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Flag relation as needing eoxact <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> (to clear these fields) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L189" title="utils/cache/relcache.c:189">EOXactListAdd</a>(relation);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3951" title="utils/cache/relcache.c:3951">RelationCacheInitialize</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This initializes the relation descriptor cache.&nbsp; At the time<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; that this is invoked, we can't do database access yet (mainly<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; because the transaction subsystem is not up); all we are doing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; is making an empty cache hashtable.&nbsp; This must be done <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; starting the initialization transaction, because otherwise<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3194" title="utils/cache/relcache.c:3194">AtEOXact_RelationCache</a> would crash if that transaction aborts<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can get the relcache set up.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L3948">&#x200c;</a><span class="PreProc">#define <span class="linkable">INITRELCACHESIZE</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">400<br/></li>
<li></span><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L3951">&#x200c;</a></span><span class="linkable">RelationCacheInitialize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allocsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * make sure cache memory context exists<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="catcache.c.html#L679" title="utils/cache/catcache.c:679">CreateCacheMemoryContext</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create hashtable that indexes the relcache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid);<br/></li>
<li>&nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L132" title="utils/cache/relcache.c:132">RelIdCacheEnt</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L134" title="utils/cache/relcache.c:134">RelationIdCache</a> = <a href="../hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;Relcache by OID&quot;</span>, <a href="#L3948" title="utils/cache/relcache.c:3948">INITRELCACHESIZE</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;ctl, HASH_ELEM | HASH_BLOBS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reserve enough <a href="#L170" title="utils/cache/relcache.c:170">in_progress_list</a> slots for many cases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; allocsize = <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L170" title="utils/cache/relcache.c:170">in_progress_list</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; allocsize * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*<a href="#L170" title="utils/cache/relcache.c:170">in_progress_list</a>));<br/></li>
<li>&nbsp; &nbsp; <a href="#L172" title="utils/cache/relcache.c:172">in_progress_list_maxlen</a> = allocsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation mapper needs to be initialized too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="relmapper.c.html#L651" title="utils/cache/relmapper.c:651">RelationMapInitialize</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3997" title="utils/cache/relcache.c:3997">RelationCacheInitializePhase2</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is called to prepare for access to shared catalogs during startup.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We must at least set up nailed reldescs for pg_database, pg_authid,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pg_auth_members, and pg_shseclabel. Ideally we'd like to have reldescs<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; for their indexes, too.&nbsp; We attempt to load this information from the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; shared relcache init file.&nbsp; If that's missing or broken, just make<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; phony entries for the catalogs themselves.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4056" title="utils/cache/relcache.c:4056">RelationCacheInitializePhase3</a> will clean up as needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3997">&#x200c;</a></span><span class="linkable">RelationCacheInitializePhase2</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation mapper needs initialized too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="relmapper.c.html#L671" title="utils/cache/relmapper.c:671">RelationMapInitializePhase2</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In bootstrap mode, the shared catalogs aren't there yet anyway, so do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nothing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * switch to cache memory context<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to load the shared relcache cache file.&nbsp; If unsuccessful, bootstrap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the cache with pre-made descriptors for the critical shared catalogs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L6063" title="utils/cache/relcache.c:6063">load_relcache_init_file</a>(<span class="Constant">true</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1874" title="utils/cache/relcache.c:1874">formrdesc</a>(<span class="Constant">&quot;pg_database&quot;</span>, DatabaseRelation_Rowtype_Id, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Natts_pg_database, <a href="#L115" title="utils/cache/relcache.c:115">Desc_pg_database</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1874" title="utils/cache/relcache.c:1874">formrdesc</a>(<span class="Constant">&quot;pg_authid&quot;</span>, AuthIdRelation_Rowtype_Id, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Natts_pg_authid, <a href="#L116" title="utils/cache/relcache.c:116">Desc_pg_authid</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1874" title="utils/cache/relcache.c:1874">formrdesc</a>(<span class="Constant">&quot;pg_auth_members&quot;</span>, AuthMemRelation_Rowtype_Id, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Natts_pg_auth_members, <a href="#L117" title="utils/cache/relcache.c:117">Desc_pg_auth_members</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1874" title="utils/cache/relcache.c:1874">formrdesc</a>(<span class="Constant">&quot;pg_shseclabel&quot;</span>, SharedSecLabelRelation_Rowtype_Id, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Natts_pg_shseclabel, <a href="#L119" title="utils/cache/relcache.c:119">Desc_pg_shseclabel</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1874" title="utils/cache/relcache.c:1874">formrdesc</a>(<span class="Constant">&quot;pg_subscription&quot;</span>, SubscriptionRelation_Rowtype_Id, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Natts_pg_subscription, <a href="#L120" title="utils/cache/relcache.c:120">Desc_pg_subscription</a>);<br/></li>
<li><br/></li>
<li><a id="L4035">&#x200c;</a><span class="PreProc">#define <span class="linkable">NUM_CRITICAL_SHARED_RELS</span>&nbsp; &nbsp; </span><span class="Constant">5</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* fix if you change list above */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4056" title="utils/cache/relcache.c:4056">RelationCacheInitializePhase3</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is called as soon as the catcache and transaction system<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; are functional and we have determined <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>.&nbsp; At this point<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; we can actually read data from the database's system catalogs.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We first try to read pre-computed relcache entries from the local<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; relcache init file.&nbsp; If that's missing or broken, make phony entries<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; for the minimum set of nailed-in-cache relations.&nbsp; Then (unless<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; bootstrapping) make sure we have entries for the critical system<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; indexes.&nbsp; Once we've done all this, we have enough infrastructure to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; open <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> system catalog or use <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> catcache.&nbsp; The last step is to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; rewrite the cache files if needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4056">&#x200c;</a></span><span class="linkable">RelationCacheInitializePhase3</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L132" title="utils/cache/relcache.c:132">RelIdCacheEnt</a> *idhentry;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needNewCacheFile = !<a href="#L146" title="utils/cache/relcache.c:146">criticalSharedRelcachesBuilt</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation mapper needs initialized too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="relmapper.c.html#L692" title="utils/cache/relmapper.c:692">RelationMapInitializePhase3</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * switch to cache memory context<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to load the local relcache cache file.&nbsp; If unsuccessful, bootstrap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the cache with pre-made descriptors for the critical &quot;nailed-in&quot; system<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catalogs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode() ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L6063" title="utils/cache/relcache.c:6063">load_relcache_init_file</a>(<span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; needNewCacheFile = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1874" title="utils/cache/relcache.c:1874">formrdesc</a>(<span class="Constant">&quot;pg_class&quot;</span>, RelationRelation_Rowtype_Id, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Natts_pg_class, <a href="#L111" title="utils/cache/relcache.c:111">Desc_pg_class</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1874" title="utils/cache/relcache.c:1874">formrdesc</a>(<span class="Constant">&quot;pg_attribute&quot;</span>, AttributeRelation_Rowtype_Id, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Natts_pg_attribute, <a href="#L112" title="utils/cache/relcache.c:112">Desc_pg_attribute</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1874" title="utils/cache/relcache.c:1874">formrdesc</a>(<span class="Constant">&quot;pg_proc&quot;</span>, ProcedureRelation_Rowtype_Id, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Natts_pg_proc, <a href="#L113" title="utils/cache/relcache.c:113">Desc_pg_proc</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1874" title="utils/cache/relcache.c:1874">formrdesc</a>(<span class="Constant">&quot;pg_type&quot;</span>, TypeRelation_Rowtype_Id, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Natts_pg_type, <a href="#L114" title="utils/cache/relcache.c:114">Desc_pg_type</a>);<br/></li>
<li><br/></li>
<li><a id="L4092">&#x200c;</a><span class="PreProc">#define <span class="linkable">NUM_CRITICAL_LOCAL_RELS</span> </span><span class="Constant">4</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* fix if you change list above */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* In bootstrap mode, the faked-up <a href="#L1874" title="utils/cache/relcache.c:1874">formrdesc</a> info is all we'll have */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we didn't get the critical system indexes loaded into relcache, do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; These are critical because the catcache and/or opclass cache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * depend on them for fetches done during relcache load.&nbsp; Thus, we have an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * infinite-recursion problem.&nbsp; We can break the recursion by doing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * heapscans instead of indexscans at certain key spots. To avoid hobbling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * performance, we only want to do that until we have the critical indexes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loaded into relcache.&nbsp; Thus, the flag <a href="#L140" title="utils/cache/relcache.c:140">criticalRelcachesBuilt</a> is used to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decide whether to do heapscan or indexscan at the key spots, and we set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it true after we've loaded the critical indexes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The critical indexes are marked as &quot;nailed in cache&quot;, partly to make it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * easy for <a href="#L6063" title="utils/cache/relcache.c:6063">load_relcache_init_file</a> to count them, but mainly because we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cannot flush and rebuild them once we've set <a href="#L140" title="utils/cache/relcache.c:140">criticalRelcachesBuilt</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * true.&nbsp; (<a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: perhaps it would be possible to reload them by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * temporarily setting <a href="#L140" title="utils/cache/relcache.c:140">criticalRelcachesBuilt</a> to false again.&nbsp; For <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * though, we just nail 'em in.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RewriteRelRulenameIndexId and TriggerRelidNameIndexId are not critical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the same way as the others, because the critical catalogs don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (currently) have <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> rules or triggers, and so these indexes can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rebuilt without inducing recursion.&nbsp; However they are used during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relcache load when a rel does have rules or triggers, so we choose to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nail them for performance reasons.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L140" title="utils/cache/relcache.c:140">criticalRelcachesBuilt</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4341" title="utils/cache/relcache.c:4341">load_critical_index</a>(ClassOidIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationRelationId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4341" title="utils/cache/relcache.c:4341">load_critical_index</a>(AttributeRelidNumIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttributeRelationId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4341" title="utils/cache/relcache.c:4341">load_critical_index</a>(IndexRelidIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexRelationId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4341" title="utils/cache/relcache.c:4341">load_critical_index</a>(OpclassOidIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OperatorClassRelationId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4341" title="utils/cache/relcache.c:4341">load_critical_index</a>(AccessMethodProcedureIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AccessMethodProcedureRelationId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4341" title="utils/cache/relcache.c:4341">load_critical_index</a>(RewriteRelRulenameIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RewriteRelationId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4341" title="utils/cache/relcache.c:4341">load_critical_index</a>(TriggerRelidNameIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TriggerRelationId);<br/></li>
<li><br/></li>
<li><a id="L4143">&#x200c;</a><span class="PreProc">#define <span class="linkable">NUM_CRITICAL_LOCAL_INDEXES</span>&nbsp; &nbsp; </span><span class="Constant">7</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* fix if you change list above */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="utils/cache/relcache.c:140">criticalRelcachesBuilt</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Process critical shared indexes too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * DatabaseNameIndexId isn't critical for relcache loading, but rather for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initial lookup of <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>, without which we'll never <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-shared catalogs at all.&nbsp; Autovacuum calls <a href="../init/postinit.c.html#L736" title="utils/init/postinit.c:736">InitPostgres</a> with a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * database OID, so it instead depends on DatabaseOidIndexId.&nbsp; We also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to nail up some indexes on pg_authid and pg_auth_members for use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during client authentication.&nbsp; SharedSecLabelObjectIndexId isn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * critical for the core system, but authentication hooks might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interested in it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L146" title="utils/cache/relcache.c:146">criticalSharedRelcachesBuilt</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4341" title="utils/cache/relcache.c:4341">load_critical_index</a>(DatabaseNameIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatabaseRelationId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4341" title="utils/cache/relcache.c:4341">load_critical_index</a>(DatabaseOidIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatabaseRelationId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4341" title="utils/cache/relcache.c:4341">load_critical_index</a>(AuthIdRolnameIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AuthIdRelationId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4341" title="utils/cache/relcache.c:4341">load_critical_index</a>(AuthIdOidIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AuthIdRelationId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4341" title="utils/cache/relcache.c:4341">load_critical_index</a>(AuthMemMemRoleIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AuthMemRelationId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4341" title="utils/cache/relcache.c:4341">load_critical_index</a>(SharedSecLabelObjectIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SharedSecLabelRelationId);<br/></li>
<li><br/></li>
<li><a id="L4175">&#x200c;</a><span class="PreProc">#define <span class="linkable">NUM_CRITICAL_SHARED_INDEXES</span> </span><span class="Constant">6</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* fix if you change list above */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L146" title="utils/cache/relcache.c:146">criticalSharedRelcachesBuilt</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now, scan all the relcache entries and update anything that might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wrong in the results from <a href="#L1874" title="utils/cache/relcache.c:1874">formrdesc</a> or the relcache cache file. If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * faked up relcache entries using <a href="#L1874" title="utils/cache/relcache.c:1874">formrdesc</a>, then read the real pg_class<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rows and replace the fake entries with them. Also, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relcache entries have rules, triggers, or security policies, load that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * info the hard way since it isn't recorded in the cache file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Whenever we access the catalogs to read data, there is a possibility of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a shared-inval cache flush causing relcache entries to be removed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a> only guarantees to still work after the *current*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entry is removed, it's unsafe to continue the hashtable scan afterward.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We handle this by restarting the scan from scratch after each access.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is theoretically O(N^2), but the number of entries that actually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to be fixed is small enough that it doesn't matter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L134" title="utils/cache/relcache.c:134">RelationIdCache</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((idhentry = (<a href="#L132" title="utils/cache/relcache.c:132">RelIdCacheEnt</a> *) <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; relation = idhentry-&gt;reldesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; restart = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure *this* entry doesn't get flushed while we work with it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2160" title="utils/cache/relcache.c:2160">RelationIncrementReferenceCount</a>(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's a faked-up entry, read the real pg_class tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relowner == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; htup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class relp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; htup = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(RelationGetRelid(relation)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(htup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(relation)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relp = (Form_pg_class) GETSTRUCT(htup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy tuple to relation-&gt;rd_rel. (See notes in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L408" title="utils/cache/relcache.c:408">AllocateRelationDesc</a>())<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy((<span class="Type">char</span> *) relation-&gt;rd_rel, (<span class="Type">char</span> *) relp, CLASS_TUPLE_SIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update rd_options while we have the tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_options)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(relation-&gt;rd_options);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L463" title="utils/cache/relcache.c:463">RelationParseRelOptions</a>(relation, htup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in rd_att were set up correctly.&nbsp; (We cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just copy them over <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>: <a href="#L1874" title="utils/cache/relcache.c:1874">formrdesc</a> must have set up the rd_att<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * data correctly to start with, because it may already have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * copied into one or more catcache entries.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(relation-&gt;rd_att-&gt;tdtypeid == relp-&gt;reltype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(relation-&gt;rd_att-&gt;tdtypmod == -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(htup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* relowner had better be OK <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, else we'll loop forever */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relowner == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid relowner in pg_class entry for </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(relation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restart = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fix data that isn't saved in relcache cache file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relhasrules or relhastriggers could possibly be wrong or out of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * date.&nbsp; If we don't actually <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> rules or triggers, clear the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * local copy of the flag so that we don't get into an infinite loop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here.&nbsp; We don't make <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> attempt to fix the pg_class entry, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relhasrules &amp;&amp; relation-&gt;rd_rules == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L732" title="utils/cache/relcache.c:732">RelationBuildRuleLock</a>(relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rules == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;relhasrules = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restart = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relhastriggers &amp;&amp; relation-&gt;trigdesc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/trigger.c.html#L1856" title="commands/trigger.c:1856">RelationBuildTriggers</a>(relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;trigdesc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;relhastriggers = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restart = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Re-load the row security policies if the relation has them, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * they are not preserved in the cache.&nbsp; Note that we can never NOT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have a policy while relrowsecurity is true,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../commands/policy.c.html#L193" title="commands/policy.c:193">RelationBuildRowSecurity</a> will create a single default-deny policy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if there is no policy defined in pg_policy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relrowsecurity &amp;&amp; relation-&gt;rd_rsdesc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/policy.c.html#L193" title="commands/policy.c:193">RelationBuildRowSecurity</a>(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(relation-&gt;rd_rsdesc != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restart = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reload tableam data if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_tableam == <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (RELKIND_HAS_TABLE_AM(relation-&gt;rd_rel-&gt;relkind) || relation-&gt;rd_rel-&gt;relkind == RELKIND_SEQUENCE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1809" title="utils/cache/relcache.c:1809">RelationInitTableAccessMethod</a>(relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(relation-&gt;rd_tableam != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restart = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release hold on the relation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2173" title="utils/cache/relcache.c:2173">RelationDecrementReferenceCount</a>(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now, restart the hashtable scan if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (restart)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1471" title="utils/hash/dynahash.c:1471">hash_seq_term</a>(&amp;status);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L134" title="utils/cache/relcache.c:134">RelationIdCache</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lastly, write out new relcache cache files if needed.&nbsp; We don't bother<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to distinguish cases where only one of the two needs an update.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (needNewCacheFile)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Force all the catcaches to finish initializing and thereby open the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * catalogs and indexes they use.&nbsp; This will preload the relcache with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entries for all the most important system catalogs and indexes, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that the init files will be most useful for future backends.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L177" title="utils/cache/syscache.c:177">InitCatalogCachePhase2</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> write the files */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6479" title="utils/cache/relcache.c:6479">write_relcache_init_file</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6479" title="utils/cache/relcache.c:6479">write_relcache_init_file</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Load one critical system index into the relcache<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * indexoid is the OID of the target index, heapoid is the OID of the catalog<br/></li>
<li></span><span class="Comment"> * it belongs to.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4341">&#x200c;</a></span><span class="linkable">load_critical_index</span>(Oid indexoid, Oid heapoid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; ird;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must lock the underlying catalog <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> locking the index to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deadlock, since <a href="#L1039" title="utils/cache/relcache.c:1039">RelationBuildDesc</a> might well need to read the catalog,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and if anyone else is exclusive-locking this catalog and index they'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be doing it in that order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a>(heapoid, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a>(indexoid, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; ird = <a href="#L1039" title="utils/cache/relcache.c:1039">RelationBuildDesc</a>(indexoid, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ird == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;could not open critical system index </span><span class="Special">%u</span><span class="Constant">&quot;</span>, indexoid));<br/></li>
<li>&nbsp; &nbsp; ird-&gt;rd_isnailed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; ird-&gt;rd_refcnt = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L227" title="storage/lmgr/lmgr.c:227">UnlockRelationOid</a>(indexoid, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L227" title="storage/lmgr/lmgr.c:227">UnlockRelationOid</a>(heapoid, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L5884" title="utils/cache/relcache.c:5884">RelationGetIndexAttOptions</a>(ird, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4409" title="utils/cache/relcache.c:4409">GetPgClassDescriptor</a> -- get a predefined tuple descriptor for pg_class<br/></li>
<li></span><span class="Comment"> * <a href="#L4422" title="utils/cache/relcache.c:4422">GetPgIndexDescriptor</a> -- get a predefined tuple descriptor for pg_index<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We need this kluge because we have to be able to access non-fixed-width<br/></li>
<li></span><span class="Comment"> * fields of pg_class and pg_index <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we have the standard catalog caches<br/></li>
<li></span><span class="Comment"> * available.&nbsp; We use predefined data that's set up in just the same way as<br/></li>
<li></span><span class="Comment"> * the bootstrapped reldescs used by <a href="#L1874" title="utils/cache/relcache.c:1874">formrdesc</a>().&nbsp; The resulting tupdesc is<br/></li>
<li></span><span class="Comment"> * not 100% kosher: it does not have the correct rowtype OID in tdtypeid, nor<br/></li>
<li></span><span class="Comment"> * does it have a TupleConstr field.&nbsp; But it's good enough for the purpose of<br/></li>
<li></span><span class="Comment"> * extracting fields.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TupleDesc<br/></li>
<li><a id="L4379">&#x200c;</a><span class="linkable">BuildHardcodedDescriptor</span>(<span class="Type">int</span> natts, <span class="Type">const</span> FormData_pg_attribute *attrs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../../access/common/tupdesc.c.html#L67" title="access/common/tupdesc.c:67">CreateTemplateTupleDesc</a>(natts);<br/></li>
<li>&nbsp; &nbsp; result-&gt;tdtypeid = RECORDOID;&nbsp; &nbsp; <span class="Comment">/* not right, but we don't care */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;tdtypmod = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(TupleDescAttr(result, i), &amp;attrs[i], ATTRIBUTE_FIXED_PART_SIZE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure attcacheoff is valid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; TupleDescAttr(result, i)-&gt;attcacheoff = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> first attribute's attcacheoff, cf <a href="#L520" title="utils/cache/relcache.c:520">RelationBuildTupleDesc</a> */<br/></li>
<li></span>&nbsp; &nbsp; TupleDescAttr(result, <span class="Constant">0</span>)-&gt;attcacheoff = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note: we don't bother to set up a TupleConstr entry */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> TupleDesc<br/></li>
<li><a id="L4409">&#x200c;</a><span class="linkable">GetPgClassDescriptor</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> TupleDesc pgclassdesc = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Already done? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pgclassdesc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgclassdesc = <a href="#L4379" title="utils/cache/relcache.c:4379">BuildHardcodedDescriptor</a>(Natts_pg_class,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L111" title="utils/cache/relcache.c:111">Desc_pg_class</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pgclassdesc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> TupleDesc<br/></li>
<li><a id="L4422">&#x200c;</a><span class="linkable">GetPgIndexDescriptor</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> TupleDesc pgindexdesc = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Already done? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pgindexdesc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgindexdesc = <a href="#L4379" title="utils/cache/relcache.c:4379">BuildHardcodedDescriptor</a>(Natts_pg_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L118" title="utils/cache/relcache.c:118">Desc_pg_index</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pgindexdesc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Load <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> default attribute value definitions for the relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ndef is the number of attributes that were marked atthasdef.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we don't make it a hard error to be missing some pg_attrdef <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment"> * We can limp along as long as nothing needs to use the default value.&nbsp; Code<br/></li>
<li></span><span class="Comment"> * that fails to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an expected AttrDefault record should throw an error.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4444">&#x200c;</a></span><span class="linkable">AttrDefaultFetch</span>(Relation relation, <span class="Type">int</span> ndef)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AttrDefault *attrdef;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; adrel;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc adscan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData skey;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; htup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate array with room for as many entries as expected */<br/></li>
<li></span>&nbsp; &nbsp; attrdef = (AttrDefault *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ndef * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrDefault));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Search pg_attrdef for relevant entries */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_attrdef_adrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(relation)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; adrel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttrDefaultRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; adscan = <a href="../../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(adrel, AttrDefaultIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">1</span>, &amp;skey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(htup = <a href="../../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(adscan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attrdef adform = (Form_pg_attrdef) GETSTRUCT(htup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* protect limited size of array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found &gt;= ndef)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;unexpected pg_attrdef record found for attribute </span><span class="Special">%d</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; adform-&gt;adnum, RelationGetRelationName(relation));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; val = fastgetattr(htup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_attrdef_adbin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; adrel-&gt;rd_att, &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;null adbin for attribute </span><span class="Special">%d</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; adform-&gt;adnum, RelationGetRelationName(relation));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* detoast and convert to cstring in caller's context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s = TextDatumGetCString(val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrdef[found].adnum = adform-&gt;adnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrdef[found].adbin = <a href="../mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(adscan);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(adrel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (found != ndef)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant"> pg_attrdef record(s) missing for relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ndef - found, RelationGetRelationName(relation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sort the AttrDefault entries by adnum, for the convenience of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../access/common/tupdesc.c.html#L419" title="access/common/tupdesc.c:419">equalTupleDescs</a>().&nbsp; (Usually, they already will be in order, but this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might not be so if <a href="../../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a> isn't using an index.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (found &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qsort(attrdef, found, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrDefault), <a href="#L4524" title="utils/cache/relcache.c:4524">AttrDefaultCmp</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Install array only after it's fully valid */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_att-&gt;constr-&gt;defval = attrdef;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_att-&gt;constr-&gt;num_defval = found;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * qsort comparator to sort AttrDefault entries by adnum<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L4524">&#x200c;</a></span><span class="linkable">AttrDefaultCmp</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> AttrDefault *ada = (<span class="Type">const</span> AttrDefault *) a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> AttrDefault *adb = (<span class="Type">const</span> AttrDefault *) b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_cmp_s16(ada-&gt;adnum, adb-&gt;adnum);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Load <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> check constraints for the relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As with defaults, if we don't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the expected number of them, just warn<br/></li>
<li></span><span class="Comment"> * here.&nbsp; The executor should throw an error if an INSERT/UPDATE is attempted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4539">&#x200c;</a></span><span class="linkable">CheckConstraintFetch</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ConstrCheck *check;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncheck = relation-&gt;rd_rel-&gt;relchecks;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; conrel;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc conscan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData skey[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; htup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate array with room for as many entries as expected */<br/></li>
<li></span>&nbsp; &nbsp; check = (ConstrCheck *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ncheck * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ConstrCheck));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Search pg_constraint for relevant entries */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_conrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(relation)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; conrel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(ConstraintRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; conscan = <a href="../../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(conrel, ConstraintRelidTypidNameIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">1</span>, skey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(htup = <a href="../../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(conscan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint conform = (Form_pg_constraint) GETSTRUCT(htup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We want check constraints only */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (conform-&gt;contype != CONSTRAINT_CHECK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* protect limited size of array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found &gt;= ncheck)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;unexpected pg_constraint record found for relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(relation));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; check[found].ccvalid = conform-&gt;convalidated;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; check[found].ccnoinherit = conform-&gt;connoinherit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; check[found].ccname = <a href="../mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(conform-&gt;conname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Grab and test conbin is actually set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; val = fastgetattr(htup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_conbin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conrel-&gt;rd_att, &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;null conbin for relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(relation));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* detoast and convert to cstring in caller's context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s = TextDatumGetCString(val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; check[found].ccbin = <a href="../mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(conscan);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(conrel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (found != ncheck)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant"> pg_constraint record(s) missing for relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ncheck - found, RelationGetRelationName(relation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sort the <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> by name.&nbsp; This ensures that CHECKs are applied in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deterministic order, and it also makes <a href="../../access/common/tupdesc.c.html#L419" title="access/common/tupdesc.c:419">equalTupleDescs</a>() faster.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (found &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qsort(check, found, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ConstrCheck), <a href="#L4628" title="utils/cache/relcache.c:4628">CheckConstraintCmp</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Install array only after it's fully valid */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_att-&gt;constr-&gt;check = check;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_att-&gt;constr-&gt;num_check = found;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * qsort comparator to sort ConstrCheck entries by name<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L4628">&#x200c;</a></span><span class="linkable">CheckConstraintCmp</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> ConstrCheck *ca = (<span class="Type">const</span> ConstrCheck *) a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> ConstrCheck *cb = (<span class="Type">const</span> ConstrCheck *) b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> strcmp(ca-&gt;ccname, cb-&gt;ccname);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4651" title="utils/cache/relcache.c:4651">RelationGetFKeyList</a> -- get a list of foreign key info for the relation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a list of ForeignKeyCacheInfo structs, one per FK constraining<br/></li>
<li></span><span class="Comment"> * the given relation.&nbsp; This data is a direct copy of relevant fields from<br/></li>
<li></span><span class="Comment"> * pg_constraint.&nbsp; The list items are in no particular order.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * CAUTION: the returned list is part of the relcache's data, and could<br/></li>
<li></span><span class="Comment"> * vanish in a relcache entry reset.&nbsp; Callers must inspect or copy it<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> doing anything that might <a href="../adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> a cache flush, such as<br/></li>
<li></span><span class="Comment"> * system catalog accesses.&nbsp; copyObject() can be used if desired.<br/></li>
<li></span><span class="Comment"> * (We define it this way because current callers want to filter and<br/></li>
<li></span><span class="Comment"> * modify the list entries anyway, so copying would be a waste of time.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L4651">&#x200c;</a><span class="linkable">RelationGetFKeyList</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; conrel;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc conscan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData skey;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; htup;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *oldlist;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick exit if we already computed the list. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_fkeyvalid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> relation-&gt;rd_fkeylist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fast path: non-partitioned tables without triggers can't have FKs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!relation-&gt;rd_rel-&gt;relhastriggers &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;relkind != RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We build the list we intend to return (in the caller's context) while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doing the scan.&nbsp; After successfully completing the scan, we copy that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list into the relcache entry.&nbsp; This avoids cache-context memory leakage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we get some sort of error partway through.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare to scan pg_constraint for entries having conrelid = this rel. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_conrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(relation)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; conrel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(ConstraintRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; conscan = <a href="../../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(conrel, ConstraintRelidTypidNameIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">1</span>, &amp;skey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(htup = <a href="../../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(conscan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint constraint = (Form_pg_constraint) GETSTRUCT(htup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ForeignKeyCacheInfo *info;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* consider only foreign keys */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (constraint-&gt;contype != CONSTRAINT_FOREIGN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info = makeNode(ForeignKeyCacheInfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info-&gt;conoid = constraint-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info-&gt;conrelid = constraint-&gt;conrelid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info-&gt;confrelid = constraint-&gt;confrelid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/pg_constraint.c.html#L1669" title="catalog/pg_constraint.c:1669">DeconstructFkConstraintRow</a>(htup, &amp;info-&gt;nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; info-&gt;conkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; info-&gt;confkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; info-&gt;conpfeqop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add FK's node to the result list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, info);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(conscan);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(conrel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now save a copy of the completed list in the relcache entry. */<br/></li>
<li></span>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; oldlist = relation-&gt;rd_fkeylist;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_fkeylist = copyObject(result);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_fkeyvalid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't leak the old list, if there is one */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1560" title="nodes/list.c:1560">list_free_deep</a>(oldlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a> -- get a list of OIDs of indexes on this relation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The index list is created only if someone requests it.&nbsp; We scan pg_index<br/></li>
<li></span><span class="Comment"> * to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> relevant indexes, and add the list to the relcache entry so that<br/></li>
<li></span><span class="Comment"> * we won't have to compute it again.&nbsp; Note that shared cache inval of a<br/></li>
<li></span><span class="Comment"> * relcache entry will delete the old list and set rd_indexvalid to false,<br/></li>
<li></span><span class="Comment"> * so that we must recompute the index list on <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> request.&nbsp; This handles<br/></li>
<li></span><span class="Comment"> * creation or deletion of an index.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Indexes that are marked not indislive are omitted from the returned list.<br/></li>
<li></span><span class="Comment"> * Such indexes are expected to be dropped momentarily, and should not be<br/></li>
<li></span><span class="Comment"> * touched at all by <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> caller of this function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned list is guaranteed to be sorted in order by OID.&nbsp; This is<br/></li>
<li></span><span class="Comment"> * needed by the executor, since for index types that we obtain exclusive<br/></li>
<li></span><span class="Comment"> * locks on when updating the index, all backends must lock the indexes in<br/></li>
<li></span><span class="Comment"> * the same order or we will get deadlocks (see <a href="../../executor/execIndexing.c.html#L156" title="executor/execIndexing.c:156">ExecOpenIndices</a>()).&nbsp; Any<br/></li>
<li></span><span class="Comment"> * consistent ordering would do, but ordering by OID is easy.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since shared cache inval causes the relcache's copy of the list to go away,<br/></li>
<li></span><span class="Comment"> * we return a copy of the list <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d in the caller's context.&nbsp; The caller<br/></li>
<li></span><span class="Comment"> * may <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>() the returned list after scanning it. This is necessary<br/></li>
<li></span><span class="Comment"> * since the caller will typically be doing syscache lookups on the relevant<br/></li>
<li></span><span class="Comment"> * indexes, and syscache lookup could cause SI messages to be processed!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In exactly the same way, we update rd_pkindex, which is the OID of the<br/></li>
<li></span><span class="Comment"> * relation's primary key index if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, else InvalidOid; and rd_replidindex,<br/></li>
<li></span><span class="Comment"> * which is the pg_class OID of an index to be used as the relation's<br/></li>
<li></span><span class="Comment"> * replication identity index, or InvalidOid if there is no such index.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L4760">&#x200c;</a><span class="linkable">RelationGetIndexList</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; indrel;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc indscan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData skey;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; htup;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *oldlist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; replident = relation-&gt;rd_rel-&gt;relreplident;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkeyIndex = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; candidateIndex = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; pkdeferrable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick exit if we already computed the list. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_indexvalid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(relation-&gt;rd_indexlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We build the list we intend to return (in the caller's context) while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doing the scan.&nbsp; After successfully completing the scan, we copy that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list into the relcache entry.&nbsp; This avoids cache-context memory leakage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we get some sort of error partway through.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare to scan pg_index for entries having indrelid = this rel. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_index_indrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(relation)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indrel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(IndexRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; indscan = <a href="../../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(indrel, IndexIndrelidIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">1</span>, &amp;skey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(htup = <a href="../../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(indscan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_index index = (Form_pg_index) GETSTRUCT(htup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> indexes that are currently being dropped.&nbsp; This will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prevent them from being searched, inserted into, or considered in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * HOT-safety decisions.&nbsp; It's unsafe to touch such an index at all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since its catalog entries could disappear at <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> instant.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!index-&gt;indislive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* add index's OID to result list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(result, index-&gt;indexrelid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Non-unique or predicate indexes aren't interesting for either oid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indexes or replication identity indexes, so don't check them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Deferred ones are not useful for replication identity either; but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we do include them if they are PKs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!index-&gt;indisunique ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../access/common/heaptuple.c.html#L455" title="access/common/heaptuple.c:455">heap_attisnull</a>(htup, Anum_pg_index_indpred, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember primary key index, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.&nbsp; We do this only if the index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is valid; but if the table is partitioned, then we do it even if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's invalid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The reason for returning invalid primary keys for foreign tables is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because of pg_dump of NOT NULL constraints, and the fact that PKs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remain marked invalid until the partitions' PKs are attached to it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we make rd_pkindex invalid, then the attnotnull flag is reset<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * after the PK is created, which causes the ALTER INDEX ATTACH<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PARTITION to fail with 'column ... is not marked NOT NULL'.&nbsp; With<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this, <a href="../../commands/tablecmds.c.html#L12940" title="commands/tablecmds.c:12940">dropconstraint_internal</a>() will believe that the columns must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not have attnotnull reset, so the PKs-on-partitions can be attached<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * correctly, until finally the PK-on-parent is marked valid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also, this doesn't harm anything, because rd_pkindex is not a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;real&quot; index anyway, but a RELKIND_PARTITIONED_INDEX.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;indisprimary &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (index-&gt;indisvalid ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkeyIndex = index-&gt;indexrelid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkdeferrable = !index-&gt;indimmediate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!index-&gt;indimmediate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!index-&gt;indisvalid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remember explicitly chosen replica index */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;indisreplident)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; candidateIndex = index-&gt;indexrelid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(indscan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(indrel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort the result list into OID order, per API spec. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1674" title="nodes/list.c:1674">list_sort</a>(result, <a href="../../nodes/list.c.html#L1703" title="nodes/list.c:1703">list_oid_cmp</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now save a copy of the completed list in the relcache entry. */<br/></li>
<li></span>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; oldlist = relation-&gt;rd_indexlist;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_indexlist = <a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(result);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_pkindex = pkeyIndex;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_ispkdeferrable = pkdeferrable;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (replident == REPLICA_IDENTITY_DEFAULT &amp;&amp; OidIsValid(pkeyIndex) &amp;&amp; !pkdeferrable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_replidindex = pkeyIndex;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (replident == REPLICA_IDENTITY_INDEX &amp;&amp; OidIsValid(candidateIndex))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_replidindex = candidateIndex;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_replidindex = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_indexvalid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't leak the old list, if there is one */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(oldlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4909" title="utils/cache/relcache.c:4909">RelationGetStatExtList</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; get a list of OIDs of statistics objects on this relation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The statistics list is created only if someone requests it, in a way<br/></li>
<li></span><span class="Comment"> * similar to <a href="#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>().&nbsp; We scan pg_statistic_ext to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a><br/></li>
<li></span><span class="Comment"> * relevant statistics, and add the list to the relcache entry so that we<br/></li>
<li></span><span class="Comment"> * won't have to compute it again.&nbsp; Note that shared cache inval of a<br/></li>
<li></span><span class="Comment"> * relcache entry will delete the old list and set rd_statvalid to 0,<br/></li>
<li></span><span class="Comment"> * so that we must recompute the statistics list on <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> request.&nbsp; This<br/></li>
<li></span><span class="Comment"> * handles creation or deletion of a statistics object.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned list is guaranteed to be sorted in order by OID, although<br/></li>
<li></span><span class="Comment"> * this is not currently needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since shared cache inval causes the relcache's copy of the list to go away,<br/></li>
<li></span><span class="Comment"> * we return a copy of the list <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d in the caller's context.&nbsp; The caller<br/></li>
<li></span><span class="Comment"> * may <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>() the returned list after scanning it. This is necessary<br/></li>
<li></span><span class="Comment"> * since the caller will typically be doing syscache lookups on the relevant<br/></li>
<li></span><span class="Comment"> * statistics, and syscache lookup could cause SI messages to be processed!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L4909">&#x200c;</a><span class="linkable">RelationGetStatExtList</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; indrel;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc indscan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData skey;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; htup;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *oldlist;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick exit if we already computed the list. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_statvalid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(relation-&gt;rd_statlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We build the list we intend to return (in the caller's context) while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doing the scan.&nbsp; After successfully completing the scan, we copy that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list into the relcache entry.&nbsp; This avoids cache-context memory leakage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we get some sort of error partway through.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare to scan pg_statistic_ext for entries having stxrelid = this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_statistic_ext_stxrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationGetRelid(relation)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indrel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(StatisticExtRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; indscan = <a href="../../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(indrel, StatisticExtRelidIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">1</span>, &amp;skey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(htup = <a href="../../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(indscan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oid = ((Form_pg_statistic_ext) GETSTRUCT(htup))-&gt;oid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(result, oid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(indscan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(indrel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort the result list into OID order, per API spec. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1674" title="nodes/list.c:1674">list_sort</a>(result, <a href="../../nodes/list.c.html#L1703" title="nodes/list.c:1703">list_oid_cmp</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now save a copy of the completed list in the relcache entry. */<br/></li>
<li></span>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; oldlist = relation-&gt;rd_statlist;<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_statlist = <a href="../../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_statvalid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't leak the old list, if there is one */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(oldlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4979" title="utils/cache/relcache.c:4979">RelationGetPrimaryKeyIndex</a> -- get OID of the relation's primary key index<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns InvalidOid if there is no such index, or if the primary key is<br/></li>
<li></span><span class="Comment"> * DEFERRABLE.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L4979">&#x200c;</a><span class="linkable">RelationGetPrimaryKeyIndex</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *ilist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!relation-&gt;rd_indexvalid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a> does the heavy lifting. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ilist = <a href="#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>(relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(ilist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(relation-&gt;rd_indexvalid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> relation-&gt;rd_ispkdeferrable ? InvalidOid : relation-&gt;rd_pkindex;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5000" title="utils/cache/relcache.c:5000">RelationGetReplicaIndex</a> -- get OID of the relation's replica identity index<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns InvalidOid if there is no such index.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L5000">&#x200c;</a><span class="linkable">RelationGetReplicaIndex</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *ilist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!relation-&gt;rd_indexvalid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a> does the heavy lifting. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ilist = <a href="#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>(relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(ilist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(relation-&gt;rd_indexvalid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> relation-&gt;rd_replidindex;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5025" title="utils/cache/relcache.c:5025">RelationGetIndexExpressions</a> -- get the index expressions for an index<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We cache the result of transforming pg_index.indexprs into a node tree.<br/></li>
<li></span><span class="Comment"> * If the rel is not an index or has no expressional columns, we return NIL.<br/></li>
<li></span><span class="Comment"> * Otherwise, the returned tree is copied into the caller's memory context.<br/></li>
<li></span><span class="Comment"> * (We don't want to return a pointer to the relcache copy, since it could<br/></li>
<li></span><span class="Comment"> * disappear due to relcache invalidation.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L5025">&#x200c;</a><span class="linkable">RelationGetIndexExpressions</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; exprsDatum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *exprsString;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick exit if we already computed the result. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_indexprs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> copyObject(relation-&gt;rd_indexprs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick exit if there is nothing to do. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_indextuple == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L455" title="access/common/heaptuple.c:455">heap_attisnull</a>(relation-&gt;rd_indextuple, Anum_pg_index_indexprs, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We build the tree we intend to return in the caller's context. After<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * successfully completing the work, we copy it into the relcache entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This avoids problems if we get some sort of error partway through.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; exprsDatum = heap_getattr(relation-&gt;rd_indextuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_index_indexprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4422" title="utils/cache/relcache.c:4422">GetPgIndexDescriptor</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; Assert(!isnull);<br/></li>
<li>&nbsp; &nbsp; exprsString = TextDatumGetCString(exprsDatum);<br/></li>
<li>&nbsp; &nbsp; result = (List *) <a href="../../nodes/read.c.html#L90" title="nodes/read.c:90">stringToNode</a>(exprsString);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(exprsString);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Run the expressions through <a href="../../optimizer/util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a>. This is not just an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * optimization, but is necessary, because the <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> will be comparing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them to similarly-processed qual clauses, and may fail to detect valid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matches without this.&nbsp; We must not use <a href="../../optimizer/prep/prepqual.c.html#L293" title="optimizer/prep/prepqual.c:293">canonicalize_qual</a>, however,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since these aren't qual expressions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = (List *) <a href="../../optimizer/util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a>(<span class="Constant">NULL</span>, (Node *) result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* May as well fix opfuncids too */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L1837" title="nodes/nodeFuncs.c:1837">fix_opfuncids</a>((Node *) result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now save a copy of the completed tree in the relcache entry. */<br/></li>
<li></span>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(relation-&gt;rd_indexcxt);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_indexprs = copyObject(result);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5084" title="utils/cache/relcache.c:5084">RelationGetDummyIndexExpressions</a> -- get dummy expressions for an index<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return a list of dummy expressions (just Const nodes) with the same<br/></li>
<li></span><span class="Comment"> * types/typmods/collations as the index's real expressions.&nbsp; This is<br/></li>
<li></span><span class="Comment"> * useful in situations where we don't want to run <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> user-defined code.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L5084">&#x200c;</a><span class="linkable">RelationGetDummyIndexExpressions</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; exprsDatum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *exprsString;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rawExprs;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick exit if there is nothing to do. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_indextuple == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L455" title="access/common/heaptuple.c:455">heap_attisnull</a>(relation-&gt;rd_indextuple, Anum_pg_index_indexprs, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract raw node tree(s) from index tuple. */<br/></li>
<li></span>&nbsp; &nbsp; exprsDatum = heap_getattr(relation-&gt;rd_indextuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_index_indexprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4422" title="utils/cache/relcache.c:4422">GetPgIndexDescriptor</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; Assert(!isnull);<br/></li>
<li>&nbsp; &nbsp; exprsString = TextDatumGetCString(exprsDatum);<br/></li>
<li>&nbsp; &nbsp; rawExprs = (List *) <a href="../../nodes/read.c.html#L90" title="nodes/read.c:90">stringToNode</a>(exprsString);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(exprsString);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Construct null Consts; the typlen and typbyval are arbitrary. */<br/></li>
<li></span>&nbsp; &nbsp; result = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, rawExprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rawExpr = (Node *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/makefuncs.c.html#L301" title="nodes/makefuncs.c:301">makeConst</a>(<a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(rawExpr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>(rawExpr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>(rawExpr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5138" title="utils/cache/relcache.c:5138">RelationGetIndexPredicate</a> -- get the index predicate for an index<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We cache the result of transforming pg_index.indpred into an implicit-AND<br/></li>
<li></span><span class="Comment"> * node tree (suitable for use in planning).<br/></li>
<li></span><span class="Comment"> * If the rel is not an index or has no predicate, we return NIL.<br/></li>
<li></span><span class="Comment"> * Otherwise, the returned tree is copied into the caller's memory context.<br/></li>
<li></span><span class="Comment"> * (We don't want to return a pointer to the relcache copy, since it could<br/></li>
<li></span><span class="Comment"> * disappear due to relcache invalidation.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L5138">&#x200c;</a><span class="linkable">RelationGetIndexPredicate</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; predDatum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *predString;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick exit if we already computed the result. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_indpred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> copyObject(relation-&gt;rd_indpred);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick exit if there is nothing to do. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_indextuple == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L455" title="access/common/heaptuple.c:455">heap_attisnull</a>(relation-&gt;rd_indextuple, Anum_pg_index_indpred, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We build the tree we intend to return in the caller's context. After<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * successfully completing the work, we copy it into the relcache entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This avoids problems if we get some sort of error partway through.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; predDatum = heap_getattr(relation-&gt;rd_indextuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Anum_pg_index_indpred,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L4422" title="utils/cache/relcache.c:4422">GetPgIndexDescriptor</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; Assert(!isnull);<br/></li>
<li>&nbsp; &nbsp; predString = TextDatumGetCString(predDatum);<br/></li>
<li>&nbsp; &nbsp; result = (List *) <a href="../../nodes/read.c.html#L90" title="nodes/read.c:90">stringToNode</a>(predString);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(predString);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Run the expression through const-simplification and canonicalization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is not just an optimization, but is necessary, because the <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will be comparing it to similarly-processed qual clauses, and may fail<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to detect valid matches without this.&nbsp; This must match the processing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done to qual clauses in <a href="../../optimizer/plan/planner.c.html#L1126" title="optimizer/plan/planner.c:1126">preprocess_expression</a>()!&nbsp; (We can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stuff involving subqueries, however, since we don't allow <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> in index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * predicates.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = (List *) <a href="../../optimizer/util/clauses.c.html#L2254" title="optimizer/util/clauses.c:2254">eval_const_expressions</a>(<span class="Constant">NULL</span>, (Node *) result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (List *) <a href="../../optimizer/prep/prepqual.c.html#L293" title="optimizer/prep/prepqual.c:293">canonicalize_qual</a>((Expr *) result, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Also convert to implicit-AND format */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="../../nodes/makefuncs.c.html#L737" title="nodes/makefuncs.c:737">make_ands_implicit</a>((Expr *) result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* May as well fix opfuncids too */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../nodes/nodeFuncs.c.html#L1837" title="nodes/nodeFuncs.c:1837">fix_opfuncids</a>((Node *) result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now save a copy of the completed tree in the relcache entry. */<br/></li>
<li></span>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(relation-&gt;rd_indexcxt);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_indpred = copyObject(result);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5231" title="utils/cache/relcache.c:5231">RelationGetIndexAttrBitmap</a> -- get a bitmap of index attribute numbers<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result has a <a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> set for each attribute used anywhere in the index<br/></li>
<li></span><span class="Comment"> * definitions of all the indexes on this relation.&nbsp; (This includes not only<br/></li>
<li></span><span class="Comment"> * simple index keys, but attributes used in expressions and partial-index<br/></li>
<li></span><span class="Comment"> * predicates.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Depending on attrKind, a bitmap covering attnums for certain columns is<br/></li>
<li></span><span class="Comment"> * returned:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; INDEX_ATTR_BITMAP_KEY&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Columns in non-partial unique indexes not<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in expressions (i.e., usable for FKs)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; INDEX_ATTR_BITMAP_PRIMARY_KEY&nbsp; &nbsp; Columns in the table's primary key<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (beware: even if PK is deferrable!)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; INDEX_ATTR_BITMAP_IDENTITY_KEY&nbsp; &nbsp; Columns in the table's replica identity<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index (empty if FULL)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; INDEX_ATTR_BITMAP_HOT_BLOCKING&nbsp; &nbsp; Columns that block updates from being HOT<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; INDEX_ATTR_BITMAP_SUMMARIZED&nbsp; &nbsp; Columns included in summarizing indexes<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Attribute numbers are offset by FirstLowInvalidHeapAttributeNumber so that<br/></li>
<li></span><span class="Comment"> * we can include system attributes (e.g., OID) in the bitmap representation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Deferred indexes are considered for the primary key, but not for replica<br/></li>
<li></span><span class="Comment"> * identity.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller had better hold at least RowExclusiveLock on the target relation<br/></li>
<li></span><span class="Comment"> * to ensure it is safe (deadlock-free) for us to take locks on the relation's<br/></li>
<li></span><span class="Comment"> * indexes.&nbsp; Note that since the introduction of CREATE INDEX CONCURRENTLY,<br/></li>
<li></span><span class="Comment"> * that lock level doesn't guarantee a stable set of indexes, so we have to<br/></li>
<li></span><span class="Comment"> * be prepared to retry here in case of a change in the set of indexes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned result is <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d in the caller's memory context and should<br/></li>
<li></span><span class="Comment"> * be <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>'d when not needed anymore.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Bitmapset *<br/></li>
<li><a id="L5231">&#x200c;</a><span class="linkable">RelationGetIndexAttrBitmap</span>(Relation relation, IndexAttrBitmapKind attrKind)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *uindexattrs;&nbsp; &nbsp; <span class="Comment">/* columns in unique indexes */<br/></li>
<li></span>&nbsp; &nbsp; Bitmapset&nbsp; *pkindexattrs;&nbsp; &nbsp; <span class="Comment">/* columns in the primary index */<br/></li>
<li></span>&nbsp; &nbsp; Bitmapset&nbsp; *idindexattrs;&nbsp; &nbsp; <span class="Comment">/* columns in the replica identity */<br/></li>
<li></span>&nbsp; &nbsp; Bitmapset&nbsp; *hotblockingattrs;&nbsp; &nbsp; <span class="Comment">/* columns with HOT blocking indexes */<br/></li>
<li></span>&nbsp; &nbsp; Bitmapset&nbsp; *summarizedattrs;&nbsp; &nbsp; <span class="Comment">/* columns with summarizing indexes */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexoidlist;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newindexoidlist;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relpkindex;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relreplindex;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick exit if we already computed the result. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_attrsvalid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (attrKind)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INDEX_ATTR_BITMAP_KEY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(relation-&gt;rd_keyattr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INDEX_ATTR_BITMAP_PRIMARY_KEY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(relation-&gt;rd_pkattr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INDEX_ATTR_BITMAP_IDENTITY_KEY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(relation-&gt;rd_idattr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INDEX_ATTR_BITMAP_HOT_BLOCKING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(relation-&gt;rd_hotblockingattr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INDEX_ATTR_BITMAP_SUMMARIZED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(relation-&gt;rd_summarizedattr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unknown attrKind </span><span class="Special">%u</span><span class="Constant">&quot;</span>, attrKind);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fast path if definitely no indexes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!RelationGetForm(relation)-&gt;relhasindex)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get cached list of index OIDs. If we have to start over, we do so here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Statement">restart</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; indexoidlist = <a href="#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fall out if no indexes (but relhasindex was set) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexoidlist == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy the rd_pkindex and rd_replidindex <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> computed by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> proceeding.&nbsp; This is needed because a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relcache flush could occur inside <a href="../../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a> below, resetting the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fields managed by <a href="#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>.&nbsp; We need to do the work with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stable <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of these fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relpkindex = relation-&gt;rd_pkindex;<br/></li>
<li>&nbsp; &nbsp; relreplindex = relation-&gt;rd_replidindex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For each index, add referenced attributes to indexattrs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we consider all indexes returned by <a href="#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>, even if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they are not indisready or indisvalid.&nbsp; This is important because an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index for which CREATE INDEX CONCURRENTLY has just started must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * included in HOT-safety decisions (see README.HOT).&nbsp; If a DROP INDEX<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CONCURRENTLY is far enough along that we should ignore the index, it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * won't be returned at all by <a href="#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; uindexattrs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pkindexattrs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; idindexattrs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; hotblockingattrs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; summarizedattrs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(l, indexoidlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexOid = lfirst_oid(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; indexDesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *indexExpressions;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *indexPredicate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isKey;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* candidate key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isPK;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* primary key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isIDKey;&nbsp; &nbsp; <span class="Comment">/* replica identity index */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset **attrs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexDesc = <a href="../../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(indexOid, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Extract index expressions and index predicate.&nbsp; Note: Don't use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L5025" title="utils/cache/relcache.c:5025">RelationGetIndexExpressions</a>()/<a href="#L5138" title="utils/cache/relcache.c:5138">RelationGetIndexPredicate</a>(), because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * those might run constant expressions evaluation, which needs a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * snapshot, which we might not have here.&nbsp; (Also, it's probably more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sound to collect the bitmaps <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transformations that might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * eliminate columns, but the practical impact of this is limited.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum = heap_getattr(indexDesc-&gt;rd_indextuple, Anum_pg_index_indexprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L4422" title="utils/cache/relcache.c:4422">GetPgIndexDescriptor</a>(), &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexExpressions = <a href="../../nodes/read.c.html#L90" title="nodes/read.c:90">stringToNode</a>(TextDatumGetCString(datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexExpressions = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum = heap_getattr(indexDesc-&gt;rd_indextuple, Anum_pg_index_indpred,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L4422" title="utils/cache/relcache.c:4422">GetPgIndexDescriptor</a>(), &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexPredicate = <a href="../../nodes/read.c.html#L90" title="nodes/read.c:90">stringToNode</a>(TextDatumGetCString(datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexPredicate = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can this index be referenced by a foreign key? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; isKey = indexDesc-&gt;rd_index-&gt;indisunique &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexExpressions == <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexPredicate == <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Is this a primary key? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; isPK = (indexOid == relpkindex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Is this index the configured (or default) replica identity? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; isIDKey = (indexOid == relreplindex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the index is summarizing, it doesn't block HOT updates, but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * may still need to update it (if the attributes were modified). So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decide which bitmap we'll update in the following loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexDesc-&gt;rd_indam-&gt;amsummarizing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrs = &amp;summarizedattrs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrs = &amp;hotblockingattrs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Collect simple attribute references */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; indexDesc-&gt;rd_index-&gt;indnatts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrnum = indexDesc-&gt;rd_index-&gt;indkey.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since we have covering indexes with non-key columns, we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * handle them accurately here. non-key columns must be added into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hotblockingattrs or summarizedattrs, since they are in index,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and update shouldn't <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Summarizing indexes do not block HOT, but do need to be updated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when the column value changes, thus require a separate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attribute bitmapset.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Obviously, non-key columns couldn't be referenced by foreign<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * key or identity key. Hence we do not include them into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * uindexattrs, pkindexattrs and idindexattrs bitmaps.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attrnum != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *attrs = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(*attrs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrnum - FirstLowInvalidHeapAttributeNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isKey &amp;&amp; i &lt; indexDesc-&gt;rd_index-&gt;indnkeyatts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uindexattrs = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(uindexattrs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attrnum - FirstLowInvalidHeapAttributeNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isPK &amp;&amp; i &lt; indexDesc-&gt;rd_index-&gt;indnkeyatts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkindexattrs = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(pkindexattrs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrnum - FirstLowInvalidHeapAttributeNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isIDKey &amp;&amp; i &lt; indexDesc-&gt;rd_index-&gt;indnkeyatts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idindexattrs = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(idindexattrs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrnum - FirstLowInvalidHeapAttributeNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Collect all attributes used in expressions, too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/util/var.c.html#L291" title="optimizer/util/var.c:291">pull_varattnos</a>(indexExpressions, <span class="Constant">1</span>, attrs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Collect all attributes in the index predicate, too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/util/var.c.html#L291" title="optimizer/util/var.c:291">pull_varattnos</a>(indexPredicate, <span class="Constant">1</span>, attrs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(indexDesc, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During one of the index_opens in the above loop, we might have received<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a relcache flush event on this relcache entry, which might have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * signaling a change in the rel's index list.&nbsp; If so, we'd better start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * over to ensure we deliver up-to-date attribute bitmaps.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newindexoidlist = <a href="#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>(relation);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(indexoidlist, newindexoidlist) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relpkindex == relation-&gt;rd_pkindex &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relreplindex == relation-&gt;rd_replidindex)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Still the same index set, so proceed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(newindexoidlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(indexoidlist);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Gotta do it over ... might as well not leak memory */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(newindexoidlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(indexoidlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(uindexattrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(pkindexattrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(idindexattrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(hotblockingattrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(summarizedattrs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> restart;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't leak the old <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of these bitmaps, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; relation-&gt;rd_attrsvalid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(relation-&gt;rd_keyattr);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_keyattr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(relation-&gt;rd_pkattr);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_pkattr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(relation-&gt;rd_idattr);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_idattr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(relation-&gt;rd_hotblockingattr);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_hotblockingattr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(relation-&gt;rd_summarizedattr);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_summarizedattr = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now save copies of the bitmaps in the relcache entry.&nbsp; We intentionally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set rd_attrsvalid last, because that's the one that signals validity of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>; if we run out of memory <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> making that copy, we won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leave the relcache entry looking like the other ones are valid but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_keyattr = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(uindexattrs);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_pkattr = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(pkindexattrs);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_idattr = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(idindexattrs);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_hotblockingattr = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(hotblockingattrs);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_summarizedattr = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(summarizedattrs);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_attrsvalid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We return our original working copy for caller to play with */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (attrKind)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INDEX_ATTR_BITMAP_KEY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> uindexattrs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INDEX_ATTR_BITMAP_PRIMARY_KEY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> pkindexattrs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INDEX_ATTR_BITMAP_IDENTITY_KEY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> idindexattrs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INDEX_ATTR_BITMAP_HOT_BLOCKING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> hotblockingattrs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INDEX_ATTR_BITMAP_SUMMARIZED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> summarizedattrs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unknown attrKind </span><span class="Special">%u</span><span class="Constant">&quot;</span>, attrKind);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5504" title="utils/cache/relcache.c:5504">RelationGetIdentityKeyBitmap</a> -- get a bitmap of replica identity attribute<br/></li>
<li></span><span class="Comment"> * numbers<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A bitmap of index attribute numbers for the configured replica identity<br/></li>
<li></span><span class="Comment"> * index is returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See also comments of <a href="#L5231" title="utils/cache/relcache.c:5231">RelationGetIndexAttrBitmap</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a special purpose function used during logical replication. Here,<br/></li>
<li></span><span class="Comment"> * unlike <a href="#L5231" title="utils/cache/relcache.c:5231">RelationGetIndexAttrBitmap</a>(), we don't acquire a lock on the required<br/></li>
<li></span><span class="Comment"> * index as we build the cache entry using a historic snapshot and all the<br/></li>
<li></span><span class="Comment"> * later changes are absorbed while decoding WAL. Due to this reason, we don't<br/></li>
<li></span><span class="Comment"> * need to retry here in case of a change in the set of indexes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Bitmapset *<br/></li>
<li><a id="L5504">&#x200c;</a><span class="linkable">RelationGetIdentityKeyBitmap</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *idindexattrs = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* columns in the replica identity */<br/></li>
<li></span>&nbsp; &nbsp; Relation&nbsp; &nbsp; indexDesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; replidindex;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick exit if we already computed the result */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_idattr != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(relation-&gt;rd_idattr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fast path if definitely no indexes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!RelationGetForm(relation)-&gt;relhasindex)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Historic snapshot must be set. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../time/snapmgr.c.html#L1672" title="utils/time/snapmgr.c:1672">HistoricSnapshotActive</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; replidindex = <a href="#L5000" title="utils/cache/relcache.c:5000">RelationGetReplicaIndex</a>(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fall out if there is no replica identity index */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(replidindex))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look up the description for the replica identity index */<br/></li>
<li></span>&nbsp; &nbsp; indexDesc = <a href="#L2062" title="utils/cache/relcache.c:2062">RelationIdGetRelation</a>(replidindex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!RelationIsValid(indexDesc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not open relation with OID </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_replidindex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add referenced attributes to idindexattrs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; indexDesc-&gt;rd_index-&gt;indnatts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrnum = indexDesc-&gt;rd_index-&gt;indkey.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't include non-key columns into idindexattrs bitmaps. See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L5231" title="utils/cache/relcache.c:5231">RelationGetIndexAttrBitmap</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attrnum != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; indexDesc-&gt;rd_index-&gt;indnkeyatts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idindexattrs = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(idindexattrs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrnum - FirstLowInvalidHeapAttributeNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2193" title="utils/cache/relcache.c:2193">RelationClose</a>(indexDesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't leak the old <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of these bitmaps, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(relation-&gt;rd_idattr);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_idattr = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now save copy of the bitmap in the relcache entry */<br/></li>
<li></span>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_idattr = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(idindexattrs);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We return our original working copy for caller to play with */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> idindexattrs;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5581" title="utils/cache/relcache.c:5581">RelationGetExclusionInfo</a> -- get info about index's exclusion constraint<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be called only for an index that is known to have an associated<br/></li>
<li></span><span class="Comment"> * exclusion constraint or primary key/unique constraint using WITHOUT<br/></li>
<li></span><span class="Comment"> * OVERLAPS.<br/></li>
<li></span><br/></li>
<li><span class="Comment"> * It returns arrays (<a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d in caller's context) of the exclusion operator<br/></li>
<li></span><span class="Comment"> * OIDs, their underlying <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>' OIDs, and their strategy numbers in the<br/></li>
<li></span><span class="Comment"> * index's opclasses.&nbsp; We cache all this information since it requires a fair<br/></li>
<li></span><span class="Comment"> * amount of work to get.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5581">&#x200c;</a></span><span class="linkable">RelationGetExclusionInfo</span>(Relation indexRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid **operators,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid **procs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint16 **strategies)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indnkeyatts;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *ops;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *funcs;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp;&nbsp; *strats;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; conrel;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc conscan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData skey[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; htup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indnkeyatts = IndexRelationGetNumberOfKeyAttributes(indexRelation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate result space in caller context */<br/></li>
<li></span>&nbsp; &nbsp; *operators = ops = (Oid *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * indnkeyatts);<br/></li>
<li>&nbsp; &nbsp; *procs = funcs = (Oid *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * indnkeyatts);<br/></li>
<li>&nbsp; &nbsp; *strategies = strats = (uint16 *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16) * indnkeyatts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick exit if we have the data cached already */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexRelation-&gt;rd_exclstrats != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ops, indexRelation-&gt;rd_exclops, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * indnkeyatts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(funcs, indexRelation-&gt;rd_exclprocs, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * indnkeyatts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(strats, indexRelation-&gt;rd_exclstrats, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16) * indnkeyatts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Search pg_constraint for the constraint associated with the index. To<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * make this not too painfully slow, we use the index on conrelid; that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will hold the parent relation's OID not the index's own OID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: if we wanted to rely on the constraint name matching the index's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * name, we could just do a direct lookup using pg_constraint's unique<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index.&nbsp; For the moment it doesn't seem worth requiring that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_conrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(indexRelation-&gt;rd_index-&gt;indrelid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; conrel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(ConstraintRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; conscan = <a href="../../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(conrel, ConstraintRelidTypidNameIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">1</span>, skey);<br/></li>
<li>&nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(htup = <a href="../../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(conscan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint conform = (Form_pg_constraint) GETSTRUCT(htup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *arr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We want the exclusion constraint owning the index */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((conform-&gt;contype != CONSTRAINT_EXCLUSION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !(conform-&gt;conperiod &amp;&amp; (<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conform-&gt;contype == CONSTRAINT_PRIMARY<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || conform-&gt;contype == CONSTRAINT_UNIQUE))) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conform-&gt;conindid != RelationGetRelid(indexRelation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* There should be only one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected exclusion constraint record found for rel </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(indexRelation));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Extract the operator OIDS from conexclop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; val = fastgetattr(htup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_conexclop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conrel-&gt;rd_att, &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;null conexclop for rel </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(indexRelation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arr = DatumGetArrayTypeP(val);&nbsp; &nbsp; <span class="Comment">/* ensure not toasted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nelem = ARR_DIMS(arr)[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ARR_NDIM(arr) != <span class="Constant">1</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelem != indnkeyatts ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ARR_HASNULL(arr) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ARR_ELEMTYPE(arr) != OIDOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;conexclop is not a 1-D Oid array&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ops, ARR_DATA_PTR(arr), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * indnkeyatts);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(conscan);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(conrel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;exclusion constraint record missing for rel </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(indexRelation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We need the func OIDs and strategy numbers too */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; indnkeyatts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcs[i] = <a href="lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(ops[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strats[i] = <a href="lsyscache.c.html#L83" title="utils/cache/lsyscache.c:83">get_op_opfamily_strategy</a>(ops[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexRelation-&gt;rd_opfamily[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't fail, since it was checked at index creation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strats[i] == InvalidStrategy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> strategy for operator </span><span class="Special">%u</span><span class="Constant"> in family </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ops[i], indexRelation-&gt;rd_opfamily[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save a copy of the results in the relcache entry. */<br/></li>
<li></span>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(indexRelation-&gt;rd_indexcxt);<br/></li>
<li>&nbsp; &nbsp; indexRelation-&gt;rd_exclops = (Oid *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * indnkeyatts);<br/></li>
<li>&nbsp; &nbsp; indexRelation-&gt;rd_exclprocs = (Oid *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * indnkeyatts);<br/></li>
<li>&nbsp; &nbsp; indexRelation-&gt;rd_exclstrats = (uint16 *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16) * indnkeyatts);<br/></li>
<li>&nbsp; &nbsp; memcpy(indexRelation-&gt;rd_exclops, ops, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * indnkeyatts);<br/></li>
<li>&nbsp; &nbsp; memcpy(indexRelation-&gt;rd_exclprocs, funcs, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * indnkeyatts);<br/></li>
<li>&nbsp; &nbsp; memcpy(indexRelation-&gt;rd_exclstrats, strats, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16) * indnkeyatts);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the publication information for the given relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Traverse all the publications which the relation is in to get the<br/></li>
<li></span><span class="Comment"> * publication actions and validate the row filter expressions for such<br/></li>
<li></span><span class="Comment"> * publications if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. We consider the row filter expression as invalid if it<br/></li>
<li></span><span class="Comment"> * references <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> column which is not part of REPLICA IDENTITY.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To avoid fetching the publication information repeatedly, we cache the<br/></li>
<li></span><span class="Comment"> * publication actions and row filter validation information.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5716">&#x200c;</a></span><span class="linkable">RelationBuildPublicationDesc</span>(Relation relation, PublicationDesc *pubdesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *puboids;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; schemaid;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *ancestors = NIL;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = RelationGetRelid(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If not publishable, it publishes no actions.&nbsp; (<a href="../../replication/pgoutput/pgoutput.c.html#L1403" title="replication/pgoutput/pgoutput.c:1403">pgoutput_change</a>() will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ignore it.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../catalog/pg_publication.c.html#L150" title="catalog/pg_publication.c:150">is_publishable_relation</a>(relation))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(pubdesc, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PublicationDesc));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pubdesc-&gt;rf_valid_for_update = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pubdesc-&gt;rf_valid_for_delete = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pubdesc-&gt;cols_valid_for_update = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pubdesc-&gt;cols_valid_for_delete = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_pubdesc)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(pubdesc, relation-&gt;rd_pubdesc, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PublicationDesc));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(pubdesc, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PublicationDesc));<br/></li>
<li>&nbsp; &nbsp; pubdesc-&gt;rf_valid_for_update = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; pubdesc-&gt;rf_valid_for_delete = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; pubdesc-&gt;cols_valid_for_update = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; pubdesc-&gt;cols_valid_for_delete = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch the publication membership info. */<br/></li>
<li></span>&nbsp; &nbsp; puboids = <a href="../../catalog/pg_publication.c.html#L687" title="catalog/pg_publication.c:687">GetRelationPublications</a>(relid);<br/></li>
<li>&nbsp; &nbsp; schemaid = RelationGetNamespace(relation);<br/></li>
<li>&nbsp; &nbsp; puboids = <a href="../../nodes/list.c.html#L1469" title="nodes/list.c:1469">list_concat_unique_oid</a>(puboids, <a href="../../catalog/pg_publication.c.html#L899" title="catalog/pg_publication.c:899">GetSchemaPublications</a>(schemaid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relispartition)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add publications that the ancestors are in too. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ancestors = <a href="../../catalog/partition.c.html#L134" title="catalog/partition.c:134">get_partition_ancestors</a>(relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, ancestors)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ancestor = lfirst_oid(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; puboids = <a href="../../nodes/list.c.html#L1469" title="nodes/list.c:1469">list_concat_unique_oid</a>(puboids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../catalog/pg_publication.c.html#L687" title="catalog/pg_publication.c:687">GetRelationPublications</a>(ancestor));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; schemaid = <a href="lsyscache.c.html#L1952" title="utils/cache/lsyscache.c:1952">get_rel_namespace</a>(ancestor);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; puboids = <a href="../../nodes/list.c.html#L1469" title="nodes/list.c:1469">list_concat_unique_oid</a>(puboids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../catalog/pg_publication.c.html#L899" title="catalog/pg_publication.c:899">GetSchemaPublications</a>(schemaid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; puboids = <a href="../../nodes/list.c.html#L1469" title="nodes/list.c:1469">list_concat_unique_oid</a>(puboids, <a href="../../catalog/pg_publication.c.html#L759" title="catalog/pg_publication.c:759">GetAllTablesPublications</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, puboids)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pubid = lfirst_oid(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_publication pubform;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PUBLICATIONOID, ObjectIdGetDatum(pubid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for publication </span><span class="Special">%u</span><span class="Constant">&quot;</span>, pubid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pubform = (Form_pg_publication) GETSTRUCT(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pubdesc-&gt;pubactions.pubinsert |= pubform-&gt;pubinsert;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pubdesc-&gt;pubactions.pubupdate |= pubform-&gt;pubupdate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pubdesc-&gt;pubactions.pubdelete |= pubform-&gt;pubdelete;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pubdesc-&gt;pubactions.pubtruncate |= pubform-&gt;pubtruncate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if all columns referenced in the filter expression are part<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the REPLICA IDENTITY index or not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the publication is FOR ALL TABLES then it means the table has no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * row filters and we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the validation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pubform-&gt;puballtables &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (pubform-&gt;pubupdate || pubform-&gt;pubdelete) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/publicationcmds.c.html#L258" title="commands/publicationcmds.c:258">pub_rf_contains_invalid_column</a>(pubid, relation, ancestors,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pubform-&gt;pubviaroot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pubform-&gt;pubupdate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pubdesc-&gt;rf_valid_for_update = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pubform-&gt;pubdelete)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pubdesc-&gt;rf_valid_for_delete = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if all columns are part of the REPLICA IDENTITY index or not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the publication is FOR ALL TABLES then it means the table has no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column list and we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the validation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pubform-&gt;puballtables &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (pubform-&gt;pubupdate || pubform-&gt;pubdelete) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/publicationcmds.c.html#L334" title="commands/publicationcmds.c:334">pub_collist_contains_invalid_column</a>(pubid, relation, ancestors,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pubform-&gt;pubviaroot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pubform-&gt;pubupdate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pubdesc-&gt;cols_valid_for_update = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pubform-&gt;pubdelete)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pubdesc-&gt;cols_valid_for_delete = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we know everything is replicated and the row filter is invalid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for update and delete, there is no point to check for other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * publications.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pubdesc-&gt;pubactions.pubinsert &amp;&amp; pubdesc-&gt;pubactions.pubupdate &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pubdesc-&gt;pubactions.pubdelete &amp;&amp; pubdesc-&gt;pubactions.pubtruncate &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !pubdesc-&gt;rf_valid_for_update &amp;&amp; !pubdesc-&gt;rf_valid_for_delete)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we know everything is replicated and the column list is invalid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for update and delete, there is no point to check for other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * publications.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pubdesc-&gt;pubactions.pubinsert &amp;&amp; pubdesc-&gt;pubactions.pubupdate &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pubdesc-&gt;pubactions.pubdelete &amp;&amp; pubdesc-&gt;pubactions.pubtruncate &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !pubdesc-&gt;cols_valid_for_update &amp;&amp; !pubdesc-&gt;cols_valid_for_delete)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_pubdesc)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(relation-&gt;rd_pubdesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_pubdesc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now save copy of the descriptor in the relcache entry. */<br/></li>
<li></span>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_pubdesc = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PublicationDesc));<br/></li>
<li>&nbsp; &nbsp; memcpy(relation-&gt;rd_pubdesc, pubdesc, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PublicationDesc));<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> bytea **<br/></li>
<li><a id="L5864">&#x200c;</a><span class="linkable">CopyIndexAttOptions</span>(bytea **srcopts, <span class="Type">int</span> natts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp; **opts = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*opts) * natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *opt = srcopts[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opts[i] = !opt ? <span class="Constant">NULL</span> : (bytea *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetPointer(<a href="../adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(PointerGetDatum(opt), <span class="Constant">false</span>, -<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> opts;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5884" title="utils/cache/relcache.c:5884">RelationGetIndexAttOptions</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; get AM/opclass-specific options for an index parsed into a binary form<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>bytea&nbsp; &nbsp; &nbsp; **<br/></li>
<li><a id="L5884">&#x200c;</a><span class="linkable">RelationGetIndexAttOptions</span>(Relation relation, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> copy)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp; **opts = relation-&gt;rd_opcoptions;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = RelationGetRelid(relation);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; natts = RelationGetNumberOfAttributes(relation);&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * IndexRelationGetNumberOfKeyAttributes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to copy cached options. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (opts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> copy ? <a href="#L5864" title="utils/cache/relcache.c:5864">CopyIndexAttOptions</a>(opts, natts) : opts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get and <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> opclass options. */<br/></li>
<li></span>&nbsp; &nbsp; opts = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*opts) * natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L140" title="utils/cache/relcache.c:140">criticalRelcachesBuilt</a> &amp;&amp; relid != AttributeRelidNumIndexId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; attoptions = <a href="lsyscache.c.html#L970" title="utils/cache/lsyscache.c:970">get_attoptions</a>(relid, i + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opts[i] = <a href="../../access/index/indexam.c.html#L996" title="access/index/indexam.c:996">index_opclass_options</a>(relation, i + <span class="Constant">1</span>, attoptions, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attoptions != (Datum) <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(attoptions));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy parsed options to the cache. */<br/></li>
<li></span>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(relation-&gt;rd_indexcxt);<br/></li>
<li>&nbsp; &nbsp; relation-&gt;rd_opcoptions = <a href="#L5864" title="utils/cache/relcache.c:5864">CopyIndexAttOptions</a>(opts, natts);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (copy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> opts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (opts[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(opts[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(opts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> relation-&gt;rd_opcoptions;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Routines to support ereport() reports of relation-related errors<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These could have been put into elog.c, but it seems like a module layering<br/></li>
<li></span><span class="Comment"> * violation to have elog.c calling relcache or syscache stuff --- and we<br/></li>
<li></span><span class="Comment"> * definitely don't want elog.h including rel.h.&nbsp; So we put them here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5945" title="utils/cache/relcache.c:5945">errtable</a> --- stores schema_name and table_name of a table<br/></li>
<li></span><span class="Comment"> * within the current <a href="../error/elog.c.html#L149" title="utils/error/elog.c:149">errordata</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L5945">&#x200c;</a></span><span class="linkable">errtable</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../error/elog.c.html#L1514" title="utils/error/elog.c:1514">err_generic_string</a>(PG_DIAG_SCHEMA_NAME,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(RelationGetNamespace(rel)));<br/></li>
<li>&nbsp; &nbsp; <a href="../error/elog.c.html#L1514" title="utils/error/elog.c:1514">err_generic_string</a>(PG_DIAG_TABLE_NAME, RelationGetRelationName(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return value does not matter */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5962" title="utils/cache/relcache.c:5962">errtablecol</a> --- stores schema_name, table_name and column_name<br/></li>
<li></span><span class="Comment"> * of a table column within the current <a href="../error/elog.c.html#L149" title="utils/error/elog.c:149">errordata</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The column is specified by attribute number --- for most callers, this is<br/></li>
<li></span><span class="Comment"> * easier and less error-prone than getting the column name for themselves.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L5962">&#x200c;</a></span><span class="linkable">errtablecol</span>(Relation rel, <span class="Type">int</span> attnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; reldesc = RelationGetDescr(rel);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *colname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use reldesc if it's a user attribute, else consult the catalogs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attnum &gt; <span class="Constant">0</span> &amp;&amp; attnum &lt;= reldesc-&gt;natts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; colname = NameStr(TupleDescAttr(reldesc, attnum - <span class="Constant">1</span>)-&gt;attname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; colname = <a href="lsyscache.c.html#L827" title="utils/cache/lsyscache.c:827">get_attname</a>(RelationGetRelid(rel), attnum, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L5986" title="utils/cache/relcache.c:5986">errtablecolname</a>(rel, colname);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5986" title="utils/cache/relcache.c:5986">errtablecolname</a> --- stores schema_name, table_name and column_name<br/></li>
<li></span><span class="Comment"> * of a table column within the current <a href="../error/elog.c.html#L149" title="utils/error/elog.c:149">errordata</a>, where the column name is<br/></li>
<li></span><span class="Comment"> * given directly rather than extracted from the relation's catalog data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Don't use this directly unless <a href="#L5962" title="utils/cache/relcache.c:5962">errtablecol</a>() is inconvenient for some<br/></li>
<li></span><span class="Comment"> * reason.&nbsp; This might possibly be needed during intermediate states in ALTER<br/></li>
<li></span><span class="Comment"> * TABLE, for instance.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L5986">&#x200c;</a></span><span class="linkable">errtablecolname</span>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *colname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L5945" title="utils/cache/relcache.c:5945">errtable</a>(rel);<br/></li>
<li>&nbsp; &nbsp; <a href="../error/elog.c.html#L1514" title="utils/error/elog.c:1514">err_generic_string</a>(PG_DIAG_COLUMN_NAME, colname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return value does not matter */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5999" title="utils/cache/relcache.c:5999">errtableconstraint</a> --- stores schema_name, table_name and constraint_name<br/></li>
<li></span><span class="Comment"> * of a table-related constraint within the current <a href="../error/elog.c.html#L149" title="utils/error/elog.c:149">errordata</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L5999">&#x200c;</a></span><span class="linkable">errtableconstraint</span>(Relation rel, <span class="Type">const</span> <span class="Type">char</span> *conname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L5945" title="utils/cache/relcache.c:5945">errtable</a>(rel);<br/></li>
<li>&nbsp; &nbsp; <a href="../error/elog.c.html#L1514" title="utils/error/elog.c:1514">err_generic_string</a>(PG_DIAG_CONSTRAINT_NAME, conname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return value does not matter */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L6063" title="utils/cache/relcache.c:6063">load_relcache_init_file</a>, <a href="#L6479" title="utils/cache/relcache.c:6479">write_relcache_init_file</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; In late 1992, we started regularly having databases with more than<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a thousand classes in them.&nbsp; With this number of classes, it became<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; critical to do indexed lookups on the system catalogs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Bootstrapping these lookups is very hard.&nbsp; We want to be able to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; use an index on pg_attribute, for example, but in order to do so,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; we must have read pg_attribute for the attributes in the index,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; which implies that we need to use the index.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; In order to get around the problem, we do the following:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; +&nbsp; When the database system is initialized (at initdb time), we<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; don't use indexes.&nbsp; We do sequential scans.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; +&nbsp; When the backend is started up in normal mode, we load an image<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of the appropriate relation descriptors, in <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> format,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; from an initialization file in the data/base/... directory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; +&nbsp; If the initialization file isn't there, then we create the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation descriptors using sequential scans and write 'em to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the initialization file for use by subsequent backends.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; As of Postgres 9.0, there is one local initialization file in each<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; database, plus one shared initialization file for shared catalogs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We could dispense with the initialization files and just build the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; critical reldescs the hard way on every backend startup, but that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; slows down backend startup noticeably.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We can in fact go further, and save more relcache entries than<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; just the ones that are absolutely critical; this allows us to speed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; up backend startup by not having to build such entries the hard way.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Presently, all the catalog and index entries that are referred to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; by catcaches are stored in the initialization files.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The same mechanism that detects when catcache and relcache entries<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; need to be invalidated (due to catalog updates) also arranges to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; unlink the initialization files when the contents may be out of date.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The files will then be rebuilt during the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> backend startup.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6063" title="utils/cache/relcache.c:6063">load_relcache_init_file</a> -- attempt to load cache from the shared<br/></li>
<li></span><span class="Comment"> * or local cache init file<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If successful, return true and set <a href="#L140" title="utils/cache/relcache.c:140">criticalRelcachesBuilt</a> or<br/></li>
<li></span><span class="Comment"> * <a href="#L146" title="utils/cache/relcache.c:146">criticalSharedRelcachesBuilt</a> to true.<br/></li>
<li></span><span class="Comment"> * If not successful, return false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: we assume we are already switched into <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L6063">&#x200c;</a></span><span class="linkable">load_relcache_init_file</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> shared)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">FILE</span>&nbsp; &nbsp; &nbsp;&nbsp; *fp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; initfilename[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp;&nbsp; *rels;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nailed_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nailed_indexes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; magic;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (shared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(initfilename, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(initfilename), <span class="Constant">&quot;global/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RELCACHE_INIT_FILENAME);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(initfilename, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(initfilename), <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../init/globals.c.html#L101" title="utils/init/globals.c:101">DatabasePath</a>, RELCACHE_INIT_FILENAME);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fp = <a href="../../storage/file/fd.c.html#L2583" title="storage/file/fd.c:2583">AllocateFile</a>(initfilename, PG_BINARY_R);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read the index relcache entries from the file.&nbsp; Note we will not enter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of them into the cache if the read fails partway through; this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * helps to guard against broken init files.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; max_rels = <span class="Constant">100</span>;<br/></li>
<li>&nbsp; &nbsp; rels = (Relation *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(max_rels * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Relation));<br/></li>
<li>&nbsp; &nbsp; num_rels = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; nailed_rels = nailed_indexes = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for correct magic number (compatible version) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fread(&amp;magic, <span class="Constant">1</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(magic), fp) != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(magic))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (magic != <a href="#L93" title="utils/cache/relcache.c:93">RELCACHE_INIT_FILEMAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (relno = <span class="Constant">0</span>;; relno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; nread;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class relform;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_not_null;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first read the relation descriptor length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nread = fread(&amp;len, <span class="Constant">1</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len), fp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nread != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nread == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* safety check for incompatible relcache layout */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelationData))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocate another relcache header */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (num_rels &gt;= max_rels)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_rels *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rels = (Relation *) <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(rels, max_rels * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Relation));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel = rels[num_rels++] = (Relation) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* then, read the Relation structure */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fread(rel, <span class="Constant">1</span>, len, fp) != len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> read the relation tuple form */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fread(&amp;len, <span class="Constant">1</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len), fp) != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relform = (Form_pg_class) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fread(relform, <span class="Constant">1</span>, len, fp) != len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel = relform;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> attribute tuple forms */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_att = <a href="../../access/common/tupdesc.c.html#L67" title="access/common/tupdesc.c:67">CreateTemplateTupleDesc</a>(relform-&gt;relnatts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_att-&gt;tdrefcount = <span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* mark as refcounted */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_att-&gt;tdtypeid = relform-&gt;reltype ? relform-&gt;reltype : RECORDOID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_att-&gt;tdtypmod = -<span class="Constant">1</span>; <span class="Comment">/* just to be sure */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> read all the attribute tuple form data entries */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; has_not_null = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; relform-&gt;relnatts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr = TupleDescAttr(rel-&gt;rd_att, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fread(&amp;len, <span class="Constant">1</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len), fp) != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len != ATTRIBUTE_FIXED_PART_SIZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fread(attr, <span class="Constant">1</span>, len, fp) != len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has_not_null |= attr-&gt;attnotnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> read the access method specific field */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fread(&amp;len, <span class="Constant">1</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len), fp) != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_options = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fread(rel-&gt;rd_options, <span class="Constant">1</span>, len, fp) != len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len != VARSIZE(rel-&gt;rd_options))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;&nbsp; &nbsp; <span class="Comment">/* sanity check */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_options = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mark not-null status */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (has_not_null)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleConstr *constr = (TupleConstr *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TupleConstr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constr-&gt;has_not_null = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_att-&gt;constr = constr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's an index, there's more to do.&nbsp; Note we explicitly ignore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partitioned indexes here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_INDEX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext indexcxt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *opfamily;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *opcintype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RegProcedure *support;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nsupport;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp;&nbsp; *indoption;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *indcollation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Count nailed indexes to ensure we have 'em all */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_isnailed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nailed_indexes++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* read the pg_index tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fread(&amp;len, <span class="Constant">1</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len), fp) != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_indextuple = (HeapTuple) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fread(rel-&gt;rd_indextuple, <span class="Constant">1</span>, len, fp) != len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fix up <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> pointers in the tuple -- see <a href="../../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_indextuple-&gt;t_data = (HeapTupleHeader) ((<span class="Type">char</span> *) rel-&gt;rd_indextuple + HEAPTUPLESIZE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_index = (Form_pg_index) GETSTRUCT(rel-&gt;rd_indextuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prepare index info context --- parameters should match<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1425" title="utils/cache/relcache.c:1425">RelationInitIndexAccessInfo</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexcxt = AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;index info&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_SMALL_SIZES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_indexcxt = indexcxt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextCopyAndSetIdentifier(indexcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now we can fetch the index AM's API struct.&nbsp; (We can't store<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that in the init file, since it contains function pointers that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might vary across server executions.&nbsp; Fortunately, it should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * safe to call the amhandler even while bootstrapping indexes.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1401" title="utils/cache/relcache.c:1401">InitIndexAmRoutine</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* read the vector of opfamily OIDs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fread(&amp;len, <span class="Constant">1</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len), fp) != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfamily = (Oid *) <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(indexcxt, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fread(opfamily, <span class="Constant">1</span>, len, fp) != len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_opfamily = opfamily;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* read the vector of opcintype OIDs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fread(&amp;len, <span class="Constant">1</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len), fp) != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcintype = (Oid *) <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(indexcxt, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fread(opcintype, <span class="Constant">1</span>, len, fp) != len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_opcintype = opcintype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* read the vector of support procedure OIDs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fread(&amp;len, <span class="Constant">1</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len), fp) != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; support = (RegProcedure *) <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(indexcxt, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fread(support, <span class="Constant">1</span>, len, fp) != len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_support = support;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* read the vector of collation OIDs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fread(&amp;len, <span class="Constant">1</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len), fp) != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indcollation = (Oid *) <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(indexcxt, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fread(indcollation, <span class="Constant">1</span>, len, fp) != len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_indcollation = indcollation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* read the vector of indoption <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fread(&amp;len, <span class="Constant">1</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len), fp) != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indoption = (int16 *) <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(indexcxt, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fread(indoption, <span class="Constant">1</span>, len, fp) != len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_indoption = indoption;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* read the vector of opcoptions <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_opcoptions = (bytea **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(indexcxt, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*rel-&gt;rd_opcoptions) * relform-&gt;relnatts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; relform-&gt;relnatts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fread(&amp;len, <span class="Constant">1</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len), fp) != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_opcoptions[i] = (bytea *) <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(indexcxt, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fread(rel-&gt;rd_opcoptions[i], <span class="Constant">1</span>, len, fp) != len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set up zeroed fmgr-info vector */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nsupport = relform-&gt;relnatts * rel-&gt;rd_indam-&gt;amsupport;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_supportinfo = (FmgrInfo *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(indexcxt, nsupport * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FmgrInfo));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Count nailed rels to ensure we have 'em all */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_isnailed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nailed_rels++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Load table AM data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RELKIND_HAS_TABLE_AM(rel-&gt;rd_rel-&gt;relkind) || rel-&gt;rd_rel-&gt;relkind == RELKIND_SEQUENCE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1809" title="utils/cache/relcache.c:1809">RelationInitTableAccessMethod</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rel-&gt;rd_index == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rel-&gt;rd_indextuple == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rel-&gt;rd_indexcxt == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rel-&gt;rd_indam == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rel-&gt;rd_opfamily == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rel-&gt;rd_opcintype == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rel-&gt;rd_support == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rel-&gt;rd_supportinfo == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rel-&gt;rd_indoption == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rel-&gt;rd_indcollation == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rel-&gt;rd_opcoptions == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Rules and triggers are not saved (mainly because the <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * format is complex and subject to change).&nbsp; They must be rebuilt if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * needed by <a href="#L4056" title="utils/cache/relcache.c:4056">RelationCacheInitializePhase3</a>.&nbsp; This is not expected to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be a big performance hit since few system catalogs have such. Ditto<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for RLS policy data, partition info, index expressions, predicates,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exclusion info, and FDW info.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rules = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rulescxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;trigdesc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rsdesc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_partkey = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_partkeycxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_partdesc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_partdesc_nodetached = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_partdesc_nodetached_xmin = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_pdcxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_pddcxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_partcheck = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_partcheckvalid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_partcheckcxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_indexprs = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_indpred = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_exclops = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_exclprocs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_exclstrats = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_fdwroutine = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset transient-state fields in the relcache entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_smgr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_isnailed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_refcnt = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_refcnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_indexvalid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_indexlist = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_pkindex = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_replidindex = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_attrsvalid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_keyattr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_pkattr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_idattr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_pubdesc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_statvalid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_statlist = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_fkeyvalid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_fkeylist = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_createSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_newRelfilelocatorSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_firstRelfilelocatorSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_droppedSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_amcache = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;pgstat_info = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Recompute lock and physical addressing info.&nbsp; This is needed in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case the pg_internal.init file was copied from some other database<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by CREATE DATABASE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L71" title="storage/lmgr/lmgr.c:71">RelationInitLockInfo</a>(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1319" title="utils/cache/relcache.c:1319">RelationInitPhysicalAddr</a>(rel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We reached the end of the init file without apparent problem.&nbsp; Did we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get the right number of nailed items?&nbsp; This is a useful crosscheck in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case the set of critical rels or indexes changes.&nbsp; However, that should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not happen in a normally-running system, so let's bleat if it does.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For the shared init file, we're called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> client authentication is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done, which means that elog(WARNING) will go only to the postmaster<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * log, where it's easily missed.&nbsp; To ensure that developers notice bad<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of <a href="#L4035" title="utils/cache/relcache.c:4035">NUM_CRITICAL_SHARED_RELS</a>/<a href="#L4175" title="utils/cache/relcache.c:4175">NUM_CRITICAL_SHARED_INDEXES</a>, we put<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an Assert(false) there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (shared)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nailed_rels != <a href="#L4035" title="utils/cache/relcache.c:4035">NUM_CRITICAL_SHARED_RELS</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nailed_indexes != <a href="#L4175" title="utils/cache/relcache.c:4175">NUM_CRITICAL_SHARED_INDEXES</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;found </span><span class="Special">%d</span><span class="Constant"> nailed shared rels and </span><span class="Special">%d</span><span class="Constant"> nailed shared indexes in init file, but expected </span><span class="Special">%d</span><span class="Constant"> and </span><span class="Special">%d</span><span class="Constant"> respectively&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nailed_rels, nailed_indexes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L4035" title="utils/cache/relcache.c:4035">NUM_CRITICAL_SHARED_RELS</a>, <a href="#L4175" title="utils/cache/relcache.c:4175">NUM_CRITICAL_SHARED_INDEXES</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure we get developers' attention about this */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In production builds, recover by bootstrapping the relcache */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nailed_rels != <a href="#L4092" title="utils/cache/relcache.c:4092">NUM_CRITICAL_LOCAL_RELS</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nailed_indexes != <a href="#L4143" title="utils/cache/relcache.c:4143">NUM_CRITICAL_LOCAL_INDEXES</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;found </span><span class="Special">%d</span><span class="Constant"> nailed rels and </span><span class="Special">%d</span><span class="Constant"> nailed indexes in init file, but expected </span><span class="Special">%d</span><span class="Constant"> and </span><span class="Special">%d</span><span class="Constant"> respectively&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nailed_rels, nailed_indexes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L4092" title="utils/cache/relcache.c:4092">NUM_CRITICAL_LOCAL_RELS</a>, <a href="#L4143" title="utils/cache/relcache.c:4143">NUM_CRITICAL_LOCAL_INDEXES</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't need an Assert() in this case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> read_failed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK, all appears well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now insert all the new relcache entries into the cache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (relno = <span class="Constant">0</span>; relno &lt; num_rels; relno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="utils/cache/relcache.c:209">RelationCacheInsert</a>(rels[relno], <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rels);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2781" title="storage/file/fd.c:2781">FreeFile</a>(fp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (shared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L146" title="utils/cache/relcache.c:146">criticalSharedRelcachesBuilt</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="utils/cache/relcache.c:140">criticalRelcachesBuilt</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * init file is broken, so do it the hard way.&nbsp; We don't bother trying to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * free the clutter we just allocated; it's not in the relcache so it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * won't hurt.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Statement">read_failed</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rels);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2781" title="storage/file/fd.c:2781">FreeFile</a>(fp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write out a new initialization file with the current contents<br/></li>
<li></span><span class="Comment"> * of the relcache (either shared rels or local rels, as indicated).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6479">&#x200c;</a></span><span class="linkable">write_relcache_init_file</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> shared)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">FILE</span>&nbsp; &nbsp; &nbsp;&nbsp; *fp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; tempfilename[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; finalfilename[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; magic;<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L132" title="utils/cache/relcache.c:132">RelIdCacheEnt</a> *idhentry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have already received <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> relcache inval events, there's no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * chance of succeeding so we may as well <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the whole thing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L154" title="utils/cache/relcache.c:154">relcacheInvalsReceived</a> != <span class="Constant">0L</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must write a temporary file and rename it into place. Otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * another backend starting at about the same time might crash trying to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * read the partially-complete file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (shared)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(tempfilename, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tempfilename), <span class="Constant">&quot;global/</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RELCACHE_INIT_FILENAME, <a href="../init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(finalfilename, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(finalfilename), <span class="Constant">&quot;global/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RELCACHE_INIT_FILENAME);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(tempfilename, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tempfilename), <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../init/globals.c.html#L101" title="utils/init/globals.c:101">DatabasePath</a>, RELCACHE_INIT_FILENAME, <a href="../init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(finalfilename, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(finalfilename), <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../init/globals.c.html#L101" title="utils/init/globals.c:101">DatabasePath</a>, RELCACHE_INIT_FILENAME);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; unlink(tempfilename);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in case it exists w/wrong permissions */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; fp = <a href="../../storage/file/fd.c.html#L2583" title="storage/file/fd.c:2583">AllocateFile</a>(tempfilename, PG_BINARY_W);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We used to consider this a fatal error, but we might as well<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * continue with backend startup ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create relation-cache initialization file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tempfilename),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Continuing anyway, but there's something wrong.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Write a magic number to serve as a file version identifier.&nbsp; We can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * change the magic number whenever the relcache layout changes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; magic = <a href="#L93" title="utils/cache/relcache.c:93">RELCACHE_INIT_FILEMAGIC</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fwrite(&amp;magic, <span class="Constant">1</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(magic), fp) != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(magic))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;could not write init file: %m&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Write all the appropriate reldescs (in no particular order).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L134" title="utils/cache/relcache.c:134">RelationIdCache</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((idhentry = (<a href="#L132" title="utils/cache/relcache.c:132">RelIdCacheEnt</a> *) <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel = idhentry-&gt;reldesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class relform = rel-&gt;rd_rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore if not correct group */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relform-&gt;relisshared != shared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore if not supposed to be in init file.&nbsp; We can allow <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation that's been loaded so far to be in the shared init file,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but unshared relations must be ones that should be in the local<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * file per <a href="#L6714" title="utils/cache/relcache.c:6714">RelationIdIsInInitFile</a>.&nbsp; (Note: if you want to change the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * criterion for rels to be kept in the init file, see also inval.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The reason for filtering here is to be sure that we don't put<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anything into the local init file for which a relcache inval would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not cause invalidation of that init file.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!shared &amp;&amp; !<a href="#L6714" title="utils/cache/relcache.c:6714">RelationIdIsInInitFile</a>(RelationGetRelid(rel)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nailed rels had better get stored. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!rel-&gt;rd_isnailed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first write the relcache entry proper */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6691" title="utils/cache/relcache.c:6691">write_item</a>(rel, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelationData), fp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> write the relation tuple form */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6691" title="utils/cache/relcache.c:6691">write_item</a>(relform, CLASS_TUPLE_SIZE, fp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>, do all the attribute tuple form data entries */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; relform-&gt;relnatts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6691" title="utils/cache/relcache.c:6691">write_item</a>(TupleDescAttr(rel-&gt;rd_att, i),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTRIBUTE_FIXED_PART_SIZE, fp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>, do the access method specific field */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6691" title="utils/cache/relcache.c:6691">write_item</a>(rel-&gt;rd_options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (rel-&gt;rd_options ? VARSIZE(rel-&gt;rd_options) : <span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's an index, there's more to do. Note we explicitly ignore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partitioned indexes here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_INDEX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* write the pg_index tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we assume this was created by <a href="../../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>! */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6691" title="utils/cache/relcache.c:6691">write_item</a>(rel-&gt;rd_indextuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HEAPTUPLESIZE + rel-&gt;rd_indextuple-&gt;t_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* write the vector of opfamily OIDs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6691" title="utils/cache/relcache.c:6691">write_item</a>(rel-&gt;rd_opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relform-&gt;relnatts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* write the vector of opcintype OIDs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6691" title="utils/cache/relcache.c:6691">write_item</a>(rel-&gt;rd_opcintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relform-&gt;relnatts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* write the vector of support procedure OIDs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6691" title="utils/cache/relcache.c:6691">write_item</a>(rel-&gt;rd_support,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relform-&gt;relnatts * (rel-&gt;rd_indam-&gt;amsupport * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RegProcedure)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* write the vector of collation OIDs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6691" title="utils/cache/relcache.c:6691">write_item</a>(rel-&gt;rd_indcollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relform-&gt;relnatts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* write the vector of indoption <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6691" title="utils/cache/relcache.c:6691">write_item</a>(rel-&gt;rd_indoption,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relform-&gt;relnatts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int16),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rel-&gt;rd_opcoptions);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* write the vector of opcoptions <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; relform-&gt;relnatts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *opt = rel-&gt;rd_opcoptions[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6691" title="utils/cache/relcache.c:6691">write_item</a>(opt, opt ? VARSIZE(opt) : <span class="Constant">0</span>, fp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L2781" title="storage/file/fd.c:2781">FreeFile</a>(fp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;could not write init file: %m&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we have to check whether the data we've so painstakingly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * accumulated is already obsolete due to someone else's just-committed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catalog changes.&nbsp; If so, we just delete the temp file and leave it to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> backend to try again.&nbsp; (Our own relcache entries will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * updated by SI message processing, but we can't be sure whether what we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wrote out was up-to-date.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This mustn't run concurrently with the code that unlinks an init file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and sends SI messages, so grab a serialization lock for the duration.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(RelCacheInitLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we have seen all incoming SI messages */<br/></li>
<li></span>&nbsp; &nbsp; <a href="inval.c.html#L806" title="utils/cache/inval.c:806">AcceptInvalidationMessages</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have received <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SI relcache invals since backend start, assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we may have written out-of-date data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L154" title="utils/cache/relcache.c:154">relcacheInvalsReceived</a> == <span class="Constant">0L</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OK, rename the temp file to its final name, deleting <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * previously-existing init file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: a failure here is possible under Cygwin, if some other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backend is holding open an unlinked-but-not-yet-gone init file. So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * treat this as a noncritical failure; just remove the useless temp<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * file on failure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rename(tempfilename, finalfilename) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unlink(tempfilename);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> the already-obsolete temp file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; unlink(tempfilename);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(RelCacheInitLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* write a chunk of data preceded by its length */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6691">&#x200c;</a></span><span class="linkable">write_item</span>(<span class="Type">const</span> <span class="Type">void</span> *data, Size len, <span class="Type">FILE</span> *fp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fwrite(&amp;len, <span class="Constant">1</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len), fp) != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;could not write init file: %m&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len &gt; <span class="Constant">0</span> &amp;&amp; fwrite(data, <span class="Constant">1</span>, len, fp) != len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;could not write init file: %m&quot;</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine whether a given relation (identified by OID) is one of the ones<br/></li>
<li></span><span class="Comment"> * we should store in a relcache init file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We must cache all nailed rels, and for efficiency we should cache every rel<br/></li>
<li></span><span class="Comment"> * that supports a syscache.&nbsp; The former set is almost but not quite a <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a><br/></li>
<li></span><span class="Comment"> * of the latter. The special cases are relations where<br/></li>
<li></span><span class="Comment"> * <a href="#L3997" title="utils/cache/relcache.c:3997">RelationCacheInitializePhase2</a>/3 chooses to nail for efficiency reasons, but<br/></li>
<li></span><span class="Comment"> * which do not support <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> syscache.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L6714">&#x200c;</a></span><span class="linkable">RelationIdIsInInitFile</span>(Oid relationId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relationId == SharedSecLabelRelationId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == TriggerRelidNameIndexId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == DatabaseNameIndexId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == SharedSecLabelObjectIndexId)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this Assert fails, we don't need the applicable special case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="syscache.c.html#L649" title="utils/cache/syscache.c:649">RelationSupportsSysCache</a>(relationId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="syscache.c.html#L649" title="utils/cache/syscache.c:649">RelationSupportsSysCache</a>(relationId);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Invalidate (remove) the init file during commit of a transaction that<br/></li>
<li></span><span class="Comment"> * changed one or more of the relation cache entries that are kept in the<br/></li>
<li></span><span class="Comment"> * local init file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To be safe against concurrent inspection or rewriting of the init file,<br/></li>
<li></span><span class="Comment"> * we must take RelCacheInitLock, then remove the old init file, then <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a><br/></li>
<li></span><span class="Comment"> * the SI messages that include relcache inval for such relations, and then<br/></li>
<li></span><span class="Comment"> * release RelCacheInitLock.&nbsp; This serializes the whole affair against<br/></li>
<li></span><span class="Comment"> * <a href="#L6479" title="utils/cache/relcache.c:6479">write_relcache_init_file</a>, so that we can be sure that <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other process<br/></li>
<li></span><span class="Comment"> * that's concurrently trying to create a new init file won't move an<br/></li>
<li></span><span class="Comment"> * already-stale version into place after we unlink.&nbsp; Also, because we unlink<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> sending the SI messages, a backend that's currently starting cannot<br/></li>
<li></span><span class="Comment"> * read the <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-obsolete init file and then <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> the SI messages that will<br/></li>
<li></span><span class="Comment"> * force it to update its relcache entries.&nbsp; (This works because the backend<br/></li>
<li></span><span class="Comment"> * startup sequence gets into the sinval array <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> trying to load the init<br/></li>
<li></span><span class="Comment"> * file.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We take the lock and do the unlink in <a href="#L6754" title="utils/cache/relcache.c:6754">RelationCacheInitFilePreInvalidate</a>,<br/></li>
<li></span><span class="Comment"> * then release the lock in <a href="#L6779" title="utils/cache/relcache.c:6779">RelationCacheInitFilePostInvalidate</a>.&nbsp; Caller must<br/></li>
<li></span><span class="Comment"> * <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending SI messages between those calls.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L6754">&#x200c;</a></span><span class="linkable">RelationCacheInitFilePreInvalidate</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; localinitfname[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; sharedinitfname[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../init/globals.c.html#L101" title="utils/init/globals.c:101">DatabasePath</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(localinitfname, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(localinitfname), <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../init/globals.c.html#L101" title="utils/init/globals.c:101">DatabasePath</a>, RELCACHE_INIT_FILENAME);<br/></li>
<li>&nbsp; &nbsp; snprintf(sharedinitfname, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(sharedinitfname), <span class="Constant">&quot;global/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RELCACHE_INIT_FILENAME);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(RelCacheInitLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The files might not be there if no backend has been started since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * last removal.&nbsp; But complain about failures other than ENOENT with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ERROR.&nbsp; Fortunately, it's not too late to abort the transaction if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't get rid of the would-be-obsolete init file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../init/globals.c.html#L101" title="utils/init/globals.c:101">DatabasePath</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6851" title="utils/cache/relcache.c:6851">unlink_initfile</a>(localinitfname, ERROR);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6851" title="utils/cache/relcache.c:6851">unlink_initfile</a>(sharedinitfname, ERROR);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L6779">&#x200c;</a></span><span class="linkable">RelationCacheInitFilePostInvalidate</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(RelCacheInitLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove the init files during postmaster startup.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We used to keep the init files across restarts, but that is unsafe in PITR<br/></li>
<li></span><span class="Comment"> * scenarios, and even in simple crash-recovery cases there are windows for<br/></li>
<li></span><span class="Comment"> * the init files to become out-of-sync with the database.&nbsp; So <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we just<br/></li>
<li></span><span class="Comment"> * remove them during startup and expect the first backend launch to rebuild<br/></li>
<li></span><span class="Comment"> * them.&nbsp; Of course, this has to happen in each database of the <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L6794">&#x200c;</a></span><span class="linkable">RelationCacheInitFileRemove</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *tblspcdir = <span class="Constant">&quot;pg_tblspc&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> dirent *de;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH + <span class="Constant">10</span> + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TABLESPACE_VERSION_DIRECTORY)];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(path, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(path), <span class="Constant">&quot;global/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RELCACHE_INIT_FILENAME);<br/></li>
<li>&nbsp; &nbsp; <a href="#L6851" title="utils/cache/relcache.c:6851">unlink_initfile</a>(path, LOG);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan everything in the default tablespace */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L6827" title="utils/cache/relcache.c:6827">RelationCacheInitFileRemoveInDir</a>(<span class="Constant">&quot;base&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan the tablespace link directory to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> non-default tablespaces */<br/></li>
<li></span>&nbsp; &nbsp; dir = <a href="../../storage/file/fd.c.html#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(tblspcdir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((de = <a href="../../storage/file/fd.c.html#L2924" title="storage/file/fd.c:2924">ReadDirExtended</a>(dir, tblspcdir, LOG)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strspn(de-&gt;d_name, <span class="Constant">&quot;0123456789&quot;</span>) == strlen(de-&gt;d_name))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Scan the tablespace dir for per-database dirs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(path, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(path), <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tblspcdir, de-&gt;d_name, TABLESPACE_VERSION_DIRECTORY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6827" title="utils/cache/relcache.c:6827">RelationCacheInitFileRemoveInDir</a>(path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2961" title="storage/file/fd.c:2961">FreeDir</a>(dir);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Process one per-tablespace directory for <a href="#L6794" title="utils/cache/relcache.c:6794">RelationCacheInitFileRemove</a> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6827">&#x200c;</a></span><span class="linkable">RelationCacheInitFileRemoveInDir</span>(<span class="Type">const</span> <span class="Type">char</span> *tblspcpath)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> dirent *de;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; initfilename[MAXPGPATH * <span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan the tablespace directory to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> per-database directories */<br/></li>
<li></span>&nbsp; &nbsp; dir = <a href="../../storage/file/fd.c.html#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(tblspcpath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((de = <a href="../../storage/file/fd.c.html#L2924" title="storage/file/fd.c:2924">ReadDirExtended</a>(dir, tblspcpath, LOG)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strspn(de-&gt;d_name, <span class="Constant">&quot;0123456789&quot;</span>) == strlen(de-&gt;d_name))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to remove the init file in each database */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(initfilename, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(initfilename), <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tblspcpath, de-&gt;d_name, RELCACHE_INIT_FILENAME);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6851" title="utils/cache/relcache.c:6851">unlink_initfile</a>(initfilename, LOG);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2961" title="storage/file/fd.c:2961">FreeDir</a>(dir);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6851">&#x200c;</a></span><span class="linkable">unlink_initfile</span>(<span class="Type">const</span> <span class="Type">char</span> *initfilename, <span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlink(initfilename) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It might not be there, but log <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error other than ENOENT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove cache file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initfilename)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ResourceOwner callbacks<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L6868">&#x200c;</a><span class="linkable">ResOwnerPrintRelCache</span>(Datum res)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = (Relation) DatumGetPointer(res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> psprintf(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, RelationGetRelationName(rel));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6876">&#x200c;</a></span><span class="linkable">ResOwnerReleaseRelation</span>(Datum res)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = (Relation) DatumGetPointer(res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This reference has already been removed from the resource owner, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just decrement reference count without calling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2146" title="utils/cache/relcache.c:2146">ResourceOwnerForgetRelationRef</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rel-&gt;rd_refcnt &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; rel-&gt;rd_refcnt -= <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2202" title="utils/cache/relcache.c:2202">RelationCloseCleanup</a>((Relation) res);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
