<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/cache/ts_cache.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/cache/ts_cache.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L70">TSConfigCacheHash</a></li>
<li><a href="#L76">TSCurrentConfig</a></li>
<li><a href="#L78">TSCurrentConfigCache</a></li>
<li><a href="#L67">TSDictionaryCacheHash</a></li>
<li><a href="#L64">TSParserCacheHash</a></li>
<li><a href="#L71">lastUsedConfig</a></li>
<li><a href="#L68">lastUsedDictionary</a></li>
<li><a href="#L65">lastUsedParser</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L94">InvalidateTSCacheCallBack</a></li>
<li><a href="#L670">assign_default_text_search_config</a></li>
<li><a href="#L602">check_default_text_search_config</a></li>
<li><a href="#L556">getTSCurrentConfig</a></li>
<li><a href="#L362">init_ts_config_cache</a></li>
<li><a href="#L385">lookup_ts_config_cache</a></li>
<li><a href="#L208">lookup_ts_dictionary_cache</a></li>
<li><a href="#L113">lookup_ts_parser_cache</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L61">MAXDICTSPERTT</a></li>
<li><a href="#L60">MAXTOKENTYPE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ts_cache.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Tsearch related object caches.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Tsearch performance is very sensitive to performance of parsers,<br/></li>
<li></span><span class="Comment"> * dictionaries and mapping, so lookups should be cached as much<br/></li>
<li></span><span class="Comment"> * as possible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Once a backend has created a cache entry for a particular TS object OID,<br/></li>
<li></span><span class="Comment"> * the cache entry will exist for the life of the backend; hence it is<br/></li>
<li></span><span class="Comment"> * safe to hold onto a pointer to the cache entry while doing things that<br/></li>
<li></span><span class="Comment"> * might result in recognizing a cache invalidation.&nbsp; Beware however that<br/></li>
<li></span><span class="Comment"> * subsidiary information might be deleted and reallocated somewhere else<br/></li>
<li></span><span class="Comment"> * if a cache inval and reval happens!&nbsp; &nbsp; This does not look like it will be<br/></li>
<li></span><span class="Comment"> * a big problem as long as parser and dictionary methods do not attempt<br/></li>
<li></span><span class="Comment"> * <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> database access.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2006-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/cache/ts_cache.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/genam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_ts_config.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_ts_config_map.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_ts_dict.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_ts_parser.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_ts_template.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/defrem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/miscnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tsearch/ts_cache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/catcache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgroids.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc_hooks.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/regproc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L60" title="utils/cache/ts_cache.c:60">MAXTOKENTYPE</a>/<a href="#L61" title="utils/cache/ts_cache.c:61">MAXDICTSPERTT</a> are arbitrary limits on the workspace size<br/></li>
<li></span><span class="Comment"> * used in <a href="#L385" title="utils/cache/ts_cache.c:385">lookup_ts_config_cache</a>().&nbsp; We could avoid hardwiring a limit<br/></li>
<li></span><span class="Comment"> * by making the workspace dynamically enlargeable, but it seems unlikely<br/></li>
<li></span><span class="Comment"> * to be worth the trouble.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L60">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAXTOKENTYPE</span>&nbsp; &nbsp; </span><span class="Constant">256<br/></li>
<li><a id="L61">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAXDICTSPERTT</span>&nbsp; &nbsp; </span><span class="Constant">100<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L64">&#x200c;</a><span class="Type">static</span> <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">TSParserCacheHash</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L65">&#x200c;</a><span class="Type">static</span> TSParserCacheEntry *<span class="linkable">lastUsedParser</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><a id="L67">&#x200c;</a><span class="Type">static</span> <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">TSDictionaryCacheHash</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L68">&#x200c;</a><span class="Type">static</span> TSDictionaryCacheEntry *<span class="linkable">lastUsedDictionary</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><a id="L70">&#x200c;</a><span class="Type">static</span> <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">TSConfigCacheHash</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L71">&#x200c;</a><span class="Type">static</span> TSConfigCacheEntry *<span class="linkable">lastUsedConfig</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC default_text_search_config, and a cache of the current config's OID<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L76">&#x200c;</a></span><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">TSCurrentConfig</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><a id="L78">&#x200c;</a><span class="Type">static</span> Oid&nbsp; &nbsp; <span class="linkable">TSCurrentConfigCache</span> = InvalidOid;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We use this syscache callback to detect when a visible change to a TS<br/></li>
<li></span><span class="Comment"> * catalog entry has been made, by either our own backend or another one.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In principle we could just flush the specific cache entry that changed,<br/></li>
<li></span><span class="Comment"> * but given that TS configuration changes are probably infrequent, it<br/></li>
<li></span><span class="Comment"> * doesn't seem worth the trouble to determine that; we just flush all the<br/></li>
<li></span><span class="Comment"> * entries of the related <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We can use the same function for all TS caches by passing the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment"> * table address as the &quot;arg&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L94">&#x200c;</a></span><span class="linkable">InvalidateTSCacheCallBack</span>(Datum arg, <span class="Type">int</span> cacheid, uint32 hashvalue)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = (<a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *) DatumGetPointer(arg);<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; TSAnyCacheEntry *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((entry = (TSAnyCacheEntry *) <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;isvalid = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Also invalidate the current-config cache if it's pg_ts_config */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> == <a href="#L70" title="utils/cache/ts_cache.c:70">TSConfigCacheHash</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="utils/cache/ts_cache.c:78">TSCurrentConfigCache</a> = InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch parser cache entry<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TSParserCacheEntry *<br/></li>
<li><a id="L113">&#x200c;</a><span class="linkable">lookup_ts_parser_cache</span>(Oid prsId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TSParserCacheEntry *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L64" title="utils/cache/ts_cache.c:64">TSParserCacheHash</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First time through: <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TSParserCacheEntry);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L64" title="utils/cache/ts_cache.c:64">TSParserCacheHash</a> = <a href="../hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;Tsearch parser cache&quot;</span>, <span class="Constant">4</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;ctl, HASH_ELEM | HASH_BLOBS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Flush cache on pg_ts_parser changes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(TSPARSEROID, <a href="#L94" title="utils/cache/ts_cache.c:94">InvalidateTSCacheCallBack</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(<a href="#L64" title="utils/cache/ts_cache.c:64">TSParserCacheHash</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Also make sure <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a> exists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="catcache.c.html#L679" title="utils/cache/catcache.c:679">CreateCacheMemoryContext</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check single-entry cache */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L65" title="utils/cache/ts_cache.c:65">lastUsedParser</a> &amp;&amp; <a href="#L65" title="utils/cache/ts_cache.c:65">lastUsedParser</a>-&gt;prsId == prsId &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L65" title="utils/cache/ts_cache.c:65">lastUsedParser</a>-&gt;isvalid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L65" title="utils/cache/ts_cache.c:65">lastUsedParser</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to look up an existing entry */<br/></li>
<li></span>&nbsp; &nbsp; entry = (TSParserCacheEntry *) <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L64" title="utils/cache/ts_cache.c:64">TSParserCacheHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;prsId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entry == <span class="Constant">NULL</span> || !entry-&gt;isvalid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one, we want to make one. But first look up the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * object to be sure the OID is real.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_ts_parser prs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TSPARSEROID, ObjectIdGetDatum(prsId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for text search parser </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prsId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prs = (Form_pg_ts_parser) GETSTRUCT(tp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sanity checks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(prs-&gt;prsstart))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;text search parser </span><span class="Special">%u</span><span class="Constant"> has no prsstart method&quot;</span>, prsId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(prs-&gt;prstoken))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;text search parser </span><span class="Special">%u</span><span class="Constant"> has no prstoken method&quot;</span>, prsId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(prs-&gt;prsend))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;text search parser </span><span class="Special">%u</span><span class="Constant"> has no prsend method&quot;</span>, prsId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now make the cache entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry = (TSParserCacheEntry *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L64" title="utils/cache/ts_cache.c:64">TSParserCacheHash</a>, &amp;prsId, HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!found);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it wasn't there a moment ago */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(entry, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TSParserCacheEntry));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;prsId = prsId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;startOid = prs-&gt;prsstart;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;tokenOid = prs-&gt;prstoken;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;endOid = prs-&gt;prsend;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;headlineOid = prs-&gt;prsheadline;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;lextypeOid = prs-&gt;prslextype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(entry-&gt;startOid, &amp;entry-&gt;prsstart, <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(entry-&gt;tokenOid, &amp;entry-&gt;prstoken, <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(entry-&gt;endOid, &amp;entry-&gt;prsend, <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(entry-&gt;headlineOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(entry-&gt;headlineOid, &amp;entry-&gt;prsheadline,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;isvalid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="utils/cache/ts_cache.c:65">lastUsedParser</a> = entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> entry;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch dictionary cache entry<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TSDictionaryCacheEntry *<br/></li>
<li><a id="L208">&#x200c;</a><span class="linkable">lookup_ts_dictionary_cache</span>(Oid dictId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TSDictionaryCacheEntry *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L67" title="utils/cache/ts_cache.c:67">TSDictionaryCacheHash</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First time through: <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TSDictionaryCacheEntry);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L67" title="utils/cache/ts_cache.c:67">TSDictionaryCacheHash</a> = <a href="../hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;Tsearch dictionary cache&quot;</span>, <span class="Constant">8</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;ctl, HASH_ELEM | HASH_BLOBS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Flush cache on pg_ts_dict and pg_ts_template changes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(TSDICTOID, <a href="#L94" title="utils/cache/ts_cache.c:94">InvalidateTSCacheCallBack</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(<a href="#L67" title="utils/cache/ts_cache.c:67">TSDictionaryCacheHash</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(TSTEMPLATEOID, <a href="#L94" title="utils/cache/ts_cache.c:94">InvalidateTSCacheCallBack</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(<a href="#L67" title="utils/cache/ts_cache.c:67">TSDictionaryCacheHash</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Also make sure <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a> exists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="catcache.c.html#L679" title="utils/cache/catcache.c:679">CreateCacheMemoryContext</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check single-entry cache */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L68" title="utils/cache/ts_cache.c:68">lastUsedDictionary</a> &amp;&amp; <a href="#L68" title="utils/cache/ts_cache.c:68">lastUsedDictionary</a>-&gt;dictId == dictId &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L68" title="utils/cache/ts_cache.c:68">lastUsedDictionary</a>-&gt;isvalid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L68" title="utils/cache/ts_cache.c:68">lastUsedDictionary</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to look up an existing entry */<br/></li>
<li></span>&nbsp; &nbsp; entry = (TSDictionaryCacheEntry *) <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L67" title="utils/cache/ts_cache.c:67">TSDictionaryCacheHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;dictId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entry == <span class="Constant">NULL</span> || !entry-&gt;isvalid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one, we want to make one. But first look up the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * object to be sure the OID is real.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tpdict,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tptmpl;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_ts_dict dict;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_ts_template template;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext saveCtx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tpdict = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TSDICTOID, ObjectIdGetDatum(dictId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tpdict))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for text search dictionary </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dictId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dict = (Form_pg_ts_dict) GETSTRUCT(tpdict);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sanity checks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(dict-&gt;dicttemplate))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;text search dictionary </span><span class="Special">%u</span><span class="Constant"> has no template&quot;</span>, dictId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Retrieve dictionary's template<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tptmpl = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TSTEMPLATEOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(dict-&gt;dicttemplate));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tptmpl))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for text search template </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dict-&gt;dicttemplate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; template = (Form_pg_ts_template) GETSTRUCT(tptmpl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sanity checks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(template-&gt;tmpllexize))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;text search template </span><span class="Special">%u</span><span class="Constant"> has no lexize method&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; template-&gt;tmpllexize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now make the cache entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry = (TSDictionaryCacheEntry *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L67" title="utils/cache/ts_cache.c:67">TSDictionaryCacheHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;dictId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!found);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it wasn't there a moment ago */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create private memory context the first time through */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saveCtx = AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;TS dictionary&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_SMALL_SIZES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextCopyAndSetIdentifier(saveCtx, NameStr(dict-&gt;dictname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Clear the existing entry's private context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saveCtx = entry-&gt;dictCtx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't let context's ident pointer dangle while we reset it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L612" title="utils/mmgr/mcxt.c:612">MemoryContextSetIdentifier</a>(saveCtx, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(saveCtx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextCopyAndSetIdentifier(saveCtx, NameStr(dict-&gt;dictname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(entry, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TSDictionaryCacheEntry));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;dictId = dictId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;dictCtx = saveCtx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;lexizeOid = template-&gt;tmpllexize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(template-&gt;tmplinit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *dictoptions;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; opt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Init method runs in dictionary's private memory context, and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make sure the options are stored there too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(entry-&gt;dictCtx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opt = <a href="syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(TSDICTOID, tpdict,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_ts_dict_dictinitoption,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dictoptions = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dictoptions = <a href="../../commands/tsearchcmds.c.html#L1621" title="commands/tsearchcmds.c:1621">deserialize_deflist</a>(opt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;dictData =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetPointer(OidFunctionCall1(template-&gt;tmplinit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(dictoptions)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tptmpl);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tpdict);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(entry-&gt;lexizeOid, &amp;entry-&gt;lexize, entry-&gt;dictCtx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;isvalid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/cache/ts_cache.c:68">lastUsedDictionary</a> = entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> entry;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize config cache and prepare callbacks.&nbsp; This is split out of<br/></li>
<li></span><span class="Comment"> * <a href="#L385" title="utils/cache/ts_cache.c:385">lookup_ts_config_cache</a> because we need to activate the callback <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * caching <a href="#L78" title="utils/cache/ts_cache.c:78">TSCurrentConfigCache</a>, too.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L362">&#x200c;</a></span><span class="linkable">init_ts_config_cache</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid);<br/></li>
<li>&nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TSConfigCacheEntry);<br/></li>
<li>&nbsp; &nbsp; <a href="#L70" title="utils/cache/ts_cache.c:70">TSConfigCacheHash</a> = <a href="../hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;Tsearch configuration cache&quot;</span>, <span class="Constant">16</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;ctl, HASH_ELEM | HASH_BLOBS);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Flush cache on pg_ts_config and pg_ts_config_map changes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(TSCONFIGOID, <a href="#L94" title="utils/cache/ts_cache.c:94">InvalidateTSCacheCallBack</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(<a href="#L70" title="utils/cache/ts_cache.c:70">TSConfigCacheHash</a>));<br/></li>
<li>&nbsp; &nbsp; <a href="inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(TSCONFIGMAP, <a href="#L94" title="utils/cache/ts_cache.c:94">InvalidateTSCacheCallBack</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(<a href="#L70" title="utils/cache/ts_cache.c:70">TSConfigCacheHash</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Also make sure <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a> exists */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="catcache.c.html#L679" title="utils/cache/catcache.c:679">CreateCacheMemoryContext</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch configuration cache entry<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TSConfigCacheEntry *<br/></li>
<li><a id="L385">&#x200c;</a><span class="linkable">lookup_ts_config_cache</span>(Oid cfgId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TSConfigCacheEntry *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L70" title="utils/cache/ts_cache.c:70">TSConfigCacheHash</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First time through: <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L362" title="utils/cache/ts_cache.c:362">init_ts_config_cache</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check single-entry cache */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L71" title="utils/cache/ts_cache.c:71">lastUsedConfig</a> &amp;&amp; <a href="#L71" title="utils/cache/ts_cache.c:71">lastUsedConfig</a>-&gt;cfgId == cfgId &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="utils/cache/ts_cache.c:71">lastUsedConfig</a>-&gt;isvalid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L71" title="utils/cache/ts_cache.c:71">lastUsedConfig</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to look up an existing entry */<br/></li>
<li></span>&nbsp; &nbsp; entry = (TSConfigCacheEntry *) <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L70" title="utils/cache/ts_cache.c:70">TSConfigCacheHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;cfgId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entry == <span class="Constant">NULL</span> || !entry-&gt;isvalid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one, we want to make one. But first look up the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * object to be sure the OID is real.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_ts_config cfg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; maprel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; mapidx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKeyData mapskey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SysScanDesc mapscan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; maptup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListDictionary maplists[<a href="#L60" title="utils/cache/ts_cache.c:60">MAXTOKENTYPE</a> + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapdicts[<a href="#L61" title="utils/cache/ts_cache.c:61">MAXDICTSPERTT</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxtokentype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndicts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TSCONFIGOID, ObjectIdGetDatum(cfgId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for text search configuration </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cfgId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cfg = (Form_pg_ts_config) GETSTRUCT(tp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sanity checks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(cfg-&gt;cfgparser))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;text search configuration </span><span class="Special">%u</span><span class="Constant"> has no parser&quot;</span>, cfgId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now make the cache entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry = (TSConfigCacheEntry *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L70" title="utils/cache/ts_cache.c:70">TSConfigCacheHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;cfgId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!found);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it wasn't there a moment ago */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Cleanup old contents */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;map)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; entry-&gt;lenmap; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;map[i].dictIds)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(entry-&gt;map[i].dictIds);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(entry-&gt;map);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(entry, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TSConfigCacheEntry));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;cfgId = cfgId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;prsId = cfg-&gt;cfgparser;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Scan pg_ts_config_map to gather dictionary list for each token type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Because the index is on (mapcfg, maptokentype, mapseqno), we will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * see the entries in maptokentype order, and in mapseqno order for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * each token type, even though we didn't explicitly ask for that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(maplists, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(maplists));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxtokentype = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndicts = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;mapskey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_ts_config_map_mapcfg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(cfgId));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maprel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(TSConfigMapRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mapidx = <a href="../../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(TSConfigMapIndexId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mapscan = <a href="../../access/index/genam.c.html#L643" title="access/index/genam.c:643">systable_beginscan_ordered</a>(maprel, mapidx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">1</span>, &amp;mapskey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((maptup = <a href="../../access/index/genam.c.html#L710" title="access/index/genam.c:710">systable_getnext_ordered</a>(mapscan, ForwardScanDirection)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_ts_config_map cfgmap = (Form_pg_ts_config_map) GETSTRUCT(maptup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toktype = cfgmap-&gt;maptokentype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (toktype &lt;= <span class="Constant">0</span> || toktype &gt; <a href="#L60" title="utils/cache/ts_cache.c:60">MAXTOKENTYPE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;maptokentype value </span><span class="Special">%d</span><span class="Constant"> is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>, toktype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (toktype &lt; maxtokentype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;maptokentype entries are out of order&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (toktype &gt; maxtokentype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* starting a new token type, but first save the prior data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndicts &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maplists[maxtokentype].len = ndicts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maplists[maxtokentype].dictIds = (Oid *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * ndicts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(maplists[maxtokentype].dictIds, mapdicts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * ndicts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxtokentype = toktype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapdicts[<span class="Constant">0</span>] = cfgmap-&gt;mapdict;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndicts = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* continuing data for current token type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndicts &gt;= <a href="#L61" title="utils/cache/ts_cache.c:61">MAXDICTSPERTT</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;too many pg_ts_config_map entries for one token type&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapdicts[ndicts++] = cfgmap-&gt;mapdict;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/index/genam.c.html#L735" title="access/index/genam.c:735">systable_endscan_ordered</a>(mapscan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(mapidx, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(maprel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndicts &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* save the last token type's dictionaries */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maplists[maxtokentype].len = ndicts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maplists[maxtokentype].dictIds = (Oid *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * ndicts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(maplists[maxtokentype].dictIds, mapdicts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * ndicts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and save the overall map */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;lenmap = maxtokentype + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;map = (ListDictionary *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListDictionary) * entry-&gt;lenmap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(entry-&gt;map, maplists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ListDictionary) * entry-&gt;lenmap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;isvalid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L71" title="utils/cache/ts_cache.c:71">lastUsedConfig</a> = entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> entry;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*---------------------------------------------------<br/></li>
<li></span><span class="Comment"> * GUC variable &quot;default_text_search_config&quot;<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Oid<br/></li>
<li><a id="L556">&#x200c;</a><span class="linkable">getTSCurrentConfig</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> emitError)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *namelist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if we have a cached value, return it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(<a href="#L78" title="utils/cache/ts_cache.c:78">TSCurrentConfigCache</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L78" title="utils/cache/ts_cache.c:78">TSCurrentConfigCache</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fail if GUC hasn't been set up yet */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L76" title="utils/cache/ts_cache.c:76">TSCurrentConfig</a> == <span class="Constant">NULL</span> || *<a href="#L76" title="utils/cache/ts_cache.c:76">TSCurrentConfig</a> == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (emitError)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;text search configuration isn't set&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L70" title="utils/cache/ts_cache.c:70">TSConfigCacheHash</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First time through: <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the tsconfig inval callback */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L362" title="utils/cache/ts_cache.c:362">init_ts_config_cache</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look up the config */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (emitError)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; namelist = <a href="../adt/regproc.c.html#L1797" title="utils/adt/regproc.c:1797">stringToQualifiedNameList</a>(<a href="#L76" title="utils/cache/ts_cache.c:76">TSCurrentConfig</a>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="utils/cache/ts_cache.c:78">TSCurrentConfigCache</a> = <a href="../../catalog/namespace.c.html#L3137" title="catalog/namespace.c:3137">get_ts_config_oid</a>(namelist, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ErrorSaveContext escontext = {T_ErrorSaveContext};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; namelist = <a href="../adt/regproc.c.html#L1797" title="utils/adt/regproc.c:1797">stringToQualifiedNameList</a>(<a href="#L76" title="utils/cache/ts_cache.c:76">TSCurrentConfig</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) &amp;escontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (namelist != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="utils/cache/ts_cache.c:78">TSCurrentConfigCache</a> = <a href="../../catalog/namespace.c.html#L3137" title="catalog/namespace.c:3137">get_ts_config_oid</a>(namelist, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="utils/cache/ts_cache.c:78">TSCurrentConfigCache</a> = InvalidOid;&nbsp; &nbsp; <span class="Comment">/* bad name list syntax */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L78" title="utils/cache/ts_cache.c:78">TSCurrentConfigCache</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* GUC check_hook for default_text_search_config */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L602">&#x200c;</a></span><span class="linkable">check_default_text_search_config</span>(<span class="Type">char</span> **<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we aren't inside a transaction, or connected to a database, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cannot do the catalog accesses necessary to verify the config name.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> it on faith.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>() &amp;&amp; <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a> != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ErrorSaveContext escontext = {T_ErrorSaveContext};<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *namelist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cfgId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_ts_config cfg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; namelist = <a href="../adt/regproc.c.html#L1797" title="utils/adt/regproc.c:1797">stringToQualifiedNameList</a>(*<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) &amp;escontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (namelist != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cfgId = <a href="../../catalog/namespace.c.html#L3137" title="catalog/namespace.c:3137">get_ts_config_oid</a>(namelist, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cfgId = InvalidOid; <span class="Comment">/* bad name list syntax */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When source == PGC_S_TEST, don't throw a hard error for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nonexistent configuration, only a NOTICE.&nbsp; See comments in guc.h.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(cfgId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (source == PGC_S_TEST)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;text search configuration </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>, *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Modify the actually stored value to be fully qualified, to ensure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * later changes of search_path don't affect it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TSCONFIGOID, ObjectIdGetDatum(cfgId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for text search configuration </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cfgId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cfg = (Form_pg_ts_config) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../adt/ruleutils.c.html#L12707" title="utils/adt/ruleutils.c:12707">quote_qualified_identifier</a>(<a href="lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(cfg-&gt;cfgnamespace),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(cfg-&gt;cfgname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* GUC wants it <a href="../misc/guc.c.html#L640" title="utils/misc/guc.c:640">guc_malloc</a>'d not <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc.c.html#L691" title="utils/misc/guc.c:691">guc_free</a>(*<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = <a href="../misc/guc.c.html#L679" title="utils/misc/guc.c:679">guc_strdup</a>(LOG, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!*<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* GUC assign_hook for default_text_search_config */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L670">&#x200c;</a></span><span class="linkable">assign_default_text_search_config</span>(<span class="Type">const</span> <span class="Type">char</span> *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Just reset the cache to force a lookup on first use */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L78" title="utils/cache/ts_cache.c:78">TSCurrentConfigCache</a> = InvalidOid;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
