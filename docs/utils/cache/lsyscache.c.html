<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/cache/lsyscache.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/cache/lsyscache.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L53">get_attavgwidth_hook</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L749">comparison_ops_are_compatible</a></li>
<li><a href="#L698">equality_ops_are_compatible</a></li>
<li><a href="#L3344">free_attstatsslot</a></li>
<li><a href="#L1799">func_parallel</a></li>
<li><a href="#L1761">func_strict</a></li>
<li><a href="#L1780">func_volatile</a></li>
<li><a href="#L2521">getBaseType</a></li>
<li><a href="#L2538">getBaseTypeAndTypmod</a></li>
<li><a href="#L3130">getSubscriptingRoutines</a></li>
<li><a href="#L2940">getTypeBinaryInputInfo</a></li>
<li><a href="#L2973">getTypeBinaryOutputInfo</a></li>
<li><a href="#L2303">getTypeIOParam</a></li>
<li><a href="#L2874">getTypeInputInfo</a></li>
<li><a href="#L2907">getTypeOutputInfo</a></li>
<li><a href="#L2787">get_array_type</a></li>
<li><a href="#L3158">get_attavgwidth</a></li>
<li><a href="#L888">get_attgenerated</a></li>
<li><a href="#L827">get_attname</a></li>
<li><a href="#L858">get_attnum</a></li>
<li><a href="#L970">get_attoptions</a></li>
<li><a href="#L3234">get_attstatsslot</a></li>
<li><a href="#L913">get_atttype</a></li>
<li><a href="#L943">get_atttypetypmodcoll</a></li>
<li><a href="#L2832">get_base_element_type</a></li>
<li><a href="#L1007">get_cast_oid</a></li>
<li><a href="#L1054">get_collation_isdeterministic</a></li>
<li><a href="#L1035">get_collation_name</a></li>
<li><a href="#L1509">get_commutator</a></li>
<li><a href="#L410">get_compatible_hash_operators</a></li>
<li><a href="#L1113">get_constraint_index</a></li>
<li><a href="#L1081">get_constraint_name</a></li>
<li><a href="#L1143">get_constraint_type</a></li>
<li><a href="#L2759">get_element_type</a></li>
<li><a href="#L267">get_equality_op_for_ordering_op</a></li>
<li><a href="#L1837">get_func_leakproof</a></li>
<li><a href="#L1608">get_func_name</a></li>
<li><a href="#L1632">get_func_namespace</a></li>
<li><a href="#L1674">get_func_nargs</a></li>
<li><a href="#L1818">get_func_prokind</a></li>
<li><a href="#L1742">get_func_retset</a></li>
<li><a href="#L1655">get_func_rettype</a></li>
<li><a href="#L1696">get_func_signature</a></li>
<li><a href="#L1858">get_func_support</a></li>
<li><a href="#L1723">get_func_variadictype</a></li>
<li><a href="#L3512">get_index_column_opclass</a></li>
<li><a href="#L3601">get_index_isclustered</a></li>
<li><a href="#L3555">get_index_isreplident</a></li>
<li><a href="#L3578">get_index_isvalid</a></li>
<li><a href="#L1161">get_language_name</a></li>
<li><a href="#L366">get_mergejoin_opfamilies</a></li>
<li><a href="#L3483">get_multirange_range</a></li>
<li><a href="#L3366">get_namespace_name</a></li>
<li><a href="#L3390">get_namespace_name_or_temp</a></li>
<li><a href="#L1533">get_negator</a></li>
<li><a href="#L601">get_op_btree_interpretation</a></li>
<li><a href="#L510">get_op_hash_functions</a></li>
<li><a href="#L136">get_op_opfamily_properties</a></li>
<li><a href="#L108">get_op_opfamily_sortfamily</a></li>
<li><a href="#L83">get_op_opfamily_strategy</a></li>
<li><a href="#L1333">get_op_rettype</a></li>
<li><a href="#L1190">get_opclass_family</a></li>
<li><a href="#L1212">get_opclass_input_type</a></li>
<li><a href="#L1260">get_opclass_method</a></li>
<li><a href="#L1235">get_opclass_opfamily_and_input_type</a></li>
<li><a href="#L1285">get_opcode</a></li>
<li><a href="#L166">get_opfamily_member</a></li>
<li><a href="#L796">get_opfamily_proc</a></li>
<li><a href="#L1310">get_opname</a></li>
<li><a href="#L1581">get_oprjoin</a></li>
<li><a href="#L1557">get_oprrest</a></li>
<li><a href="#L305">get_ordering_op_for_equality_op</a></li>
<li><a href="#L207">get_ordering_op_properties</a></li>
<li><a href="#L2811">get_promoted_array_type</a></li>
<li><a href="#L3645">get_publication_name</a></li>
<li><a href="#L3625">get_publication_oid</a></li>
<li><a href="#L3433">get_range_collation</a></li>
<li><a href="#L3458">get_range_multirange</a></li>
<li><a href="#L3407">get_range_subtype</a></li>
<li><a href="#L1928">get_rel_name</a></li>
<li><a href="#L1952">get_rel_namespace</a></li>
<li><a href="#L2078">get_rel_persistence</a></li>
<li><a href="#L2100">get_rel_relam</a></li>
<li><a href="#L2027">get_rel_relispartition</a></li>
<li><a href="#L2003">get_rel_relkind</a></li>
<li><a href="#L2054">get_rel_tablespace</a></li>
<li><a href="#L1979">get_rel_type_id</a></li>
<li><a href="#L1885">get_relname_relid</a></li>
<li><a href="#L1899">get_relnatts</a></li>
<li><a href="#L3695">get_subscription_name</a></li>
<li><a href="#L3675">get_subscription_oid</a></li>
<li><a href="#L2120">get_transform_fromsql</a></li>
<li><a href="#L2142">get_transform_tosql</a></li>
<li><a href="#L2731">get_typ_typrelid</a></li>
<li><a href="#L2399">get_typalign</a></li>
<li><a href="#L2578">get_typavgwidth</a></li>
<li><a href="#L2222">get_typbyval</a></li>
<li><a href="#L3056">get_typcollation</a></li>
<li><a href="#L2448">get_typdefault</a></li>
<li><a href="#L2710">get_type_category_preferred</a></li>
<li><a href="#L2325">get_type_io_data</a></li>
<li><a href="#L2173">get_typisdefined</a></li>
<li><a href="#L2197">get_typlen</a></li>
<li><a href="#L2251">get_typlenbyval</a></li>
<li><a href="#L2271">get_typlenbyvalalign</a></li>
<li><a href="#L3006">get_typmodin</a></li>
<li><a href="#L3031">get_typmodout</a></li>
<li><a href="#L2419">get_typstorage</a></li>
<li><a href="#L3097">get_typsubscript</a></li>
<li><a href="#L2629">get_typtype</a></li>
<li><a href="#L1437">op_hashjoinable</a></li>
<li><a href="#L66">op_in_opfamily</a></li>
<li><a href="#L1358">op_input_types</a></li>
<li><a href="#L1386">op_mergejoinable</a></li>
<li><a href="#L1477">op_strict</a></li>
<li><a href="#L1493">op_volatile</a></li>
<li><a href="#L3081">type_is_collatable</a></li>
<li><a href="#L2678">type_is_enum</a></li>
<li><a href="#L2698">type_is_multirange</a></li>
<li><a href="#L2688">type_is_range</a></li>
<li><a href="#L2655">type_is_rowtype</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * lsyscache.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Convenience routines for common queries in the system catalog cache.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/cache/lsyscache.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Eventually, the index information should go through here, too.<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;bootstrap/bootstrap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_am.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_amop.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_amproc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_cast.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_class.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_collation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_constraint.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_index.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_language.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_opclass.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_operator.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_publication.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_range.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_statistic.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_subscription.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_transform.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/catcache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgroids.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/typcache.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Hook for plugins to get control in <a href="#L3158" title="utils/cache/lsyscache.c:3158">get_attavgwidth</a>() */<br/></li>
<li><a id="L53">&#x200c;</a></span>get_attavgwidth_hook_type <span class="linkable">get_attavgwidth_hook</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ---------- AMOP CACHES ----------&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L66" title="utils/cache/lsyscache.c:66">op_in_opfamily</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return t iff operator 'opno' is in operator family 'opfamily'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function only considers search operators, not ordering operators.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L66">&#x200c;</a></span><span class="linkable">op_in_opfamily</span>(Oid opno, Oid opfamily)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> SearchSysCacheExists3(AMOPOPID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(opno),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CharGetDatum(AMOP_SEARCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(opfamily));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L83" title="utils/cache/lsyscache.c:83">get_op_opfamily_strategy</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get the operator's strategy number within the specified opfamily,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; or 0 if it's not a member of the opfamily.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function only considers search operators, not ordering operators.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L83">&#x200c;</a></span><span class="linkable">get_op_opfamily_strategy</span>(Oid opno, Oid opfamily)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Form_pg_amop amop_tup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L240" title="utils/cache/syscache.c:240">SearchSysCache3</a>(AMOPOPID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(opno),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CharGetDatum(AMOP_SEARCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(opfamily));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; amop_tup = (Form_pg_amop) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; result = amop_tup-&gt;amopstrategy;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L108" title="utils/cache/lsyscache.c:108">get_op_opfamily_sortfamily</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If the operator is an ordering operator within the specified opfamily,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; return its amopsortfamily OID; else return InvalidOid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L108">&#x200c;</a><span class="linkable">get_op_opfamily_sortfamily</span>(Oid opno, Oid opfamily)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Form_pg_amop amop_tup;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L240" title="utils/cache/syscache.c:240">SearchSysCache3</a>(AMOPOPID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(opno),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CharGetDatum(AMOP_ORDER),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(opfamily));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>&nbsp; &nbsp; amop_tup = (Form_pg_amop) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; result = amop_tup-&gt;amopsortfamily;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L136" title="utils/cache/lsyscache.c:136">get_op_opfamily_properties</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get the operator's strategy number and declared input data types<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; within the specified opfamily.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller should already have verified that opno is a member of opfamily,<br/></li>
<li></span><span class="Comment"> * therefore we raise an error if the tuple is not found.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L136">&#x200c;</a></span><span class="linkable">get_op_opfamily_properties</span>(Oid opno, Oid opfamily, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> ordering_op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *lefttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *righttype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Form_pg_amop amop_tup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L240" title="utils/cache/syscache.c:240">SearchSysCache3</a>(AMOPOPID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(opno),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CharGetDatum(ordering_op ? AMOP_ORDER : AMOP_SEARCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(opfamily));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;operator </span><span class="Special">%u</span><span class="Constant"> is not a member of opfamily </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; opno, opfamily);<br/></li>
<li>&nbsp; &nbsp; amop_tup = (Form_pg_amop) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; *strategy = amop_tup-&gt;amopstrategy;<br/></li>
<li>&nbsp; &nbsp; *lefttype = amop_tup-&gt;amoplefttype;<br/></li>
<li>&nbsp; &nbsp; *righttype = amop_tup-&gt;amoprighttype;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get the OID of the operator that implements the specified strategy<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; with the specified datatypes for the specified opfamily.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns InvalidOid if there is no pg_amop entry for the given keys.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L166">&#x200c;</a><span class="linkable">get_opfamily_member</span>(Oid opfamily, Oid lefttype, Oid righttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int16 strategy)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Form_pg_amop amop_tup;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L251" title="utils/cache/syscache.c:251">SearchSysCache4</a>(AMOPSTRATEGY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(opfamily),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(lefttype),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(righttype),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int16GetDatum(strategy));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>&nbsp; &nbsp; amop_tup = (Form_pg_amop) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; result = amop_tup-&gt;amopopr;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L207" title="utils/cache/lsyscache.c:207">get_ordering_op_properties</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the OID of an ordering operator (a btree &quot;&lt;&quot; or &quot;&gt;&quot; operator),<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; determine its opfamily, its declared input datatype, and its<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; strategy number (BTLessStrategyNumber or BTGreaterStrategyNumber).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if no matching pg_amop entry exists.<br/></li>
<li></span><span class="Comment"> * (This indicates that the operator is not a valid ordering operator.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the operator could be registered in multiple families, for example<br/></li>
<li></span><span class="Comment"> * if someone were to build a &quot;reverse sort&quot; opfamily.&nbsp; This would result in<br/></li>
<li></span><span class="Comment"> * uncertainty as to whether &quot;ORDER BY USING op&quot; would default to NULLS FIRST<br/></li>
<li></span><span class="Comment"> * or NULLS LAST, as well as inefficient planning due to failure to match up<br/></li>
<li></span><span class="Comment"> * pathkeys that should be the same.&nbsp; So we want a determinate result here.<br/></li>
<li></span><span class="Comment"> * Because of the way the syscache search works, we'll use the interpretation<br/></li>
<li></span><span class="Comment"> * associated with the opfamily with smallest OID, which is probably<br/></li>
<li></span><span class="Comment"> * determinate enough.&nbsp; Since there is no longer <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> particularly good reason<br/></li>
<li></span><span class="Comment"> * to build reverse-sort opfamilies, it doesn't seem worth expending <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * additional effort on ensuring consistency.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L207">&#x200c;</a></span><span class="linkable">get_ordering_op_properties</span>(Oid opno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *opfamily, Oid *opcintype, int16 *strategy)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; CatCList&nbsp;&nbsp; *catlist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ensure outputs are initialized on failure */<br/></li>
<li></span>&nbsp; &nbsp; *opfamily = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; *opcintype = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; *strategy = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Search pg_amop to see if the target operator is registered as the &quot;&lt;&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or &quot;&gt;&quot; operator of <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> btree opfamily.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; catlist = SearchSysCacheList1(AMOPOPID, ObjectIdGetDatum(opno));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; catlist-&gt;n_members; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple = &amp;catlist-&gt;members[i]-&gt;tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_amop aform = (Form_pg_amop) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must be btree */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aform-&gt;amopmethod != BTREE_AM_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aform-&gt;amopstrategy == BTLessStrategyNumber ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aform-&gt;amopstrategy == BTGreaterStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found it ... should have consistent input types */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aform-&gt;amoplefttype == aform-&gt;amoprighttype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found a suitable opfamily, return info */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *opfamily = aform-&gt;amopfamily;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *opcintype = aform-&gt;amoplefttype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *strategy = aform-&gt;amopstrategy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseSysCacheList(catlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L267" title="utils/cache/lsyscache.c:267">get_equality_op_for_ordering_op</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get the OID of the datatype-specific btree equality operator<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; associated with an ordering operator (a &quot;&lt;&quot; or &quot;&gt;&quot; operator).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If &quot;reverse&quot; isn't NULL, also set *reverse to false if the operator is &quot;&lt;&quot;,<br/></li>
<li></span><span class="Comment"> * true if it's &quot;&gt;&quot;<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns InvalidOid if no matching equality operator can be found.<br/></li>
<li></span><span class="Comment"> * (This indicates that the operator is not a valid ordering operator.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L267">&#x200c;</a><span class="linkable">get_equality_op_for_ordering_op</span>(Oid opno, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *reverse)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfamily;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcintype;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; strategy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the operator in pg_amop */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L207" title="utils/cache/lsyscache.c:207">get_ordering_op_properties</a>(opno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;opfamily, &amp;opcintype, &amp;strategy))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found a suitable opfamily, get matching equality operator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; opcintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; opcintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTEqualStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (reverse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *reverse = (strategy == BTGreaterStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L305" title="utils/cache/lsyscache.c:305">get_ordering_op_for_equality_op</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get the OID of a datatype-specific btree ordering operator<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; associated with an equality operator.&nbsp; (If there are multiple<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; possibilities, assume <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one will do.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is used when we have to sort data <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> unique-ifying,<br/></li>
<li></span><span class="Comment"> * and don't much care which sorting op is used as long as it's compatible<br/></li>
<li></span><span class="Comment"> * with the intended equality operator.&nbsp; Since we need a sorting operator,<br/></li>
<li></span><span class="Comment"> * it should be single-data-type even if the given operator is cross-type.<br/></li>
<li></span><span class="Comment"> * The caller specifies whether to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an op for the LHS or RHS data type.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns InvalidOid if no matching ordering operator can be found.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L305">&#x200c;</a><span class="linkable">get_ordering_op_for_equality_op</span>(Oid opno, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> use_lhs_type)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; CatCList&nbsp;&nbsp; *catlist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Search pg_amop to see if the target operator is registered as the &quot;=&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operator of <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> btree opfamily.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; catlist = SearchSysCacheList1(AMOPOPID, ObjectIdGetDatum(opno));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; catlist-&gt;n_members; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple = &amp;catlist-&gt;members[i]-&gt;tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_amop aform = (Form_pg_amop) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must be btree */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aform-&gt;amopmethod != BTREE_AM_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aform-&gt;amopstrategy == BTEqualStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found a suitable opfamily, get matching ordering operator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typid = use_lhs_type ? aform-&gt;amoplefttype : aform-&gt;amoprighttype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(aform-&gt;amopfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typid, typid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTLessStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* failure probably shouldn't happen, but keep looking if so */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseSysCacheList(catlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L366" title="utils/cache/lsyscache.c:366">get_mergejoin_opfamilies</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given a putatively mergejoinable operator, return a list of the OIDs<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; of the btree opfamilies in which it represents equality.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is possible (though at present unusual) for an operator to be equality<br/></li>
<li></span><span class="Comment"> * in more than one opfamily, hence the result is a list.&nbsp; This also lets us<br/></li>
<li></span><span class="Comment"> * return NIL if the operator is not found in <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> opfamilies.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> currently uses simple <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>() tests to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the lists<br/></li>
<li></span><span class="Comment"> * returned by this function, which makes the list order relevant, though<br/></li>
<li></span><span class="Comment"> * strictly speaking it should not be.&nbsp; Because of the way syscache list<br/></li>
<li></span><span class="Comment"> * searches are handled, in normal operation the result will be sorted by OID<br/></li>
<li></span><span class="Comment"> * so everything works fine.&nbsp; If running with system index usage disabled,<br/></li>
<li></span><span class="Comment"> * the result ordering is unspecified and hence the <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> might fail to<br/></li>
<li></span><span class="Comment"> * recognize optimization opportunities ... but that's hardly a scenario in<br/></li>
<li></span><span class="Comment"> * which performance is good anyway, so there's no point in expending code<br/></li>
<li></span><span class="Comment"> * or cycles here to guarantee the ordering in that case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L366">&#x200c;</a><span class="linkable">get_mergejoin_opfamilies</span>(Oid opno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li>&nbsp; &nbsp; CatCList&nbsp;&nbsp; *catlist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Search pg_amop to see if the target operator is registered as the &quot;=&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operator of <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> btree opfamily.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; catlist = SearchSysCacheList1(AMOPOPID, ObjectIdGetDatum(opno));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; catlist-&gt;n_members; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple = &amp;catlist-&gt;members[i]-&gt;tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_amop aform = (Form_pg_amop) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must be btree equality */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aform-&gt;amopmethod == BTREE_AM_OID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aform-&gt;amopstrategy == BTEqualStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(result, aform-&gt;amopfamily);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseSysCacheList(catlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L410" title="utils/cache/lsyscache.c:410">get_compatible_hash_operators</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get the OID(s) of <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> equality operator(s) compatible with the given<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; operator, but operating on its LHS and/or RHS datatype.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * An operator for the LHS type is sought and returned into *lhs_opno if<br/></li>
<li></span><span class="Comment"> * lhs_opno isn't NULL.&nbsp; Similarly, an operator for the RHS type is sought<br/></li>
<li></span><span class="Comment"> * and returned into *rhs_opno if rhs_opno isn't NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the given operator is not cross-type, the results should be the same<br/></li>
<li></span><span class="Comment"> * operator, but in cross-type situations they will be different.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if able to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the requested operator(s), false if not.<br/></li>
<li></span><span class="Comment"> * (This indicates that the operator should not have been marked oprcanhash.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L410">&#x200c;</a></span><span class="linkable">get_compatible_hash_operators</span>(Oid opno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid *lhs_opno, Oid *rhs_opno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; CatCList&nbsp;&nbsp; *catlist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure output args are initialized on failure */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lhs_opno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *lhs_opno = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rhs_opno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *rhs_opno = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Search pg_amop to see if the target operator is registered as the &quot;=&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operator of <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> opfamily.&nbsp; If the operator is registered in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multiple opfamilies, assume we can use <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; catlist = SearchSysCacheList1(AMOPOPID, ObjectIdGetDatum(opno));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; catlist-&gt;n_members; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple = &amp;catlist-&gt;members[i]-&gt;tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_amop aform = (Form_pg_amop) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aform-&gt;amopmethod == HASH_AM_OID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aform-&gt;amopstrategy == HTEqualStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No extra lookup needed if given operator is single-type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aform-&gt;amoplefttype == aform-&gt;amoprighttype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lhs_opno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *lhs_opno = opno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rhs_opno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rhs_opno = opno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get the matching single-type operator(s).&nbsp; Failure probably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shouldn't happen --- it implies a bogus opfamily --- but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * continue looking if so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lhs_opno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *lhs_opno = <a href="#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(aform-&gt;amopfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aform-&gt;amoplefttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aform-&gt;amoplefttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HTEqualStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(*lhs_opno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Matching LHS found, done if caller doesn't want RHS */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rhs_opno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rhs_opno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rhs_opno = <a href="#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(aform-&gt;amopfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aform-&gt;amoprighttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aform-&gt;amoprighttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HTEqualStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(*rhs_opno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Forget <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> LHS operator from this opfamily */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lhs_opno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *lhs_opno = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Matching RHS found, so done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseSysCacheList(catlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L510" title="utils/cache/lsyscache.c:510">get_op_hash_functions</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get the OID(s) of the standard <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> support function(s) compatible with<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the given operator, operating on its LHS and/or RHS datatype as required.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A function for the LHS type is sought and returned into *lhs_procno if<br/></li>
<li></span><span class="Comment"> * lhs_procno isn't NULL.&nbsp; Similarly, a function for the RHS type is sought<br/></li>
<li></span><span class="Comment"> * and returned into *rhs_procno if rhs_procno isn't NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the given operator is not cross-type, the results should be the same<br/></li>
<li></span><span class="Comment"> * function, but in cross-type situations they will be different.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if able to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the requested function(s), false if not.<br/></li>
<li></span><span class="Comment"> * (This indicates that the operator should not have been marked oprcanhash.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L510">&#x200c;</a></span><span class="linkable">get_op_hash_functions</span>(Oid opno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RegProcedure *lhs_procno, RegProcedure *rhs_procno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; CatCList&nbsp;&nbsp; *catlist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure output args are initialized on failure */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lhs_procno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *lhs_procno = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rhs_procno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *rhs_procno = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Search pg_amop to see if the target operator is registered as the &quot;=&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operator of <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> opfamily.&nbsp; If the operator is registered in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multiple opfamilies, assume we can use <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; catlist = SearchSysCacheList1(AMOPOPID, ObjectIdGetDatum(opno));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; catlist-&gt;n_members; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple = &amp;catlist-&gt;members[i]-&gt;tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_amop aform = (Form_pg_amop) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aform-&gt;amopmethod == HASH_AM_OID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aform-&gt;amopstrategy == HTEqualStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get the matching support function(s).&nbsp; Failure probably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shouldn't happen --- it implies a bogus opfamily --- but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * continue looking if so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lhs_procno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *lhs_procno = <a href="#L796" title="utils/cache/lsyscache.c:796">get_opfamily_proc</a>(aform-&gt;amopfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aform-&gt;amoplefttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aform-&gt;amoplefttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASHSTANDARD_PROC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(*lhs_procno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Matching LHS found, done if caller doesn't want RHS */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rhs_procno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Only one lookup needed if given operator is single-type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aform-&gt;amoplefttype == aform-&gt;amoprighttype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rhs_procno = *lhs_procno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rhs_procno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rhs_procno = <a href="#L796" title="utils/cache/lsyscache.c:796">get_opfamily_proc</a>(aform-&gt;amopfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aform-&gt;amoprighttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aform-&gt;amoprighttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASHSTANDARD_PROC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(*rhs_procno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Forget <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> LHS function from this opfamily */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lhs_procno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *lhs_procno = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Matching RHS found, so done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseSysCacheList(catlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L601" title="utils/cache/lsyscache.c:601">get_op_btree_interpretation</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given an operator's OID, <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out which btree opfamilies it belongs to,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and what properties it has within each one.&nbsp; The results are returned<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; as a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d list of OpBtreeInterpretation structs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In addition to the normal btree operators, we consider a &lt;&gt; operator to be<br/></li>
<li></span><span class="Comment"> * a &quot;member&quot; of an opfamily if its negator is an equality operator of the<br/></li>
<li></span><span class="Comment"> * opfamily.&nbsp; ROWCOMPARE_NE is returned as the strategy number for this case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L601">&#x200c;</a><span class="linkable">get_op_btree_interpretation</span>(Oid opno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li>&nbsp; &nbsp; OpBtreeInterpretation *thisresult;<br/></li>
<li>&nbsp; &nbsp; CatCList&nbsp;&nbsp; *catlist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find all the pg_amop entries containing the operator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; catlist = SearchSysCacheList1(AMOPOPID, ObjectIdGetDatum(opno));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; catlist-&gt;n_members; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; op_tuple = &amp;catlist-&gt;members[i]-&gt;tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_amop op_form = (Form_pg_amop) GETSTRUCT(op_tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StrategyNumber op_strategy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must be btree */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op_form-&gt;amopmethod != BTREE_AM_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the operator's btree strategy number */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; op_strategy = (StrategyNumber) op_form-&gt;amopstrategy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(op_strategy &gt;= <span class="Constant">1</span> &amp;&amp; op_strategy &lt;= <span class="Constant">5</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; thisresult = (OpBtreeInterpretation *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OpBtreeInterpretation));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; thisresult-&gt;opfamily_id = op_form-&gt;amopfamily;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; thisresult-&gt;strategy = op_strategy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; thisresult-&gt;oplefttype = op_form-&gt;amoplefttype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; thisresult-&gt;oprighttype = op_form-&gt;amoprighttype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, thisresult);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseSysCacheList(catlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> btree opfamily containing the operator, perhaps<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it is a &lt;&gt; operator.&nbsp; See if it has a negator that is in an opfamily.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_negator = <a href="#L1533" title="utils/cache/lsyscache.c:1533">get_negator</a>(opno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(op_negator))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; catlist = SearchSysCacheList1(AMOPOPID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(op_negator));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; catlist-&gt;n_members; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; op_tuple = &amp;catlist-&gt;members[i]-&gt;tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_amop op_form = (Form_pg_amop) GETSTRUCT(op_tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StrategyNumber op_strategy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must be btree */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op_form-&gt;amopmethod != BTREE_AM_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the operator's btree strategy number */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_strategy = (StrategyNumber) op_form-&gt;amopstrategy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(op_strategy &gt;= <span class="Constant">1</span> &amp;&amp; op_strategy &lt;= <span class="Constant">5</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Only consider negators that are = */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op_strategy != BTEqualStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, report it with &quot;strategy&quot; ROWCOMPARE_NE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisresult = (OpBtreeInterpretation *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OpBtreeInterpretation));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisresult-&gt;opfamily_id = op_form-&gt;amopfamily;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisresult-&gt;strategy = ROWCOMPARE_NE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisresult-&gt;oplefttype = op_form-&gt;amoplefttype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisresult-&gt;oprighttype = op_form-&gt;amoprighttype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, thisresult);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReleaseSysCacheList(catlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L698" title="utils/cache/lsyscache.c:698">equality_ops_are_compatible</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return true if the two given equality operators have compatible<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; semantics.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is trivially true if they are the same operator.&nbsp; Otherwise,<br/></li>
<li></span><span class="Comment"> * we look to see if they can be found in the same btree or <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> opfamily.<br/></li>
<li></span><span class="Comment"> * Either finding allows us to assume that they have compatible notions<br/></li>
<li></span><span class="Comment"> * of equality.&nbsp; (The reason we need to do these pushups is that one might<br/></li>
<li></span><span class="Comment"> * be a cross-type operator; for instance <a href="../adt/int.c.html#L504" title="utils/adt/int.c:504">int24eq</a> vs <a href="../adt/int.c.html#L396" title="utils/adt/int.c:396">int4eq</a>.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L698">&#x200c;</a></span><span class="linkable">equality_ops_are_compatible</span>(Oid opno1, Oid opno2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; CatCList&nbsp;&nbsp; *catlist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Easy if they're the same operator */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (opno1 == opno2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We search through all the pg_amop entries for opno1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; catlist = SearchSysCacheList1(AMOPOPID, ObjectIdGetDatum(opno1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; catlist-&gt;n_members; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; op_tuple = &amp;catlist-&gt;members[i]-&gt;tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_amop op_form = (Form_pg_amop) GETSTRUCT(op_tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must be btree or <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op_form-&gt;amopmethod == BTREE_AM_OID ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_form-&gt;amopmethod == HASH_AM_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L66" title="utils/cache/lsyscache.c:66">op_in_opfamily</a>(opno2, op_form-&gt;amopfamily))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseSysCacheList(catlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L749" title="utils/cache/lsyscache.c:749">comparison_ops_are_compatible</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return true if the two given comparison operators have compatible<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; semantics.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is trivially true if they are the same operator.&nbsp; Otherwise,<br/></li>
<li></span><span class="Comment"> * we look to see if they can be found in the same btree opfamily.<br/></li>
<li></span><span class="Comment"> * For example, '&lt;' and '&gt;=' ops match if they belong to the same family.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (This is identical to <a href="#L698" title="utils/cache/lsyscache.c:698">equality_ops_are_compatible</a>(), except that we<br/></li>
<li></span><span class="Comment"> * don't bother to examine <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> opclasses.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L749">&#x200c;</a></span><span class="linkable">comparison_ops_are_compatible</span>(Oid opno1, Oid opno2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; CatCList&nbsp;&nbsp; *catlist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Easy if they're the same operator */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (opno1 == opno2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We search through all the pg_amop entries for opno1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; catlist = SearchSysCacheList1(AMOPOPID, ObjectIdGetDatum(opno1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; catlist-&gt;n_members; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; op_tuple = &amp;catlist-&gt;members[i]-&gt;tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_amop op_form = (Form_pg_amop) GETSTRUCT(op_tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op_form-&gt;amopmethod == BTREE_AM_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L66" title="utils/cache/lsyscache.c:66">op_in_opfamily</a>(opno2, op_form-&gt;amopfamily))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseSysCacheList(catlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ---------- AMPROC CACHES ----------&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L796" title="utils/cache/lsyscache.c:796">get_opfamily_proc</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get the OID of the specified support function<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; for the specified opfamily and datatypes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns InvalidOid if there is no pg_amproc entry for the given keys.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L796">&#x200c;</a><span class="linkable">get_opfamily_proc</span>(Oid opfamily, Oid lefttype, Oid righttype, int16 procnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Form_pg_amproc amproc_tup;<br/></li>
<li>&nbsp; &nbsp; RegProcedure result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L251" title="utils/cache/syscache.c:251">SearchSysCache4</a>(AMPROCNUM,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(opfamily),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(lefttype),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(righttype),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int16GetDatum(procnum));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>&nbsp; &nbsp; amproc_tup = (Form_pg_amproc) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; result = amproc_tup-&gt;amproc;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ---------- ATTRIBUTE CACHES ----------&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L827" title="utils/cache/lsyscache.c:827">get_attname</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the relation id and the attribute number, return the &quot;attname&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; field from the attribute relation as a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'ed string.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If no such attribute exists and missing_ok is true, NULL is returned;<br/></li>
<li></span><span class="Comment"> * otherwise a not-intended-for-user-consumption error is thrown.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L827">&#x200c;</a><span class="linkable">get_attname</span>(Oid relid, AttrNumber attnum, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L229" title="utils/cache/syscache.c:229">SearchSysCache2</a>(ATTNUM,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(relid), Int16GetDatum(attnum));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att_tup = (Form_pg_attribute) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(att_tup-&gt;attname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!missing_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for attribute </span><span class="Special">%d</span><span class="Constant"> of relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attnum, relid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L858" title="utils/cache/lsyscache.c:858">get_attnum</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the relation id and the attribute name,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; return the &quot;attnum&quot; field from the attribute relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns InvalidAttrNumber if the attr doesn't exist (or is dropped).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>AttrNumber<br/></li>
<li><a id="L858">&#x200c;</a><span class="linkable">get_attnum</span>(Oid relid, <span class="Type">const</span> <span class="Type">char</span> *attname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L359" title="utils/cache/syscache.c:359">SearchSysCacheAttName</a>(relid, attname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att_tup = (Form_pg_attribute) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = att_tup-&gt;attnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidAttrNumber;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L888" title="utils/cache/lsyscache.c:888">get_attgenerated</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the relation id and the attribute number,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; return the &quot;attgenerated&quot; field from the attribute relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Errors if not found.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Since not generated is represented by '\0', this can also be used as a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Boolean test.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char<br/></li>
<li><a id="L888">&#x200c;</a></span><span class="linkable">get_attgenerated</span>(Oid relid, AttrNumber attnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute att_tup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L229" title="utils/cache/syscache.c:229">SearchSysCache2</a>(ATTNUM,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(relid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int16GetDatum(attnum));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for attribute </span><span class="Special">%d</span><span class="Constant"> of relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attnum, relid);<br/></li>
<li>&nbsp; &nbsp; att_tup = (Form_pg_attribute) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; result = att_tup-&gt;attgenerated;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L913" title="utils/cache/lsyscache.c:913">get_atttype</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the relation OID and the attribute number with the relation,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; return the attribute type OID.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L913">&#x200c;</a><span class="linkable">get_atttype</span>(Oid relid, AttrNumber attnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L229" title="utils/cache/syscache.c:229">SearchSysCache2</a>(ATTNUM,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(relid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int16GetDatum(attnum));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att_tup = (Form_pg_attribute) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = att_tup-&gt;atttypid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L943" title="utils/cache/lsyscache.c:943">get_atttypetypmodcoll</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; A three-fer: given the relation id and the attribute number,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; fetch atttypid, atttypmod, and attcollation in a single cache lookup.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike the otherwise-similar <a href="#L913" title="utils/cache/lsyscache.c:913">get_atttype</a>, this routine<br/></li>
<li></span><span class="Comment"> * raises an error if it can't obtain the information.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L943">&#x200c;</a></span><span class="linkable">get_atttypetypmodcoll</span>(Oid relid, AttrNumber attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid *typid, int32 *typmod, Oid *collid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute att_tup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L229" title="utils/cache/syscache.c:229">SearchSysCache2</a>(ATTNUM,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(relid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int16GetDatum(attnum));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for attribute </span><span class="Special">%d</span><span class="Constant"> of relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attnum, relid);<br/></li>
<li>&nbsp; &nbsp; att_tup = (Form_pg_attribute) GETSTRUCT(tp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *typid = att_tup-&gt;atttypid;<br/></li>
<li>&nbsp; &nbsp; *typmod = att_tup-&gt;atttypmod;<br/></li>
<li>&nbsp; &nbsp; *collid = att_tup-&gt;attcollation;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L970" title="utils/cache/lsyscache.c:970">get_attoptions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the relation id and the attribute number,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; return the attribute options text[] datum, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L970">&#x200c;</a><span class="linkable">get_attoptions</span>(Oid relid, int16 attnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; attopts;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="syscache.c.html#L229" title="utils/cache/syscache.c:229">SearchSysCache2</a>(ATTNUM,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(relid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int16GetDatum(attnum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for attribute </span><span class="Special">%d</span><span class="Constant"> of relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attnum, relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attopts = <a href="syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(ATTNAME, tuple, Anum_pg_attribute_attoptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(attopts, <span class="Constant">false</span>, -<span class="Constant">1</span>); <span class="Comment">/* text[] */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ---------- PG_CAST CACHE ----------&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1007" title="utils/cache/lsyscache.c:1007">get_cast_oid</a> - given two type OIDs, look up a cast OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If missing_ok is false, throw an error if the cast is not found.&nbsp; If<br/></li>
<li></span><span class="Comment"> * true, just return InvalidOid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L1007">&#x200c;</a><span class="linkable">get_cast_oid</span>(Oid sourcetypeid, Oid targettypeid, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oid = GetSysCacheOid2(CASTSOURCETARGET, Anum_pg_cast_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(sourcetypeid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(targettypeid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(oid) &amp;&amp; !missing_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cast from type </span><span class="Special">%s</span><span class="Constant"> to type </span><span class="Special">%s</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(sourcetypeid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(targettypeid))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> oid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ---------- COLLATION CACHE ----------&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1035" title="utils/cache/lsyscache.c:1035">get_collation_name</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the name of a given pg_collation entry.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d copy of the string, or NULL if no such collation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: since collation name is not unique, be wary of code that uses this<br/></li>
<li></span><span class="Comment"> * for anything except preparing error messages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L1035">&#x200c;</a><span class="linkable">get_collation_name</span>(Oid colloid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(COLLOID, ObjectIdGetDatum(colloid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_collation colltup = (Form_pg_collation) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(colltup-&gt;collname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1054">&#x200c;</a></span><span class="linkable">get_collation_isdeterministic</span>(Oid colloid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Form_pg_collation colltup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(COLLOID, ObjectIdGetDatum(colloid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for collation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, colloid);<br/></li>
<li>&nbsp; &nbsp; colltup = (Form_pg_collation) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; result = colltup-&gt;collisdeterministic;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ---------- CONSTRAINT CACHE ----------&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1081" title="utils/cache/lsyscache.c:1081">get_constraint_name</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the name of a given pg_constraint entry.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d copy of the string, or NULL if no such constraint.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: since constraint name is not unique, be wary of code that uses this<br/></li>
<li></span><span class="Comment"> * for anything except preparing error messages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L1081">&#x200c;</a><span class="linkable">get_constraint_name</span>(Oid conoid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CONSTROID, ObjectIdGetDatum(conoid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint contup = (Form_pg_constraint) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(contup-&gt;conname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1113" title="utils/cache/lsyscache.c:1113">get_constraint_index</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the OID of a unique, primary-key, or exclusion constraint,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; return the OID of the underlying index.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns InvalidOid if the constraint could not be found or is of<br/></li>
<li></span><span class="Comment"> * the wrong type.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The intent of this function is to return the index &quot;owned&quot; by the<br/></li>
<li></span><span class="Comment"> * specified constraint.&nbsp; Therefore we must check contype, since some<br/></li>
<li></span><span class="Comment"> * pg_constraint entries (e.g. for foreign-key constraints) store the<br/></li>
<li></span><span class="Comment"> * OID of an index that is referenced but not owned by the constraint.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L1113">&#x200c;</a><span class="linkable">get_constraint_index</span>(Oid conoid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CONSTROID, ObjectIdGetDatum(conoid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint contup = (Form_pg_constraint) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (contup-&gt;contype == CONSTRAINT_UNIQUE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; contup-&gt;contype == CONSTRAINT_PRIMARY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; contup-&gt;contype == CONSTRAINT_EXCLUSION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = contup-&gt;conindid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1143" title="utils/cache/lsyscache.c:1143">get_constraint_type</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return the pg_constraint.contype value for the given constraint.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * No frills.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char<br/></li>
<li><a id="L1143">&#x200c;</a></span><span class="linkable">get_constraint_type</span>(Oid conoid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; contype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CONSTROID, ObjectIdGetDatum(conoid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for constraint </span><span class="Special">%u</span><span class="Constant">&quot;</span>, conoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; contype = ((Form_pg_constraint) GETSTRUCT(tp))-&gt;contype;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> contype;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ---------- LANGUAGE CACHE ----------&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li><span class="Type">char</span> *<br/></li>
<li><a id="L1161">&#x200c;</a><span class="linkable">get_language_name</span>(Oid langoid, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(LANGOID, ObjectIdGetDatum(langoid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_language lantup = (Form_pg_language) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(lantup-&gt;lanname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!missing_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for language </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; langoid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ---------- OPCLASS CACHE ----------&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1190" title="utils/cache/lsyscache.c:1190">get_opclass_family</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the OID of the operator family the opclass belongs to.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L1190">&#x200c;</a><span class="linkable">get_opclass_family</span>(Oid opclass)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Form_pg_opclass cla_tup;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CLAOID, ObjectIdGetDatum(opclass));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for opclass </span><span class="Special">%u</span><span class="Constant">&quot;</span>, opclass);<br/></li>
<li>&nbsp; &nbsp; cla_tup = (Form_pg_opclass) GETSTRUCT(tp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = cla_tup-&gt;opcfamily;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1212" title="utils/cache/lsyscache.c:1212">get_opclass_input_type</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the OID of the datatype the opclass indexes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L1212">&#x200c;</a><span class="linkable">get_opclass_input_type</span>(Oid opclass)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Form_pg_opclass cla_tup;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CLAOID, ObjectIdGetDatum(opclass));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for opclass </span><span class="Special">%u</span><span class="Constant">&quot;</span>, opclass);<br/></li>
<li>&nbsp; &nbsp; cla_tup = (Form_pg_opclass) GETSTRUCT(tp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = cla_tup-&gt;opcintype;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1235" title="utils/cache/lsyscache.c:1235">get_opclass_opfamily_and_input_type</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the OID of the operator family the opclass belongs to,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the OID of the datatype the opclass indexes<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1235">&#x200c;</a></span><span class="linkable">get_opclass_opfamily_and_input_type</span>(Oid opclass, Oid *opfamily, Oid *opcintype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Form_pg_opclass cla_tup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CLAOID, ObjectIdGetDatum(opclass));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cla_tup = (Form_pg_opclass) GETSTRUCT(tp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *opfamily = cla_tup-&gt;opcfamily;<br/></li>
<li>&nbsp; &nbsp; *opcintype = cla_tup-&gt;opcintype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1260" title="utils/cache/lsyscache.c:1260">get_opclass_method</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the OID of the index access method the opclass belongs to.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L1260">&#x200c;</a><span class="linkable">get_opclass_method</span>(Oid opclass)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Form_pg_opclass cla_tup;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CLAOID, ObjectIdGetDatum(opclass));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for opclass </span><span class="Special">%u</span><span class="Constant">&quot;</span>, opclass);<br/></li>
<li>&nbsp; &nbsp; cla_tup = (Form_pg_opclass) GETSTRUCT(tp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = cla_tup-&gt;opcmethod;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ---------- OPERATOR CACHE ----------&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the regproc id of the routine used to implement an<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; operator given the operator oid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RegProcedure<br/></li>
<li><a id="L1285">&#x200c;</a><span class="linkable">get_opcode</span>(Oid opno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(OPEROID, ObjectIdGetDatum(opno));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RegProcedure result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = optup-&gt;oprcode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (RegProcedure) InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1310" title="utils/cache/lsyscache.c:1310">get_opname</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; returns the name of the operator with the given opno<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: returns a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d copy of the string, or NULL if no such operator.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L1310">&#x200c;</a><span class="linkable">get_opname</span>(Oid opno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(OPEROID, ObjectIdGetDatum(opno));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(optup-&gt;oprname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1333" title="utils/cache/lsyscache.c:1333">get_op_rettype</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given operator oid, return the operator's result type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L1333">&#x200c;</a><span class="linkable">get_op_rettype</span>(Oid opno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(OPEROID, ObjectIdGetDatum(opno));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = optup-&gt;oprresult;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1358" title="utils/cache/lsyscache.c:1358">op_input_types</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the left and right input datatypes for an operator<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (InvalidOid if not relevant).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1358">&#x200c;</a></span><span class="linkable">op_input_types</span>(Oid opno, Oid *lefttype, Oid *righttype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Form_pg_operator optup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(OPEROID, ObjectIdGetDatum(opno));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))&nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for operator </span><span class="Special">%u</span><span class="Constant">&quot;</span>, opno);<br/></li>
<li>&nbsp; &nbsp; optup = (Form_pg_operator) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; *lefttype = optup-&gt;oprleft;<br/></li>
<li>&nbsp; &nbsp; *righttype = optup-&gt;oprright;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1386" title="utils/cache/lsyscache.c:1386">op_mergejoinable</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if the operator is potentially mergejoinable.&nbsp; (The <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a><br/></li>
<li></span><span class="Comment"> * will fail to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> mergejoin plans unless there are suitable btree<br/></li>
<li></span><span class="Comment"> * opfamily entries for this operator and associated sortops.&nbsp; The pg_operator<br/></li>
<li></span><span class="Comment"> * flag is just a hint to tell the <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> whether to bother looking.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In some cases (currently only <a href="../adt/arrayfuncs.c.html#L3795" title="utils/adt/arrayfuncs.c:3795">array_eq</a> and <a href="../adt/rowtypes.c.html#L1067" title="utils/adt/rowtypes.c:1067">record_eq</a>), mergejoinability<br/></li>
<li></span><span class="Comment"> * depends on the specific input data type the operator is invoked for, so<br/></li>
<li></span><span class="Comment"> * that must be passed as well. We currently assume that only one input's type<br/></li>
<li></span><span class="Comment"> * is needed to check this --- by convention, pass the left input's data type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1386">&#x200c;</a></span><span class="linkable">op_mergejoinable</span>(Oid opno, Oid inputtype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For <a href="../adt/arrayfuncs.c.html#L3795" title="utils/adt/arrayfuncs.c:3795">array_eq</a> or <a href="../adt/rowtypes.c.html#L1067" title="utils/adt/rowtypes.c:1067">record_eq</a>, we can sort if the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> or field types<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are all sortable.&nbsp; We could implement all the checks for that here, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the typcache already does that and caches the results too, so let's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rely on the typcache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (opno == ARRAY_EQ_OP)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(inputtype, TYPECACHE_CMP_PROC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;cmp_proc == F_BTARRAYCMP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (opno == RECORD_EQ_OP)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(inputtype, TYPECACHE_CMP_PROC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;cmp_proc == F_BTRECORDCMP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* For all other operators, rely on pg_operator.oprcanmerge */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(OPEROID, ObjectIdGetDatum(opno));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = optup-&gt;oprcanmerge;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1437" title="utils/cache/lsyscache.c:1437">op_hashjoinable</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if the operator is hashjoinable.&nbsp; (There must be a suitable<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> opfamily entry for this operator if it is so marked.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In some cases (currently only <a href="../adt/arrayfuncs.c.html#L3795" title="utils/adt/arrayfuncs.c:3795">array_eq</a>), hashjoinability depends on the<br/></li>
<li></span><span class="Comment"> * specific input data type the operator is invoked for, so that must be<br/></li>
<li></span><span class="Comment"> * passed as well.&nbsp; We currently assume that only one input's type is needed<br/></li>
<li></span><span class="Comment"> * to check this --- by convention, pass the left input's data type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1437">&#x200c;</a></span><span class="linkable">op_hashjoinable</span>(Oid opno, Oid inputtype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* As in <a href="#L1386" title="utils/cache/lsyscache.c:1386">op_mergejoinable</a>, let the typcache handle the hard cases */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (opno == ARRAY_EQ_OP)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(inputtype, TYPECACHE_HASH_PROC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;hash_proc == F_HASH_ARRAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (opno == RECORD_EQ_OP)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(inputtype, TYPECACHE_HASH_PROC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;hash_proc == F_HASH_RECORD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* For all other operators, rely on pg_operator.oprcanhash */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(OPEROID, ObjectIdGetDatum(opno));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = optup-&gt;oprcanhash;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1477" title="utils/cache/lsyscache.c:1477">op_strict</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Get the proisstrict flag for the operator's underlying function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1477">&#x200c;</a></span><span class="linkable">op_strict</span>(Oid opno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RegProcedure funcid = <a href="#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(opno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (funcid == (RegProcedure) InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;operator </span><span class="Special">%u</span><span class="Constant"> does not exist&quot;</span>, opno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1761" title="utils/cache/lsyscache.c:1761">func_strict</a>((Oid) funcid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1493" title="utils/cache/lsyscache.c:1493">op_volatile</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Get the provolatile flag for the operator's underlying function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char<br/></li>
<li><a id="L1493">&#x200c;</a></span><span class="linkable">op_volatile</span>(Oid opno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RegProcedure funcid = <a href="#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(opno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (funcid == (RegProcedure) InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;operator </span><span class="Special">%u</span><span class="Constant"> does not exist&quot;</span>, opno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1780" title="utils/cache/lsyscache.c:1780">func_volatile</a>((Oid) funcid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1509" title="utils/cache/lsyscache.c:1509">get_commutator</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the corresponding commutator of an operator.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L1509">&#x200c;</a><span class="linkable">get_commutator</span>(Oid opno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(OPEROID, ObjectIdGetDatum(opno));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = optup-&gt;oprcom;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1533" title="utils/cache/lsyscache.c:1533">get_negator</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the corresponding negator of an operator.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L1533">&#x200c;</a><span class="linkable">get_negator</span>(Oid opno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(OPEROID, ObjectIdGetDatum(opno));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = optup-&gt;oprnegate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1557" title="utils/cache/lsyscache.c:1557">get_oprrest</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns procedure id for computing selectivity of an operator.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RegProcedure<br/></li>
<li><a id="L1557">&#x200c;</a><span class="linkable">get_oprrest</span>(Oid opno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(OPEROID, ObjectIdGetDatum(opno));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RegProcedure result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = optup-&gt;oprrest;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (RegProcedure) InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1581" title="utils/cache/lsyscache.c:1581">get_oprjoin</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns procedure id for computing selectivity of a join.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RegProcedure<br/></li>
<li><a id="L1581">&#x200c;</a><span class="linkable">get_oprjoin</span>(Oid opno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(OPEROID, ObjectIdGetDatum(opno));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RegProcedure result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = optup-&gt;oprjoin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (RegProcedure) InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ---------- FUNCTION CACHE ----------&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1608" title="utils/cache/lsyscache.c:1608">get_func_name</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; returns the name of the function with the given funcid<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: returns a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d copy of the string, or NULL if no such function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L1608">&#x200c;</a><span class="linkable">get_func_name</span>(Oid funcid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PROCOID, ObjectIdGetDatum(funcid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_proc functup = (Form_pg_proc) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(functup-&gt;proname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1632" title="utils/cache/lsyscache.c:1632">get_func_namespace</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the pg_namespace OID associated with a given function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L1632">&#x200c;</a><span class="linkable">get_func_namespace</span>(Oid funcid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PROCOID, ObjectIdGetDatum(funcid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_proc functup = (Form_pg_proc) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = functup-&gt;pronamespace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1655" title="utils/cache/lsyscache.c:1655">get_func_rettype</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given procedure id, return the function's result type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L1655">&#x200c;</a><span class="linkable">get_func_rettype</span>(Oid funcid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PROCOID, ObjectIdGetDatum(funcid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for function </span><span class="Special">%u</span><span class="Constant">&quot;</span>, funcid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = ((Form_pg_proc) GETSTRUCT(tp))-&gt;prorettype;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1674" title="utils/cache/lsyscache.c:1674">get_func_nargs</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given procedure id, return the number of arguments.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1674">&#x200c;</a></span><span class="linkable">get_func_nargs</span>(Oid funcid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PROCOID, ObjectIdGetDatum(funcid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for function </span><span class="Special">%u</span><span class="Constant">&quot;</span>, funcid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = ((Form_pg_proc) GETSTRUCT(tp))-&gt;pronargs;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1696" title="utils/cache/lsyscache.c:1696">get_func_signature</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given procedure id, return the function's argument and result types.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (The return value is the result type.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The arguments are returned as a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L1696">&#x200c;</a><span class="linkable">get_func_signature</span>(Oid funcid, Oid **argtypes, <span class="Type">int</span> *nargs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Form_pg_proc procstruct;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PROCOID, ObjectIdGetDatum(funcid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for function </span><span class="Special">%u</span><span class="Constant">&quot;</span>, funcid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; procstruct = (Form_pg_proc) GETSTRUCT(tp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = procstruct-&gt;prorettype;<br/></li>
<li>&nbsp; &nbsp; *nargs = (<span class="Type">int</span>) procstruct-&gt;pronargs;<br/></li>
<li>&nbsp; &nbsp; Assert(*nargs == procstruct-&gt;proargtypes.dim1);<br/></li>
<li>&nbsp; &nbsp; *argtypes = (Oid *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(*nargs * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; memcpy(*argtypes, procstruct-&gt;proargtypes.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, *nargs * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1723" title="utils/cache/lsyscache.c:1723">get_func_variadictype</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given procedure id, return the function's provariadic field.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L1723">&#x200c;</a><span class="linkable">get_func_variadictype</span>(Oid funcid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PROCOID, ObjectIdGetDatum(funcid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for function </span><span class="Special">%u</span><span class="Constant">&quot;</span>, funcid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = ((Form_pg_proc) GETSTRUCT(tp))-&gt;provariadic;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1742" title="utils/cache/lsyscache.c:1742">get_func_retset</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given procedure id, return the function's proretset flag.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1742">&#x200c;</a></span><span class="linkable">get_func_retset</span>(Oid funcid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PROCOID, ObjectIdGetDatum(funcid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for function </span><span class="Special">%u</span><span class="Constant">&quot;</span>, funcid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = ((Form_pg_proc) GETSTRUCT(tp))-&gt;proretset;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1761" title="utils/cache/lsyscache.c:1761">func_strict</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given procedure id, return the function's proisstrict flag.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1761">&#x200c;</a></span><span class="linkable">func_strict</span>(Oid funcid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PROCOID, ObjectIdGetDatum(funcid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for function </span><span class="Special">%u</span><span class="Constant">&quot;</span>, funcid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = ((Form_pg_proc) GETSTRUCT(tp))-&gt;proisstrict;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1780" title="utils/cache/lsyscache.c:1780">func_volatile</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given procedure id, return the function's provolatile flag.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char<br/></li>
<li><a id="L1780">&#x200c;</a></span><span class="linkable">func_volatile</span>(Oid funcid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PROCOID, ObjectIdGetDatum(funcid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for function </span><span class="Special">%u</span><span class="Constant">&quot;</span>, funcid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = ((Form_pg_proc) GETSTRUCT(tp))-&gt;provolatile;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1799" title="utils/cache/lsyscache.c:1799">func_parallel</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given procedure id, return the function's proparallel flag.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char<br/></li>
<li><a id="L1799">&#x200c;</a></span><span class="linkable">func_parallel</span>(Oid funcid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PROCOID, ObjectIdGetDatum(funcid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for function </span><span class="Special">%u</span><span class="Constant">&quot;</span>, funcid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = ((Form_pg_proc) GETSTRUCT(tp))-&gt;proparallel;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1818" title="utils/cache/lsyscache.c:1818">get_func_prokind</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; Given procedure id, return the routine kind.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char<br/></li>
<li><a id="L1818">&#x200c;</a></span><span class="linkable">get_func_prokind</span>(Oid funcid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PROCOID, ObjectIdGetDatum(funcid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for function </span><span class="Special">%u</span><span class="Constant">&quot;</span>, funcid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = ((Form_pg_proc) GETSTRUCT(tp))-&gt;prokind;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1837" title="utils/cache/lsyscache.c:1837">get_func_leakproof</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; Given procedure id, return the function's leakproof field.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1837">&#x200c;</a></span><span class="linkable">get_func_leakproof</span>(Oid funcid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PROCOID, ObjectIdGetDatum(funcid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for function </span><span class="Special">%u</span><span class="Constant">&quot;</span>, funcid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = ((Form_pg_proc) GETSTRUCT(tp))-&gt;proleakproof;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1858" title="utils/cache/lsyscache.c:1858">get_func_support</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the support function OID associated with a given function,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; or InvalidOid if there is <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RegProcedure<br/></li>
<li><a id="L1858">&#x200c;</a><span class="linkable">get_func_support</span>(Oid funcid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PROCOID, ObjectIdGetDatum(funcid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_proc functup = (Form_pg_proc) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RegProcedure result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = functup-&gt;prosupport;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (RegProcedure) InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ---------- RELATION CACHE ----------&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1885" title="utils/cache/lsyscache.c:1885">get_relname_relid</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given name and namespace of a relation, look up the OID.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns InvalidOid if there is no such relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L1885">&#x200c;</a><span class="linkable">get_relname_relid</span>(<span class="Type">const</span> <span class="Type">char</span> *relname, Oid relnamespace)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> GetSysCacheOid2(RELNAMENSP, Anum_pg_class_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(relnamespace));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1899" title="utils/cache/lsyscache.c:1899">get_relnatts</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the number of attributes for a given relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1899">&#x200c;</a></span><span class="linkable">get_relnatts</span>(Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class reltup = (Form_pg_class) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = reltup-&gt;relnatts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidAttrNumber;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the name of a given relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d copy of the string, or NULL if no such relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: since relation name is not unique, be wary of code that uses this<br/></li>
<li></span><span class="Comment"> * for anything except preparing error messages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L1928">&#x200c;</a><span class="linkable">get_rel_name</span>(Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class reltup = (Form_pg_class) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(reltup-&gt;relname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1952" title="utils/cache/lsyscache.c:1952">get_rel_namespace</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the pg_namespace OID associated with a given relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L1952">&#x200c;</a><span class="linkable">get_rel_namespace</span>(Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class reltup = (Form_pg_class) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = reltup-&gt;relnamespace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1979" title="utils/cache/lsyscache.c:1979">get_rel_type_id</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the pg_type OID associated with a given relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: not all pg_class entries have associated pg_type OIDs; so be<br/></li>
<li></span><span class="Comment"> * careful to check for InvalidOid result.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L1979">&#x200c;</a><span class="linkable">get_rel_type_id</span>(Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class reltup = (Form_pg_class) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = reltup-&gt;reltype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2003" title="utils/cache/lsyscache.c:2003">get_rel_relkind</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the relkind associated with a given relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char<br/></li>
<li><a id="L2003">&#x200c;</a></span><span class="linkable">get_rel_relkind</span>(Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class reltup = (Form_pg_class) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = reltup-&gt;relkind;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Special">'\0'</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2027" title="utils/cache/lsyscache.c:2027">get_rel_relispartition</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the relispartition flag associated with a given relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2027">&#x200c;</a></span><span class="linkable">get_rel_relispartition</span>(Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class reltup = (Form_pg_class) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = reltup-&gt;relispartition;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2054" title="utils/cache/lsyscache.c:2054">get_rel_tablespace</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the pg_tablespace OID associated with a given relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: InvalidOid might mean either that we couldn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the relation,<br/></li>
<li></span><span class="Comment"> * or that it is in the database's default tablespace.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L2054">&#x200c;</a><span class="linkable">get_rel_tablespace</span>(Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class reltup = (Form_pg_class) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = reltup-&gt;reltablespace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2078" title="utils/cache/lsyscache.c:2078">get_rel_persistence</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the relpersistence associated with a given relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char<br/></li>
<li><a id="L2078">&#x200c;</a></span><span class="linkable">get_rel_persistence</span>(Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Form_pg_class reltup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, relid);<br/></li>
<li>&nbsp; &nbsp; reltup = (Form_pg_class) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; result = reltup-&gt;relpersistence;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2100" title="utils/cache/lsyscache.c:2100">get_rel_relam</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the relam associated with a given relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L2100">&#x200c;</a><span class="linkable">get_rel_relam</span>(Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Form_pg_class reltup;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, relid);<br/></li>
<li>&nbsp; &nbsp; reltup = (Form_pg_class) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; result = reltup-&gt;relam;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ---------- TRANSFORM CACHE ----------&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>Oid<br/></li>
<li><a id="L2120">&#x200c;</a><span class="linkable">get_transform_fromsql</span>(Oid typid, Oid langid, List *trftypes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(trftypes, typid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tup = <a href="syscache.c.html#L229" title="utils/cache/syscache.c:229">SearchSysCache2</a>(TRFTYPELANG, ObjectIdGetDatum(typid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(langid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; funcid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcid = ((Form_pg_transform) GETSTRUCT(tup))-&gt;trffromsql;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> funcid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Oid<br/></li>
<li><a id="L2142">&#x200c;</a><span class="linkable">get_transform_tosql</span>(Oid typid, Oid langid, List *trftypes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(trftypes, typid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tup = <a href="syscache.c.html#L229" title="utils/cache/syscache.c:229">SearchSysCache2</a>(TRFTYPELANG, ObjectIdGetDatum(typid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(langid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; funcid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcid = ((Form_pg_transform) GETSTRUCT(tup))-&gt;trftosql;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> funcid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ---------- TYPE CACHE ----------&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2173" title="utils/cache/lsyscache.c:2173">get_typisdefined</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the type OID, determine whether the type is defined<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (if not, it's only a shell).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2173">&#x200c;</a></span><span class="linkable">get_typisdefined</span>(Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = typtup-&gt;typisdefined;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2197" title="utils/cache/lsyscache.c:2197">get_typlen</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the type OID, return the length of the type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>int16<br/></li>
<li><a id="L2197">&#x200c;</a><span class="linkable">get_typlen</span>(Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = typtup-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2222" title="utils/cache/lsyscache.c:2222">get_typbyval</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the type OID, determine whether the type is returned by value or<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; not.&nbsp; Returns true if by value, false if by reference.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2222">&#x200c;</a></span><span class="linkable">get_typbyval</span>(Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = typtup-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2251" title="utils/cache/lsyscache.c:2251">get_typlenbyval</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; A two-fer: given the type OID, return both typlen and typbyval.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Since both pieces of info are needed to know how to copy a Datum,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; many places need both.&nbsp; Might as well get them with one cache lookup<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; instead of two.&nbsp; Also, this routine raises an error instead of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; returning a bogus value when given a bad type OID.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2251">&#x200c;</a></span><span class="linkable">get_typlenbyval</span>(Oid typid, int16 *typlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *typbyval)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Form_pg_type typtup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, typid);<br/></li>
<li>&nbsp; &nbsp; typtup = (Form_pg_type) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; *typlen = typtup-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; *typbyval = typtup-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2271" title="utils/cache/lsyscache.c:2271">get_typlenbyvalalign</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; A three-fer: given the type OID, return typlen, typbyval, typalign.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2271">&#x200c;</a></span><span class="linkable">get_typlenbyvalalign</span>(Oid typid, int16 *typlen, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *typalign)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Form_pg_type typtup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, typid);<br/></li>
<li>&nbsp; &nbsp; typtup = (Form_pg_type) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; *typlen = typtup-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; *typbyval = typtup-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; *typalign = typtup-&gt;typalign;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2303" title="utils/cache/lsyscache.c:2303">getTypeIOParam</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given a pg_type row, <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> the type OID to pass to I/O <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Formerly, all I/O <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> were passed pg_type.typelem as their second<br/></li>
<li></span><span class="Comment"> * parameter, but we <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have a more complex rule about what to pass.<br/></li>
<li></span><span class="Comment"> * This knowledge is intended to be centralized here --- direct references<br/></li>
<li></span><span class="Comment"> * to typelem elsewhere in the code are wrong, if they are associated with<br/></li>
<li></span><span class="Comment"> * I/O calls and not with actual subscripting operations!&nbsp; (But see<br/></li>
<li></span><span class="Comment"> * bootstrap.c's <a href="../../bootstrap/bootstrap.c.html#L806" title="bootstrap/bootstrap.c:806">boot_get_type_io_data</a>() if you need to change this.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As of PostgreSQL 8.1, output <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> receive only the value itself<br/></li>
<li></span><span class="Comment"> * and not <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> auxiliary parameters, so the name of this routine is <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment"> * a <a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of a misnomer ... it should be getTypeInputParam.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L2303">&#x200c;</a><span class="linkable">getTypeIOParam</span>(HeapTuple typeTuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Form_pg_type typeStruct = (Form_pg_type) GETSTRUCT(typeTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Array types get their typelem as parameter; everybody else gets their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * own type OID as parameter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(typeStruct-&gt;typelem))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> typeStruct-&gt;typelem;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> typeStruct-&gt;oid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2325" title="utils/cache/lsyscache.c:2325">get_type_io_data</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; A six-fer:&nbsp; &nbsp; given the type OID, return typlen, typbyval, typalign,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typdelim, typioparam, and IO function OID. The IO function<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returned is controlled by IOFuncSelector<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2325">&#x200c;</a></span><span class="linkable">get_type_io_data</span>(Oid typid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IOFuncSelector which_func,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int16 *typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *typalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *typdelim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *typioparam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *func)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; typeTuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_type typeStruct;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In bootstrap mode, pass it off to bootstrap.c.&nbsp; This hack allows us to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use <a href="../adt/arrayfuncs.c.html#L179" title="utils/adt/arrayfuncs.c:179">array_in</a> and <a href="../adt/arrayfuncs.c.html#L1016" title="utils/adt/arrayfuncs.c:1016">array_out</a> during bootstrap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typinput;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typoutput;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L806" title="bootstrap/bootstrap.c:806">boot_get_type_io_data</a>(typid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typdelim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typioparam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;typinput,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;typoutput);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (which_func)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IOFunc_input:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *func = typinput;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IOFunc_output:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *func = typoutput;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;binary I/O not supported during bootstrap&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typeTuple = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(typeTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, typid);<br/></li>
<li>&nbsp; &nbsp; typeStruct = (Form_pg_type) GETSTRUCT(typeTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *typlen = typeStruct-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; *typbyval = typeStruct-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; *typalign = typeStruct-&gt;typalign;<br/></li>
<li>&nbsp; &nbsp; *typdelim = typeStruct-&gt;typdelim;<br/></li>
<li>&nbsp; &nbsp; *typioparam = <a href="#L2303" title="utils/cache/lsyscache.c:2303">getTypeIOParam</a>(typeTuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (which_func)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IOFunc_input:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *func = typeStruct-&gt;typinput;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IOFunc_output:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *func = typeStruct-&gt;typoutput;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IOFunc_receive:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *func = typeStruct-&gt;typreceive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IOFunc_send:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *func = typeStruct-&gt;typsend;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(typeTuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span><span class="Type">char<br/></li>
<li><a id="L2399">&#x200c;</a></span><span class="linkable">get_typalign</span>(Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = typtup-&gt;typalign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TYPALIGN_INT;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Type">char<br/></li>
<li><a id="L2419">&#x200c;</a></span><span class="linkable">get_typstorage</span>(Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = typtup-&gt;typstorage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TYPSTORAGE_PLAIN;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2448" title="utils/cache/lsyscache.c:2448">get_typdefault</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Given a type OID, return the type's default value, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; The result is a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d expression node tree, or NULL if there<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; is no defined default for the datatype.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: caller should be prepared to coerce result to correct datatype;<br/></li>
<li></span><span class="Comment"> * the returned expression tree might produce something of the wrong type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Node *<br/></li>
<li><a id="L2448">&#x200c;</a><span class="linkable">get_typdefault</span>(Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; typeTuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_type type;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNull;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typeTuple = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(typeTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, typid);<br/></li>
<li>&nbsp; &nbsp; type = (Form_pg_type) GETSTRUCT(typeTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * typdefault and typdefaultbin are potentially null, so don't try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * access 'em as struct fields. Must do it the hard way with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; datum = <a href="syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(TYPEOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_type_typdefaultbin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isNull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!isNull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have an expression default */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; expr = <a href="../../nodes/read.c.html#L90" title="nodes/read.c:90">stringToNode</a>(TextDatumGetCString(datum));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Perhaps we have a plain literal default */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; datum = <a href="syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(TYPEOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_type_typdefault,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isNull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *strDefaultVal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Convert text datum to C string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strDefaultVal = TextDatumGetCString(datum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Convert C string to a value of the given type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum = <a href="../fmgr/fmgr.c.html#L1754" title="utils/fmgr/fmgr.c:1754">OidInputFunctionCall</a>(type-&gt;typinput, strDefaultVal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2303" title="utils/cache/lsyscache.c:2303">getTypeIOParam</a>(typeTuple), -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Build a Const node containing the value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr = (Node *) <a href="../../nodes/makefuncs.c.html#L301" title="nodes/makefuncs.c:301">makeConst</a>(typid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type-&gt;typcollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type-&gt;typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type-&gt;typbyval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(strDefaultVal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No default */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(typeTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2521" title="utils/cache/lsyscache.c:2521">getBaseType</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If the given type is a domain, return its base type;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; otherwise return the type's own OID.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L2521">&#x200c;</a><span class="linkable">getBaseType</span>(Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2538" title="utils/cache/lsyscache.c:2538">getBaseTypeAndTypmod</a>(typid, &amp;typmod);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2538" title="utils/cache/lsyscache.c:2538">getBaseTypeAndTypmod</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If the given type is a domain, return its base type and typmod;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; otherwise return the type's own OID, and leave *typmod unchanged.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the &quot;applied typmod&quot; should be -1 for every domain level<br/></li>
<li></span><span class="Comment"> * above the bottommost; therefore, if the passed-in typid is indeed<br/></li>
<li></span><span class="Comment"> * a domain, *typmod should be -1.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L2538">&#x200c;</a><span class="linkable">getBaseTypeAndTypmod</span>(Oid typid, int32 *typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We loop to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the bottom base type in a stack of domains.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_type typTup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, typid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typTup = (Form_pg_type) GETSTRUCT(tup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typTup-&gt;typtype != TYPTYPE_DOMAIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not a domain, so done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(*typmod == -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typid = typTup-&gt;typbasetype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *typmod = typTup-&gt;typtypmod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> typid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2578" title="utils/cache/lsyscache.c:2578">get_typavgwidth</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Given a type OID and a typmod value (pass -1 if typmod is unknown),<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; estimate the average width of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of the type.&nbsp; This is used by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>, which doesn't require absolutely correct results;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; it's OK (and expected) to guess if we don't know for sure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>int32<br/></li>
<li><a id="L2578">&#x200c;</a><span class="linkable">get_typavgwidth</span>(Oid typid, int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen = <a href="#L2197" title="utils/cache/lsyscache.c:2197">get_typlen</a>(typid);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; maxwidth;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Easy if it's a fixed-width type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (typlen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> typlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../adt/format_type.c.html#L412" title="utils/adt/format_type.c:412">type_maximum_size</a> knows the encoding of typmod for some datatypes;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't duplicate that knowledge here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; maxwidth = <a href="../adt/format_type.c.html#L412" title="utils/adt/format_type.c:412">type_maximum_size</a>(typid, typmod);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (maxwidth &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For BPCHAR, the max width is also the only width.&nbsp; Otherwise we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to guess about the typical data width given the max. A sliding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scale for percentage of max width seems reasonable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typid == BPCHAROID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> maxwidth;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (maxwidth &lt;= <span class="Constant">32</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> maxwidth;&nbsp; &nbsp; <span class="Comment">/* assume full width */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (maxwidth &lt; <span class="Constant">1000</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">32</span> + (maxwidth - <span class="Constant">32</span>) / <span class="Constant">2</span>;&nbsp; &nbsp; <span class="Comment">/* assume 50% */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Beyond 1000, assume we're looking at something like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;<a href="../adt/varchar.c.html#L609" title="utils/adt/varchar.c:609">varchar</a>(10000)&quot; where the limit isn't actually reached often, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use a fixed estimate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">32</span> + (<span class="Constant">1000</span> - <span class="Constant">32</span>) / <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Oops, we have no idea ... wild guess time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">32</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2629" title="utils/cache/lsyscache.c:2629">get_typtype</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the type OID, <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> if it is a basic type, a complex type, etc.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; It returns the null char if the cache lookup fails...<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char<br/></li>
<li><a id="L2629">&#x200c;</a></span><span class="linkable">get_typtype</span>(Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = typtup-&gt;typtype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Special">'\0'</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2655" title="utils/cache/lsyscache.c:2655">type_is_rowtype</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Convenience function to determine whether a type OID represents<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a &quot;rowtype&quot; type --- either RECORD or a named composite type<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (including a domain over a named composite type).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2655">&#x200c;</a></span><span class="linkable">type_is_rowtype</span>(Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typid == RECORDOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* easy case */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L2629" title="utils/cache/lsyscache.c:2629">get_typtype</a>(typid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TYPTYPE_COMPOSITE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TYPTYPE_DOMAIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2629" title="utils/cache/lsyscache.c:2629">get_typtype</a>(<a href="#L2521" title="utils/cache/lsyscache.c:2521">getBaseType</a>(typid)) == TYPTYPE_COMPOSITE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2678" title="utils/cache/lsyscache.c:2678">type_is_enum</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Returns true if the given type is an enum type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2678">&#x200c;</a></span><span class="linkable">type_is_enum</span>(Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L2629" title="utils/cache/lsyscache.c:2629">get_typtype</a>(typid) == TYPTYPE_ENUM);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2688" title="utils/cache/lsyscache.c:2688">type_is_range</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Returns true if the given type is a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2688">&#x200c;</a></span><span class="linkable">type_is_range</span>(Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L2629" title="utils/cache/lsyscache.c:2629">get_typtype</a>(typid) == TYPTYPE_RANGE);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2698" title="utils/cache/lsyscache.c:2698">type_is_multirange</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Returns true if the given type is a multirange type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2698">&#x200c;</a></span><span class="linkable">type_is_multirange</span>(Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L2629" title="utils/cache/lsyscache.c:2629">get_typtype</a>(typid) == TYPTYPE_MULTIRANGE);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2710" title="utils/cache/lsyscache.c:2710">get_type_category_preferred</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the type OID, fetch its category and preferred-type status.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Throws error on failure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2710">&#x200c;</a></span><span class="linkable">get_type_category_preferred</span>(Oid typid, <span class="Type">char</span> *typcategory, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *typispreferred)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Form_pg_type typtup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, typid);<br/></li>
<li>&nbsp; &nbsp; typtup = (Form_pg_type) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; *typcategory = typtup-&gt;typcategory;<br/></li>
<li>&nbsp; &nbsp; *typispreferred = typtup-&gt;typispreferred;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2731" title="utils/cache/lsyscache.c:2731">get_typ_typrelid</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the type OID, get the typrelid (InvalidOid if not a complex<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; type).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L2731">&#x200c;</a><span class="linkable">get_typ_typrelid</span>(Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = typtup-&gt;typrelid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2759" title="utils/cache/lsyscache.c:2759">get_element_type</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the type OID, get the typelem (InvalidOid if not an array type).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: this only succeeds for &quot;true&quot; arrays having <a href="../adt/arraysubs.c.html#L539" title="utils/adt/arraysubs.c:539">array_subscript_handler</a><br/></li>
<li></span><span class="Comment"> * as typsubscript.&nbsp; For other types, InvalidOid is returned independently<br/></li>
<li></span><span class="Comment"> * of whether they have typelem or typsubscript set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L2759">&#x200c;</a><span class="linkable">get_element_type</span>(Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsTrueArrayType(typtup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = typtup-&gt;typelem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2787" title="utils/cache/lsyscache.c:2787">get_array_type</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the type OID, get the corresponding &quot;true&quot; array type.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns InvalidOid if no array type can be found.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L2787">&#x200c;</a><span class="linkable">get_array_type</span>(Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = ((Form_pg_type) GETSTRUCT(tp))-&gt;typarray;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2811" title="utils/cache/lsyscache.c:2811">get_promoted_array_type</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The &quot;promoted&quot; type is what you'd get from an ARRAY(SELECT ...)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; construct, that is, either the corresponding &quot;true&quot; array type<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; if the input is a scalar type that has such an array type,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; or the same type if the input is already a &quot;true&quot; array type.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns InvalidOid if neither rule is satisfied.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L2811">&#x200c;</a><span class="linkable">get_promoted_array_type</span>(Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; array_type = <a href="#L2787" title="utils/cache/lsyscache.c:2787">get_array_type</a>(typid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(array_type))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> array_type;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(<a href="#L2759" title="utils/cache/lsyscache.c:2759">get_element_type</a>(typid)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> typid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2832" title="utils/cache/lsyscache.c:2832">get_base_element_type</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the type OID, get the typelem, looking &quot;through&quot; <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> domain<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; to its underlying array type.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is equivalent to <a href="#L2759" title="utils/cache/lsyscache.c:2759">get_element_type</a>(<a href="#L2521" title="utils/cache/lsyscache.c:2521">getBaseType</a>(typid)), but avoids<br/></li>
<li></span><span class="Comment"> * an extra cache lookup.&nbsp; Note that it fails to provide <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> information<br/></li>
<li></span><span class="Comment"> * about the typmod of the array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L2832">&#x200c;</a><span class="linkable">get_base_element_type</span>(Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We loop to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the bottom base type in a stack of domains.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_type typTup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typTup = (Form_pg_type) GETSTRUCT(tup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typTup-&gt;typtype != TYPTYPE_DOMAIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not a domain, so stop descending */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This test must match <a href="#L2759" title="utils/cache/lsyscache.c:2759">get_element_type</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsTrueArrayType(typTup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = typTup-&gt;typelem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typid = typTup-&gt;typbasetype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Like <a href="#L2759" title="utils/cache/lsyscache.c:2759">get_element_type</a>, silently return InvalidOid for bogus input */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2874" title="utils/cache/lsyscache.c:2874">getTypeInputInfo</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get info needed for converting <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of a type to <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> form<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2874">&#x200c;</a></span><span class="linkable">getTypeInputInfo</span>(Oid type, Oid *typInput, Oid *typIOParam)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; typeTuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_type pt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typeTuple = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(type));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(typeTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, type);<br/></li>
<li>&nbsp; &nbsp; pt = (Form_pg_type) GETSTRUCT(typeTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!pt-&gt;typisdefined)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;type </span><span class="Special">%s</span><span class="Constant"> is only a shell&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(type))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(pt-&gt;typinput))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no input function available for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(type))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *typInput = pt-&gt;typinput;<br/></li>
<li>&nbsp; &nbsp; *typIOParam = <a href="#L2303" title="utils/cache/lsyscache.c:2303">getTypeIOParam</a>(typeTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(typeTuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2907" title="utils/cache/lsyscache.c:2907">getTypeOutputInfo</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get info needed for printing <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of a type<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2907">&#x200c;</a></span><span class="linkable">getTypeOutputInfo</span>(Oid type, Oid *typOutput, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *typIsVarlena)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; typeTuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_type pt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typeTuple = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(type));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(typeTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, type);<br/></li>
<li>&nbsp; &nbsp; pt = (Form_pg_type) GETSTRUCT(typeTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!pt-&gt;typisdefined)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;type </span><span class="Special">%s</span><span class="Constant"> is only a shell&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(type))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(pt-&gt;typoutput))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no output function available for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(type))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *typOutput = pt-&gt;typoutput;<br/></li>
<li>&nbsp; &nbsp; *typIsVarlena = (!pt-&gt;typbyval) &amp;&amp; (pt-&gt;typlen == -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(typeTuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2940" title="utils/cache/lsyscache.c:2940">getTypeBinaryInputInfo</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get info needed for binary input of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of a type<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2940">&#x200c;</a></span><span class="linkable">getTypeBinaryInputInfo</span>(Oid type, Oid *typReceive, Oid *typIOParam)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; typeTuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_type pt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typeTuple = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(type));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(typeTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, type);<br/></li>
<li>&nbsp; &nbsp; pt = (Form_pg_type) GETSTRUCT(typeTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!pt-&gt;typisdefined)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;type </span><span class="Special">%s</span><span class="Constant"> is only a shell&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(type))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(pt-&gt;typreceive))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no binary input function available for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(type))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *typReceive = pt-&gt;typreceive;<br/></li>
<li>&nbsp; &nbsp; *typIOParam = <a href="#L2303" title="utils/cache/lsyscache.c:2303">getTypeIOParam</a>(typeTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(typeTuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2973" title="utils/cache/lsyscache.c:2973">getTypeBinaryOutputInfo</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get info needed for binary output of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of a type<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2973">&#x200c;</a></span><span class="linkable">getTypeBinaryOutputInfo</span>(Oid type, Oid *typSend, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *typIsVarlena)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; typeTuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_type pt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typeTuple = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(type));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(typeTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, type);<br/></li>
<li>&nbsp; &nbsp; pt = (Form_pg_type) GETSTRUCT(typeTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!pt-&gt;typisdefined)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;type </span><span class="Special">%s</span><span class="Constant"> is only a shell&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(type))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(pt-&gt;typsend))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no binary output function available for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(type))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *typSend = pt-&gt;typsend;<br/></li>
<li>&nbsp; &nbsp; *typIsVarlena = (!pt-&gt;typbyval) &amp;&amp; (pt-&gt;typlen == -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(typeTuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3006" title="utils/cache/lsyscache.c:3006">get_typmodin</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the type OID, return the type's typmodin procedure, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L3006">&#x200c;</a><span class="linkable">get_typmodin</span>(Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = typtup-&gt;typmodin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3031" title="utils/cache/lsyscache.c:3031">get_typmodout</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the type OID, return the type's typmodout procedure, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L3031">&#x200c;</a><span class="linkable">get_typmodout</span>(Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = typtup-&gt;typmodout;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NOT_USED */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3056" title="utils/cache/lsyscache.c:3056">get_typcollation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the type OID, return the type's typcollation attribute.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L3056">&#x200c;</a><span class="linkable">get_typcollation</span>(Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = typtup-&gt;typcollation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3081" title="utils/cache/lsyscache.c:3081">type_is_collatable</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return whether the type cares about collations<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3081">&#x200c;</a></span><span class="linkable">type_is_collatable</span>(Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> OidIsValid(<a href="#L3056" title="utils/cache/lsyscache.c:3056">get_typcollation</a>(typid));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3097" title="utils/cache/lsyscache.c:3097">get_typsubscript</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the type OID, return the type's subscripting handler's OID,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; if it has one.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If typelemp isn't NULL, we also store the type's typelem value there.<br/></li>
<li></span><span class="Comment"> * This saves some callers an extra catalog lookup.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RegProcedure<br/></li>
<li><a id="L3097">&#x200c;</a><span class="linkable">get_typsubscript</span>(Oid typid, Oid *typelemp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_type typform = (Form_pg_type) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RegProcedure handler = typform-&gt;typsubscript;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typelemp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *typelemp = typform-&gt;typelem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> handler;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typelemp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *typelemp = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3130" title="utils/cache/lsyscache.c:3130">getSubscriptingRoutines</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the type OID, fetch the type's subscripting methods struct.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return NULL if type is not subscriptable.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If typelemp isn't NULL, we also store the type's typelem value there.<br/></li>
<li></span><span class="Comment"> * This saves some callers an extra catalog lookup.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">struct</span> SubscriptRoutines *<br/></li>
<li><a id="L3130">&#x200c;</a><span class="linkable">getSubscriptingRoutines</span>(Oid typid, Oid *typelemp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RegProcedure typsubscript = <a href="#L3097" title="utils/cache/lsyscache.c:3097">get_typsubscript</a>(typid, typelemp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(typsubscript))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">const</span> <span class="Type">struct</span> SubscriptRoutines *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DatumGetPointer(OidFunctionCall0(typsubscript));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ---------- STATISTICS CACHE ----------&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3158" title="utils/cache/lsyscache.c:3158">get_attavgwidth</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Given the table and attribute number of a column, get the average<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; width of entries in the column.&nbsp; Return zero if no data available.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently this is only consulted for individual tables, not for inheritance<br/></li>
<li></span><span class="Comment"> * trees, so we don't need an &quot;inh&quot; parameter.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Calling a hook at this point looks somewhat strange, but is required<br/></li>
<li></span><span class="Comment"> * because the optimizer calls this function without <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other way for<br/></li>
<li></span><span class="Comment"> * plug-ins to control the result.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>int32<br/></li>
<li><a id="L3158">&#x200c;</a><span class="linkable">get_attavgwidth</span>(Oid relid, AttrNumber attnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; stawidth;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L53" title="utils/cache/lsyscache.c:53">get_attavgwidth_hook</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stawidth = (*<a href="#L53" title="utils/cache/lsyscache.c:53">get_attavgwidth_hook</a>) (relid, attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stawidth &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> stawidth;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L240" title="utils/cache/syscache.c:240">SearchSysCache3</a>(STATRELATTINH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(relid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int16GetDatum(attnum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BoolGetDatum(<span class="Constant">false</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stawidth = ((Form_pg_statistic) GETSTRUCT(tp))-&gt;stawidth;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stawidth &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> stawidth;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Extract the contents of a &quot;slot&quot; of a pg_statistic tuple.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns true if requested slot type was found, else false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike other routines in this file, this takes a pointer to an<br/></li>
<li></span><span class="Comment"> * already-looked-up tuple in the pg_statistic cache.&nbsp; We do this since<br/></li>
<li></span><span class="Comment"> * most callers will want to extract more than one value from the cache<br/></li>
<li></span><span class="Comment"> * entry, and we don't want to <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> the cache lookup unnecessarily.<br/></li>
<li></span><span class="Comment"> * Also, this API allows this routine to be used with statistics tuples<br/></li>
<li></span><span class="Comment"> * that have been provided by a stats hook and didn't really come from<br/></li>
<li></span><span class="Comment"> * pg_statistic.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * sslot: pointer to output area (typically, a local variable in the caller).<br/></li>
<li></span><span class="Comment"> * statstuple: pg_statistic tuple to be examined.<br/></li>
<li></span><span class="Comment"> * reqkind: STAKIND code for desired statistics slot kind.<br/></li>
<li></span><span class="Comment"> * reqop: STAOP value wanted, or InvalidOid if don't care.<br/></li>
<li></span><span class="Comment"> * flags: bitmask of ATTSTATSSLOT_VALUES and/or ATTSTATSSLOT_NUMBERS.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If a matching slot is found, true is returned, and *sslot is filled thus:<br/></li>
<li></span><span class="Comment"> * staop: receives the actual STAOP value.<br/></li>
<li></span><span class="Comment"> * stacoll: receives the actual STACOLL value.<br/></li>
<li></span><span class="Comment"> * valuetype: receives actual datatype of the elements of stavalues.<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>: receives pointer to an array of the slot's stavalues.<br/></li>
<li></span><span class="Comment"> * nvalues: receives number of stavalues.<br/></li>
<li></span><span class="Comment"> * numbers: receives pointer to an array of the slot's stanumbers (as float4).<br/></li>
<li></span><span class="Comment"> * nnumbers: receives number of stanumbers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * valuetype/<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>/nvalues are InvalidOid/NULL/0 if ATTSTATSSLOT_VALUES<br/></li>
<li></span><span class="Comment"> * wasn't specified.&nbsp; Likewise, numbers/nnumbers are NULL/0 if<br/></li>
<li></span><span class="Comment"> * ATTSTATSSLOT_NUMBERS wasn't specified.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If no matching slot is found, false is returned, and *sslot is zeroed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the current API doesn't allow for searching for a slot with<br/></li>
<li></span><span class="Comment"> * a particular collation.&nbsp; If we ever actually support recording more than<br/></li>
<li></span><span class="Comment"> * one collation, we'll have to extend the API, but for <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> simple is good.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The data referred to by the fields of sslot is locally <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d and<br/></li>
<li></span><span class="Comment"> * is independent of the original pg_statistic tuple.&nbsp; When the caller<br/></li>
<li></span><span class="Comment"> * is done with it, call <a href="#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a> to release the <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If it's desirable to call <a href="#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a> when <a href="#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a> might<br/></li>
<li></span><span class="Comment"> * not have been called, memset'ing sslot to zeroes will allow that.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Passing flags=0 can be useful to quickly check if the requested slot type<br/></li>
<li></span><span class="Comment"> * exists.&nbsp; In this case no arrays are extracted, so <a href="#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a> need<br/></li>
<li></span><span class="Comment"> * not be called.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3234">&#x200c;</a></span><span class="linkable">get_attstatsslot</span>(AttStatsSlot *sslot, HeapTuple statstuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> reqkind, Oid reqop, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Form_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *statarray;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arrayelemtype;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; narrayelem;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; typeTuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_type typeForm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> *sslot properly */<br/></li>
<li></span>&nbsp; &nbsp; memset(sslot, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttStatsSlot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; STATISTIC_NUM_SLOTS; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((&amp;stats-&gt;stakind1)[i] == reqkind &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (reqop == InvalidOid || (&amp;stats-&gt;staop1)[i] == reqop))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= STATISTIC_NUM_SLOTS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not there */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; sslot-&gt;staop = (&amp;stats-&gt;staop1)[i];<br/></li>
<li>&nbsp; &nbsp; sslot-&gt;stacoll = (&amp;stats-&gt;stacoll1)[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; ATTSTATSSLOT_VALUES)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; val = <a href="syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(STATRELATTINH, statstuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Anum_pg_statistic_stavalues1 + i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Detoast the array if needed, and in <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case make a copy that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * under control of this AttStatsSlot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; statarray = DatumGetArrayTypePCopy(val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Extract the actual array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type, and pass it back in case the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caller needs it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sslot-&gt;valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Need info about <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typeTuple = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(arrayelemtype));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(typeTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, arrayelemtype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typeForm = (Form_pg_type) GETSTRUCT(typeTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Deconstruct array into Datum elements; NULLs not expected */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../adt/arrayfuncs.c.html#L3612" title="utils/adt/arrayfuncs.c:3612">deconstruct_array</a>(statarray,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arrayelemtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeForm-&gt;typlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeForm-&gt;typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeForm-&gt;typalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;sslot-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, <span class="Constant">NULL</span>, &amp;sslot-&gt;nvalues);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type is pass-by-reference, we <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have a bunch of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Datums that are pointers into the statarray, so we need to keep<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that until <a href="#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>.&nbsp; Otherwise, all the useful info is in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sslot-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[], so we can free the array object immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!typeForm-&gt;typbyval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sslot-&gt;values_arr = statarray;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(statarray);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(typeTuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; ATTSTATSSLOT_NUMBERS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; val = <a href="syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(STATRELATTINH, statstuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Anum_pg_statistic_stanumbers1 + i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Detoast the array if needed, and in <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case make a copy that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * under control of this AttStatsSlot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; statarray = DatumGetArrayTypePCopy(val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We expect the array to be a 1-D float4 array; verify that. We don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to use <a href="../adt/arrayfuncs.c.html#L3612" title="utils/adt/arrayfuncs.c:3612">deconstruct_array</a>() since the array data is just going<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to look like a C array of float4 <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; narrayelem = ARR_DIMS(statarray)[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ARR_NDIM(statarray) != <span class="Constant">1</span> || narrayelem &lt;= <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ARR_HASNULL(statarray) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ARR_ELEMTYPE(statarray) != FLOAT4OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;stanumbers is not a 1-D float4 array&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Give caller a pointer directly into the statarray */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sslot-&gt;numbers = (float4 *) ARR_DATA_PTR(statarray);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sslot-&gt;nnumbers = narrayelem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We'll free the statarray in <a href="#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sslot-&gt;numbers_arr = statarray;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Free data allocated by <a href="#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3344">&#x200c;</a></span><span class="linkable">free_attstatsslot</span>(AttStatsSlot *sslot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[] array was separately <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d by <a href="../adt/arrayfuncs.c.html#L3612" title="utils/adt/arrayfuncs.c:3612">deconstruct_array</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sslot-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(sslot-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The numbers[] array points into numbers_arr, do not <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Free the detoasted array objects, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sslot-&gt;values_arr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(sslot-&gt;values_arr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sslot-&gt;numbers_arr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(sslot-&gt;numbers_arr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ---------- PG_NAMESPACE CACHE ----------&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the name of a given namespace<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d copy of the string, or NULL if no such namespace.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L3366">&#x200c;</a><span class="linkable">get_namespace_name</span>(Oid nspid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(NAMESPACEOID, ObjectIdGetDatum(nspid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_namespace nsptup = (Form_pg_namespace) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(nsptup-&gt;nspname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3390" title="utils/cache/lsyscache.c:3390">get_namespace_name_or_temp</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; As above, but if it is this backend's temporary namespace, return<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &quot;pg_temp&quot; instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L3390">&#x200c;</a><span class="linkable">get_namespace_name_or_temp</span>(Oid nspid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../catalog/namespace.c.html#L3634" title="catalog/namespace.c:3634">isTempNamespace</a>(nspid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;pg_temp&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(nspid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ---------- PG_RANGE CACHES ----------&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3407" title="utils/cache/lsyscache.c:3407">get_range_subtype</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the subtype of a given <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns InvalidOid if the type is not a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L3407">&#x200c;</a><span class="linkable">get_range_subtype</span>(Oid rangeOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RANGETYPE, ObjectIdGetDatum(rangeOid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_range rngtup = (Form_pg_range) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = rngtup-&gt;rngsubtype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3433" title="utils/cache/lsyscache.c:3433">get_range_collation</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the collation of a given <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns InvalidOid if the type is not a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type,<br/></li>
<li></span><span class="Comment"> * or if its subtype is not collatable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L3433">&#x200c;</a><span class="linkable">get_range_collation</span>(Oid rangeOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RANGETYPE, ObjectIdGetDatum(rangeOid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_range rngtup = (Form_pg_range) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = rngtup-&gt;rngcollation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3458" title="utils/cache/lsyscache.c:3458">get_range_multirange</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the multirange type of a given <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns InvalidOid if the type is not a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L3458">&#x200c;</a><span class="linkable">get_range_multirange</span>(Oid rangeOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RANGETYPE, ObjectIdGetDatum(rangeOid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_range rngtup = (Form_pg_range) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = rngtup-&gt;rngmultitypid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3483" title="utils/cache/lsyscache.c:3483">get_multirange_range</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type of a given multirange<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns InvalidOid if the type is not a multirange.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L3483">&#x200c;</a><span class="linkable">get_multirange_range</span>(Oid multirangeOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RANGEMULTIRANGE, ObjectIdGetDatum(multirangeOid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_range rngtup = (Form_pg_range) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = rngtup-&gt;rngtypid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ---------- PG_INDEX CACHE ----------&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3512" title="utils/cache/lsyscache.c:3512">get_index_column_opclass</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the index OID and column number,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; return opclass of the index column<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or InvalidOid if the index was not found<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or column is non-key one.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L3512">&#x200c;</a><span class="linkable">get_index_column_opclass</span>(Oid index_oid, <span class="Type">int</span> attno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_index rd_index;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; oidvector&nbsp; *indclass;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opclass;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First we need to know the column's opclass. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(INDEXRELID, ObjectIdGetDatum(index_oid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rd_index = (Form_pg_index) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* caller is supposed to guarantee this */<br/></li>
<li></span>&nbsp; &nbsp; Assert(attno &gt; <span class="Constant">0</span> &amp;&amp; attno &lt;= rd_index-&gt;indnatts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Non-key attributes don't have an opclass */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attno &gt; rd_index-&gt;indnkeyatts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; datum = <a href="syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(INDEXRELID, tuple, Anum_pg_index_indclass);<br/></li>
<li>&nbsp; &nbsp; indclass = ((oidvector *) DatumGetPointer(datum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(attno &lt;= indclass-&gt;dim1);<br/></li>
<li>&nbsp; &nbsp; opclass = indclass-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[attno - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> opclass;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3555" title="utils/cache/lsyscache.c:3555">get_index_isreplident</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the index OID, return pg_index.indisreplident.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3555">&#x200c;</a></span><span class="linkable">get_index_isreplident</span>(Oid index_oid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_index rd_index;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(INDEXRELID, ObjectIdGetDatum(index_oid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rd_index = (Form_pg_index) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; result = rd_index-&gt;indisreplident;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3578" title="utils/cache/lsyscache.c:3578">get_index_isvalid</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the index OID, return pg_index.indisvalid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3578">&#x200c;</a></span><span class="linkable">get_index_isvalid</span>(Oid index_oid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isvalid;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_index rd_index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(INDEXRELID, ObjectIdGetDatum(index_oid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for index </span><span class="Special">%u</span><span class="Constant">&quot;</span>, index_oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rd_index = (Form_pg_index) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; isvalid = rd_index-&gt;indisvalid;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> isvalid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3601" title="utils/cache/lsyscache.c:3601">get_index_isclustered</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the index OID, return pg_index.indisclustered.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3601">&#x200c;</a></span><span class="linkable">get_index_isclustered</span>(Oid index_oid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isclustered;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_index rd_index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(INDEXRELID, ObjectIdGetDatum(index_oid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for index </span><span class="Special">%u</span><span class="Constant">&quot;</span>, index_oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rd_index = (Form_pg_index) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; isclustered = rd_index-&gt;indisclustered;<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> isclustered;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3625" title="utils/cache/lsyscache.c:3625">get_publication_oid</a> - given a publication name, look up the OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If missing_ok is false, throw an error if name not found.&nbsp; If true, just<br/></li>
<li></span><span class="Comment"> * return InvalidOid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L3625">&#x200c;</a><span class="linkable">get_publication_oid</span>(<span class="Type">const</span> <span class="Type">char</span> *pubname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oid = GetSysCacheOid1(PUBLICATIONNAME, Anum_pg_publication_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum(pubname));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(oid) &amp;&amp; !missing_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;publication </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>, pubname)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> oid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3645" title="utils/cache/lsyscache.c:3645">get_publication_name</a> - given a publication Oid, look up the name<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If missing_ok is false, throw an error if name not found.&nbsp; If true, just<br/></li>
<li></span><span class="Comment"> * return NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L3645">&#x200c;</a><span class="linkable">get_publication_name</span>(Oid pubid, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *pubname;<br/></li>
<li>&nbsp; &nbsp; Form_pg_publication pubform;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tup = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PUBLICATIONOID, ObjectIdGetDatum(pubid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!missing_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for publication </span><span class="Special">%u</span><span class="Constant">&quot;</span>, pubid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pubform = (Form_pg_publication) GETSTRUCT(tup);<br/></li>
<li>&nbsp; &nbsp; pubname = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(pubform-&gt;pubname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pubname;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3675" title="utils/cache/lsyscache.c:3675">get_subscription_oid</a> - given a subscription name, look up the OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If missing_ok is false, throw an error if name not found.&nbsp; If true, just<br/></li>
<li></span><span class="Comment"> * return InvalidOid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L3675">&#x200c;</a><span class="linkable">get_subscription_oid</span>(<span class="Type">const</span> <span class="Type">char</span> *subname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oid = GetSysCacheOid2(SUBSCRIPTIONNAME, Anum_pg_subscription_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>, CStringGetDatum(subname));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(oid) &amp;&amp; !missing_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;subscription </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>, subname)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> oid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3695" title="utils/cache/lsyscache.c:3695">get_subscription_name</a> - given a subscription OID, look up the name<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If missing_ok is false, throw an error if name not found.&nbsp; If true, just<br/></li>
<li></span><span class="Comment"> * return NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L3695">&#x200c;</a><span class="linkable">get_subscription_name</span>(Oid subid, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *subname;<br/></li>
<li>&nbsp; &nbsp; Form_pg_subscription subform;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tup = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(SUBSCRIPTIONOID, ObjectIdGetDatum(subid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!missing_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for subscription </span><span class="Special">%u</span><span class="Constant">&quot;</span>, subid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; subform = (Form_pg_subscription) GETSTRUCT(tup);<br/></li>
<li>&nbsp; &nbsp; subname = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(subform-&gt;subname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> subname;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
