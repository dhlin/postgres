<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/cache/catcache.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/cache/catcache.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L64">CacheHdr</a></li>
<li><a href="#L118">catcache_resowner_desc</a></li>
<li><a href="#L128">catlistref_resowner_desc</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L2180">CatCacheCopyKeys</a></li>
<li><a href="#L2155">CatCacheFreeKeys</a></li>
<li><a href="#L606">CatCacheInvalidate</a></li>
<li><a href="#L441">CatCachePrintStats</a></li>
<li><a href="#L551">CatCacheRemoveCList</a></li>
<li><a href="#L509">CatCacheRemoveCTup</a></li>
<li><a href="#L422">CatalogCacheCompareTuple</a></li>
<li><a href="#L325">CatalogCacheComputeHashValue</a></li>
<li><a href="#L367">CatalogCacheComputeTupleHashValue</a></li>
<li><a href="#L2026">CatalogCacheCreateEntry</a></li>
<li><a href="#L783">CatalogCacheFlushCatalog</a></li>
<li><a href="#L1035">CatalogCacheInitializeCache</a></li>
<li><a href="#L679">CreateCacheMemoryContext</a></li>
<li><a href="#L255">GetCCHashEqFuncs</a></li>
<li><a href="#L1612">GetCatCacheHashValue</a></li>
<li><a href="#L1196">IndexScanOK</a></li>
<li><a href="#L827">InitCatCache</a></li>
<li><a href="#L1144">InitCatCachePhase2</a></li>
<li><a href="#L2250">PrepareToInvalidateCacheTuple</a></li>
<li><a href="#L934">RehashCatCache</a></li>
<li><a href="#L972">RehashCatCacheLists</a></li>
<li><a href="#L1573">ReleaseCatCache</a></li>
<li><a href="#L1986">ReleaseCatCacheList</a></li>
<li><a href="#L1992">ReleaseCatCacheListWithOwner</a></li>
<li><a href="#L1579">ReleaseCatCacheWithOwner</a></li>
<li><a href="#L2317">ResOwnerPrintCatCache</a></li>
<li><a href="#L2340">ResOwnerPrintCatCacheList</a></li>
<li><a href="#L2311">ResOwnerReleaseCatCache</a></li>
<li><a href="#L2334">ResOwnerReleaseCatCacheList</a></li>
<li><a href="#L701">ResetCatalogCache</a></li>
<li><a href="#L753">ResetCatalogCaches</a></li>
<li><a href="#L155">ResourceOwnerForgetCatCacheListRef</a></li>
<li><a href="#L145">ResourceOwnerForgetCatCacheRef</a></li>
<li><a href="#L150">ResourceOwnerRememberCatCacheListRef</a></li>
<li><a href="#L140">ResourceOwnerRememberCatCacheRef</a></li>
<li><a href="#L1261">SearchCatCache</a></li>
<li><a href="#L1278">SearchCatCache1</a></li>
<li><a href="#L1286">SearchCatCache2</a></li>
<li><a href="#L1294">SearchCatCache3</a></li>
<li><a href="#L1302">SearchCatCache4</a></li>
<li><a href="#L1312">SearchCatCacheInternal</a></li>
<li><a href="#L1646">SearchCatCacheList</a></li>
<li><a href="#L1424">SearchCatCacheMiss</a></li>
<li><a href="#L172">chareqfast</a></li>
<li><a href="#L178">charhashfast</a></li>
<li><a href="#L201">int2eqfast</a></li>
<li><a href="#L207">int2hashfast</a></li>
<li><a href="#L213">int4eqfast</a></li>
<li><a href="#L219">int4hashfast</a></li>
<li><a href="#L184">nameeqfast</a></li>
<li><a href="#L193">namehashfast</a></li>
<li><a href="#L242">oidvectoreqfast</a></li>
<li><a href="#L248">oidvectorhashfast</a></li>
<li><a href="#L225">texteqfast</a></li>
<li><a href="#L235">texthashfast</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L58">CACHE_elog</a></li>
<li><a href="#L60">CACHE_elog</a></li>
<li><a href="#L1014">CatalogCacheInitializeCache_DEBUG1</a></li>
<li><a href="#L1030">CatalogCacheInitializeCache_DEBUG1</a></li>
<li><a href="#L1018">CatalogCacheInitializeCache_DEBUG2</a></li>
<li><a href="#L1031">CatalogCacheInitializeCache_DEBUG2</a></li>
<li><a href="#L50">HASH_INDEX</a></li>
<li><a href="#L816">InitCatCache_DEBUG2</a></li>
<li><a href="#L823">InitCatCache_DEBUG2</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * catcache.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; System catalog cache for tuples matching a key.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/cache/catcache.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/genam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/heaptoast.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/relscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_collation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/hashfn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/pg_prng.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><span class="PreProc">#ifdef CATCACHE_STATS<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for <a href="../../storage/ipc/ipc.c.html#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a> */<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/catcache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgroids.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/resowner.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li> <span class="Comment">/* #define CACHEDEBUG */</span>&nbsp; &nbsp; <span class="Comment">/* turns DEBUG elogs on */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value and the size of the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table, <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the bucket<br/></li>
<li></span><span class="Comment"> * in which the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value belongs. Since the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table must contain<br/></li>
<li></span><span class="Comment"> * a power-of-2 number of elements, this is a simple bitmask.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L50">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">HASH_INDEX</span>(h, sz) ((Index) ((h) &amp; ((sz) - </span><span class="Constant">1</span><span class="PreProc">)))<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; variables, macros and other stuff<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef CACHEDEBUG<br/></li>
<li><a id="L58">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CACHE_elog</span>(...)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(</span><span class="Constant">__VA_ARGS__</span><span class="PreProc">)<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li><a id="L60">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CACHE_elog</span>(...)<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Cache management header --- pointer is NULL until created */<br/></li>
<li><a id="L64">&#x200c;</a></span><span class="Type">static</span> CatCacheHeader *<span class="linkable">CacheHdr</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> HeapTuple <a href="#L1312" title="utils/cache/catcache.c:1312">SearchCatCacheInternal</a>(CatCache *cache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum v1, Datum v2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum v3, Datum v4);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> pg_noinline HeapTuple <a href="#L1424" title="utils/cache/catcache.c:1424">SearchCatCacheMiss</a>(CatCache *cache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 hashValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index hashIndex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum v1, Datum v2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum v3, Datum v4);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> uint32 <a href="#L325" title="utils/cache/catcache.c:325">CatalogCacheComputeHashValue</a>(CatCache *cache, <span class="Type">int</span> nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum v1, Datum v2, Datum v3, Datum v4);<br/></li>
<li><span class="Type">static</span> uint32 <a href="#L367" title="utils/cache/catcache.c:367">CatalogCacheComputeTupleHashValue</a>(CatCache *cache, <span class="Type">int</span> nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple tuple);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L422" title="utils/cache/catcache.c:422">CatalogCacheCompareTuple</a>(<span class="Type">const</span> CatCache *cache, <span class="Type">int</span> nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> Datum *cachekeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> Datum *searchkeys);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef CATCACHE_STATS<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L441" title="utils/cache/catcache.c:441">CatCachePrintStats</a>(<span class="Type">int</span> code, Datum arg);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L509" title="utils/cache/catcache.c:509">CatCacheRemoveCTup</a>(CatCache *cache, CatCTup *ct);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L551" title="utils/cache/catcache.c:551">CatCacheRemoveCList</a>(CatCache *cache, CatCList *cl);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L934" title="utils/cache/catcache.c:934">RehashCatCache</a>(CatCache *cp);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L972" title="utils/cache/catcache.c:972">RehashCatCacheLists</a>(CatCache *cp);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1035" title="utils/cache/catcache.c:1035">CatalogCacheInitializeCache</a>(CatCache *cache);<br/></li>
<li><span class="Type">static</span> CatCTup *<a href="#L2026" title="utils/cache/catcache.c:2026">CatalogCacheCreateEntry</a>(CatCache *cache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple ntp, SysScanDesc scandesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *arguments,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 hashValue, Index hashIndex);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1579" title="utils/cache/catcache.c:1579">ReleaseCatCacheWithOwner</a>(HeapTuple tuple, ResourceOwner resowner);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1992" title="utils/cache/catcache.c:1992">ReleaseCatCacheListWithOwner</a>(CatCList *list, ResourceOwner resowner);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2155" title="utils/cache/catcache.c:2155">CatCacheFreeKeys</a>(TupleDesc tupdesc, <span class="Type">int</span> nkeys, <span class="Type">int</span> *attnos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *keys);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2180" title="utils/cache/catcache.c:2180">CatCacheCopyKeys</a>(TupleDesc tupdesc, <span class="Type">int</span> nkeys, <span class="Type">int</span> *attnos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *srckeys, Datum *dstkeys);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* ResourceOwner callbacks to hold catcache references */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2311" title="utils/cache/catcache.c:2311">ResOwnerReleaseCatCache</a>(Datum res);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L2317" title="utils/cache/catcache.c:2317">ResOwnerPrintCatCache</a>(Datum res);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2334" title="utils/cache/catcache.c:2334">ResOwnerReleaseCatCacheList</a>(Datum res);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L2340" title="utils/cache/catcache.c:2340">ResOwnerPrintCatCacheList</a>(Datum res);<br/></li>
<li><br/></li>
<li><a id="L118">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> ResourceOwnerDesc <span class="linkable">catcache_resowner_desc</span> =<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* catcache references */<br/></li>
<li></span>&nbsp; &nbsp; .name = <span class="Constant">&quot;catcache reference&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; .release_phase = RESOURCE_RELEASE_AFTER_LOCKS,<br/></li>
<li>&nbsp; &nbsp; .release_priority = RELEASE_PRIO_CATCACHE_REFS,<br/></li>
<li>&nbsp; &nbsp; .ReleaseResource = <a href="#L2311" title="utils/cache/catcache.c:2311">ResOwnerReleaseCatCache</a>,<br/></li>
<li>&nbsp; &nbsp; .DebugPrint = <a href="#L2317" title="utils/cache/catcache.c:2317">ResOwnerPrintCatCache</a><br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L128">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> ResourceOwnerDesc <span class="linkable">catlistref_resowner_desc</span> =<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* catcache-list pins */<br/></li>
<li></span>&nbsp; &nbsp; .name = <span class="Constant">&quot;catcache list reference&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; .release_phase = RESOURCE_RELEASE_AFTER_LOCKS,<br/></li>
<li>&nbsp; &nbsp; .release_priority = RELEASE_PRIO_CATCACHE_LIST_REFS,<br/></li>
<li>&nbsp; &nbsp; .ReleaseResource = <a href="#L2334" title="utils/cache/catcache.c:2334">ResOwnerReleaseCatCacheList</a>,<br/></li>
<li>&nbsp; &nbsp; .DebugPrint = <a href="#L2340" title="utils/cache/catcache.c:2340">ResOwnerPrintCatCacheList</a><br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Convenience wrappers over <a href="../resowner/resowner.c.html#L514" title="utils/resowner/resowner.c:514">ResourceOwnerRemember</a>/Forget */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L140">&#x200c;</a></span><span class="linkable">ResourceOwnerRememberCatCacheRef</span>(ResourceOwner owner, HeapTuple tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../resowner/resowner.c.html#L514" title="utils/resowner/resowner.c:514">ResourceOwnerRemember</a>(owner, PointerGetDatum(tuple), &amp;<a href="#L118" title="utils/cache/catcache.c:118">catcache_resowner_desc</a>);<br/></li>
<li>}<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L145">&#x200c;</a></span><span class="linkable">ResourceOwnerForgetCatCacheRef</span>(ResourceOwner owner, HeapTuple tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../resowner/resowner.c.html#L554" title="utils/resowner/resowner.c:554">ResourceOwnerForget</a>(owner, PointerGetDatum(tuple), &amp;<a href="#L118" title="utils/cache/catcache.c:118">catcache_resowner_desc</a>);<br/></li>
<li>}<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L150">&#x200c;</a></span><span class="linkable">ResourceOwnerRememberCatCacheListRef</span>(ResourceOwner owner, CatCList *list)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../resowner/resowner.c.html#L514" title="utils/resowner/resowner.c:514">ResourceOwnerRemember</a>(owner, PointerGetDatum(list), &amp;<a href="#L128" title="utils/cache/catcache.c:128">catlistref_resowner_desc</a>);<br/></li>
<li>}<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L155">&#x200c;</a></span><span class="linkable">ResourceOwnerForgetCatCacheListRef</span>(ResourceOwner owner, CatCList *list)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../resowner/resowner.c.html#L554" title="utils/resowner/resowner.c:554">ResourceOwnerForget</a>(owner, PointerGetDatum(list), &amp;<a href="#L128" title="utils/cache/catcache.c:128">catlistref_resowner_desc</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Hash and equality <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for system types that are used as cache key<br/></li>
<li></span><span class="Comment"> * fields.&nbsp; In some cases, we just call the regular SQL-callable <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for<br/></li>
<li></span><span class="Comment"> * the appropriate data type, but that tends to be a little slow, and the<br/></li>
<li></span><span class="Comment"> * speed of these <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> is performance-critical.&nbsp; Therefore, for data<br/></li>
<li></span><span class="Comment"> * types that frequently occur as catcache keys, we hard-code the logic here.<br/></li>
<li></span><span class="Comment"> * Avoiding the overhead of DirectFunctionCallN(...) is a substantial win, and<br/></li>
<li></span><span class="Comment"> * in certain cases (like int4) we can adopt a faster <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> algorithm as well.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L172">&#x200c;</a></span><span class="linkable">chareqfast</span>(Datum a, Datum b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetChar(a) == DatumGetChar(b);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> uint32<br/></li>
<li><a id="L178">&#x200c;</a><span class="linkable">charhashfast</span>(Datum datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> murmurhash32((int32) DatumGetChar(datum));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L184">&#x200c;</a></span><span class="linkable">nameeqfast</span>(Datum a, Datum b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ca = NameStr(*DatumGetName(a));<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cb = NameStr(*DatumGetName(b));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> strncmp(ca, cb, NAMEDATALEN) == <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> uint32<br/></li>
<li><a id="L193">&#x200c;</a><span class="linkable">namehashfast</span>(Datum datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *key = NameStr(*DatumGetName(datum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> hash_any((<span class="Type">unsigned</span> <span class="Type">char</span> *) key, strlen(key));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L201">&#x200c;</a></span><span class="linkable">int2eqfast</span>(Datum a, Datum b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetInt16(a) == DatumGetInt16(b);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> uint32<br/></li>
<li><a id="L207">&#x200c;</a><span class="linkable">int2hashfast</span>(Datum datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> murmurhash32((int32) DatumGetInt16(datum));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L213">&#x200c;</a></span><span class="linkable">int4eqfast</span>(Datum a, Datum b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetInt32(a) == DatumGetInt32(b);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> uint32<br/></li>
<li><a id="L219">&#x200c;</a><span class="linkable">int4hashfast</span>(Datum datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> murmurhash32((int32) DatumGetInt32(datum));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L225">&#x200c;</a></span><span class="linkable">texteqfast</span>(Datum a, Datum b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The use of DEFAULT_COLLATION_OID is fairly arbitrary here.&nbsp; We just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * want to take the fast &quot;deterministic&quot; path in <a href="../adt/varlena.c.html#L1619" title="utils/adt/varlena.c:1619">texteq</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetBool(<a href="../fmgr/fmgr.c.html#L812" title="utils/fmgr/fmgr.c:812">DirectFunctionCall2Coll</a>(<a href="../adt/varlena.c.html#L1619" title="utils/adt/varlena.c:1619">texteq</a>, DEFAULT_COLLATION_OID, a, b));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> uint32<br/></li>
<li><a id="L235">&#x200c;</a><span class="linkable">texthashfast</span>(Datum datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* analogously here as in <a href="#L225" title="utils/cache/catcache.c:225">texteqfast</a>() */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetInt32(<a href="../fmgr/fmgr.c.html#L792" title="utils/fmgr/fmgr.c:792">DirectFunctionCall1Coll</a>(<a href="../../access/hash/hashfunc.c.html#L267" title="access/hash/hashfunc.c:267">hashtext</a>, DEFAULT_COLLATION_OID, datum));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L242">&#x200c;</a></span><span class="linkable">oidvectoreqfast</span>(Datum a, Datum b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetBool(DirectFunctionCall2(<a href="../adt/oid.c.html#L344" title="utils/adt/oid.c:344">oidvectoreq</a>, a, b));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> uint32<br/></li>
<li><a id="L248">&#x200c;</a><span class="linkable">oidvectorhashfast</span>(Datum datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetInt32(DirectFunctionCall1(<a href="../../access/hash/hashfunc.c.html#L232" title="access/hash/hashfunc.c:232">hashoidvector</a>, datum));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Lookup support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for a type. */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L255">&#x200c;</a></span><span class="linkable">GetCCHashEqFuncs</span>(Oid keytype, CCHashFN *hashfunc, RegProcedure *eqfunc, CCFastEqualFN *fasteqfunc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (keytype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BOOLOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *hashfunc = <a href="#L178" title="utils/cache/catcache.c:178">charhashfast</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *fasteqfunc = <a href="#L172" title="utils/cache/catcache.c:172">chareqfast</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *eqfunc = F_BOOLEQ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CHAROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *hashfunc = <a href="#L178" title="utils/cache/catcache.c:178">charhashfast</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *fasteqfunc = <a href="#L172" title="utils/cache/catcache.c:172">chareqfast</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *eqfunc = F_CHAREQ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> NAMEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *hashfunc = <a href="#L193" title="utils/cache/catcache.c:193">namehashfast</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *fasteqfunc = <a href="#L184" title="utils/cache/catcache.c:184">nameeqfast</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *eqfunc = F_NAMEEQ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT2OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *hashfunc = <a href="#L207" title="utils/cache/catcache.c:207">int2hashfast</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *fasteqfunc = <a href="#L201" title="utils/cache/catcache.c:201">int2eqfast</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *eqfunc = F_INT2EQ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT4OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *hashfunc = <a href="#L219" title="utils/cache/catcache.c:219">int4hashfast</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *fasteqfunc = <a href="#L213" title="utils/cache/catcache.c:213">int4eqfast</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *eqfunc = F_INT4EQ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TEXTOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *hashfunc = <a href="#L235" title="utils/cache/catcache.c:235">texthashfast</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *fasteqfunc = <a href="#L225" title="utils/cache/catcache.c:225">texteqfast</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *eqfunc = F_TEXTEQ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OIDOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGPROCOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGPROCEDUREOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGOPEROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGOPERATOROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGCLASSOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGTYPEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGCOLLATIONOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGCONFIGOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGDICTIONARYOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGROLEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REGNAMESPACEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *hashfunc = <a href="#L219" title="utils/cache/catcache.c:219">int4hashfast</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *fasteqfunc = <a href="#L213" title="utils/cache/catcache.c:213">int4eqfast</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *eqfunc = F_OIDEQ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OIDVECTOROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *hashfunc = <a href="#L248" title="utils/cache/catcache.c:248">oidvectorhashfast</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *fasteqfunc = <a href="#L242" title="utils/cache/catcache.c:242">oidvectoreqfast</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *eqfunc = F_OIDVECTOREQ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;type </span><span class="Special">%u</span><span class="Constant"> not supported as catcache key&quot;</span>, keytype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *hashfunc = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *eqfunc = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L325" title="utils/cache/catcache.c:325">CatalogCacheComputeHashValue</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Compute the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value associated with a given set of lookup keys<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint32<br/></li>
<li><a id="L325">&#x200c;</a><span class="linkable">CatalogCacheComputeHashValue</span>(CatCache *cache, <span class="Type">int</span> nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum v1, Datum v2, Datum v3, Datum v4)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hashValue = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; oneHash;<br/></li>
<li>&nbsp; &nbsp; CCHashFN&nbsp;&nbsp; *cc_hashfunc = cache-&gt;cc_hashfunc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L58" title="utils/cache/catcache.c:58">CACHE_elog</a>(DEBUG2, <span class="Constant">&quot;<a href="#L325" title="utils/cache/catcache.c:325">CatalogCacheComputeHashValue</a> </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant"> </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_relname, nkeys, cache);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (nkeys)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">4</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oneHash = (cc_hashfunc[<span class="Constant">3</span>]) (v4);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashValue ^= pg_rotate_left32(oneHash, <span class="Constant">24</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALLTHROUGH */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">3</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oneHash = (cc_hashfunc[<span class="Constant">2</span>]) (v3);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashValue ^= pg_rotate_left32(oneHash, <span class="Constant">16</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALLTHROUGH */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">2</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oneHash = (cc_hashfunc[<span class="Constant">1</span>]) (v2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashValue ^= pg_rotate_left32(oneHash, <span class="Constant">8</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALLTHROUGH */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oneHash = (cc_hashfunc[<span class="Constant">0</span>]) (v1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashValue ^= oneHash;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;wrong number of <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> keys: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, nkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> hashValue;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L367" title="utils/cache/catcache.c:367">CatalogCacheComputeTupleHashValue</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Compute the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value associated with a given tuple to be cached<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint32<br/></li>
<li><a id="L367">&#x200c;</a><span class="linkable">CatalogCacheComputeTupleHashValue</span>(CatCache *cache, <span class="Type">int</span> nkeys, HeapTuple tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; v1 = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v2 = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v3 = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v4 = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *cc_keyno = cache-&gt;cc_keyno;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; cc_tupdesc = cache-&gt;cc_tupdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now extract key fields from tuple, insert into scankey */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (nkeys)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">4</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v4 = fastgetattr(tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cc_keyno[<span class="Constant">3</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cc_tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;isNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!isNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALLTHROUGH */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">3</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v3 = fastgetattr(tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cc_keyno[<span class="Constant">2</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cc_tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;isNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!isNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALLTHROUGH */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">2</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v2 = fastgetattr(tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cc_keyno[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cc_tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;isNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!isNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALLTHROUGH */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v1 = fastgetattr(tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cc_keyno[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cc_tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;isNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!isNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;wrong number of <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> keys: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, nkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L325" title="utils/cache/catcache.c:325">CatalogCacheComputeHashValue</a>(cache, nkeys, v1, v2, v3, v4);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L422" title="utils/cache/catcache.c:422">CatalogCacheCompareTuple</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Compare a tuple to the passed arguments.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L422">&#x200c;</a></span><span class="linkable">CatalogCacheCompareTuple</span>(<span class="Type">const</span> CatCache *cache, <span class="Type">int</span> nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> Datum *cachekeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> Datum *searchkeys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> CCFastEqualFN *cc_fastequal = cache-&gt;cc_fastequal;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(cc_fastequal[i]) (cachekeys[i], searchkeys[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef CATCACHE_STATS<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L441">&#x200c;</a></span><span class="linkable">CatCachePrintStats</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; slist_iter&nbsp; &nbsp; iter;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; cc_searches = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; cc_hits = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; cc_neg_hits = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; cc_newloads = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; cc_invals = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; cc_nlists = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; cc_lsearches = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; cc_lhits = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slist_foreach(iter, &amp;<a href="#L64" title="utils/cache/catcache.c:64">CacheHdr</a>-&gt;ch_caches)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CatCache&nbsp;&nbsp; *cache = slist_container(CatCache, cc_next, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cache-&gt;cc_ntup == <span class="Constant">0</span> &amp;&amp; cache-&gt;cc_searches == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> unused caches */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;catcache </span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">: </span><span class="Special">%d</span><span class="Constant"> tup, </span><span class="Special">%ld</span><span class="Constant"> srch, </span><span class="Special">%ld</span><span class="Constant">+</span><span class="Special">%ld</span><span class="Constant">=</span><span class="Special">%ld</span><span class="Constant"> hits, </span><span class="Special">%ld</span><span class="Constant">+</span><span class="Special">%ld</span><span class="Constant">=</span><span class="Special">%ld</span><span class="Constant"> loads, </span><span class="Special">%ld</span><span class="Constant"> invals, </span><span class="Special">%d</span><span class="Constant"> lists, </span><span class="Special">%ld</span><span class="Constant"> lsrch, </span><span class="Special">%ld</span><span class="Constant"> lhits&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_relname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_indexoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_ntup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_searches,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_hits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_neg_hits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_hits + cache-&gt;cc_neg_hits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_newloads,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_searches - cache-&gt;cc_hits - cache-&gt;cc_neg_hits - cache-&gt;cc_newloads,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_searches - cache-&gt;cc_hits - cache-&gt;cc_neg_hits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_invals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_nlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_lsearches,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_lhits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cc_searches += cache-&gt;cc_searches;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cc_hits += cache-&gt;cc_hits;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cc_neg_hits += cache-&gt;cc_neg_hits;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cc_newloads += cache-&gt;cc_newloads;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cc_invals += cache-&gt;cc_invals;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cc_nlists += cache-&gt;cc_nlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cc_lsearches += cache-&gt;cc_lsearches;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cc_lhits += cache-&gt;cc_lhits;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;catcache totals: </span><span class="Special">%d</span><span class="Constant"> tup, </span><span class="Special">%ld</span><span class="Constant"> srch, </span><span class="Special">%ld</span><span class="Constant">+</span><span class="Special">%ld</span><span class="Constant">=</span><span class="Special">%ld</span><span class="Constant"> hits, </span><span class="Special">%ld</span><span class="Constant">+</span><span class="Special">%ld</span><span class="Constant">=</span><span class="Special">%ld</span><span class="Constant"> loads, </span><span class="Special">%ld</span><span class="Constant"> invals, </span><span class="Special">%ld</span><span class="Constant"> lists, </span><span class="Special">%ld</span><span class="Constant"> lsrch, </span><span class="Special">%ld</span><span class="Constant"> lhits&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L64" title="utils/cache/catcache.c:64">CacheHdr</a>-&gt;ch_ntup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cc_searches,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cc_hits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cc_neg_hits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cc_hits + cc_neg_hits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cc_newloads,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cc_searches - cc_hits - cc_neg_hits - cc_newloads,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cc_searches - cc_hits - cc_neg_hits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cc_invals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cc_nlists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cc_lsearches,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cc_lhits);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* CATCACHE_STATS */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L509" title="utils/cache/catcache.c:509">CatCacheRemoveCTup</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlink and delete the given cache entry<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: if it is a member of a CatCList, the CatCList is deleted too.<br/></li>
<li></span><span class="Comment"> * Both the cache entry and the list had better have zero refcount.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L509">&#x200c;</a></span><span class="linkable">CatCacheRemoveCTup</span>(CatCache *cache, CatCTup *ct)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(ct-&gt;refcount == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(ct-&gt;my_cache == cache);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ct-&gt;c_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The cleanest way to handle this is to call <a href="#L551" title="utils/cache/catcache.c:551">CatCacheRemoveCList</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which will recurse back to me, and the recursive call will do the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * work.&nbsp; Set the &quot;dead&quot; flag to make sure it does recurse.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ct-&gt;dead = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L551" title="utils/cache/catcache.c:551">CatCacheRemoveCList</a>(cache, ct-&gt;c_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing left to do */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* delink from linked list */<br/></li>
<li></span>&nbsp; &nbsp; dlist_delete(&amp;ct-&gt;cache_elem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Free keys when we're dealing with a negative entry, normal entries just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * point into tuple, allocated together with the CatCTup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ct-&gt;negative)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2155" title="utils/cache/catcache.c:2155">CatCacheFreeKeys</a>(cache-&gt;cc_tupdesc, cache-&gt;cc_nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_keyno, ct-&gt;keys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ct);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; --cache-&gt;cc_ntup;<br/></li>
<li>&nbsp; &nbsp; --<a href="#L64" title="utils/cache/catcache.c:64">CacheHdr</a>-&gt;ch_ntup;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L551" title="utils/cache/catcache.c:551">CatCacheRemoveCList</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlink and delete the given cache list entry<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> dead member entries that become unreferenced are deleted too.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L551">&#x200c;</a></span><span class="linkable">CatCacheRemoveCList</span>(CatCache *cache, CatCList *cl)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(cl-&gt;refcount == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(cl-&gt;my_cache == cache);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* delink from member tuples */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = cl-&gt;n_members; --i &gt;= <span class="Constant">0</span>;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CatCTup&nbsp; &nbsp; *ct = cl-&gt;members[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ct-&gt;c_list == cl);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ct-&gt;c_list = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if the member is dead and <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> has no references, remove it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<br/></li>
<li><span class="PreProc">#ifndef CATCACHE_FORCE_RELEASE<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ct-&gt;dead &amp;&amp;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ct-&gt;refcount == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L509" title="utils/cache/catcache.c:509">CatCacheRemoveCTup</a>(cache, ct);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* delink from linked list */<br/></li>
<li></span>&nbsp; &nbsp; dlist_delete(&amp;cl-&gt;cache_elem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* free associated column data */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2155" title="utils/cache/catcache.c:2155">CatCacheFreeKeys</a>(cache-&gt;cc_tupdesc, cl-&gt;nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_keyno, cl-&gt;keys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(cl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; --cache-&gt;cc_nlist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L606" title="utils/cache/catcache.c:606">CatCacheInvalidate</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Invalidate entries in the specified cache, given a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; We delete cache entries that match the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value, whether positive<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; or negative.&nbsp; We don't care whether the invalidation is the result<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; of a tuple insertion or a deletion.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; We used to try to match positive cache entries by TID, but that is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; unsafe after a VACUUM FULL on a system catalog: an inval event could<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; be queued <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> VACUUM FULL, and then processed afterwards, when the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; target tuple that has to be invalidated has a different TID than it<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; did when the event was created.&nbsp; So <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we just <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> the small risk of unnecessary invalidations due to false matches.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This routine is only quasi-public: it should only be used by inval.c.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L606">&#x200c;</a></span><span class="linkable">CatCacheInvalidate</span>(CatCache *cache, uint32 hashValue)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; hashIndex;<br/></li>
<li>&nbsp; &nbsp; dlist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L58" title="utils/cache/catcache.c:58">CACHE_elog</a>(DEBUG2, <span class="Constant">&quot;<a href="#L606" title="utils/cache/catcache.c:606">CatCacheInvalidate</a>: called&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't bother to check whether the cache has finished initialization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * yet; if not, there will be no entries in it so no problem.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Invalidate *all* CatCLists in this cache; it's too hard to tell which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * searches might still be correct, so just zap 'em all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; cache-&gt;cc_nlbuckets; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_head *bucket = &amp;cache-&gt;cc_lbucket[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach_modify(iter, bucket)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CatCList&nbsp;&nbsp; *cl = dlist_container(CatCList, cache_elem, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cl-&gt;refcount &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cl-&gt;dead = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L551" title="utils/cache/catcache.c:551">CatCacheRemoveCList</a>(cache, cl);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inspect the proper <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> bucket for tuple matches<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hashIndex = <a href="#L50" title="utils/cache/catcache.c:50">HASH_INDEX</a>(hashValue, cache-&gt;cc_nbuckets);<br/></li>
<li>&nbsp; &nbsp; dlist_foreach_modify(iter, &amp;cache-&gt;cc_bucket[hashIndex])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CatCTup&nbsp; &nbsp; *ct = dlist_container(CatCTup, cache_elem, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hashValue == ct-&gt;hash_value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ct-&gt;refcount &gt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ct-&gt;c_list &amp;&amp; ct-&gt;c_list-&gt;refcount &gt; <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ct-&gt;dead = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* list, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, was marked dead above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ct-&gt;c_list == <span class="Constant">NULL</span> || ct-&gt;c_list-&gt;dead);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L509" title="utils/cache/catcache.c:509">CatCacheRemoveCTup</a>(cache, ct);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L58" title="utils/cache/catcache.c:58">CACHE_elog</a>(DEBUG2, <span class="Constant">&quot;<a href="#L606" title="utils/cache/catcache.c:606">CatCacheInvalidate</a>: invalidated&quot;</span>);<br/></li>
<li><span class="PreProc">#ifdef CATCACHE_STATS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;cc_invals++;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* could be multiple matches, so keep looking! */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; public <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Standard routine for creating cache context if it doesn't exist yet<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There are a lot of places (probably far more than necessary) that check<br/></li>
<li></span><span class="Comment"> * whether <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a> exists yet and want to create it if not.<br/></li>
<li></span><span class="Comment"> * We centralize knowledge of exactly how to create it here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L679">&#x200c;</a></span><span class="linkable">CreateCacheMemoryContext</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Purely for paranoia, check that context doesn't exist; caller probably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * did so already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a> = AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L701" title="utils/cache/catcache.c:701">ResetCatalogCache</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Reset one catalog cache to empty.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is not very efficient if the target cache is nearly empty.<br/></li>
<li></span><span class="Comment"> * However, it shouldn't need to be efficient; we don't invoke it often.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L701">&#x200c;</a></span><span class="linkable">ResetCatalogCache</span>(CatCache *cache)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_mutable_iter iter;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove each list in this cache, or at least mark it dead */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; cache-&gt;cc_nlbuckets; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_head *bucket = &amp;cache-&gt;cc_lbucket[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach_modify(iter, bucket)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CatCList&nbsp;&nbsp; *cl = dlist_container(CatCList, cache_elem, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cl-&gt;refcount &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cl-&gt;dead = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L551" title="utils/cache/catcache.c:551">CatCacheRemoveCList</a>(cache, cl);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove each tuple in this cache, or at least mark it dead */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; cache-&gt;cc_nbuckets; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_head *bucket = &amp;cache-&gt;cc_bucket[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach_modify(iter, bucket)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CatCTup&nbsp; &nbsp; *ct = dlist_container(CatCTup, cache_elem, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ct-&gt;refcount &gt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ct-&gt;c_list &amp;&amp; ct-&gt;c_list-&gt;refcount &gt; <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ct-&gt;dead = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* list, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, was marked dead above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ct-&gt;c_list == <span class="Constant">NULL</span> || ct-&gt;c_list-&gt;dead);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L509" title="utils/cache/catcache.c:509">CatCacheRemoveCTup</a>(cache, ct);<br/></li>
<li><span class="PreProc">#ifdef CATCACHE_STATS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;cc_invals++;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L753" title="utils/cache/catcache.c:753">ResetCatalogCaches</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Reset all caches when a shared cache inval event forces it<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L753">&#x200c;</a></span><span class="linkable">ResetCatalogCaches</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; slist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L58" title="utils/cache/catcache.c:58">CACHE_elog</a>(DEBUG2, <span class="Constant">&quot;<a href="#L753" title="utils/cache/catcache.c:753">ResetCatalogCaches</a> called&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slist_foreach(iter, &amp;<a href="#L64" title="utils/cache/catcache.c:64">CacheHdr</a>-&gt;ch_caches)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CatCache&nbsp;&nbsp; *cache = slist_container(CatCache, cc_next, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L701" title="utils/cache/catcache.c:701">ResetCatalogCache</a>(cache);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L58" title="utils/cache/catcache.c:58">CACHE_elog</a>(DEBUG2, <span class="Constant">&quot;end of <a href="#L753" title="utils/cache/catcache.c:753">ResetCatalogCaches</a> call&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L783" title="utils/cache/catcache.c:783">CatalogCacheFlushCatalog</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Flush all catcache entries that came from the specified system catalog.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This is needed after VACUUM FULL/CLUSTER on the catalog, since the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; tuples very likely <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have different TIDs than <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>.&nbsp; (At one point<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; we also tried to force re-execution of <a href="#L1035" title="utils/cache/catcache.c:1035">CatalogCacheInitializeCache</a> for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the cache(s) on that catalog.&nbsp; This is a bad idea since it leads to all<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; kinds of trouble if a cache flush occurs while loading cache entries.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; We <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> avoid the need to do it by copying cc_tupdesc out of the relcache,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rather than relying on the relcache to keep a tupdesc for us.&nbsp; Of course<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; this assumes the tupdesc of a cachable system table will not change...)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L783">&#x200c;</a></span><span class="linkable">CatalogCacheFlushCatalog</span>(Oid catId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; slist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L58" title="utils/cache/catcache.c:58">CACHE_elog</a>(DEBUG2, <span class="Constant">&quot;<a href="#L783" title="utils/cache/catcache.c:783">CatalogCacheFlushCatalog</a> called for </span><span class="Special">%u</span><span class="Constant">&quot;</span>, catId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slist_foreach(iter, &amp;<a href="#L64" title="utils/cache/catcache.c:64">CacheHdr</a>-&gt;ch_caches)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CatCache&nbsp;&nbsp; *cache = slist_container(CatCache, cc_next, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Does this cache store tuples of the target catalog? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cache-&gt;cc_reloid == catId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Yes, so flush all its contents */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L701" title="utils/cache/catcache.c:701">ResetCatalogCache</a>(cache);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Tell inval.c to call syscache callbacks for this cache */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="inval.c.html#L1577" title="utils/cache/inval.c:1577">CallSyscacheCallbacks</a>(cache-&gt;id, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L58" title="utils/cache/catcache.c:58">CACHE_elog</a>(DEBUG2, <span class="Constant">&quot;end of <a href="#L783" title="utils/cache/catcache.c:783">CatalogCacheFlushCatalog</a> call&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L827" title="utils/cache/catcache.c:827">InitCatCache</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This allocates and initializes a cache for a system catalog relation.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Actually, the cache is only partially initialized to avoid opening the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; relation.&nbsp; The relation will be opened and the rest of the cache<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; structure initialized on the first access.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef CACHEDEBUG<br/></li>
<li><a id="L816">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">InitCatCache_DEBUG2</span> \<br/></li>
<li></span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; elog(DEBUG2, </span><span class="Constant">&quot;<a href="#L827" title="utils/cache/catcache.c:827">InitCatCache</a>: rel=</span><span class="Special">%u</span><span class="Constant"> ind=</span><span class="Special">%u</span><span class="Constant"> id=</span><span class="Special">%d</span><span class="Constant"> nkeys=</span><span class="Special">%d</span><span class="Constant"> size=</span><span class="Special">%d</span><span class="Constant">&quot;</span><span class="PreProc">, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cp-&gt;cc_reloid, cp-&gt;cc_indexoid, cp-&gt;id, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cp-&gt;cc_nkeys, cp-&gt;cc_nbuckets); \<br/></li>
<li></span><span class="PreProc">} </span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li><a id="L823">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">InitCatCache_DEBUG2</span><br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>CatCache *<br/></li>
<li><a id="L827">&#x200c;</a><span class="linkable">InitCatCache</span>(<span class="Type">int</span> id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid reloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid indexoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">int</span> *key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nbuckets)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CatCache&nbsp;&nbsp; *cp;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nbuckets is the initial number of <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> buckets to use in this catcache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It will be enlarged later if it becomes too full.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nbuckets must be a power of two.&nbsp; We check this via Assert rather than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a full runtime check because the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> will be coming from constant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If you're confused by the power-of-two check, see comments in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bitmapset.c for an explanation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(nbuckets &gt; <span class="Constant">0</span> &amp;&amp; (nbuckets &amp; -nbuckets) == nbuckets);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first switch to the cache context so our allocations do not vanish at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the end of a transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L679" title="utils/cache/catcache.c:679">CreateCacheMemoryContext</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if first time through, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the cache group header<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L64" title="utils/cache/catcache.c:64">CacheHdr</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L64" title="utils/cache/catcache.c:64">CacheHdr</a> = (CatCacheHeader *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CatCacheHeader));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slist_init(&amp;<a href="#L64" title="utils/cache/catcache.c:64">CacheHdr</a>-&gt;ch_caches);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L64" title="utils/cache/catcache.c:64">CacheHdr</a>-&gt;ch_ntup = <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#ifdef CATCACHE_STATS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set up to <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> stats at backend exit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a>(<a href="#L441" title="utils/cache/catcache.c:441">CatCachePrintStats</a>, <span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate a new cache structure, aligning to a cacheline boundary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we rely on zeroing to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> all the dlist headers correctly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cp = (CatCache *) <a href="../mmgr/mcxt.c.html#L1510" title="utils/mmgr/mcxt.c:1510">palloc_aligned</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CatCache), PG_CACHE_LINE_SIZE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MCXT_ALLOC_ZERO);<br/></li>
<li>&nbsp; &nbsp; cp-&gt;cc_bucket = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(nbuckets * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(dlist_head));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Many catcaches never receive <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> list searches.&nbsp; Therefore, we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocate the cc_lbuckets till we get a list search.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cp-&gt;cc_lbucket = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the cache's relation information for the relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corresponding to this cache, and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> some of the new cache's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> fields.&nbsp; But don't open the relation yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cp-&gt;id = id;<br/></li>
<li>&nbsp; &nbsp; cp-&gt;cc_relname = <span class="Constant">&quot;(not known yet)&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; cp-&gt;cc_reloid = reloid;<br/></li>
<li>&nbsp; &nbsp; cp-&gt;cc_indexoid = indexoid;<br/></li>
<li>&nbsp; &nbsp; cp-&gt;cc_relisshared = <span class="Constant">false</span>; <span class="Comment">/* temporary */<br/></li>
<li></span>&nbsp; &nbsp; cp-&gt;cc_tupdesc = (TupleDesc) <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; cp-&gt;cc_ntup = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; cp-&gt;cc_nlist = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; cp-&gt;cc_nbuckets = nbuckets;<br/></li>
<li>&nbsp; &nbsp; cp-&gt;cc_nlbuckets = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; cp-&gt;cc_nkeys = nkeys;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nkeys; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(AttributeNumberIsValid(key[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cp-&gt;cc_keyno[i] = key[i];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new cache is initialized as far as we can go for <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * debugging information, if appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L816" title="utils/cache/catcache.c:816">InitCatCache_DEBUG2</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * add completed cache to top of group header's list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; slist_push_head(&amp;<a href="#L64" title="utils/cache/catcache.c:64">CacheHdr</a>-&gt;ch_caches, &amp;cp-&gt;cc_next);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * back to the old context <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we return...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cp;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Enlarge a catcache, doubling the number of buckets.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L934">&#x200c;</a></span><span class="linkable">RehashCatCache</span>(CatCache *cp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_head *newbucket;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newnbuckets;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;rehashing catalog cache id </span><span class="Special">%d</span><span class="Constant"> for </span><span class="Special">%s</span><span class="Constant">; </span><span class="Special">%d</span><span class="Constant"> tups, </span><span class="Special">%d</span><span class="Constant"> buckets&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cp-&gt;id, cp-&gt;cc_relname, cp-&gt;cc_ntup, cp-&gt;cc_nbuckets);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate a new, larger, <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table. */<br/></li>
<li></span>&nbsp; &nbsp; newnbuckets = cp-&gt;cc_nbuckets * <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; newbucket = (dlist_head *) <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>, newnbuckets * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(dlist_head));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Move all entries from old <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table to new. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; cp-&gt;cc_nbuckets; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach_modify(iter, &amp;cp-&gt;cc_bucket[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CatCTup&nbsp; &nbsp; *ct = dlist_container(CatCTup, cache_elem, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashIndex = <a href="#L50" title="utils/cache/catcache.c:50">HASH_INDEX</a>(ct-&gt;hash_value, newnbuckets);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_push_head(&amp;newbucket[hashIndex], &amp;ct-&gt;cache_elem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Switch to the new array. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(cp-&gt;cc_bucket);<br/></li>
<li>&nbsp; &nbsp; cp-&gt;cc_nbuckets = newnbuckets;<br/></li>
<li>&nbsp; &nbsp; cp-&gt;cc_bucket = newbucket;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Enlarge a catcache's list storage, doubling the number of buckets.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L972">&#x200c;</a></span><span class="linkable">RehashCatCacheLists</span>(CatCache *cp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_head *newbucket;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newnbuckets;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;rehashing catalog cache id </span><span class="Special">%d</span><span class="Constant"> for </span><span class="Special">%s</span><span class="Constant">; </span><span class="Special">%d</span><span class="Constant"> lists, </span><span class="Special">%d</span><span class="Constant"> buckets&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cp-&gt;id, cp-&gt;cc_relname, cp-&gt;cc_nlist, cp-&gt;cc_nlbuckets);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate a new, larger, <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table. */<br/></li>
<li></span>&nbsp; &nbsp; newnbuckets = cp-&gt;cc_nlbuckets * <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; newbucket = (dlist_head *) <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>, newnbuckets * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(dlist_head));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Move all entries from old <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table to new. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; cp-&gt;cc_nlbuckets; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach_modify(iter, &amp;cp-&gt;cc_lbucket[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CatCList&nbsp;&nbsp; *cl = dlist_container(CatCList, cache_elem, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashIndex = <a href="#L50" title="utils/cache/catcache.c:50">HASH_INDEX</a>(cl-&gt;hash_value, newnbuckets);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_push_head(&amp;newbucket[hashIndex], &amp;cl-&gt;cache_elem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Switch to the new array. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(cp-&gt;cc_lbucket);<br/></li>
<li>&nbsp; &nbsp; cp-&gt;cc_nlbuckets = newnbuckets;<br/></li>
<li>&nbsp; &nbsp; cp-&gt;cc_lbucket = newbucket;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1035" title="utils/cache/catcache.c:1035">CatalogCacheInitializeCache</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function does final initialization of a catcache: obtain the tuple<br/></li>
<li></span><span class="Comment"> * descriptor and set up the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> and equality function links.&nbsp; We assume<br/></li>
<li></span><span class="Comment"> * that the relcache entry can be opened at this point!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef CACHEDEBUG<br/></li>
<li><a id="L1014">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CatalogCacheInitializeCache_DEBUG1</span> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; elog(DEBUG2, </span><span class="Constant">&quot;<a href="#L1035" title="utils/cache/catcache.c:1035">CatalogCacheInitializeCache</a>: cache @</span><span class="Special">%p</span><span class="Constant"> rel=</span><span class="Special">%u</span><span class="Constant">&quot;</span><span class="PreProc">, cache, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_reloid)<br/></li>
<li></span><br/></li>
<li><a id="L1018">&#x200c;</a><span class="PreProc">#define <span class="linkable">CatalogCacheInitializeCache_DEBUG2</span> \<br/></li>
<li></span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (cache-&gt;cc_keyno[i] &gt; </span><span class="Constant">0</span><span class="PreProc">) { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, </span><span class="Constant">&quot;<a href="#L1035" title="utils/cache/catcache.c:1035">CatalogCacheInitializeCache</a>: load </span><span class="Special">%d</span><span class="Constant">/</span><span class="Special">%d</span><span class="Constant"> w/</span><span class="Special">%d</span><span class="Constant">, </span><span class="Special">%u</span><span class="Constant">&quot;</span><span class="PreProc">, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i+</span><span class="Constant">1</span><span class="PreProc">, cache-&gt;cc_nkeys, cache-&gt;cc_keyno[i], \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleDescAttr(tupdesc, cache-&gt;cc_keyno[i] - </span><span class="Constant">1</span><span class="PreProc">)-&gt;atttypid); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; } </span><span class="Statement">else</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, </span><span class="Constant">&quot;<a href="#L1035" title="utils/cache/catcache.c:1035">CatalogCacheInitializeCache</a>: load </span><span class="Special">%d</span><span class="Constant">/</span><span class="Special">%d</span><span class="Constant"> w/</span><span class="Special">%d</span><span class="Constant">&quot;</span><span class="PreProc">, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i+</span><span class="Constant">1</span><span class="PreProc">, cache-&gt;cc_nkeys, cache-&gt;cc_keyno[i]); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; } \<br/></li>
<li></span><span class="PreProc">} </span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li><a id="L1030">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CatalogCacheInitializeCache_DEBUG1</span><br/></li>
<li><a id="L1031">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CatalogCacheInitializeCache_DEBUG2</span><br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1035">&#x200c;</a></span><span class="linkable">CatalogCacheInitializeCache</span>(CatCache *cache)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; relation;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1014" title="utils/cache/catcache.c:1014">CatalogCacheInitializeCache_DEBUG1</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relation = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(cache-&gt;cc_reloid, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * switch to the cache context so our allocations do not vanish at the end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of a transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copy the relcache's tuple descriptor to permanent cache storage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tupdesc = <a href="../../access/common/tupdesc.c.html#L173" title="access/common/tupdesc.c:173">CreateTupleDescCopyConstr</a>(RelationGetDescr(relation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * save the relation's name and relisshared flag, too (cc_relname is used<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only for debugging purposes)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cache-&gt;cc_relname = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(RelationGetRelationName(relation));<br/></li>
<li>&nbsp; &nbsp; cache-&gt;cc_relisshared = RelationGetForm(relation)-&gt;relisshared;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * return to the caller's memory context and close the rel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(relation, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L58" title="utils/cache/catcache.c:58">CACHE_elog</a>(DEBUG2, <span class="Constant">&quot;<a href="#L1035" title="utils/cache/catcache.c:1035">CatalogCacheInitializeCache</a>: </span><span class="Special">%s</span><span class="Constant">, </span><span class="Special">%d</span><span class="Constant"> keys&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_relname, cache-&gt;cc_nkeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> cache's key information<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; cache-&gt;cc_nkeys; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keytype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RegProcedure eqfunc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1018" title="utils/cache/catcache.c:1018">CatalogCacheInitializeCache_DEBUG2</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cache-&gt;cc_keyno[i] &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr = TupleDescAttr(tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_keyno[i] - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keytype = attr-&gt;atttypid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cache key columns should always be NOT NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(attr-&gt;attnotnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cache-&gt;cc_keyno[i] &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;sys attributes are not supported in caches&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keytype = OIDOID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L255" title="utils/cache/catcache.c:255">GetCCHashEqFuncs</a>(keytype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;cache-&gt;cc_hashfunc[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;eqfunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;cache-&gt;cc_fastequal[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do equality-function lookup (we assume this won't need a catalog<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lookup for <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> supported type)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(eqfunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;cache-&gt;cc_skey[i].sk_func,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize sk_attno suitably for HeapKeyTest() and heap scans */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;cc_skey[i].sk_attno = cache-&gt;cc_keyno[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fill in sk_strategy as well --- always standard equality */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;cc_skey[i].sk_strategy = BTEqualStrategyNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;cc_skey[i].sk_subtype = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If a catcache key requires a collation, it must be C collation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;cc_skey[i].sk_collation = C_COLLATION_OID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L58" title="utils/cache/catcache.c:58">CACHE_elog</a>(DEBUG2, <span class="Constant">&quot;<a href="#L1035" title="utils/cache/catcache.c:1035">CatalogCacheInitializeCache</a> </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant"> </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_relname, i, cache);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mark this cache fully initialized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cache-&gt;cc_tupdesc = tupdesc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1144" title="utils/cache/catcache.c:1144">InitCatCachePhase2</a> -- external interface for <a href="#L1035" title="utils/cache/catcache.c:1035">CatalogCacheInitializeCache</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * One reason to call this routine is to ensure that the relcache has<br/></li>
<li></span><span class="Comment"> * created entries for all the catalogs and indexes referenced by catcaches.<br/></li>
<li></span><span class="Comment"> * Therefore, provide an option to open the index as well as fixing the<br/></li>
<li></span><span class="Comment"> * cache itself.&nbsp; An exception is the indexes on pg_am, which we don't use<br/></li>
<li></span><span class="Comment"> * (cf. <a href="#L1196" title="utils/cache/catcache.c:1196">IndexScanOK</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1144">&#x200c;</a></span><span class="linkable">InitCatCachePhase2</span>(CatCache *cache, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> touch_index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cache-&gt;cc_tupdesc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1035" title="utils/cache/catcache.c:1035">CatalogCacheInitializeCache</a>(cache);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (touch_index &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;id != AMOID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;id != AMNAME)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; idesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must lock the underlying catalog <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> opening the index to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * avoid deadlock, since <a href="../../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a> could possibly result in reading<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this same catalog, and if anyone else is exclusive-locking this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * catalog and index they'll be doing it in that order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a>(cache-&gt;cc_reloid, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idesc = <a href="../../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(cache-&gt;cc_indexoid, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * While we've got the index open, let's check that it's unique (and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not just deferrable-unique, thank you very much).&nbsp; This is just to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * catch thinkos in definitions of new catcaches, so we don't worry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about the pg_am indexes not getting tested.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(idesc-&gt;rd_index-&gt;indisunique &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idesc-&gt;rd_index-&gt;indimmediate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(idesc, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L227" title="storage/lmgr/lmgr.c:227">UnlockRelationOid</a>(cache-&gt;cc_reloid, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1196" title="utils/cache/catcache.c:1196">IndexScanOK</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This function checks for tuples that will be fetched by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="relcache.c.html#L1596" title="utils/cache/relcache.c:1596">IndexSupportInitialize</a>() during relcache initialization for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; certain system indexes that support critical syscaches.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We can't use an indexscan to fetch these, else we'll get into<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; infinite recursion.&nbsp; A plain heap scan will work, however.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Once we have completed relcache initialization (signaled by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="relcache.c.html#L140" title="utils/cache/relcache.c:140">criticalRelcachesBuilt</a>), we don't have to worry anymore.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Similarly, during backend startup we have to be able to use the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pg_authid, pg_auth_members and pg_database syscaches for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; authentication even if we don't yet have relcache entries for those<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; catalogs' indexes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1196">&#x200c;</a></span><span class="linkable">IndexScanOK</span>(CatCache *cache, ScanKey cur_skey)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (cache-&gt;id)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INDEXRELID:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Rather than tracking exactly which indexes have to be loaded<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can use indexscans (which changes from time to time),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just force all pg_index searches to be heap scans until we've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * built the critical relcaches.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="relcache.c.html#L140" title="utils/cache/relcache.c:140">criticalRelcachesBuilt</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AMOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AMNAME:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Always do heap scans in pg_am, because it's so small there's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not much point in an indexscan anyway.&nbsp; We *must* do this when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * initially building critical relcache entries, but we might as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * well just always do it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AUTHNAME:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AUTHOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AUTHMEMMEMROLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DATABASEOID:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Protect authentication lookups occurring <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> relcache has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * collected entries for shared indexes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="relcache.c.html#L146" title="utils/cache/relcache.c:146">criticalSharedRelcachesBuilt</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Normal case, allow index scan */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1261" title="utils/cache/catcache.c:1261">SearchCatCache</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This call searches a system cache for a tuple, opening the relation<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; if necessary (on the first access to a particular cache).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The result is NULL if not found, or a pointer to a HeapTuple in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the cache.&nbsp; The caller must not modify the tuple, and must call<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1573" title="utils/cache/catcache.c:1573">ReleaseCatCache</a>() when done with it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The search key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> should be expressed as Datums of the key columns'<br/></li>
<li></span><span class="Comment"> * datatype(s).&nbsp; (Pass zeroes for <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unused parameters.)&nbsp; As a special<br/></li>
<li></span><span class="Comment"> * exception, the passed-in key for a NAME column can be just a C string;<br/></li>
<li></span><span class="Comment"> * the caller need not go to the trouble of converting it to a fully<br/></li>
<li></span><span class="Comment"> * null-padded NAME.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>HeapTuple<br/></li>
<li><a id="L1261">&#x200c;</a><span class="linkable">SearchCatCache</span>(CatCache *cache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum v1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum v2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum v3,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum v4)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1312" title="utils/cache/catcache.c:1312">SearchCatCacheInternal</a>(cache, cache-&gt;cc_nkeys, v1, v2, v3, v4);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SearchCatCacheN() are <a href="#L1261" title="utils/cache/catcache.c:1261">SearchCatCache</a>() versions for a specific number of<br/></li>
<li></span><span class="Comment"> * arguments. The compiler can inline the body and unroll loops, making them a<br/></li>
<li></span><span class="Comment"> * <a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> faster than <a href="#L1261" title="utils/cache/catcache.c:1261">SearchCatCache</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>HeapTuple<br/></li>
<li><a id="L1278">&#x200c;</a><span class="linkable">SearchCatCache1</span>(CatCache *cache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum v1)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1312" title="utils/cache/catcache.c:1312">SearchCatCacheInternal</a>(cache, <span class="Constant">1</span>, v1, <span class="Constant">0</span>, <span class="Constant">0</span>, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>HeapTuple<br/></li>
<li><a id="L1286">&#x200c;</a><span class="linkable">SearchCatCache2</span>(CatCache *cache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum v1, Datum v2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1312" title="utils/cache/catcache.c:1312">SearchCatCacheInternal</a>(cache, <span class="Constant">2</span>, v1, v2, <span class="Constant">0</span>, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>HeapTuple<br/></li>
<li><a id="L1294">&#x200c;</a><span class="linkable">SearchCatCache3</span>(CatCache *cache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum v1, Datum v2, Datum v3)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1312" title="utils/cache/catcache.c:1312">SearchCatCacheInternal</a>(cache, <span class="Constant">3</span>, v1, v2, v3, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>HeapTuple<br/></li>
<li><a id="L1302">&#x200c;</a><span class="linkable">SearchCatCache4</span>(CatCache *cache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum v1, Datum v2, Datum v3, Datum v4)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1312" title="utils/cache/catcache.c:1312">SearchCatCacheInternal</a>(cache, <span class="Constant">4</span>, v1, v2, v3, v4);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Work-horse for <a href="#L1261" title="utils/cache/catcache.c:1261">SearchCatCache</a>/SearchCatCacheN.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> HeapTuple<br/></li>
<li><a id="L1312">&#x200c;</a><span class="linkable">SearchCatCacheInternal</span>(CatCache *cache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum v1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum v2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum v3,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum v4)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arguments[CATCACHE_MAXKEYS];<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hashValue;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; hashIndex;<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li>&nbsp; &nbsp; dlist_head *bucket;<br/></li>
<li>&nbsp; &nbsp; CatCTup&nbsp; &nbsp; *ct;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we're in an xact, even if this ends up being a cache hit */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(cache-&gt;cc_nkeys == nkeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one-time startup overhead for each cache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(cache-&gt;cc_tupdesc == <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1035" title="utils/cache/catcache.c:1035">CatalogCacheInitializeCache</a>(cache);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef CATCACHE_STATS<br/></li>
<li></span>&nbsp; &nbsp; cache-&gt;cc_searches++;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize local parameter array */<br/></li>
<li></span>&nbsp; &nbsp; arguments[<span class="Constant">0</span>] = v1;<br/></li>
<li>&nbsp; &nbsp; arguments[<span class="Constant">1</span>] = v2;<br/></li>
<li>&nbsp; &nbsp; arguments[<span class="Constant">2</span>] = v3;<br/></li>
<li>&nbsp; &nbsp; arguments[<span class="Constant">3</span>] = v4;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> bucket in which to look for the tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hashValue = <a href="#L325" title="utils/cache/catcache.c:325">CatalogCacheComputeHashValue</a>(cache, nkeys, v1, v2, v3, v4);<br/></li>
<li>&nbsp; &nbsp; hashIndex = <a href="#L50" title="utils/cache/catcache.c:50">HASH_INDEX</a>(hashValue, cache-&gt;cc_nbuckets);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> bucket until we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a match or exhaust our tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: it's okay to use dlist_foreach here, even though we modify the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dlist within the loop, because we don't continue the loop afterwards.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bucket = &amp;cache-&gt;cc_bucket[hashIndex];<br/></li>
<li>&nbsp; &nbsp; dlist_foreach(iter, bucket)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ct = dlist_container(CatCTup, cache_elem, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ct-&gt;dead)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore dead entries */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ct-&gt;hash_value != hashValue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* quickly <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> entry if wrong <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> val */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L422" title="utils/cache/catcache.c:422">CatalogCacheCompareTuple</a>(cache, nkeys, ct-&gt;keys, arguments))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We found a match in the cache.&nbsp; Move it to the front of the list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for its hashbucket, in order to speed subsequent searches.&nbsp; (The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * most frequently accessed elements in <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> hashbucket will tend to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * near the front of the hashbucket's list.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dlist_move_head(bucket, &amp;ct-&gt;cache_elem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's a positive entry, bump its refcount and return it. If it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * negative, we can report failure to the caller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ct-&gt;negative)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(<a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ct-&gt;refcount++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="utils/cache/catcache.c:140">ResourceOwnerRememberCatCacheRef</a>(<a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>, &amp;ct-&gt;tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L58" title="utils/cache/catcache.c:58">CACHE_elog</a>(DEBUG2, <span class="Constant">&quot;<a href="#L1261" title="utils/cache/catcache.c:1261">SearchCatCache</a>(</span><span class="Special">%s</span><span class="Constant">): found in bucket </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_relname, hashIndex);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef CATCACHE_STATS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;cc_hits++;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> &amp;ct-&gt;tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L58" title="utils/cache/catcache.c:58">CACHE_elog</a>(DEBUG2, <span class="Constant">&quot;<a href="#L1261" title="utils/cache/catcache.c:1261">SearchCatCache</a>(</span><span class="Special">%s</span><span class="Constant">): found neg entry in bucket </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_relname, hashIndex);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef CATCACHE_STATS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;cc_neg_hits++;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1424" title="utils/cache/catcache.c:1424">SearchCatCacheMiss</a>(cache, nkeys, hashValue, hashIndex, v1, v2, v3, v4);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Search the actual catalogs, rather than the cache.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is kept separate from <a href="#L1312" title="utils/cache/catcache.c:1312">SearchCatCacheInternal</a>() to keep the fast-path<br/></li>
<li></span><span class="Comment"> * as small as possible.&nbsp; To avoid that effort being undone by a helpful<br/></li>
<li></span><span class="Comment"> * compiler, try to explicitly forbid inlining.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> pg_noinline HeapTuple<br/></li>
<li><a id="L1424">&#x200c;</a><span class="linkable">SearchCatCacheMiss</span>(CatCache *cache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 hashValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Index hashIndex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum v1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum v2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum v3,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum v4)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ScanKeyData cur_skey[CATCACHE_MAXKEYS];<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; relation;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scandesc;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; ntp;<br/></li>
<li>&nbsp; &nbsp; CatCTup&nbsp; &nbsp; *ct;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; stale;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arguments[CATCACHE_MAXKEYS];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize local parameter array */<br/></li>
<li></span>&nbsp; &nbsp; arguments[<span class="Constant">0</span>] = v1;<br/></li>
<li>&nbsp; &nbsp; arguments[<span class="Constant">1</span>] = v2;<br/></li>
<li>&nbsp; &nbsp; arguments[<span class="Constant">2</span>] = v3;<br/></li>
<li>&nbsp; &nbsp; arguments[<span class="Constant">3</span>] = v4;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Tuple was not found in cache, so we have to try to retrieve it directly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the relation.&nbsp; If found, we will add it to the cache; if not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * found, we will add a negative cache entry instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: it is possible for recursive cache lookups to occur while reading<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the relation --- for example, due to shared-cache-inval messages being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processed during <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>().&nbsp; This is OK.&nbsp; It's even possible for one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of those lookups to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> and enter the very same tuple we are trying to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fetch here.&nbsp; If that happens, we will enter a second copy of the tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into the cache.&nbsp; The first copy will never be referenced again, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will eventually age out of the cache, so there's no functional problem.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This case is rare enough that it's not worth expending extra cycles to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * detect.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Another case, which we *must* handle, is that the tuple could become<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outdated during <a href="#L2026" title="utils/cache/catcache.c:2026">CatalogCacheCreateEntry</a>'s attempt to detoast it (since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="inval.c.html#L806" title="utils/cache/inval.c:806">AcceptInvalidationMessages</a> can run during TOAST table access).&nbsp; We do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not want to return already-stale catcache entries, so we loop around<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and do the table scan again if that happens.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relation = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(cache-&gt;cc_reloid, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ok, need to make a lookup in the relation, copy the scankey and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fill out <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> per-call fields.&nbsp; (We must re-do this when retrying,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because <a href="../../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a> scribbles on the scankey.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(cur_skey, cache-&gt;cc_skey, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKeyData) * nkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cur_skey[<span class="Constant">0</span>].sk_argument = v1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cur_skey[<span class="Constant">1</span>].sk_argument = v2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cur_skey[<span class="Constant">2</span>].sk_argument = v3;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cur_skey[<span class="Constant">3</span>].sk_argument = v4;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scandesc = <a href="../../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;cc_indexoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1196" title="utils/cache/catcache.c:1196">IndexScanOK</a>(cache, cur_skey),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_skey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ct = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stale = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(ntp = <a href="../../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scandesc)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ct = <a href="#L2026" title="utils/cache/catcache.c:2026">CatalogCacheCreateEntry</a>(cache, ntp, scandesc, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hashValue, hashIndex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* upon failure, we must start the scan over */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ct == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stale = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* immediately set the refcount to 1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(<a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ct-&gt;refcount++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="utils/cache/catcache.c:140">ResourceOwnerRememberCatCacheRef</a>(<a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>, &amp;ct-&gt;tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* assume only one match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scandesc);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (stale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(relation, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If tuple was not found, we need to build a negative cache entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * containing a fake tuple.&nbsp; The fake tuple has the correct key columns,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but nulls everywhere else.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In bootstrap mode, we don't build negative entries, because the cache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * invalidation mechanism isn't alive and can't clear them if the tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * gets created later.&nbsp; (Bootstrap doesn't do UPDATEs, so it doesn't need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cache inval for that.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ct == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ct = <a href="#L2026" title="utils/cache/catcache.c:2026">CatalogCacheCreateEntry</a>(cache, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, arguments,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hashValue, hashIndex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Creating a negative cache entry shouldn't fail */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ct != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L58" title="utils/cache/catcache.c:58">CACHE_elog</a>(DEBUG2, <span class="Constant">&quot;<a href="#L1261" title="utils/cache/catcache.c:1261">SearchCatCache</a>(</span><span class="Special">%s</span><span class="Constant">): Contains </span><span class="Special">%d</span><span class="Constant">/</span><span class="Special">%d</span><span class="Constant"> tuples&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_relname, cache-&gt;cc_ntup, <a href="#L64" title="utils/cache/catcache.c:64">CacheHdr</a>-&gt;ch_ntup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L58" title="utils/cache/catcache.c:58">CACHE_elog</a>(DEBUG2, <span class="Constant">&quot;<a href="#L1261" title="utils/cache/catcache.c:1261">SearchCatCache</a>(</span><span class="Special">%s</span><span class="Constant">): put neg entry in bucket </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_relname, hashIndex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are not returning the negative entry to the caller, so leave its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * refcount zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L58" title="utils/cache/catcache.c:58">CACHE_elog</a>(DEBUG2, <span class="Constant">&quot;<a href="#L1261" title="utils/cache/catcache.c:1261">SearchCatCache</a>(</span><span class="Special">%s</span><span class="Constant">): Contains </span><span class="Special">%d</span><span class="Constant">/</span><span class="Special">%d</span><span class="Constant"> tuples&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_relname, cache-&gt;cc_ntup, <a href="#L64" title="utils/cache/catcache.c:64">CacheHdr</a>-&gt;ch_ntup);<br/></li>
<li>&nbsp; &nbsp; <a href="#L58" title="utils/cache/catcache.c:58">CACHE_elog</a>(DEBUG2, <span class="Constant">&quot;<a href="#L1261" title="utils/cache/catcache.c:1261">SearchCatCache</a>(</span><span class="Special">%s</span><span class="Constant">): put in bucket </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_relname, hashIndex);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef CATCACHE_STATS<br/></li>
<li></span>&nbsp; &nbsp; cache-&gt;cc_newloads++;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> &amp;ct-&gt;tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1573" title="utils/cache/catcache.c:1573">ReleaseCatCache</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Decrement the reference count of a catcache entry (releasing the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; hold grabbed by a successful <a href="#L1261" title="utils/cache/catcache.c:1261">SearchCatCache</a>).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: if compiled with -DCATCACHE_FORCE_RELEASE then catcache entries<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; will be freed as soon as their refcount goes to zero.&nbsp; In combination<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; with aset.c's CLOBBER_FREED_MEMORY option, this provides a good test<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; to catch references to already-released catcache entries.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1573">&#x200c;</a></span><span class="linkable">ReleaseCatCache</span>(HeapTuple tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1579" title="utils/cache/catcache.c:1579">ReleaseCatCacheWithOwner</a>(tuple, <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1579">&#x200c;</a></span><span class="linkable">ReleaseCatCacheWithOwner</span>(HeapTuple tuple, ResourceOwner resowner)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CatCTup&nbsp; &nbsp; *ct = (CatCTup *) (((<span class="Type">char</span> *) tuple) -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offsetof(CatCTup, tuple));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Safety checks to ensure we were handed a cache entry */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ct-&gt;ct_magic == CT_MAGIC);<br/></li>
<li>&nbsp; &nbsp; Assert(ct-&gt;refcount &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ct-&gt;refcount--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (resowner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L145" title="utils/cache/catcache.c:145">ResourceOwnerForgetCatCacheRef</a>(<a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>, &amp;ct-&gt;tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<br/></li>
<li><span class="PreProc">#ifndef CATCACHE_FORCE_RELEASE<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ct-&gt;dead &amp;&amp;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ct-&gt;refcount == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (ct-&gt;c_list == <span class="Constant">NULL</span> || ct-&gt;c_list-&gt;refcount == <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L509" title="utils/cache/catcache.c:509">CatCacheRemoveCTup</a>(ct-&gt;my_cache, ct);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1612" title="utils/cache/catcache.c:1612">GetCatCacheHashValue</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Compute the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value for a given set of search keys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The reason for exposing this as part of the API is that the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value is<br/></li>
<li></span><span class="Comment"> * exposed in cache invalidation operations, so there are places outside the<br/></li>
<li></span><span class="Comment"> * catcache code that need to be able to compute the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint32<br/></li>
<li><a id="L1612">&#x200c;</a><span class="linkable">GetCatCacheHashValue</span>(CatCache *cache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum v1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum v2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum v3,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum v4)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one-time startup overhead for each cache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cache-&gt;cc_tupdesc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1035" title="utils/cache/catcache.c:1035">CatalogCacheInitializeCache</a>(cache);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calculate the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L325" title="utils/cache/catcache.c:325">CatalogCacheComputeHashValue</a>(cache, cache-&gt;cc_nkeys, v1, v2, v3, v4);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1646" title="utils/cache/catcache.c:1646">SearchCatCacheList</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Generate a list of all tuples matching a partial key (that is,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a key specifying just the first K of the cache's N key columns).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; It doesn't make <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sense to specify all of the cache's key columns<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; here: since the key is unique, there could be at most one match, so<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; you ought to use <a href="#L1261" title="utils/cache/catcache.c:1261">SearchCatCache</a>() instead.&nbsp; Hence this function takes<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; one fewer Datum argument than <a href="#L1261" title="utils/cache/catcache.c:1261">SearchCatCache</a>() does.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The caller must not modify the list object or the pointed-to tuples,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and must call <a href="#L1986" title="utils/cache/catcache.c:1986">ReleaseCatCacheList</a>() when done with the list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>CatCList *<br/></li>
<li><a id="L1646">&#x200c;</a><span class="linkable">SearchCatCacheList</span>(CatCache *cache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum v1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum v2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum v3)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; v4 = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dummy last-column value */<br/></li>
<li></span>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arguments[CATCACHE_MAXKEYS];<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; lHashValue;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; lHashIndex;<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li>&nbsp; &nbsp; dlist_head *lbucket;<br/></li>
<li>&nbsp; &nbsp; CatCList&nbsp;&nbsp; *cl;<br/></li>
<li>&nbsp; &nbsp; CatCTup&nbsp; &nbsp; *ct;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *<span class="Type">volatile</span> ctlist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *ctlist_item;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmembers;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ordered;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; ntp;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one-time startup overhead for each cache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(cache-&gt;cc_tupdesc == <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1035" title="utils/cache/catcache.c:1035">CatalogCacheInitializeCache</a>(cache);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(nkeys &gt; <span class="Constant">0</span> &amp;&amp; nkeys &lt; cache-&gt;cc_nkeys);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef CATCACHE_STATS<br/></li>
<li></span>&nbsp; &nbsp; cache-&gt;cc_lsearches++;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize local parameter array */<br/></li>
<li></span>&nbsp; &nbsp; arguments[<span class="Constant">0</span>] = v1;<br/></li>
<li>&nbsp; &nbsp; arguments[<span class="Constant">1</span>] = v2;<br/></li>
<li>&nbsp; &nbsp; arguments[<span class="Constant">2</span>] = v3;<br/></li>
<li>&nbsp; &nbsp; arguments[<span class="Constant">3</span>] = v4;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we haven't previously done a list search in this cache, create the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bucket header array; otherwise, consider whether it's time to enlarge<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cache-&gt;cc_lbucket == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Arbitrary initial size --- must be a power of 2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbuckets = <span class="Constant">16</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;cc_lbucket = (dlist_head *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nbuckets * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(dlist_head));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't set cc_nlbuckets if we get OOM allocating cc_lbucket */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;cc_nlbuckets = nbuckets;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table has become too full, enlarge the buckets array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Quite arbitrarily, we enlarge when fill factor &gt; 2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cache-&gt;cc_nlist &gt; cache-&gt;cc_nlbuckets * <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L972" title="utils/cache/catcache.c:972">RehashCatCacheLists</a>(cache);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> bucket in which to look for the CatCList.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lHashValue = <a href="#L325" title="utils/cache/catcache.c:325">CatalogCacheComputeHashValue</a>(cache, nkeys, v1, v2, v3, v4);<br/></li>
<li>&nbsp; &nbsp; lHashIndex = <a href="#L50" title="utils/cache/catcache.c:50">HASH_INDEX</a>(lHashValue, cache-&gt;cc_nlbuckets);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan the items until we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a match or exhaust our list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: it's okay to use dlist_foreach here, even though we modify the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dlist within the loop, because we don't continue the loop afterwards.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lbucket = &amp;cache-&gt;cc_lbucket[lHashIndex];<br/></li>
<li>&nbsp; &nbsp; dlist_foreach(iter, lbucket)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cl = dlist_container(CatCList, cache_elem, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cl-&gt;dead)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore dead entries */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cl-&gt;hash_value != lHashValue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* quickly <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> entry if wrong <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> val */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * see if the cached list matches our key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cl-&gt;nkeys != nkeys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L422" title="utils/cache/catcache.c:422">CatalogCacheCompareTuple</a>(cache, nkeys, cl-&gt;keys, arguments))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We found a matching list.&nbsp; Move the list to the front of the list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for its hashbucket, so as to speed subsequent searches.&nbsp; (We do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * move the members to the fronts of their hashbucket lists, however,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since there's no point in that unless they are searched for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * individually.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dlist_move_head(lbucket, &amp;cl-&gt;cache_elem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Bump the list's refcount and return it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(<a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cl-&gt;refcount++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L150" title="utils/cache/catcache.c:150">ResourceOwnerRememberCatCacheListRef</a>(<a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>, cl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L58" title="utils/cache/catcache.c:58">CACHE_elog</a>(DEBUG2, <span class="Constant">&quot;<a href="#L1646" title="utils/cache/catcache.c:1646">SearchCatCacheList</a>(</span><span class="Special">%s</span><span class="Constant">): found list&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_relname);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef CATCACHE_STATS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;cc_lhits++;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> cl;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * List was not found in cache, so we have to build it by reading the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation.&nbsp; For each matching tuple found in the relation, use an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * existing cache entry if possible, else build a new one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have to bump the member refcounts temporarily to ensure they won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get dropped from the cache while loading other members. We use a PG_TRY<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * block to ensure we can undo those refcounts if we get an error <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we finish constructing the CatCList.&nbsp; ctlist must be valid throughout<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the PG_TRY block.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ctlist = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKeyData cur_skey[CATCACHE_MAXKEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; relation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SysScanDesc scandesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; stale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(cache-&gt;cc_reloid, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ok, need to make a lookup in the relation, copy the scankey and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fill out <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> per-call fields.&nbsp; (We must re-do this when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * retrying, because <a href="../../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a> scribbles on the scankey.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(cur_skey, cache-&gt;cc_skey, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKeyData) * cache-&gt;cc_nkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_skey[<span class="Constant">0</span>].sk_argument = v1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_skey[<span class="Constant">1</span>].sk_argument = v2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_skey[<span class="Constant">2</span>].sk_argument = v3;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_skey[<span class="Constant">3</span>].sk_argument = v4;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scandesc = <a href="../../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;cc_indexoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1196" title="utils/cache/catcache.c:1196">IndexScanOK</a>(cache, cur_skey),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_skey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The list will be ordered iff we are doing an index scan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ordered = (scandesc-&gt;irel != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stale = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(ntp = <a href="../../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scandesc)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hashValue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; hashIndex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_head *bucket;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * See if there's an entry for this tuple already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ct = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashValue = <a href="#L367" title="utils/cache/catcache.c:367">CatalogCacheComputeTupleHashValue</a>(cache, cache-&gt;cc_nkeys, ntp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashIndex = <a href="#L50" title="utils/cache/catcache.c:50">HASH_INDEX</a>(hashValue, cache-&gt;cc_nbuckets);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bucket = &amp;cache-&gt;cc_bucket[hashIndex];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach(iter, bucket)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ct = dlist_container(CatCTup, cache_elem, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ct-&gt;dead || ct-&gt;negative)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; <span class="Comment">/* ignore dead and negative entries */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ct-&gt;hash_value != hashValue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; <span class="Comment">/* quickly <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> entry if wrong <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> val */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/page/itemptr.c.html#L35" title="storage/page/itemptr.c:35">ItemPointerEquals</a>(&amp;(ct-&gt;tuple.t_self), &amp;(ntp-&gt;t_self)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; <span class="Comment">/* not same tuple */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Found a match, but can't use it if it belongs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * another list already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ct-&gt;c_list)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* A-OK */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a usable entry, so make a new one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ct = <a href="#L2026" title="utils/cache/catcache.c:2026">CatalogCacheCreateEntry</a>(cache, ntp, scandesc, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hashValue, hashIndex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* upon failure, we must start the scan over */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ct == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Release refcounts on <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> items we already had.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dare not try to free them if they're <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unreferenced, since an error while doing that would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result in the PG_CATCH below doing extra refcount<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decrements.&nbsp; Besides, we'll likely re-adopt those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * items in the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> iteration, so it's not worth<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * complicating matters to try to get rid of them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(ctlist_item, ctlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ct = (CatCTup *) lfirst(ctlist_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ct-&gt;c_list == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ct-&gt;refcount &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ct-&gt;refcount--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset ctlist in preparation for new try */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctlist = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stale = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Careful here: add entry to ctlist, then bump its refcount */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This way leaves state correct if <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a> runs out of memory */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctlist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(ctlist, ct);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ct-&gt;refcount++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scandesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (stale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(relation, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure the resource owner has room to remember this entry. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(<a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now we can build the CatCList entry. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nmembers = list_length(ctlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cl = (CatCList *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(offsetof(CatCList, members) + nmembers * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CatCTup *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Extract key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2180" title="utils/cache/catcache.c:2180">CatCacheCopyKeys</a>(cache-&gt;cc_tupdesc, nkeys, cache-&gt;cc_keyno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; arguments, cl-&gt;keys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> past the last thing that could <a href="../adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> an elog <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have finished building the CatCList and remembering it in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * resource owner.&nbsp; So it's OK to fall out of the PG_TRY, and indeed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'd better do so <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we start marking the members as belonging<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(ctlist_item, ctlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ct = (CatCTup *) lfirst(ctlist_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ct-&gt;c_list == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ct-&gt;refcount &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ct-&gt;refcount--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<br/></li>
<li><span class="PreProc">#ifndef CATCACHE_FORCE_RELEASE<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ct-&gt;dead &amp;&amp;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ct-&gt;refcount == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ct-&gt;c_list == <span class="Constant">NULL</span> || ct-&gt;c_list-&gt;refcount == <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L509" title="utils/cache/catcache.c:509">CatCacheRemoveCTup</a>(cache, ct);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_TRY();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cl-&gt;cl_magic = CL_MAGIC;<br/></li>
<li>&nbsp; &nbsp; cl-&gt;my_cache = cache;<br/></li>
<li>&nbsp; &nbsp; cl-&gt;refcount = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for the moment */<br/></li>
<li></span>&nbsp; &nbsp; cl-&gt;dead = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; cl-&gt;ordered = ordered;<br/></li>
<li>&nbsp; &nbsp; cl-&gt;nkeys = nkeys;<br/></li>
<li>&nbsp; &nbsp; cl-&gt;hash_value = lHashValue;<br/></li>
<li>&nbsp; &nbsp; cl-&gt;n_members = nmembers;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(ctlist_item, ctlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cl-&gt;members[i++] = ct = (CatCTup *) lfirst(ctlist_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ct-&gt;c_list == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ct-&gt;c_list = cl;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* release the temporary refcount on the member */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ct-&gt;refcount &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ct-&gt;refcount--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mark list dead if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> members already dead */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ct-&gt;dead)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cl-&gt;dead = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(i == nmembers);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add the CatCList to the appropriate bucket, and count it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dlist_push_head(lbucket, &amp;cl-&gt;cache_elem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cache-&gt;cc_nlist++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finally, bump the list's refcount and return it */<br/></li>
<li></span>&nbsp; &nbsp; cl-&gt;refcount++;<br/></li>
<li>&nbsp; &nbsp; <a href="#L150" title="utils/cache/catcache.c:150">ResourceOwnerRememberCatCacheListRef</a>(<a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>, cl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L58" title="utils/cache/catcache.c:58">CACHE_elog</a>(DEBUG2, <span class="Constant">&quot;<a href="#L1646" title="utils/cache/catcache.c:1646">SearchCatCacheList</a>(</span><span class="Special">%s</span><span class="Constant">): made list of </span><span class="Special">%d</span><span class="Constant"> members&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_relname, nmembers);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cl;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1986" title="utils/cache/catcache.c:1986">ReleaseCatCacheList</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Decrement the reference count of a catcache list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1986">&#x200c;</a></span><span class="linkable">ReleaseCatCacheList</span>(CatCList *list)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1992" title="utils/cache/catcache.c:1992">ReleaseCatCacheListWithOwner</a>(list, <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1992">&#x200c;</a></span><span class="linkable">ReleaseCatCacheListWithOwner</span>(CatCList *list, ResourceOwner resowner)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Safety checks to ensure we were handed a cache entry */<br/></li>
<li></span>&nbsp; &nbsp; Assert(list-&gt;cl_magic == CL_MAGIC);<br/></li>
<li>&nbsp; &nbsp; Assert(list-&gt;refcount &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; list-&gt;refcount--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (resowner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L155" title="utils/cache/catcache.c:155">ResourceOwnerForgetCatCacheListRef</a>(<a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>, list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<br/></li>
<li><span class="PreProc">#ifndef CATCACHE_FORCE_RELEASE<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; list-&gt;dead &amp;&amp;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; list-&gt;refcount == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L551" title="utils/cache/catcache.c:551">CatCacheRemoveCList</a>(list-&gt;my_cache, list);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2026" title="utils/cache/catcache.c:2026">CatalogCacheCreateEntry</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Create a new CatCTup entry, copying the given HeapTuple and other<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; supplied data into it.&nbsp; The new entry initially has refcount 0.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To create a normal cache entry, ntp must be the HeapTuple just fetched<br/></li>
<li></span><span class="Comment"> * from scandesc, and &quot;arguments&quot; is not used.&nbsp; To create a negative cache<br/></li>
<li></span><span class="Comment"> * entry, pass NULL for ntp and scandesc; then &quot;arguments&quot; is the cache<br/></li>
<li></span><span class="Comment"> * keys to use.&nbsp; In either case, hashValue/hashIndex are the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * computed from the cache keys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns NULL if we attempt to detoast the tuple and observe that it<br/></li>
<li></span><span class="Comment"> * became stale.&nbsp; (This cannot happen for a negative entry.)&nbsp; Caller must<br/></li>
<li></span><span class="Comment"> * retry the tuple lookup in that case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> CatCTup *<br/></li>
<li><a id="L2026">&#x200c;</a><span class="linkable">CatalogCacheCreateEntry</span>(CatCache *cache, HeapTuple ntp, SysScanDesc scandesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *arguments,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 hashValue, Index hashIndex)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CatCTup&nbsp; &nbsp; *ct;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; dtp;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ntp)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The visibility recheck below essentially never fails during our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * regression tests, and there's no easy way to force it to fail for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * testing purposes.&nbsp; To ensure we have test coverage for the retry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * paths in our callers, make debug builds randomly fail about 0.1% of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the times through this code path, even when there's no toasted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_prng_uint32(&amp;pg_global_prng_state) &lt;= (PG_UINT32_MAX / <span class="Constant">1000</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there are <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> out-of-line toasted fields in the tuple, expand<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them in-line.&nbsp; This saves cycles during later use of the catcache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry, and also protects us against the possibility of the toast<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples being freed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we attempt to fetch them, in case of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * something using a slightly stale catcache entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleHasExternal(ntp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dtp = <a href="../../access/heap/heaptoast.c.html#L350" title="access/heap/heaptoast.c:350">toast_flatten_tuple</a>(ntp, cache-&gt;cc_tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The tuple could become stale while we are doing toast table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * access (since <a href="inval.c.html#L806" title="utils/cache/inval.c:806">AcceptInvalidationMessages</a> can run then), so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must recheck its visibility afterwards.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/index/genam.c.html#L562" title="access/index/genam.c:562">systable_recheck_tuple</a>(scandesc, ntp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(dtp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dtp = ntp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allocate memory for CatCTup and the cached tuple in one go */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ct = (CatCTup *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CatCTup) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MAXIMUM_ALIGNOF + dtp-&gt;t_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ct-&gt;tuple.t_len = dtp-&gt;t_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ct-&gt;tuple.t_self = dtp-&gt;t_self;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ct-&gt;tuple.t_tableOid = dtp-&gt;t_tableOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ct-&gt;tuple.t_data = (HeapTupleHeader)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN(((<span class="Type">char</span> *) ct) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CatCTup));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy tuple contents */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy((<span class="Type">char</span> *) ct-&gt;tuple.t_data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">const</span> <span class="Type">char</span> *) dtp-&gt;t_data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dtp-&gt;t_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dtp != ntp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(dtp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* extract keys - they'll point into the tuple if not by-value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; cache-&gt;cc_nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; atp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atp = heap_getattr(&amp;ct-&gt;tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_keyno[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cache-&gt;cc_tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ct-&gt;keys[i] = atp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set up keys for a negative cache entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ct = (CatCTup *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CatCTup));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Store keys - they'll point into separately allocated memory if not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by-value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2180" title="utils/cache/catcache.c:2180">CatCacheCopyKeys</a>(cache-&gt;cc_tupdesc, cache-&gt;cc_nkeys, cache-&gt;cc_keyno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; arguments, ct-&gt;keys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finish initializing the CatCTup header, and add it to the cache's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * linked list and counts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ct-&gt;ct_magic = CT_MAGIC;<br/></li>
<li>&nbsp; &nbsp; ct-&gt;my_cache = cache;<br/></li>
<li>&nbsp; &nbsp; ct-&gt;c_list = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ct-&gt;refcount = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for the moment */<br/></li>
<li></span>&nbsp; &nbsp; ct-&gt;dead = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ct-&gt;negative = (ntp == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; ct-&gt;hash_value = hashValue;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_push_head(&amp;cache-&gt;cc_bucket[hashIndex], &amp;ct-&gt;cache_elem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cache-&gt;cc_ntup++;<br/></li>
<li>&nbsp; &nbsp; <a href="#L64" title="utils/cache/catcache.c:64">CacheHdr</a>-&gt;ch_ntup++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table has become too full, enlarge the buckets array. Quite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arbitrarily, we enlarge when fill factor &gt; 2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cache-&gt;cc_ntup &gt; cache-&gt;cc_nbuckets * <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L934" title="utils/cache/catcache.c:934">RehashCatCache</a>(cache);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ct;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper routine that frees keys stored in the keys array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2155">&#x200c;</a></span><span class="linkable">CatCacheFreeKeys</span>(TupleDesc tupdesc, <span class="Type">int</span> nkeys, <span class="Type">int</span> *attnos, Datum *keys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = attnos[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* system attribute are not supported in caches */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(attnum &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att = TupleDescAttr(tupdesc, attnum - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!att-&gt;attbyval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(keys[i]));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper routine that copies the keys in the srckeys array into the dstkeys<br/></li>
<li></span><span class="Comment"> * one, guaranteeing that the datums are fully allocated in the current memory<br/></li>
<li></span><span class="Comment"> * context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2180">&#x200c;</a></span><span class="linkable">CatCacheCopyKeys</span>(TupleDesc tupdesc, <span class="Type">int</span> nkeys, <span class="Type">int</span> *attnos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *srckeys, Datum *dstkeys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: memory and lookup performance could possibly be improved by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * storing all keys in one allocation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = attnos[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(tupdesc, attnum - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; src = srckeys[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; NameData&nbsp; &nbsp; srcname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Must be careful in case the caller passed a C string where a NAME<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is wanted: convert the given argument to a correctly padded NAME.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise the memcpy() done by <a href="../adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>() could fall off the end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;atttypid == NAMEOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../adt/name.c.html#L233" title="utils/adt/name.c:233">namestrcpy</a>(&amp;srcname, DatumGetCString(src));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src = NameGetDatum(&amp;srcname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dstkeys[i] = <a href="../adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(src,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; att-&gt;attbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; att-&gt;attlen);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2250" title="utils/cache/catcache.c:2250">PrepareToInvalidateCacheTuple</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This is part of a rather subtle chain of events, so pay attention:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; When a tuple is inserted or deleted, it cannot be flushed from the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; catcaches immediately, for reasons explained at the top of cache/inval.c.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Instead we have to add entry(s) for the tuple to a list of pending tuple<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; invalidations that will be done at the end of the command or transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The lists of tuples that need to be flushed are kept by inval.c.&nbsp; This<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; routine is a helper routine for inval.c.&nbsp; Given a tuple belonging to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the specified relation, <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> all catcaches it could be in, compute the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; correct <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value for each such catcache, and call the specified<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; function to record the cache id and <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value in inval.c's lists.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="syscache.c.html#L577" title="utils/cache/syscache.c:577">SysCacheInvalidate</a> will be called later, if appropriate,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; using the recorded information.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; For an insert or delete, tuple is the target tuple and newtuple is NULL.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; For an update, we are called just once, with tuple being the old tuple<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; version and newtuple the new version.&nbsp; We should make two list entries<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; if the tuple's <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value changed, but only one if it didn't.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Note that it is irrelevant whether the given tuple is actually loaded<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; into the catcache at the moment.&nbsp; Even if it's not there <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, it might<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; be by the end of the command, or there might be a matching negative entry<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; to flush --- or other backends' caches might have such entries --- so<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; we have to make list entries to flush it later.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Also note that it's not an error if there are no catcaches for the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; specified relation.&nbsp; inval.c doesn't know exactly which rels have<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; catcaches --- it will call this routine for <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuple that's in a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; system relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2250">&#x200c;</a></span><span class="linkable">PrepareToInvalidateCacheTuple</span>(Relation relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple newtuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> (*function) (<span class="Type">int</span>, uint32, Oid))<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; slist_iter&nbsp; &nbsp; iter;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reloid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L58" title="utils/cache/catcache.c:58">CACHE_elog</a>(DEBUG2, <span class="Constant">&quot;<a href="#L2250" title="utils/cache/catcache.c:2250">PrepareToInvalidateCacheTuple</a>: called&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sanity checks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(RelationIsValid(relation));<br/></li>
<li>&nbsp; &nbsp; Assert(HeapTupleIsValid(tuple));<br/></li>
<li>&nbsp; &nbsp; Assert(PointerIsValid(function));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L64" title="utils/cache/catcache.c:64">CacheHdr</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; reloid = RelationGetRelid(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; for each cache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp;&nbsp; if the cache contains tuples from the specified relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; compute the tuple's <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value(s) in this cache,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; and call the passed function to register the information.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ----------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; slist_foreach(iter, &amp;<a href="#L64" title="utils/cache/catcache.c:64">CacheHdr</a>-&gt;ch_caches)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CatCache&nbsp;&nbsp; *ccp = slist_container(CatCache, cc_next, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hashvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dbid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ccp-&gt;cc_reloid != reloid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Just in case cache hasn't finished initialization yet... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ccp-&gt;cc_tupdesc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1035" title="utils/cache/catcache.c:1035">CatalogCacheInitializeCache</a>(ccp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashvalue = <a href="#L367" title="utils/cache/catcache.c:367">CatalogCacheComputeTupleHashValue</a>(ccp, ccp-&gt;cc_nkeys, tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dbid = ccp-&gt;cc_relisshared ? (Oid) <span class="Constant">0</span> : <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*function) (ccp-&gt;id, hashvalue, dbid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newtuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; newhashvalue;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newhashvalue = <a href="#L367" title="utils/cache/catcache.c:367">CatalogCacheComputeTupleHashValue</a>(ccp, ccp-&gt;cc_nkeys, newtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newhashvalue != hashvalue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*function) (ccp-&gt;id, newhashvalue, dbid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ResourceOwner callbacks */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2311">&#x200c;</a></span><span class="linkable">ResOwnerReleaseCatCache</span>(Datum res)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1579" title="utils/cache/catcache.c:1579">ReleaseCatCacheWithOwner</a>((HeapTuple) DatumGetPointer(res), <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L2317">&#x200c;</a><span class="linkable">ResOwnerPrintCatCache</span>(Datum res)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple = (HeapTuple) DatumGetPointer(res);<br/></li>
<li>&nbsp; &nbsp; CatCTup&nbsp; &nbsp; *ct = (CatCTup *) (((<span class="Type">char</span> *) tuple) -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offsetof(CatCTup, tuple));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Safety check to ensure we were handed a cache entry */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ct-&gt;ct_magic == CT_MAGIC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> psprintf(<span class="Constant">&quot;cache </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">), tuple </span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant"> has count </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ct-&gt;my_cache-&gt;cc_relname, ct-&gt;my_cache-&gt;id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerGetBlockNumber(&amp;(tuple-&gt;t_self)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerGetOffsetNumber(&amp;(tuple-&gt;t_self)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ct-&gt;refcount);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2334">&#x200c;</a></span><span class="linkable">ResOwnerReleaseCatCacheList</span>(Datum res)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1992" title="utils/cache/catcache.c:1992">ReleaseCatCacheListWithOwner</a>((CatCList *) DatumGetPointer(res), <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L2340">&#x200c;</a><span class="linkable">ResOwnerPrintCatCacheList</span>(Datum res)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CatCList&nbsp;&nbsp; *list = (CatCList *) DatumGetPointer(res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> psprintf(<span class="Constant">&quot;cache </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">), list </span><span class="Special">%p</span><span class="Constant"> has count </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list-&gt;my_cache-&gt;cc_relname, list-&gt;my_cache-&gt;id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list, list-&gt;refcount);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
