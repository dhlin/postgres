<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/cache/inval.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/cache/inval.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L171">InvalMessageArrays</a></li>
<li><a href="#L240">debug_discard_caches</a></li>
<li><a href="#L273">relcache_callback_count</a></li>
<li><a href="#L271">relcache_callback_list</a></li>
<li><a href="#L265">syscache_callback_count</a></li>
<li><a href="#L263">syscache_callback_links</a></li>
<li><a href="#L261">syscache_callback_list</a></li>
<li><a href="#L237">transInvalInfo</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L165">InvalMessageArray</a></li>
<li><a href="#L169">InvalMessageArray</a></li>
<li><a href="#L174">InvalidationMsgsGroup</a></li>
<li><a href="#L178">InvalidationMsgsGroup</a></li>
<li><a href="#L267">RELCACHECALLBACK</a></li>
<li><a href="#L255">SYSCACHECALLBACK</a></li>
<li><a href="#L219">TransInvalidationInfo</a></li>
<li><a href="#L235">TransInvalidationInfo</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L806">AcceptInvalidationMessages</a></li>
<li><a href="#L423">AddCatalogInvalidationMessage</a></li>
<li><a href="#L395">AddCatcacheInvalidationMessage</a></li>
<li><a href="#L290">AddInvalidationMessage</a></li>
<li><a href="#L441">AddRelcacheInvalidationMessage</a></li>
<li><a href="#L473">AddSnapshotInvalidationMessage</a></li>
<li><a href="#L330">AppendInvalidationMessageSubGroup</a></li>
<li><a href="#L500">AppendInvalidationMessages</a></li>
<li><a href="#L1082">AtEOSubXact_Inval</a></li>
<li><a href="#L1025">AtEOXact_Inval</a></li>
<li><a href="#L1336">CacheInvalidateCatalog</a></li>
<li><a href="#L1204">CacheInvalidateHeapTuple</a></li>
<li><a href="#L1360">CacheInvalidateRelcache</a></li>
<li><a href="#L1384">CacheInvalidateRelcacheAll</a></li>
<li><a href="#L1419">CacheInvalidateRelcacheByRelid</a></li>
<li><a href="#L1396">CacheInvalidateRelcacheByTuple</a></li>
<li><a href="#L1489">CacheInvalidateRelmap</a></li>
<li><a href="#L1459">CacheInvalidateSmgr</a></li>
<li><a href="#L1558">CacheRegisterRelcacheCallback</a></li>
<li><a href="#L1516">CacheRegisterSyscacheCallback</a></li>
<li><a href="#L1577">CallSyscacheCallbacks</a></li>
<li><a href="#L1170">CommandEndInvalidationMessages</a></li>
<li><a href="#L792">InvalidateSystemCaches</a></li>
<li><a href="#L674">InvalidateSystemCachesExtended</a></li>
<li><a href="#L705">LocalExecuteInvalidationMessage</a></li>
<li><a href="#L1604">LogLogicalInvalidations</a></li>
<li><a href="#L863">PostPrepare_Inval</a></li>
<li><a href="#L611">PrepareInvalidationState</a></li>
<li><a href="#L961">ProcessCommittedInvalidationMessages</a></li>
<li><a href="#L514">ProcessInvalidationMessages</a></li>
<li><a href="#L526">ProcessInvalidationMessagesMulti</a></li>
<li><a href="#L558">RegisterCatalogInvalidation</a></li>
<li><a href="#L544">RegisterCatcacheInvalidation</a></li>
<li><a href="#L570">RegisterRelcacheInvalidation</a></li>
<li><a href="#L600">RegisterSnapshotInvalidation</a></li>
<li><a href="#L882">xactGetCommittedInvalidationMessages</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L161">CatCacheMsgs</a></li>
<li><a href="#L253">MAX_RELCACHE_CALLBACKS</a></li>
<li><a href="#L252">MAX_SYSCACHE_CALLBACKS</a></li>
<li><a href="#L197">NumMessagesInGroup</a></li>
<li><a href="#L194">NumMessagesInSubGroup</a></li>
<li><a href="#L354">ProcessMessageSubGroup</a></li>
<li><a href="#L372">ProcessMessageSubGroupMulti</a></li>
<li><a href="#L162">RelCacheMsgs</a></li>
<li><a href="#L188">SetGroupToFollow</a></li>
<li><a href="#L181">SetSubGroupToFollow</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * inval.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; POSTGRES cache invalidation dispatcher code.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This is subtle stuff, so pay attention:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; When a tuple is updated or deleted, our standard visibility rules<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; consider that it is *still valid* so long as we are in the same command,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; ie, until the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>() or transaction commit.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (See access/heap/heapam_visibility.c, and note that system catalogs are<br/></li>
<li></span><span class="Comment"> *&nbsp; generally scanned under the most current snapshot available, rather than<br/></li>
<li></span><span class="Comment"> *&nbsp; the transaction snapshot.)&nbsp; &nbsp; At the command boundary, the old tuple stops<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; being valid and the new version, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, becomes valid.&nbsp; Therefore,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; we cannot simply flush a tuple from the system caches during <a href="../../access/heap/heapam.c.html#L3146" title="access/heap/heapam.c:3146">heap_update</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; or <a href="../../access/heap/heapam.c.html#L2679" title="access/heap/heapam.c:2679">heap_delete</a>().&nbsp; The tuple is still good at that point; what's more,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; even if we did flush it, it might be reloaded into the caches by a later<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; request in the same command.&nbsp; So the correct behavior is to keep a list<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; of outdated (updated/deleted) tuples and then do the required cache<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; flushes at the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> command boundary.&nbsp; We must also keep track of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; inserted tuples so that we can flush &quot;negative&quot; cache entries that match<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the new tuples; again, that mustn't happen until end of command.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Once we have finished the command, we still need to remember inserted<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; tuples (including new versions of updated tuples), so that we can flush<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; them from the caches if we abort the transaction.&nbsp; Similarly, we'd better<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; be able to flush &quot;negative&quot; cache entries that may have been loaded in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; place of deleted tuples, so we still need the deleted ones too.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If we successfully complete the transaction, we have to broadcast all<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; these invalidation events to other backends (via the SI message queue)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; so that they can flush obsolete entries from their caches.&nbsp; Note we have<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; to record the transaction commit <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> sending SI messages, otherwise<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the other backends won't see our updated tuples as good.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; When a subtransaction aborts, we can process and discard <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> events<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; it has queued.&nbsp; When a subtransaction commits, we just add its events<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; to the pending lists of the parent transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; In short, we need to remember until xact end every insert or delete<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; of a tuple that might be in the system caches.&nbsp; Updates are treated as<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; two events, delete + insert, for simplicity.&nbsp; (If the update doesn't<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; change the tuple <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value, catcache.c optimizes this into one event.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; We do not need to register EVERY tuple operation in this way, just those<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; on tuples in relations that have associated catcaches.&nbsp; We do, however,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; have to register every operation on every tuple that *could* be in a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; catcache, whether or not it currently is in our cache.&nbsp; Also, if the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; tuple is in a relation that has multiple catcaches, we need to register<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; an invalidation message for each such catcache.&nbsp; catcache.c's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="catcache.c.html#L2250" title="utils/cache/catcache.c:2250">PrepareToInvalidateCacheTuple</a>() routine provides the knowledge of which<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; catcaches may need invalidation for a given tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Also, whenever we see an operation on a pg_class, pg_attribute, or<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; pg_index tuple, we register a relcache flush operation for the relation<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; described by that tuple (as specified in <a href="#L1204" title="utils/cache/inval.c:1204">CacheInvalidateHeapTuple</a>()).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Likewise for pg_constraint tuples for foreign keys on relations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; We keep the relcache flush requests in lists separate from the catcache<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; tuple flush requests.&nbsp; This allows us to issue all the pending catcache<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; flushes <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we issue relcache flushes, which saves us from loading<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; a catcache tuple during relcache load only to flush it again right away.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Also, we avoid queuing multiple relcache flush requests for the same<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; relation, since a relcache flush is relatively expensive to do.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (</span><span class="Todo">XXX</span><span class="Comment"> is it worth testing likewise for duplicate catcache flush entries?<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Probably not.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Many subsystems own higher-level caches that depend on relcache and/or<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; catcache, and they register callbacks here to invalidate their caches.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; While building a higher-level cache entry, a backend may receive a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; callback for the being-built entry or one of its dependencies.&nbsp; This<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; implies the new higher-level entry would be born stale, and it might<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; remain stale for the life of the backend.&nbsp; Many caches do not prevent<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; that.&nbsp; They rely on DDL for can't-<a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> catalog changes taking<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; AccessExclusiveLock on suitable objects.&nbsp; (For a change made with less<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; locking, backends might never read the change.)&nbsp; The relation cache,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; however, needs to reflect changes from CREATE INDEX CONCURRENTLY no later<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; than the beginning of the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> transaction.&nbsp; Hence, when a relevant<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; invalidation callback arrives during a build, relcache.c reattempts that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; build.&nbsp; Caches with similar needs could do likewise.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If a relcache flush is issued for a system relation that we preload<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; from the relcache init file, we must also delete the init file so that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; it will be rebuilt during the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> backend restart.&nbsp; The actual work of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; manipulating the init file is in relcache.c, but we keep track of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; need for it here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Currently, inval messages are sent without regard for the possibility<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; that the object described by the catalog tuple might be a session-local<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; object such as a temporary table.&nbsp; This is because (1) this code has<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; no practical way to tell the difference, and (2) it is not certain that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; other backends don't have catalog cache or even relcache entries for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; such tables, anyway; there is nothing that prevents that.&nbsp; It might be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; worth trying to avoid sending such inval traffic in the future, if those<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; problems can be overcome cheaply.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; When <a href="../../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a>=logical, write invalidations into WAL at each command end to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; support the decoding of the in-progress transactions.&nbsp; See<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1170" title="utils/cache/inval.c:1170">CommandEndInvalidationMessages</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/cache/inval.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/catalog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_constraint.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/sinval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/smgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/catcache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memdebug.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/relmapper.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Pending requests are stored as ready-to-<a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> SharedInvalidationMessages.<br/></li>
<li></span><span class="Comment"> * We keep the messages themselves in arrays in <a href="../mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a><br/></li>
<li></span><span class="Comment"> * (there are separate arrays for catcache and relcache messages).&nbsp; Control<br/></li>
<li></span><span class="Comment"> * information is kept in a chain of <a href="#L219" title="utils/cache/inval.c:219">TransInvalidationInfo</a> structs, also<br/></li>
<li></span><span class="Comment"> * allocated in <a href="../mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>.&nbsp; (We could keep a subtransaction's<br/></li>
<li></span><span class="Comment"> * <a href="#L219" title="utils/cache/inval.c:219">TransInvalidationInfo</a> in its <a href="../mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a>; but that's more<br/></li>
<li></span><span class="Comment"> * wasteful not less so, since in very many scenarios it'd be the only<br/></li>
<li></span><span class="Comment"> * allocation in the subtransaction's <a href="../mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a>.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We can store the message arrays densely, and yet avoid moving data around<br/></li>
<li></span><span class="Comment"> * within an array, because within <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one subtransaction we need only<br/></li>
<li></span><span class="Comment"> * distinguish between messages emitted by prior commands and those emitted<br/></li>
<li></span><span class="Comment"> * by the current command.&nbsp; Once a command completes and we've done local<br/></li>
<li></span><span class="Comment"> * processing on its messages, we can fold those into the prior-commands<br/></li>
<li></span><span class="Comment"> * messages just by changing array indexes in the <a href="#L219" title="utils/cache/inval.c:219">TransInvalidationInfo</a><br/></li>
<li></span><span class="Comment"> * struct.&nbsp; Similarly, we need distinguish messages of prior subtransactions<br/></li>
<li></span><span class="Comment"> * from those of the current subtransaction only until the subtransaction<br/></li>
<li></span><span class="Comment"> * completes, after which we adjust the array indexes in the parent's<br/></li>
<li></span><span class="Comment"> * <a href="#L219" title="utils/cache/inval.c:219">TransInvalidationInfo</a> to include the subtransaction's messages.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The ordering of the individual messages within a command's or<br/></li>
<li></span><span class="Comment"> * subtransaction's output is not considered significant, although this<br/></li>
<li></span><span class="Comment"> * implementation happens to preserve the order in which they were queued.<br/></li>
<li></span><span class="Comment"> * (Previous versions of this code did not preserve it.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For notational convenience, control information is kept in two-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment"> * arrays, the first for catcache messages and the second for relcache<br/></li>
<li></span><span class="Comment"> * messages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L161">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CatCacheMsgs</span> </span><span class="Constant">0<br/></li>
<li><a id="L162">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RelCacheMsgs</span> </span><span class="Constant">1<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Pointers to <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> arrays in <a href="../mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a> */<br/></li>
<li><a id="L165">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">InvalMessageArray</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SharedInvalidationMessage *msgs;&nbsp; &nbsp; <span class="Comment">/* <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d array (can be expanded) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxmsgs;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* current allocated size of array */<br/></li>
<li><a id="L169">&#x200c;</a></span>} <span class="linkable">InvalMessageArray</span>;<br/></li>
<li><br/></li>
<li><a id="L171">&#x200c;</a><span class="Type">static</span> <a href="#L165" title="utils/cache/inval.c:165">InvalMessageArray</a> <span class="linkable">InvalMessageArrays</span>[<span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li><span class="Comment">/* Control information for one logical group of messages */<br/></li>
<li><a id="L174">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">InvalidationMsgsGroup</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstmsg[<span class="Constant">2</span>];&nbsp; &nbsp; <span class="Comment">/* first index in relevant array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextmsg[<span class="Constant">2</span>];&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* last+1 index */<br/></li>
<li><a id="L178">&#x200c;</a></span>} <span class="linkable">InvalidationMsgsGroup</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Macros to <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> preserve <a href="#L174" title="utils/cache/inval.c:174">InvalidationMsgsGroup</a> abstraction */<br/></li>
<li><a id="L181">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SetSubGroupToFollow</span>(targetgroup, priorgroup, subgroup) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; (targetgroup)-&gt;firstmsg[subgroup] = \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (targetgroup)-&gt;nextmsg[subgroup] = \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (priorgroup)-&gt;nextmsg[subgroup]; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L188">&#x200c;</a><span class="PreProc">#define <span class="linkable">SetGroupToFollow</span>(targetgroup, priorgroup) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L181" title="utils/cache/inval.c:181">SetSubGroupToFollow</a>(targetgroup, priorgroup, <a href="#L161" title="utils/cache/inval.c:161">CatCacheMsgs</a>); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L181" title="utils/cache/inval.c:181">SetSubGroupToFollow</a>(targetgroup, priorgroup, <a href="#L162" title="utils/cache/inval.c:162">RelCacheMsgs</a>); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L194">&#x200c;</a><span class="PreProc">#define <span class="linkable">NumMessagesInSubGroup</span>(group, subgroup) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((group)-&gt;nextmsg[subgroup] - (group)-&gt;firstmsg[subgroup])<br/></li>
<li></span><br/></li>
<li><a id="L197">&#x200c;</a><span class="PreProc">#define <span class="linkable">NumMessagesInGroup</span>(group) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (<a href="#L194" title="utils/cache/inval.c:194">NumMessagesInSubGroup</a>(group, <a href="#L161" title="utils/cache/inval.c:161">CatCacheMsgs</a>) + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; <a href="#L194" title="utils/cache/inval.c:194">NumMessagesInSubGroup</a>(group, <a href="#L162" title="utils/cache/inval.c:162">RelCacheMsgs</a>))<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------<br/></li>
<li></span><span class="Comment"> * Invalidation messages are divided into two groups:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 1) events so far in current command, not yet reflected to caches.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 2) events in previous commands of current transaction; these have<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; been reflected to local caches, and must be either broadcast to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; other backends or rolled back from local cache when we commit<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; or abort the transaction.<br/></li>
<li></span><span class="Comment"> * Actually, we need such groups for each level of nested transaction,<br/></li>
<li></span><span class="Comment"> * so that we can discard events from an aborted subtransaction.&nbsp; When<br/></li>
<li></span><span class="Comment"> * a subtransaction commits, we append its events to the parent's groups.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The relcache-file-invalidated flag can just be a simple boolean,<br/></li>
<li></span><span class="Comment"> * since we only act on it at transaction commit; we don't care which<br/></li>
<li></span><span class="Comment"> * command of the transaction set it.<br/></li>
<li></span><span class="Comment"> *----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L219">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">TransInvalidationInfo</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Back link to parent transaction's info */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L219" title="utils/cache/inval.c:219">TransInvalidationInfo</a> *parent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Subtransaction nesting depth */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my_level;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Events emitted by current command */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L174" title="utils/cache/inval.c:174">InvalidationMsgsGroup</a> CurrentCmdInvalidMsgs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Events emitted by previous commands of this (sub)transaction */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L174" title="utils/cache/inval.c:174">InvalidationMsgsGroup</a> PriorCmdInvalidMsgs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* init file must be invalidated? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; RelcacheInitFileInval;<br/></li>
<li><a id="L235">&#x200c;</a>} <span class="linkable">TransInvalidationInfo</span>;<br/></li>
<li><br/></li>
<li><a id="L237">&#x200c;</a><span class="Type">static</span> <a href="#L219" title="utils/cache/inval.c:219">TransInvalidationInfo</a> *<span class="linkable">transInvalInfo</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* GUC storage */<br/></li>
<li><a id="L240">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">debug_discard_caches</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Dynamically-registered callback <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; Current implementation<br/></li>
<li></span><span class="Comment"> * assumes there won't be enough of these to justify a dynamically resizable<br/></li>
<li></span><span class="Comment"> * array; it'd be easy to improve that if needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To avoid searching in <a href="#L1577" title="utils/cache/inval.c:1577">CallSyscacheCallbacks</a>, all callbacks for a given<br/></li>
<li></span><span class="Comment"> * syscache are linked into a list pointed to by <a href="#L263" title="utils/cache/inval.c:263">syscache_callback_links</a>[id].<br/></li>
<li></span><span class="Comment"> * The link <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are <a href="#L261" title="utils/cache/inval.c:261">syscache_callback_list</a>[] index plus 1, or 0 for <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L252">&#x200c;</a><span class="PreProc">#define <span class="linkable">MAX_SYSCACHE_CALLBACKS</span> </span><span class="Constant">64<br/></li>
<li><a id="L253">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_RELCACHE_CALLBACKS</span> </span><span class="Constant">10<br/></li>
<li></span><br/></li>
<li><a id="L255">&#x200c;</a><span class="Type">static</span> <span class="Type">struct</span> <span class="linkable">SYSCACHECALLBACK</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; id;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cache number */<br/></li>
<li></span>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; link;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> callback index+1 for same cache */<br/></li>
<li></span>&nbsp; &nbsp; SyscacheCallbackFunction function;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arg;<br/></li>
<li><a id="L261">&#x200c;</a>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">syscache_callback_list</span>[<a href="#L252" title="utils/cache/inval.c:252">MAX_SYSCACHE_CALLBACKS</a>];<br/></li>
<li><br/></li>
<li><a id="L263">&#x200c;</a><span class="Type">static</span> int16 <span class="linkable">syscache_callback_links</span>[<a href="syscache.c.html#L80" title="utils/cache/syscache.c:80">SysCacheSize</a>];<br/></li>
<li><br/></li>
<li><a id="L265">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">syscache_callback_count</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><a id="L267">&#x200c;</a><span class="Type">static</span> <span class="Type">struct</span> <span class="linkable">RELCACHECALLBACK</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelcacheCallbackFunction function;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arg;<br/></li>
<li><a id="L271">&#x200c;</a>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">relcache_callback_list</span>[<a href="#L253" title="utils/cache/inval.c:253">MAX_RELCACHE_CALLBACKS</a>];<br/></li>
<li><br/></li>
<li><a id="L273">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">relcache_callback_count</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Invalidation subgroup support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L290" title="utils/cache/inval.c:290">AddInvalidationMessage</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Add an invalidation message to a (sub)group.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The group must be the last active one, since we assume we can add to the<br/></li>
<li></span><span class="Comment"> * end of the relevant <a href="#L165" title="utils/cache/inval.c:165">InvalMessageArray</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * subgroup must be <a href="#L161" title="utils/cache/inval.c:161">CatCacheMsgs</a> or <a href="#L162" title="utils/cache/inval.c:162">RelCacheMsgs</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L290">&#x200c;</a></span><span class="linkable">AddInvalidationMessage</span>(<a href="#L174" title="utils/cache/inval.c:174">InvalidationMsgsGroup</a> *group, <span class="Type">int</span> subgroup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> SharedInvalidationMessage *msg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L165" title="utils/cache/inval.c:165">InvalMessageArray</a> *ima = &amp;<a href="#L171" title="utils/cache/inval.c:171">InvalMessageArrays</a>[subgroup];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextindex = group-&gt;nextmsg[subgroup];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nextindex &gt;= ima-&gt;maxmsgs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ima-&gt;msgs == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create new storage array in <a href="../mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reqsize = <span class="Constant">32</span>;&nbsp; &nbsp; <span class="Comment">/* arbitrary */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ima-&gt;msgs = (SharedInvalidationMessage *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reqsize * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SharedInvalidationMessage));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ima-&gt;maxmsgs = reqsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(nextindex == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Enlarge storage array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reqsize = <span class="Constant">2</span> * ima-&gt;maxmsgs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ima-&gt;msgs = (SharedInvalidationMessage *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(ima-&gt;msgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reqsize * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SharedInvalidationMessage));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ima-&gt;maxmsgs = reqsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Okay, add message to current group */<br/></li>
<li></span>&nbsp; &nbsp; ima-&gt;msgs[nextindex] = *msg;<br/></li>
<li>&nbsp; &nbsp; group-&gt;nextmsg[subgroup]++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Append one subgroup of invalidation messages to another, resetting<br/></li>
<li></span><span class="Comment"> * the source subgroup to empty.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L330">&#x200c;</a></span><span class="linkable">AppendInvalidationMessageSubGroup</span>(<a href="#L174" title="utils/cache/inval.c:174">InvalidationMsgsGroup</a> *dest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L174" title="utils/cache/inval.c:174">InvalidationMsgsGroup</a> *src,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> subgroup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Messages must be adjacent in <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> array */<br/></li>
<li></span>&nbsp; &nbsp; Assert(dest-&gt;nextmsg[subgroup] == src-&gt;firstmsg[subgroup]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... which makes this easy: */<br/></li>
<li></span>&nbsp; &nbsp; dest-&gt;nextmsg[subgroup] = src-&gt;nextmsg[subgroup];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is handy for some callers and irrelevant for others.&nbsp; But we do it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * always, reasoning that it's bad to leave different groups pointing at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same fragment of the message array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L181" title="utils/cache/inval.c:181">SetSubGroupToFollow</a>(src, dest, subgroup);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process a subgroup of invalidation messages.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a macro that executes the given code fragment for each message in<br/></li>
<li></span><span class="Comment"> * a message subgroup.&nbsp; The fragment should refer to the message as *msg.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L354">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ProcessMessageSubGroup</span>(group, subgroup, codeFragment) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Type">int</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; _msgindex = (group)-&gt;firstmsg[subgroup]; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Type">int</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; _endmsg = (group)-&gt;nextmsg[subgroup]; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">for</span><span class="PreProc"> (; _msgindex &lt; _endmsg; _msgindex++) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SharedInvalidationMessage *msg = \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L171" title="utils/cache/inval.c:171">InvalMessageArrays</a>[subgroup].msgs[_msgindex]; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; codeFragment; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; } \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process a subgroup of invalidation messages as an array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As above, but the code fragment can handle an array of messages.<br/></li>
<li></span><span class="Comment"> * The fragment should refer to the messages as msgs[], with n entries.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L372">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ProcessMessageSubGroupMulti</span>(group, subgroup, codeFragment) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Type">int</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; n = <a href="#L194" title="utils/cache/inval.c:194">NumMessagesInSubGroup</a>(group, subgroup); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (n &gt; </span><span class="Constant">0</span><span class="PreProc">) { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SharedInvalidationMessage *msgs = \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L171" title="utils/cache/inval.c:171">InvalMessageArrays</a>[subgroup].msgs[(group)-&gt;firstmsg[subgroup]]; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; codeFragment; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; } \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Invalidation group support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These routines understand about the division of a logical invalidation<br/></li>
<li></span><span class="Comment"> * group into separate physical arrays for catcache and relcache entries.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add a catcache inval entry<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L395">&#x200c;</a></span><span class="linkable">AddCatcacheInvalidationMessage</span>(<a href="#L174" title="utils/cache/inval.c:174">InvalidationMsgsGroup</a> *group,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> id, uint32 hashValue, Oid dbId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SharedInvalidationMessage msg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(id &lt; <span class="Constant">CHAR_MAX</span>);<br/></li>
<li>&nbsp; &nbsp; msg.cc.id = (int8) id;<br/></li>
<li>&nbsp; &nbsp; msg.cc.dbId = dbId;<br/></li>
<li>&nbsp; &nbsp; msg.cc.hashValue = hashValue;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Define padding bytes in SharedInvalidationMessage structs to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * defined. Otherwise the sinvaladt.c ringbuffer, which is accessed by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multiple processes, will cause spurious valgrind warnings about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * undefined memory being used. That's because valgrind remembers the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * undefined bytes from the last local process's store, not realizing that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * another process has written since, filling the previously uninitialized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bytes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(&amp;msg, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(msg));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L290" title="utils/cache/inval.c:290">AddInvalidationMessage</a>(group, <a href="#L161" title="utils/cache/inval.c:161">CatCacheMsgs</a>, &amp;msg);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add a whole-catalog inval entry<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L423">&#x200c;</a></span><span class="linkable">AddCatalogInvalidationMessage</span>(<a href="#L174" title="utils/cache/inval.c:174">InvalidationMsgsGroup</a> *group,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid dbId, Oid catId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SharedInvalidationMessage msg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; msg.cat.id = SHAREDINVALCATALOG_ID;<br/></li>
<li>&nbsp; &nbsp; msg.cat.dbId = dbId;<br/></li>
<li>&nbsp; &nbsp; msg.cat.catId = catId;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check <a href="#L395" title="utils/cache/inval.c:395">AddCatcacheInvalidationMessage</a>() for an explanation */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(&amp;msg, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(msg));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L290" title="utils/cache/inval.c:290">AddInvalidationMessage</a>(group, <a href="#L161" title="utils/cache/inval.c:161">CatCacheMsgs</a>, &amp;msg);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add a relcache inval entry<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L441">&#x200c;</a></span><span class="linkable">AddRelcacheInvalidationMessage</span>(<a href="#L174" title="utils/cache/inval.c:174">InvalidationMsgsGroup</a> *group,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid dbId, Oid relId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SharedInvalidationMessage msg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't add a duplicate item. We assume dbId need not be checked because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it will never change. InvalidOid for relId means all relations so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't need to add individual ones when it is present.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L354" title="utils/cache/inval.c:354">ProcessMessageSubGroup</a>(group, <a href="#L162" title="utils/cache/inval.c:162">RelCacheMsgs</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement">if</span> (msg-&gt;rc.id == SHAREDINVALRELCACHE_ID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (msg-&gt;rc.relId == relId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg-&gt;rc.relId == InvalidOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement">return</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, add the item */<br/></li>
<li></span>&nbsp; &nbsp; msg.rc.id = SHAREDINVALRELCACHE_ID;<br/></li>
<li>&nbsp; &nbsp; msg.rc.dbId = dbId;<br/></li>
<li>&nbsp; &nbsp; msg.rc.relId = relId;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check <a href="#L395" title="utils/cache/inval.c:395">AddCatcacheInvalidationMessage</a>() for an explanation */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(&amp;msg, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(msg));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L290" title="utils/cache/inval.c:290">AddInvalidationMessage</a>(group, <a href="#L162" title="utils/cache/inval.c:162">RelCacheMsgs</a>, &amp;msg);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add a snapshot inval entry<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We put these into the relcache subgroup for simplicity.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L473">&#x200c;</a></span><span class="linkable">AddSnapshotInvalidationMessage</span>(<a href="#L174" title="utils/cache/inval.c:174">InvalidationMsgsGroup</a> *group,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid dbId, Oid relId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SharedInvalidationMessage msg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't add a duplicate item */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* We assume dbId need not be checked because it will never change */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L354" title="utils/cache/inval.c:354">ProcessMessageSubGroup</a>(group, <a href="#L162" title="utils/cache/inval.c:162">RelCacheMsgs</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement">if</span> (msg-&gt;sn.id == SHAREDINVALSNAPSHOT_ID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; msg-&gt;sn.relId == relId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement">return</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, add the item */<br/></li>
<li></span>&nbsp; &nbsp; msg.sn.id = SHAREDINVALSNAPSHOT_ID;<br/></li>
<li>&nbsp; &nbsp; msg.sn.dbId = dbId;<br/></li>
<li>&nbsp; &nbsp; msg.sn.relId = relId;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check <a href="#L395" title="utils/cache/inval.c:395">AddCatcacheInvalidationMessage</a>() for an explanation */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(&amp;msg, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(msg));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L290" title="utils/cache/inval.c:290">AddInvalidationMessage</a>(group, <a href="#L162" title="utils/cache/inval.c:162">RelCacheMsgs</a>, &amp;msg);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Append one group of invalidation messages to another, resetting<br/></li>
<li></span><span class="Comment"> * the source group to empty.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L500">&#x200c;</a></span><span class="linkable">AppendInvalidationMessages</span>(<a href="#L174" title="utils/cache/inval.c:174">InvalidationMsgsGroup</a> *dest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L174" title="utils/cache/inval.c:174">InvalidationMsgsGroup</a> *src)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L330" title="utils/cache/inval.c:330">AppendInvalidationMessageSubGroup</a>(dest, src, <a href="#L161" title="utils/cache/inval.c:161">CatCacheMsgs</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L330" title="utils/cache/inval.c:330">AppendInvalidationMessageSubGroup</a>(dest, src, <a href="#L162" title="utils/cache/inval.c:162">RelCacheMsgs</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Execute the given function for all the messages in an invalidation group.<br/></li>
<li></span><span class="Comment"> * The group is not altered.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * catcache entries are processed first, for reasons mentioned above.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L514">&#x200c;</a></span><span class="linkable">ProcessInvalidationMessages</span>(<a href="#L174" title="utils/cache/inval.c:174">InvalidationMsgsGroup</a> *group,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> (*func) (SharedInvalidationMessage *msg))<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L354" title="utils/cache/inval.c:354">ProcessMessageSubGroup</a>(group, <a href="#L161" title="utils/cache/inval.c:161">CatCacheMsgs</a>, func(msg));<br/></li>
<li>&nbsp; &nbsp; <a href="#L354" title="utils/cache/inval.c:354">ProcessMessageSubGroup</a>(group, <a href="#L162" title="utils/cache/inval.c:162">RelCacheMsgs</a>, func(msg));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * As above, but the function is able to process an array of messages<br/></li>
<li></span><span class="Comment"> * rather than just one at a time.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L526">&#x200c;</a></span><span class="linkable">ProcessInvalidationMessagesMulti</span>(<a href="#L174" title="utils/cache/inval.c:174">InvalidationMsgsGroup</a> *group,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> (*func) (<span class="Type">const</span> SharedInvalidationMessage *msgs, <span class="Type">int</span> n))<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L372" title="utils/cache/inval.c:372">ProcessMessageSubGroupMulti</a>(group, <a href="#L161" title="utils/cache/inval.c:161">CatCacheMsgs</a>, func(msgs, n));<br/></li>
<li>&nbsp; &nbsp; <a href="#L372" title="utils/cache/inval.c:372">ProcessMessageSubGroupMulti</a>(group, <a href="#L162" title="utils/cache/inval.c:162">RelCacheMsgs</a>, func(msgs, n));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; private support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L544" title="utils/cache/inval.c:544">RegisterCatcacheInvalidation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Register an invalidation event for a catcache tuple entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L544">&#x200c;</a></span><span class="linkable">RegisterCatcacheInvalidation</span>(<span class="Type">int</span> cacheId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 hashValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid dbId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L395" title="utils/cache/inval.c:395">AddCatcacheInvalidationMessage</a>(&amp;<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;CurrentCmdInvalidMsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cacheId, hashValue, dbId);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L558" title="utils/cache/inval.c:558">RegisterCatalogInvalidation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Register an invalidation event for all catcache entries from a catalog.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L558">&#x200c;</a></span><span class="linkable">RegisterCatalogInvalidation</span>(Oid dbId, Oid catId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L423" title="utils/cache/inval.c:423">AddCatalogInvalidationMessage</a>(&amp;<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;CurrentCmdInvalidMsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dbId, catId);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L570" title="utils/cache/inval.c:570">RegisterRelcacheInvalidation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As above, but register a relcache invalidation event.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L570">&#x200c;</a></span><span class="linkable">RegisterRelcacheInvalidation</span>(Oid dbId, Oid relId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L441" title="utils/cache/inval.c:441">AddRelcacheInvalidationMessage</a>(&amp;<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;CurrentCmdInvalidMsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dbId, relId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Most of the time, relcache invalidation is associated with system<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catalog updates, but there are a few cases where it isn't.&nbsp; Quick hack<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to ensure that the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>() will think that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to do <a href="#L1170" title="utils/cache/inval.c:1170">CommandEndInvalidationMessages</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../access/transam/xact.c.html#L826" title="access/transam/xact.c:826">GetCurrentCommandId</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the relation being invalidated is one of those cached in a relcache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * init file, mark that we need to zap that file at commit. For simplicity<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * invalidations for a specific database always invalidate the shared file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as well.&nbsp; Also zap when we are invalidating whole relcache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relId == InvalidOid || <a href="relcache.c.html#L6714" title="utils/cache/relcache.c:6714">RelationIdIsInInitFile</a>(relId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;RelcacheInitFileInval = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L600" title="utils/cache/inval.c:600">RegisterSnapshotInvalidation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Register an invalidation event for MVCC scans against a given catalog.<br/></li>
<li></span><span class="Comment"> * Only needed for catalogs that don't have catcaches.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L600">&#x200c;</a></span><span class="linkable">RegisterSnapshotInvalidation</span>(Oid dbId, Oid relId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L473" title="utils/cache/inval.c:473">AddSnapshotInvalidationMessage</a>(&amp;<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;CurrentCmdInvalidMsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dbId, relId);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L611" title="utils/cache/inval.c:611">PrepareInvalidationState</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Initialize inval data for the current (sub)transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L611">&#x200c;</a></span><span class="linkable">PrepareInvalidationState</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L219" title="utils/cache/inval.c:219">TransInvalidationInfo</a> *myInfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a> != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;my_level == <a href="../../access/transam/xact.c.html#L926" title="access/transam/xact.c:926">GetCurrentTransactionNestLevel</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; myInfo = (<a href="#L219" title="utils/cache/inval.c:219">TransInvalidationInfo</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(<a href="../mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L219" title="utils/cache/inval.c:219">TransInvalidationInfo</a>));<br/></li>
<li>&nbsp; &nbsp; myInfo-&gt;parent = <a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>;<br/></li>
<li>&nbsp; &nbsp; myInfo-&gt;my_level = <a href="../../access/transam/xact.c.html#L926" title="access/transam/xact.c:926">GetCurrentTransactionNestLevel</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now, do we have a previous stack entry? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Yes; this one should be for a deeper nesting level. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(myInfo-&gt;my_level &gt; <a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;my_level);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The parent (sub)transaction must not have <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> current (i.e.,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not-yet-locally-processed) messages.&nbsp; If it did, we'd have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * semantic problem: the new subtransaction presumably ought not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * able to see those events yet, but since the CommandCounter is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * linear, that can't work once the subtransaction advances the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * counter.&nbsp; This is a convenient place to check for that, as well as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * being important to keep management of the message arrays simple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L197" title="utils/cache/inval.c:197">NumMessagesInGroup</a>(&amp;<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;CurrentCmdInvalidMsgs) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot start a subtransaction when there are unprocessed inval messages&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a> set firstmsg = nextmsg = 0 in each group,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which is fine for the first (sub)transaction, but otherwise we need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to update them to follow whatever is already in the arrays.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L188" title="utils/cache/inval.c:188">SetGroupToFollow</a>(&amp;myInfo-&gt;PriorCmdInvalidMsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;CurrentCmdInvalidMsgs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L188" title="utils/cache/inval.c:188">SetGroupToFollow</a>(&amp;myInfo-&gt;CurrentCmdInvalidMsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;myInfo-&gt;PriorCmdInvalidMsgs);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Here, we need only clear <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> array pointers left over from a prior<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L171" title="utils/cache/inval.c:171">InvalMessageArrays</a>[<a href="#L161" title="utils/cache/inval.c:161">CatCacheMsgs</a>].msgs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L171" title="utils/cache/inval.c:171">InvalMessageArrays</a>[<a href="#L161" title="utils/cache/inval.c:161">CatCacheMsgs</a>].maxmsgs = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L171" title="utils/cache/inval.c:171">InvalMessageArrays</a>[<a href="#L162" title="utils/cache/inval.c:162">RelCacheMsgs</a>].msgs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L171" title="utils/cache/inval.c:171">InvalMessageArrays</a>[<a href="#L162" title="utils/cache/inval.c:162">RelCacheMsgs</a>].maxmsgs = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a> = myInfo;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; public <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L674">&#x200c;</a></span><span class="linkable">InvalidateSystemCachesExtended</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> debug_discard)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../time/snapmgr.c.html#L422" title="utils/time/snapmgr.c:422">InvalidateCatalogSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="catcache.c.html#L753" title="utils/cache/catcache.c:753">ResetCatalogCaches</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="relcache.c.html#L2973" title="utils/cache/relcache.c:2973">RelationCacheInvalidate</a>(debug_discard); <span class="Comment">/* gets smgr and relmap too */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L265" title="utils/cache/inval.c:265">syscache_callback_count</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="#L255" title="utils/cache/inval.c:255">SYSCACHECALLBACK</a> *ccitem = <a href="#L261" title="utils/cache/inval.c:261">syscache_callback_list</a> + i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ccitem-&gt;function(ccitem-&gt;arg, ccitem-&gt;id, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L273" title="utils/cache/inval.c:273">relcache_callback_count</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="#L267" title="utils/cache/inval.c:267">RELCACHECALLBACK</a> *ccitem = <a href="#L271" title="utils/cache/inval.c:271">relcache_callback_list</a> + i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ccitem-&gt;function(ccitem-&gt;arg, InvalidOid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L705" title="utils/cache/inval.c:705">LocalExecuteInvalidationMessage</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Process a single invalidation message (which could be of <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> type).<br/></li>
<li></span><span class="Comment"> * Only the local caches are flushed; this does not transmit the message<br/></li>
<li></span><span class="Comment"> * to other backends.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L705">&#x200c;</a></span><span class="linkable">LocalExecuteInvalidationMessage</span>(SharedInvalidationMessage *msg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (msg-&gt;id &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (msg-&gt;cc.dbId == <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a> || msg-&gt;cc.dbId == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../time/snapmgr.c.html#L422" title="utils/time/snapmgr.c:422">InvalidateCatalogSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L577" title="utils/cache/syscache.c:577">SysCacheInvalidate</a>(msg-&gt;cc.id, msg-&gt;cc.hashValue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1577" title="utils/cache/inval.c:1577">CallSyscacheCallbacks</a>(msg-&gt;cc.id, msg-&gt;cc.hashValue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (msg-&gt;id == SHAREDINVALCATALOG_ID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (msg-&gt;cat.dbId == <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a> || msg-&gt;cat.dbId == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../time/snapmgr.c.html#L422" title="utils/time/snapmgr.c:422">InvalidateCatalogSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="catcache.c.html#L783" title="utils/cache/catcache.c:783">CatalogCacheFlushCatalog</a>(msg-&gt;cat.catId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="catcache.c.html#L783" title="utils/cache/catcache.c:783">CatalogCacheFlushCatalog</a> calls <a href="#L1577" title="utils/cache/inval.c:1577">CallSyscacheCallbacks</a> as needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (msg-&gt;id == SHAREDINVALRELCACHE_ID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (msg-&gt;rc.dbId == <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a> || msg-&gt;rc.dbId == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (msg-&gt;rc.relId == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="relcache.c.html#L2973" title="utils/cache/relcache.c:2973">RelationCacheInvalidate</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="relcache.c.html#L2917" title="utils/cache/relcache.c:2917">RelationCacheInvalidateEntry</a>(msg-&gt;rc.relId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L273" title="utils/cache/inval.c:273">relcache_callback_count</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="#L267" title="utils/cache/inval.c:267">RELCACHECALLBACK</a> *ccitem = <a href="#L271" title="utils/cache/inval.c:271">relcache_callback_list</a> + i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ccitem-&gt;function(ccitem-&gt;arg, msg-&gt;rc.relId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (msg-&gt;id == SHAREDINVALSMGR_ID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We could have smgr entries for relations of other databases, so no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * short-circuit test is possible here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; RelFileLocatorBackend rlocator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rlocator.locator = msg-&gt;sm.rlocator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rlocator.backend = (msg-&gt;sm.backend_hi &lt;&lt; <span class="Constant">16</span>) | (<span class="Type">int</span>) msg-&gt;sm.backend_lo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/smgr/smgr.c.html#L379" title="storage/smgr/smgr.c:379">smgrreleaserellocator</a>(rlocator);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (msg-&gt;id == SHAREDINVALRELMAP_ID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We only care about our own database and shared catalogs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (msg-&gt;rm.dbId == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="relmapper.c.html#L468" title="utils/cache/relmapper.c:468">RelationMapInvalidate</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (msg-&gt;rm.dbId == <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="relmapper.c.html#L468" title="utils/cache/relmapper.c:468">RelationMapInvalidate</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (msg-&gt;id == SHAREDINVALSNAPSHOT_ID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We only care about our own database and shared catalogs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (msg-&gt;sn.dbId == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../time/snapmgr.c.html#L422" title="utils/time/snapmgr.c:422">InvalidateCatalogSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (msg-&gt;sn.dbId == <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../time/snapmgr.c.html#L422" title="utils/time/snapmgr.c:422">InvalidateCatalogSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;unrecognized SI message ID: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, msg-&gt;id);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L792" title="utils/cache/inval.c:792">InvalidateSystemCaches</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This blows away all tuples in the system catalog caches and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; all the cached relation descriptors and smgr cache entries.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Relation descriptors that have positive refcounts are then rebuilt.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We call this when we see a shared-inval-queue overflow signal,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; since that tells us we've lost some shared-inval messages and hence<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; don't know what needs to be invalidated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L792">&#x200c;</a></span><span class="linkable">InvalidateSystemCaches</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L674" title="utils/cache/inval.c:674">InvalidateSystemCachesExtended</a>(<span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L806" title="utils/cache/inval.c:806">AcceptInvalidationMessages</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Read and process invalidation messages from the shared invalidation<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; message queue.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This should be called as the first step in processing a transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L806">&#x200c;</a></span><span class="linkable">AcceptInvalidationMessages</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/sinval.c.html#L69" title="storage/ipc/sinval.c:69">ReceiveSharedInvalidMessages</a>(<a href="#L705" title="utils/cache/inval.c:705">LocalExecuteInvalidationMessage</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L792" title="utils/cache/inval.c:792">InvalidateSystemCaches</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Test code to force cache flushes anytime a flush could happen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This helps detect intermittent faults caused by code that reads a cache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entry and then performs an action that could invalidate the entry, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rarely actually does so.&nbsp; This can spot issues that would otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only arise with badly timed concurrent DDL, for example.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The default <a href="#L240" title="utils/cache/inval.c:240">debug_discard_caches</a> = 0 does no forced cache flushes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If used with CLOBBER_FREED_MEMORY,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L240" title="utils/cache/inval.c:240">debug_discard_caches</a> = 1 (formerly known as CLOBBER_CACHE_ALWAYS)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * provides a fairly thorough test that the system contains no cache-flush<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hazards.&nbsp; However, it also makes the system unbelievably slow --- the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * regression tests take about 100 times longer than normal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If you're a glutton for punishment, try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L240" title="utils/cache/inval.c:240">debug_discard_caches</a> = 3 (formerly known as CLOBBER_CACHE_RECURSIVELY).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This slows things by at least a factor of 10000, so I wouldn't suggest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trying to run the entire regression tests that way.&nbsp; It's useful to try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a few simple tests, to make sure that cache reload isn't subject to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> cache-flush hazards, but after you've done a few thousand<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recursive reloads it's unlikely you'll learn more.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef DISCARD_CACHES_ENABLED<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="../error/elog.c.html#L153" title="utils/error/elog.c:153">recursion_depth</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../error/elog.c.html#L153" title="utils/error/elog.c:153">recursion_depth</a> &lt; <a href="#L240" title="utils/cache/inval.c:240">debug_discard_caches</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L153" title="utils/error/elog.c:153">recursion_depth</a>++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L674" title="utils/cache/inval.c:674">InvalidateSystemCachesExtended</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L153" title="utils/error/elog.c:153">recursion_depth</a>--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L863" title="utils/cache/inval.c:863">PostPrepare_Inval</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Clean up after successful PREPARE.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Here, we want to act as though the transaction aborted, so that we will<br/></li>
<li></span><span class="Comment"> * undo <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> syscache changes it made, thereby bringing us into sync with the<br/></li>
<li></span><span class="Comment"> * outside world, which doesn't believe the transaction committed yet.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the prepared transaction is later aborted, there is nothing more to<br/></li>
<li></span><span class="Comment"> * do; if it commits, we will receive the consequent inval messages just<br/></li>
<li></span><span class="Comment"> * like everyone else.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L863">&#x200c;</a></span><span class="linkable">PostPrepare_Inval</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1025" title="utils/cache/inval.c:1025">AtEOXact_Inval</a>(<span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L882" title="utils/cache/inval.c:882">xactGetCommittedInvalidationMessages</a>() is called by<br/></li>
<li></span><span class="Comment"> * <a href="../../access/transam/xact.c.html#L1304" title="access/transam/xact.c:1304">RecordTransactionCommit</a>() to collect invalidation messages to add to the<br/></li>
<li></span><span class="Comment"> * commit record. This applies only to commit message types, never to<br/></li>
<li></span><span class="Comment"> * abort <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>. Must always run <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="#L1025" title="utils/cache/inval.c:1025">AtEOXact_Inval</a>(), since that<br/></li>
<li></span><span class="Comment"> * removes the data we need to see.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Remember that this runs <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we have officially committed, so we<br/></li>
<li></span><span class="Comment"> * must not do anything here to change what might occur *if* we should<br/></li>
<li></span><span class="Comment"> * fail between here and the actual commit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * see also <a href="../../access/transam/xact.c.html#L6081" title="access/transam/xact.c:6081">xact_redo_commit</a>() and <a href="../../access/rmgrdesc/xactdesc.c.html#L331" title="access/rmgrdesc/xactdesc.c:331">xact_desc_commit</a>()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L882">&#x200c;</a></span><span class="linkable">xactGetCommittedInvalidationMessages</span>(SharedInvalidationMessage **msgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *RelcacheInitFileInval)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SharedInvalidationMessage *msgarray;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nummsgs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmsgs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick exit if we haven't done anything with invalidation messages. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *RelcacheInitFileInval = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *msgs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must be at top of stack */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;my_level == <span class="Constant">1</span> &amp;&amp; <a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;parent == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Relcache init file invalidation requires processing both <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after we <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the SI messages.&nbsp; However, we need not do anything unless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we committed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *RelcacheInitFileInval = <a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;RelcacheInitFileInval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Collect all the pending messages into a single contiguous array of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * invalidation messages, to simplify what needs to happen while building<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the commit WAL message.&nbsp; Maintain the order that they would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processed in by <a href="#L1025" title="utils/cache/inval.c:1025">AtEOXact_Inval</a>(), to ensure emulated behaviour in redo<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is as similar as possible to original.&nbsp; We want the same bugs, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not new ones.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nummsgs = <a href="#L197" title="utils/cache/inval.c:197">NumMessagesInGroup</a>(&amp;<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;PriorCmdInvalidMsgs) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L197" title="utils/cache/inval.c:197">NumMessagesInGroup</a>(&amp;<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;CurrentCmdInvalidMsgs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *msgs = msgarray = (SharedInvalidationMessage *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nummsgs * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SharedInvalidationMessage));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nmsgs = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L372" title="utils/cache/inval.c:372">ProcessMessageSubGroupMulti</a>(&amp;<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;PriorCmdInvalidMsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L161" title="utils/cache/inval.c:161">CatCacheMsgs</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (memcpy(msgarray + nmsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SharedInvalidationMessage)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nmsgs += n));<br/></li>
<li>&nbsp; &nbsp; <a href="#L372" title="utils/cache/inval.c:372">ProcessMessageSubGroupMulti</a>(&amp;<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;CurrentCmdInvalidMsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L161" title="utils/cache/inval.c:161">CatCacheMsgs</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (memcpy(msgarray + nmsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SharedInvalidationMessage)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nmsgs += n));<br/></li>
<li>&nbsp; &nbsp; <a href="#L372" title="utils/cache/inval.c:372">ProcessMessageSubGroupMulti</a>(&amp;<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;PriorCmdInvalidMsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L162" title="utils/cache/inval.c:162">RelCacheMsgs</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (memcpy(msgarray + nmsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SharedInvalidationMessage)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nmsgs += n));<br/></li>
<li>&nbsp; &nbsp; <a href="#L372" title="utils/cache/inval.c:372">ProcessMessageSubGroupMulti</a>(&amp;<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;CurrentCmdInvalidMsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L162" title="utils/cache/inval.c:162">RelCacheMsgs</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (memcpy(msgarray + nmsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SharedInvalidationMessage)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nmsgs += n));<br/></li>
<li>&nbsp; &nbsp; Assert(nmsgs == nummsgs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nmsgs;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L961" title="utils/cache/inval.c:961">ProcessCommittedInvalidationMessages</a> is executed by <a href="../../access/transam/xact.c.html#L6081" title="access/transam/xact.c:6081">xact_redo_commit</a>() or<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/ipc/standby.c.html#L1159" title="storage/ipc/standby.c:1159">standby_redo</a>() to process invalidation messages. Currently that happens<br/></li>
<li></span><span class="Comment"> * only at end-of-xact.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Relcache init file invalidation requires processing both<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> and after we <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the SI messages. See <a href="#L1025" title="utils/cache/inval.c:1025">AtEOXact_Inval</a>()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L961">&#x200c;</a></span><span class="linkable">ProcessCommittedInvalidationMessages</span>(SharedInvalidationMessage *msgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nmsgs, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> RelcacheInitFileInval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid dbid, Oid tsid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nmsgs &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG4, <span class="Constant">&quot;replaying commit with </span><span class="Special">%d</span><span class="Constant"> messages</span><span class="Special">%s</span><span class="Constant">&quot;</span>, nmsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (RelcacheInitFileInval ? <span class="Constant">&quot; and relcache file invalidation&quot;</span> : <span class="Constant">&quot;&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RelcacheInitFileInval)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG4, <span class="Constant">&quot;removing relcache init files for database </span><span class="Special">%u</span><span class="Constant">&quot;</span>, dbid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="relcache.c.html#L6754" title="utils/cache/relcache.c:6754">RelationCacheInitFilePreInvalidate</a>, when the invalidation message<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is for a specific database, requires <a href="../init/globals.c.html#L101" title="utils/init/globals.c:101">DatabasePath</a> to be set, but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should not use <a href="../init/miscinit.c.html#L328" title="utils/init/miscinit.c:328">SetDatabasePath</a> during recovery, since it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * intended to be used only once by normal backends.&nbsp; Hence, a quick<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hack: set <a href="../init/globals.c.html#L101" title="utils/init/globals.c:101">DatabasePath</a> directly then unset after use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(dbid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../init/globals.c.html#L101" title="utils/init/globals.c:101">DatabasePath</a> = GetDatabasePath(dbid, tsid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="relcache.c.html#L6754" title="utils/cache/relcache.c:6754">RelationCacheInitFilePreInvalidate</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(dbid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="../init/globals.c.html#L101" title="utils/init/globals.c:101">DatabasePath</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../init/globals.c.html#L101" title="utils/init/globals.c:101">DatabasePath</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/sinval.c.html#L47" title="storage/ipc/sinval.c:47">SendSharedInvalidMessages</a>(msgs, nmsgs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RelcacheInitFileInval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="relcache.c.html#L6779" title="utils/cache/relcache.c:6779">RelationCacheInitFilePostInvalidate</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1025" title="utils/cache/inval.c:1025">AtEOXact_Inval</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Process queued-up invalidation messages at end of <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If isCommit, we must <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> out the messages in our PriorCmdInvalidMsgs list<br/></li>
<li></span><span class="Comment"> * to the shared invalidation message queue.&nbsp; Note that these will be read<br/></li>
<li></span><span class="Comment"> * not only by other backends, but also by our own backend at the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment"> * transaction start (via <a href="#L806" title="utils/cache/inval.c:806">AcceptInvalidationMessages</a>).&nbsp; This means that<br/></li>
<li></span><span class="Comment"> * we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> immediate local processing of anything that's still in<br/></li>
<li></span><span class="Comment"> * CurrentCmdInvalidMsgs, and just <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> that list out too.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If not isCommit, we are aborting, and must locally process the messages<br/></li>
<li></span><span class="Comment"> * in PriorCmdInvalidMsgs.&nbsp; No messages need be sent to other backends,<br/></li>
<li></span><span class="Comment"> * since they'll not have seen our changed tuples anyway.&nbsp; We can forget<br/></li>
<li></span><span class="Comment"> * about CurrentCmdInvalidMsgs too, since those changes haven't touched<br/></li>
<li></span><span class="Comment"> * the caches yet.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, reset our state to empty.&nbsp; We need not physically<br/></li>
<li></span><span class="Comment"> * free memory here, since <a href="../mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a> is about to be emptied<br/></li>
<li></span><span class="Comment"> * anyway.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This should be called as the last step in processing a transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1025">&#x200c;</a></span><span class="linkable">AtEOXact_Inval</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick exit if no messages */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must be at top of stack */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;my_level == <span class="Constant">1</span> &amp;&amp; <a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;parent == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isCommit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Relcache init file invalidation requires processing both <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * after we <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the SI messages.&nbsp; However, we need not do anything<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unless we committed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;RelcacheInitFileInval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="relcache.c.html#L6754" title="utils/cache/relcache.c:6754">RelationCacheInitFilePreInvalidate</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L500" title="utils/cache/inval.c:500">AppendInvalidationMessages</a>(&amp;<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;PriorCmdInvalidMsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;CurrentCmdInvalidMsgs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L526" title="utils/cache/inval.c:526">ProcessInvalidationMessagesMulti</a>(&amp;<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;PriorCmdInvalidMsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/ipc/sinval.c.html#L47" title="storage/ipc/sinval.c:47">SendSharedInvalidMessages</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;RelcacheInitFileInval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="relcache.c.html#L6779" title="utils/cache/relcache.c:6779">RelationCacheInitFilePostInvalidate</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L514" title="utils/cache/inval.c:514">ProcessInvalidationMessages</a>(&amp;<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;PriorCmdInvalidMsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L705" title="utils/cache/inval.c:705">LocalExecuteInvalidationMessage</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Need not free anything explicitly */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a> = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1082" title="utils/cache/inval.c:1082">AtEOSubXact_Inval</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Process queued-up invalidation messages at end of subtransaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If isCommit, process CurrentCmdInvalidMsgs if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> (there probably aren't),<br/></li>
<li></span><span class="Comment"> * and then attach both CurrentCmdInvalidMsgs and PriorCmdInvalidMsgs to the<br/></li>
<li></span><span class="Comment"> * parent's PriorCmdInvalidMsgs list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If not isCommit, we are aborting, and must locally process the messages<br/></li>
<li></span><span class="Comment"> * in PriorCmdInvalidMsgs.&nbsp; No messages need be sent to other backends.<br/></li>
<li></span><span class="Comment"> * We can forget about CurrentCmdInvalidMsgs too, since those changes haven't<br/></li>
<li></span><span class="Comment"> * touched the caches yet.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, pop the transaction stack.&nbsp; We need not physically free memory<br/></li>
<li></span><span class="Comment"> * here, since <a href="../mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a> is about to be emptied anyway<br/></li>
<li></span><span class="Comment"> * (if aborting).&nbsp; Beware of the possibility of aborting the same nesting<br/></li>
<li></span><span class="Comment"> * level twice, though.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1082">&#x200c;</a></span><span class="linkable">AtEOSubXact_Inval</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my_level;<br/></li>
<li>&nbsp; &nbsp; <a href="#L219" title="utils/cache/inval.c:219">TransInvalidationInfo</a> *myInfo = <a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick exit if no messages. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (myInfo == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Also bail out quickly if messages are not for this level. */<br/></li>
<li></span>&nbsp; &nbsp; my_level = <a href="../../access/transam/xact.c.html#L926" title="access/transam/xact.c:926">GetCurrentTransactionNestLevel</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (myInfo-&gt;my_level != my_level)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(myInfo-&gt;my_level &lt; my_level);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isCommit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If CurrentCmdInvalidMsgs still has anything, fix it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1170" title="utils/cache/inval.c:1170">CommandEndInvalidationMessages</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We create invalidation stack entries lazily, so the parent might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not have one.&nbsp; Instead of creating one, moving all the data over,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and then freeing our own, we can just adjust the level of our own<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (myInfo-&gt;parent == <span class="Constant">NULL</span> || myInfo-&gt;parent-&gt;my_level &lt; my_level - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; myInfo-&gt;my_level--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pass up my inval messages to parent.&nbsp; Notice that we stick them in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PriorCmdInvalidMsgs, not CurrentCmdInvalidMsgs, since they've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already been locally processed.&nbsp; (This would <a href="../adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> the Assert in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L330" title="utils/cache/inval.c:330">AppendInvalidationMessageSubGroup</a> if the parent's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * CurrentCmdInvalidMsgs isn't empty; but we already checked that in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L611" title="utils/cache/inval.c:611">PrepareInvalidationState</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L500" title="utils/cache/inval.c:500">AppendInvalidationMessages</a>(&amp;myInfo-&gt;parent-&gt;PriorCmdInvalidMsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;myInfo-&gt;PriorCmdInvalidMsgs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must readjust parent's CurrentCmdInvalidMsgs indexes <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L188" title="utils/cache/inval.c:188">SetGroupToFollow</a>(&amp;myInfo-&gt;parent-&gt;CurrentCmdInvalidMsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;myInfo-&gt;parent-&gt;PriorCmdInvalidMsgs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Pending relcache inval becomes parent's problem too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (myInfo-&gt;RelcacheInitFileInval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; myInfo-&gt;parent-&gt;RelcacheInitFileInval = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Pop the transaction state stack */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a> = myInfo-&gt;parent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Need not free anything else explicitly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(myInfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L514" title="utils/cache/inval.c:514">ProcessInvalidationMessages</a>(&amp;myInfo-&gt;PriorCmdInvalidMsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L705" title="utils/cache/inval.c:705">LocalExecuteInvalidationMessage</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Pop the transaction state stack */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a> = myInfo-&gt;parent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Need not free anything else explicitly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(myInfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1170" title="utils/cache/inval.c:1170">CommandEndInvalidationMessages</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Process queued-up invalidation messages at end of one command<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; in a transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Here, we <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> no messages to the shared queue, since we don't know yet if<br/></li>
<li></span><span class="Comment"> * we will commit.&nbsp; We do need to locally process the CurrentCmdInvalidMsgs<br/></li>
<li></span><span class="Comment"> * list, so as to flush our caches of <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> entries we have outdated in the<br/></li>
<li></span><span class="Comment"> * current command.&nbsp; We then move the current-cmd list over to become part<br/></li>
<li></span><span class="Comment"> * of the prior-cmds list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This should be called during <a href="../../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>(),<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; after we have advanced the command ID.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1170">&#x200c;</a></span><span class="linkable">CommandEndInvalidationMessages</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * You might think this shouldn't be called outside <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transaction, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bootstrap does it, and also ABORT issued when not in a transaction. So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just quietly return if no state to work on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L514" title="utils/cache/inval.c:514">ProcessInvalidationMessages</a>(&amp;<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;CurrentCmdInvalidMsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L705" title="utils/cache/inval.c:705">LocalExecuteInvalidationMessage</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* WAL Log per-command invalidation messages for <a href="../../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a>=logical */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (XLogLogicalInfoActive())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1604" title="utils/cache/inval.c:1604">LogLogicalInvalidations</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L500" title="utils/cache/inval.c:500">AppendInvalidationMessages</a>(&amp;<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;PriorCmdInvalidMsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;CurrentCmdInvalidMsgs);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1204" title="utils/cache/inval.c:1204">CacheInvalidateHeapTuple</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Register the given tuple for invalidation at end of command<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (ie, current command is creating or outdating this tuple).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Also, detect whether a relcache invalidation is implied.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For an insert or delete, tuple is the target tuple and newtuple is NULL.<br/></li>
<li></span><span class="Comment"> * For an update, we are called just once, with tuple being the old tuple<br/></li>
<li></span><span class="Comment"> * version and newtuple the new version.&nbsp; This allows avoidance of duplicate<br/></li>
<li></span><span class="Comment"> * effort during an update.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1204">&#x200c;</a></span><span class="linkable">CacheInvalidateHeapTuple</span>(Relation relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTuple tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTuple newtuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupleRelId;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; databaseId;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relationId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do nothing during bootstrap */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We only need to worry about invalidation for tuples that are in system<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catalogs; user-relation tuples are never in catcaches and can't affect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the relcache either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../catalog/catalog.c.html#L103" title="catalog/catalog.c:103">IsCatalogRelation</a>(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../catalog/catalog.c.html#L103" title="catalog/catalog.c:103">IsCatalogRelation</a>() will return true for TOAST tables of system<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catalogs, but we don't care about those, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../catalog/catalog.c.html#L145" title="catalog/catalog.c:145">IsToastRelation</a>(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're not prepared to queue invalidation messages for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subtransaction level, get ready <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L611" title="utils/cache/inval.c:611">PrepareInvalidationState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First let the catcache do its thing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tupleRelId = RelationGetRelid(relation);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="syscache.c.html#L601" title="utils/cache/syscache.c:601">RelationInvalidatesSnapshotsOnly</a>(tupleRelId))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; databaseId = <a href="../../catalog/catalog.c.html#L243" title="catalog/catalog.c:243">IsSharedRelation</a>(tupleRelId) ? InvalidOid : <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L600" title="utils/cache/inval.c:600">RegisterSnapshotInvalidation</a>(databaseId, tupleRelId);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="catcache.c.html#L2250" title="utils/cache/catcache.c:2250">PrepareToInvalidateCacheTuple</a>(relation, tuple, newtuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L544" title="utils/cache/inval.c:544">RegisterCatcacheInvalidation</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now, is this tuple one of the primary definers of a relcache entry? See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comments in file header for deeper explanation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note we ignore newtuple here; we assume an update cannot move a tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from being part of one relcache entry to being part of another.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tupleRelId == RelationRelationId)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class classtup = (Form_pg_class) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId = classtup-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (classtup-&gt;relisshared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; databaseId = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; databaseId = <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (tupleRelId == AttributeRelationId)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute atttup = (Form_pg_attribute) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId = atttup-&gt;attrelid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * KLUGE ALERT: we always <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the relcache event with <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * even if the rel in question is shared (which we can't easily tell).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This essentially means that only backends in this same database<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will react to the relcache flush request.&nbsp; This is in fact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * appropriate, since only those backends could see our pg_attribute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * change anyway.&nbsp; It looks a <a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> ugly though.&nbsp; (In practice, shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relations can't have schema changes after bootstrap, so we should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * never come here for a shared rel anyway.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; databaseId = <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (tupleRelId == IndexRelationId)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_index indextup = (Form_pg_index) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When a pg_index row is updated, we should <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> out a relcache inval<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for the index relation.&nbsp; As above, we don't know the shared status<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the index, but in practice it doesn't matter since indexes of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shared catalogs can't have such updates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relationId = indextup-&gt;indexrelid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; databaseId = <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (tupleRelId == ConstraintRelationId)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint constrtup = (Form_pg_constraint) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Foreign keys are part of relcache entries, too, so <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> out an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inval for the table that the FK applies to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (constrtup-&gt;contype == CONSTRAINT_FOREIGN &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OidIsValid(constrtup-&gt;conrelid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relationId = constrtup-&gt;conrelid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; databaseId = <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Yes.&nbsp; We need to register a relcache invalidation event.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L570" title="utils/cache/inval.c:570">RegisterRelcacheInvalidation</a>(databaseId, relationId);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1336" title="utils/cache/inval.c:1336">CacheInvalidateCatalog</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Register invalidation of the whole content of a system catalog.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is normally used in VACUUM FULL/CLUSTER, where we haven't so much<br/></li>
<li></span><span class="Comment"> * changed <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples as moved them around.&nbsp; Some uses of catcache entries<br/></li>
<li></span><span class="Comment"> * expect their TIDs to be correct, so we have to blow away the entries.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we expect caller to verify that the rel actually is a system<br/></li>
<li></span><span class="Comment"> * catalog.&nbsp; If it isn't, no great harm is done, just a wasted sinval message.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1336">&#x200c;</a></span><span class="linkable">CacheInvalidateCatalog</span>(Oid catalogId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; databaseId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L611" title="utils/cache/inval.c:611">PrepareInvalidationState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../catalog/catalog.c.html#L243" title="catalog/catalog.c:243">IsSharedRelation</a>(catalogId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; databaseId = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; databaseId = <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L558" title="utils/cache/inval.c:558">RegisterCatalogInvalidation</a>(databaseId, catalogId);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1360" title="utils/cache/inval.c:1360">CacheInvalidateRelcache</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Register invalidation of the specified relation's relcache entry<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; at end of command.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used in places that need to force relcache rebuild but aren't<br/></li>
<li></span><span class="Comment"> * changing <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the tuples recognized as contributors to the relcache<br/></li>
<li></span><span class="Comment"> * entry by <a href="#L1204" title="utils/cache/inval.c:1204">CacheInvalidateHeapTuple</a>.&nbsp; (An example is dropping an index.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1360">&#x200c;</a></span><span class="linkable">CacheInvalidateRelcache</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; databaseId;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relationId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L611" title="utils/cache/inval.c:611">PrepareInvalidationState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relationId = RelationGetRelid(relation);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relisshared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; databaseId = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; databaseId = <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L570" title="utils/cache/inval.c:570">RegisterRelcacheInvalidation</a>(databaseId, relationId);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1384" title="utils/cache/inval.c:1384">CacheInvalidateRelcacheAll</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Register invalidation of the whole relcache at the end of command.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used by alter publication as changes in publications may affect<br/></li>
<li></span><span class="Comment"> * large number of tables.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1384">&#x200c;</a></span><span class="linkable">CacheInvalidateRelcacheAll</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L611" title="utils/cache/inval.c:611">PrepareInvalidationState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L570" title="utils/cache/inval.c:570">RegisterRelcacheInvalidation</a>(InvalidOid, InvalidOid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1396" title="utils/cache/inval.c:1396">CacheInvalidateRelcacheByTuple</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; As above, but relation is identified by passing its pg_class tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1396">&#x200c;</a></span><span class="linkable">CacheInvalidateRelcacheByTuple</span>(HeapTuple classTuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Form_pg_class classtup = (Form_pg_class) GETSTRUCT(classTuple);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; databaseId;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relationId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L611" title="utils/cache/inval.c:611">PrepareInvalidationState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relationId = classtup-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (classtup-&gt;relisshared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; databaseId = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; databaseId = <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L570" title="utils/cache/inval.c:570">RegisterRelcacheInvalidation</a>(databaseId, relationId);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1419" title="utils/cache/inval.c:1419">CacheInvalidateRelcacheByRelid</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; As above, but relation is identified by passing its OID.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is the least efficient of the three options; use one of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the above routines if you have a Relation or pg_class tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1419">&#x200c;</a></span><span class="linkable">CacheInvalidateRelcacheByRelid</span>(Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L611" title="utils/cache/inval.c:611">PrepareInvalidationState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tup = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, relid);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1396" title="utils/cache/inval.c:1396">CacheInvalidateRelcacheByTuple</a>(tup);<br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1459" title="utils/cache/inval.c:1459">CacheInvalidateSmgr</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Register invalidation of smgr references to a physical relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Sending this type of invalidation msg forces other backends to close open<br/></li>
<li></span><span class="Comment"> * smgr entries for the rel.&nbsp; This should be done to flush dangling open-file<br/></li>
<li></span><span class="Comment"> * references when the physical rel is being dropped or truncated.&nbsp; Because<br/></li>
<li></span><span class="Comment"> * these are nontransactional (i.e., not-rollback-able) operations, we just<br/></li>
<li></span><span class="Comment"> * <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the inval message immediately without <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> queuing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: in most cases there will have been a relcache flush issued against<br/></li>
<li></span><span class="Comment"> * the rel at the logical level.&nbsp; We need a separate smgr-level flush because<br/></li>
<li></span><span class="Comment"> * it is possible for backends to have open smgr entries for rels they don't<br/></li>
<li></span><span class="Comment"> * have a relcache entry for, e.g. because the only thing they ever did with<br/></li>
<li></span><span class="Comment"> * the rel is write out dirty shared buffers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: because these messages are nontransactional, they won't be captured<br/></li>
<li></span><span class="Comment"> * in commit/abort WAL entries.&nbsp; Instead, calls to <a href="#L1459" title="utils/cache/inval.c:1459">CacheInvalidateSmgr</a>()<br/></li>
<li></span><span class="Comment"> * should happen in low-level smgr.c routines, which are executed while<br/></li>
<li></span><span class="Comment"> * replaying WAL as well as when creating it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: In order to avoid bloating SharedInvalidationMessage, we store only<br/></li>
<li></span><span class="Comment"> * three bytes of the ProcNumber using what would otherwise be padding space.<br/></li>
<li></span><span class="Comment"> * Thus, the maximum possible ProcNumber is 2^23-1.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1459">&#x200c;</a></span><span class="linkable">CacheInvalidateSmgr</span>(RelFileLocatorBackend rlocator)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SharedInvalidationMessage msg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; msg.sm.id = SHAREDINVALSMGR_ID;<br/></li>
<li>&nbsp; &nbsp; msg.sm.backend_hi = rlocator.backend &gt;&gt; <span class="Constant">16</span>;<br/></li>
<li>&nbsp; &nbsp; msg.sm.backend_lo = rlocator.backend &amp; <span class="Constant">0xffff</span>;<br/></li>
<li>&nbsp; &nbsp; msg.sm.rlocator = rlocator.locator;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check <a href="#L395" title="utils/cache/inval.c:395">AddCatcacheInvalidationMessage</a>() for an explanation */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(&amp;msg, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(msg));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/sinval.c.html#L47" title="storage/ipc/sinval.c:47">SendSharedInvalidMessages</a>(&amp;msg, <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1489" title="utils/cache/inval.c:1489">CacheInvalidateRelmap</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Register invalidation of the relation mapping for a database,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; or for the shared catalogs if databaseId is zero.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Sending this type of invalidation msg forces other backends to re-read<br/></li>
<li></span><span class="Comment"> * the indicated relation mapping file.&nbsp; It is also necessary to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a<br/></li>
<li></span><span class="Comment"> * relcache inval for the specific relations whose mapping has been altered,<br/></li>
<li></span><span class="Comment"> * else the relcache won't get updated with the new filenode data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: because these messages are nontransactional, they won't be captured<br/></li>
<li></span><span class="Comment"> * in commit/abort WAL entries.&nbsp; Instead, calls to <a href="#L1489" title="utils/cache/inval.c:1489">CacheInvalidateRelmap</a>()<br/></li>
<li></span><span class="Comment"> * should happen in low-level relmapper.c routines, which are executed while<br/></li>
<li></span><span class="Comment"> * replaying WAL as well as when creating it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1489">&#x200c;</a></span><span class="linkable">CacheInvalidateRelmap</span>(Oid databaseId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SharedInvalidationMessage msg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; msg.rm.id = SHAREDINVALRELMAP_ID;<br/></li>
<li>&nbsp; &nbsp; msg.rm.dbId = databaseId;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check <a href="#L395" title="utils/cache/inval.c:395">AddCatcacheInvalidationMessage</a>() for an explanation */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(&amp;msg, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(msg));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/sinval.c.html#L47" title="storage/ipc/sinval.c:47">SendSharedInvalidMessages</a>(&amp;msg, <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Register the specified function to be called for all future<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; invalidation events in the specified cache.&nbsp; The cache ID and the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value of the tuple being invalidated will be passed to the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: Hash value zero will be passed if a cache reset request is received.<br/></li>
<li></span><span class="Comment"> * In this case the called routines should flush all cached state.<br/></li>
<li></span><span class="Comment"> * Yes, there's a possibility of a false match to zero, but it doesn't seem<br/></li>
<li></span><span class="Comment"> * worth troubling over, especially since most of the current callees just<br/></li>
<li></span><span class="Comment"> * flush all cached state anyway.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1516">&#x200c;</a></span><span class="linkable">CacheRegisterSyscacheCallback</span>(<span class="Type">int</span> cacheid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SyscacheCallbackFunction func,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cacheid &lt; <span class="Constant">0</span> || cacheid &gt;= <a href="syscache.c.html#L80" title="utils/cache/syscache.c:80">SysCacheSize</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;invalid cache ID: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, cacheid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L265" title="utils/cache/inval.c:265">syscache_callback_count</a> &gt;= <a href="#L252" title="utils/cache/inval.c:252">MAX_SYSCACHE_CALLBACKS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;out of <a href="#L261" title="utils/cache/inval.c:261">syscache_callback_list</a> slots&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L263" title="utils/cache/inval.c:263">syscache_callback_links</a>[cacheid] == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first callback for this cache */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L263" title="utils/cache/inval.c:263">syscache_callback_links</a>[cacheid] = <a href="#L265" title="utils/cache/inval.c:265">syscache_callback_count</a> + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* add to end of chain, so that older callbacks are called first */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <a href="#L263" title="utils/cache/inval.c:263">syscache_callback_links</a>[cacheid] - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L261" title="utils/cache/inval.c:261">syscache_callback_list</a>[i].link &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <a href="#L261" title="utils/cache/inval.c:261">syscache_callback_list</a>[i].link - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L261" title="utils/cache/inval.c:261">syscache_callback_list</a>[i].link = <a href="#L265" title="utils/cache/inval.c:265">syscache_callback_count</a> + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L261" title="utils/cache/inval.c:261">syscache_callback_list</a>[<a href="#L265" title="utils/cache/inval.c:265">syscache_callback_count</a>].id = cacheid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L261" title="utils/cache/inval.c:261">syscache_callback_list</a>[<a href="#L265" title="utils/cache/inval.c:265">syscache_callback_count</a>].link = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L261" title="utils/cache/inval.c:261">syscache_callback_list</a>[<a href="#L265" title="utils/cache/inval.c:265">syscache_callback_count</a>].function = func;<br/></li>
<li>&nbsp; &nbsp; <a href="#L261" title="utils/cache/inval.c:261">syscache_callback_list</a>[<a href="#L265" title="utils/cache/inval.c:265">syscache_callback_count</a>].arg = arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ++<a href="#L265" title="utils/cache/inval.c:265">syscache_callback_count</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1558" title="utils/cache/inval.c:1558">CacheRegisterRelcacheCallback</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Register the specified function to be called for all future<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; relcache invalidation events.&nbsp; The OID of the relation being<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; invalidated will be passed to the function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: InvalidOid will be passed if a cache reset request is received.<br/></li>
<li></span><span class="Comment"> * In this case the called routines should flush all cached state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1558">&#x200c;</a></span><span class="linkable">CacheRegisterRelcacheCallback</span>(RelcacheCallbackFunction func,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L273" title="utils/cache/inval.c:273">relcache_callback_count</a> &gt;= <a href="#L253" title="utils/cache/inval.c:253">MAX_RELCACHE_CALLBACKS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;out of <a href="#L271" title="utils/cache/inval.c:271">relcache_callback_list</a> slots&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L271" title="utils/cache/inval.c:271">relcache_callback_list</a>[<a href="#L273" title="utils/cache/inval.c:273">relcache_callback_count</a>].function = func;<br/></li>
<li>&nbsp; &nbsp; <a href="#L271" title="utils/cache/inval.c:271">relcache_callback_list</a>[<a href="#L273" title="utils/cache/inval.c:273">relcache_callback_count</a>].arg = arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ++<a href="#L273" title="utils/cache/inval.c:273">relcache_callback_count</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1577" title="utils/cache/inval.c:1577">CallSyscacheCallbacks</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exported so that <a href="catcache.c.html#L783" title="utils/cache/catcache.c:783">CatalogCacheFlushCatalog</a> can call it, saving<br/></li>
<li></span><span class="Comment"> * this module from knowing which catcache IDs correspond to which catalogs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1577">&#x200c;</a></span><span class="linkable">CallSyscacheCallbacks</span>(<span class="Type">int</span> cacheid, uint32 hashvalue)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cacheid &lt; <span class="Constant">0</span> || cacheid &gt;= <a href="syscache.c.html#L80" title="utils/cache/syscache.c:80">SysCacheSize</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid cache ID: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, cacheid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = <a href="#L263" title="utils/cache/inval.c:263">syscache_callback_links</a>[cacheid] - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (i &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> <a href="#L255" title="utils/cache/inval.c:255">SYSCACHECALLBACK</a> *ccitem = <a href="#L261" title="utils/cache/inval.c:261">syscache_callback_list</a> + i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ccitem-&gt;id == cacheid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ccitem-&gt;function(ccitem-&gt;arg, cacheid, hashvalue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i = ccitem-&gt;link - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1604" title="utils/cache/inval.c:1604">LogLogicalInvalidations</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Emit WAL for invalidations caused by the current command.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is currently only used for logging invalidations at the command end<br/></li>
<li></span><span class="Comment"> * or at commit time if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> invalidations are pending.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1604">&#x200c;</a></span><span class="linkable">LogLogicalInvalidations</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; xl_xact_invals xlrec;<br/></li>
<li>&nbsp; &nbsp; <a href="#L174" title="utils/cache/inval.c:174">InvalidationMsgsGroup</a> *group;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmsgs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick exit if we haven't done anything with invalidation messages. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; group = &amp;<a href="#L237" title="utils/cache/inval.c:237">transInvalInfo</a>-&gt;CurrentCmdInvalidMsgs;<br/></li>
<li>&nbsp; &nbsp; nmsgs = <a href="#L197" title="utils/cache/inval.c:197">NumMessagesInGroup</a>(group);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nmsgs &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* prepare record */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;xlrec, <span class="Constant">0</span>, MinSizeOfXactInvals);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.nmsgs = nmsgs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* perform insertion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xlrec), MinSizeOfXactInvals);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L372" title="utils/cache/inval.c:372">ProcessMessageSubGroupMulti</a>(group, <a href="#L161" title="utils/cache/inval.c:161">CatCacheMsgs</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) msgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; n * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SharedInvalidationMessage)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L372" title="utils/cache/inval.c:372">ProcessMessageSubGroupMulti</a>(group, <a href="#L162" title="utils/cache/inval.c:162">RelCacheMsgs</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) msgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; n * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SharedInvalidationMessage)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_XACT_ID, XLOG_XACT_INVALIDATIONS);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
