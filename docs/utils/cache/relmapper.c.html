<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/cache/relmapper.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/cache/relmapper.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L132">active_local_updates</a></li>
<li><a href="#L131">active_shared_updates</a></li>
<li><a href="#L113">local_map</a></li>
<li><a href="#L134">pending_local_updates</a></li>
<li><a href="#L133">pending_shared_updates</a></li>
<li><a href="#L112">shared_map</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L89">RelMapFile</a></li>
<li><a href="#L95">RelMapFile</a></li>
<li><a href="#L83">RelMapping</a></li>
<li><a href="#L87">RelMapping</a></li>
<li><a href="#L101">SerializedActiveRelMaps</a></li>
<li><a href="#L105">SerializedActiveRelMaps</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L504">AtCCI_RelationMap</a></li>
<li><a href="#L541">AtEOXact_RelationMap</a></li>
<li><a href="#L588">AtPrepare_RelationMap</a></li>
<li><a href="#L611">CheckPointRelationMap</a></li>
<li><a href="#L713">EstimateRelationMapSpace</a></li>
<li><a href="#L292">RelationMapCopy</a></li>
<li><a href="#L218">RelationMapFilenumberToOid</a></li>
<li><a href="#L625">RelationMapFinishBootstrap</a></li>
<li><a href="#L651">RelationMapInitialize</a></li>
<li><a href="#L671">RelationMapInitializePhase2</a></li>
<li><a href="#L692">RelationMapInitializePhase3</a></li>
<li><a href="#L468">RelationMapInvalidate</a></li>
<li><a href="#L490">RelationMapInvalidateAll</a></li>
<li><a href="#L165">RelationMapOidToFilenumber</a></li>
<li><a href="#L265">RelationMapOidToFilenumberForDatabase</a></li>
<li><a href="#L438">RelationMapRemoveMapping</a></li>
<li><a href="#L325">RelationMapUpdateMap</a></li>
<li><a href="#L741">RestoreRelationMap</a></li>
<li><a href="#L724">SerializeRelationMap</a></li>
<li><a href="#L383">apply_map_update</a></li>
<li><a href="#L765">load_relmap_file</a></li>
<li><a href="#L416">merge_map_updates</a></li>
<li><a href="#L1039">perform_relmap_update</a></li>
<li><a href="#L784">read_relmap_file</a></li>
<li><a href="#L1096">relmap_redo</a></li>
<li><a href="#L889">write_relmap_file</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L81">MAX_MAPPINGS</a></li>
<li><a href="#L73">RELMAPPER_FILEMAGIC</a></li>
<li><a href="#L70">RELMAPPER_FILENAME</a></li>
<li><a href="#L71">RELMAPPER_TEMP_FILENAME</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * relmapper.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Catalog-to-filenumber mapping<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For most tables, the physical file underlying the table is specified by<br/></li>
<li></span><span class="Comment"> * pg_class.relfilenode.&nbsp; However, that obviously won't work for pg_class<br/></li>
<li></span><span class="Comment"> * itself, nor for the other &quot;nailed&quot; catalogs for which we have to be able<br/></li>
<li></span><span class="Comment"> * to set up working Relation entries without access to pg_class.&nbsp; It also<br/></li>
<li></span><span class="Comment"> * does not work for shared catalogs, since there is no practical way to<br/></li>
<li></span><span class="Comment"> * update other databases' pg_class entries when relocating a shared catalog.<br/></li>
<li></span><span class="Comment"> * Therefore, for these special catalogs (henceforth referred to as &quot;mapped<br/></li>
<li></span><span class="Comment"> * catalogs&quot;) we rely on a separately maintained file that shows the mapping<br/></li>
<li></span><span class="Comment"> * from catalog OIDs to filenumbers.&nbsp; Each database has a map file for<br/></li>
<li></span><span class="Comment"> * its local mapped catalogs, and there is a separate map file for shared<br/></li>
<li></span><span class="Comment"> * catalogs.&nbsp; Mapped catalogs have zero in their pg_class.relfilenode entries.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Relocation of a normal table is committed (ie, the new physical file becomes<br/></li>
<li></span><span class="Comment"> * authoritative) when the pg_class row update commits.&nbsp; For mapped catalogs,<br/></li>
<li></span><span class="Comment"> * the act of updating the map file is effectively commit of the relocation.<br/></li>
<li></span><span class="Comment"> * We postpone the file update till just <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> commit of the transaction<br/></li>
<li></span><span class="Comment"> * doing the rewrite, but there is necessarily a window between.&nbsp; Therefore<br/></li>
<li></span><span class="Comment"> * mapped catalogs can only be relocated by operations such as VACUUM FULL<br/></li>
<li></span><span class="Comment"> * and CLUSTER, which make no transactionally-significant changes: it must be<br/></li>
<li></span><span class="Comment"> * safe for the new file to replace the old, even if the transaction itself<br/></li>
<li></span><span class="Comment"> * aborts.&nbsp; An important factor here is that the indexes and toast table of<br/></li>
<li></span><span class="Comment"> * a mapped catalog must also be mapped, so that the rewrites/relocations of<br/></li>
<li></span><span class="Comment"> * all these files commit in a single map file update rather than being tied<br/></li>
<li></span><span class="Comment"> * to transaction commit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/cache/relmapper.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_tablespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/storage.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lwlock.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/relmapper.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The map file is critical data: we have no automatic method for recovering<br/></li>
<li></span><span class="Comment"> * from loss or corruption of it.&nbsp; We use a CRC so that we can detect<br/></li>
<li></span><span class="Comment"> * corruption.&nbsp; Since the file might be more than one standard-size disk<br/></li>
<li></span><span class="Comment"> * sector in size, we cannot rely on overwrite-in-place. Instead, we generate<br/></li>
<li></span><span class="Comment"> * a new file and rename it into place, atomically replacing the original file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Entries in the mappings[] array are in no particular order.&nbsp; We could<br/></li>
<li></span><span class="Comment"> * speed searching by insisting on OID order, but it really shouldn't be<br/></li>
<li></span><span class="Comment"> * worth the trouble given the intended size of the mapping sets.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L70">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RELMAPPER_FILENAME</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">&quot;pg_filenode.map&quot;<br/></li>
<li><a id="L71">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RELMAPPER_TEMP_FILENAME</span>&nbsp; &nbsp; </span><span class="Constant">&quot;pg_filenode.map.tmp&quot;<br/></li>
<li></span><br/></li>
<li><a id="L73">&#x200c;</a><span class="PreProc">#define <span class="linkable">RELMAPPER_FILEMAGIC</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x592717</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* version ID value */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * There's no need for this constant to have <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> particular value, and we<br/></li>
<li></span><span class="Comment"> * can raise it as necessary if we end up with more mapped relations. For<br/></li>
<li></span><span class="Comment"> * <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we just pick a round number that is modestly larger than the expected<br/></li>
<li></span><span class="Comment"> * number of mappings.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L81">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_MAPPINGS</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">64<br/></li>
<li></span><br/></li>
<li><a id="L83">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">RelMapping</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapoid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OID of a catalog */<br/></li>
<li></span>&nbsp; &nbsp; RelFileNumber mapfilenumber;&nbsp; &nbsp; <span class="Comment">/* its rel file number */<br/></li>
<li><a id="L87">&#x200c;</a></span>} <span class="linkable">RelMapping</span>;<br/></li>
<li><br/></li>
<li><a id="L89">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">RelMapFile</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; magic;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* always <a href="#L73" title="utils/cache/relmapper.c:73">RELMAPPER_FILEMAGIC</a> */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; num_mappings;&nbsp; &nbsp; <span class="Comment">/* number of valid <a href="#L83" title="utils/cache/relmapper.c:83">RelMapping</a> entries */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L83" title="utils/cache/relmapper.c:83">RelMapping</a>&nbsp; &nbsp; mappings[<a href="#L81" title="utils/cache/relmapper.c:81">MAX_MAPPINGS</a>];<br/></li>
<li>&nbsp; &nbsp; pg_crc32c&nbsp; &nbsp; crc;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* CRC of all above */<br/></li>
<li><a id="L95">&#x200c;</a></span>} <span class="linkable">RelMapFile</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * State for serializing local and shared relmappings for parallel workers<br/></li>
<li></span><span class="Comment"> * (active states only).&nbsp; See notes on active_* and pending_* updates state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L101">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">SerializedActiveRelMaps</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a>&nbsp; &nbsp; <a href="#L131" title="utils/cache/relmapper.c:131">active_shared_updates</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a>&nbsp; &nbsp; <a href="#L132" title="utils/cache/relmapper.c:132">active_local_updates</a>;<br/></li>
<li><a id="L105">&#x200c;</a>} <span class="linkable">SerializedActiveRelMaps</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The currently known contents of the shared map file and our database's<br/></li>
<li></span><span class="Comment"> * local map file are stored here.&nbsp; These can be reloaded from disk<br/></li>
<li></span><span class="Comment"> * immediately whenever we receive an update sinval message.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L112">&#x200c;</a></span><span class="Type">static</span> <a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a> <span class="linkable">shared_map</span>;<br/></li>
<li><a id="L113">&#x200c;</a><span class="Type">static</span> <a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a> <span class="linkable">local_map</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We use the same <a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a> data structure to track uncommitted local<br/></li>
<li></span><span class="Comment"> * changes in the mappings (but note the magic and crc fields are not made<br/></li>
<li></span><span class="Comment"> * valid in these variables).&nbsp; Currently, map updates are not allowed within<br/></li>
<li></span><span class="Comment"> * subtransactions, so one set of transaction-level changes is sufficient.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The active_xxx variables contain updates that are valid in our transaction<br/></li>
<li></span><span class="Comment"> * and should be honored by <a href="#L165" title="utils/cache/relmapper.c:165">RelationMapOidToFilenumber</a>.&nbsp; The pending_xxx<br/></li>
<li></span><span class="Comment"> * variables contain updates we have been told about that aren't active yet;<br/></li>
<li></span><span class="Comment"> * they will become active at the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>.&nbsp; This setup<br/></li>
<li></span><span class="Comment"> * lets map updates act similarly to updates of pg_class rows, ie, they<br/></li>
<li></span><span class="Comment"> * become visible only at the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a> boundary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Active shared and active local updates are serialized by the parallel<br/></li>
<li></span><span class="Comment"> * infrastructure, and deserialized within parallel workers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L131">&#x200c;</a></span><span class="Type">static</span> <a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a> <span class="linkable">active_shared_updates</span>;<br/></li>
<li><a id="L132">&#x200c;</a><span class="Type">static</span> <a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a> <span class="linkable">active_local_updates</span>;<br/></li>
<li><a id="L133">&#x200c;</a><span class="Type">static</span> <a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a> <span class="linkable">pending_shared_updates</span>;<br/></li>
<li><a id="L134">&#x200c;</a><span class="Type">static</span> <a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a> <span class="linkable">pending_local_updates</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* non-export function prototypes */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L383" title="utils/cache/relmapper.c:383">apply_map_update</a>(<a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a> *map, Oid relationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelFileNumber fileNumber, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> add_okay);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L416" title="utils/cache/relmapper.c:416">merge_map_updates</a>(<a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a> *map, <span class="Type">const</span> <a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a> *updates,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> add_okay);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L765" title="utils/cache/relmapper.c:765">load_relmap_file</a>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> shared, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> lock_held);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L784" title="utils/cache/relmapper.c:784">read_relmap_file</a>(<a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a> *map, <span class="Type">char</span> *dbpath, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> lock_held,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> elevel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L889" title="utils/cache/relmapper.c:889">write_relmap_file</a>(<a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a> *newmap, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> write_wal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> send_sinval, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> preserve_files,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid dbid, Oid tsid, <span class="Type">const</span> <span class="Type">char</span> *dbpath);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1039" title="utils/cache/relmapper.c:1039">perform_relmap_update</a>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> shared, <span class="Type">const</span> <a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a> *updates);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L165" title="utils/cache/relmapper.c:165">RelationMapOidToFilenumber</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The raison d' etre ... given a relation OID, look up its filenumber.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Although shared and local relation OIDs should never overlap, the caller<br/></li>
<li></span><span class="Comment"> * always knows which we need --- so pass that information to avoid useless<br/></li>
<li></span><span class="Comment"> * searching.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns InvalidRelFileNumber if the OID is not known (which should never<br/></li>
<li></span><span class="Comment"> * happen, but the caller is in a better position to report a meaningful<br/></li>
<li></span><span class="Comment"> * error).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RelFileNumber<br/></li>
<li><a id="L165">&#x200c;</a><span class="linkable">RelationMapOidToFilenumber</span>(Oid relationId, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> shared)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a> *map;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there are active updates, believe those over the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> <a href="../mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (shared)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; map = &amp;<a href="#L131" title="utils/cache/relmapper.c:131">active_shared_updates</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; map-&gt;num_mappings; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relationId == map-&gt;mappings[i].mapoid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> map-&gt;mappings[i].mapfilenumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; map = &amp;<a href="#L112" title="utils/cache/relmapper.c:112">shared_map</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; map-&gt;num_mappings; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relationId == map-&gt;mappings[i].mapoid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> map-&gt;mappings[i].mapfilenumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; map = &amp;<a href="#L132" title="utils/cache/relmapper.c:132">active_local_updates</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; map-&gt;num_mappings; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relationId == map-&gt;mappings[i].mapoid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> map-&gt;mappings[i].mapfilenumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; map = &amp;<a href="#L113" title="utils/cache/relmapper.c:113">local_map</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; map-&gt;num_mappings; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relationId == map-&gt;mappings[i].mapoid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> map-&gt;mappings[i].mapfilenumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> InvalidRelFileNumber;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L218" title="utils/cache/relmapper.c:218">RelationMapFilenumberToOid</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Do the reverse of the normal direction of mapping done in<br/></li>
<li></span><span class="Comment"> * <a href="#L165" title="utils/cache/relmapper.c:165">RelationMapOidToFilenumber</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is not supposed to be used during normal running but rather for<br/></li>
<li></span><span class="Comment"> * information purposes when looking at the filesystem or xlog.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns InvalidOid if the OID is not known; this can easily happen if the<br/></li>
<li></span><span class="Comment"> * relfilenumber doesn't pertain to a mapped relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L218">&#x200c;</a><span class="linkable">RelationMapFilenumberToOid</span>(RelFileNumber filenumber, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> shared)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a> *map;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there are active updates, believe those over the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> <a href="../mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (shared)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; map = &amp;<a href="#L131" title="utils/cache/relmapper.c:131">active_shared_updates</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; map-&gt;num_mappings; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (filenumber == map-&gt;mappings[i].mapfilenumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> map-&gt;mappings[i].mapoid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; map = &amp;<a href="#L112" title="utils/cache/relmapper.c:112">shared_map</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; map-&gt;num_mappings; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (filenumber == map-&gt;mappings[i].mapfilenumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> map-&gt;mappings[i].mapoid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; map = &amp;<a href="#L132" title="utils/cache/relmapper.c:132">active_local_updates</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; map-&gt;num_mappings; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (filenumber == map-&gt;mappings[i].mapfilenumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> map-&gt;mappings[i].mapoid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; map = &amp;<a href="#L113" title="utils/cache/relmapper.c:113">local_map</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; map-&gt;num_mappings; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (filenumber == map-&gt;mappings[i].mapfilenumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> map-&gt;mappings[i].mapoid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L265" title="utils/cache/relmapper.c:265">RelationMapOidToFilenumberForDatabase</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Like <a href="#L165" title="utils/cache/relmapper.c:165">RelationMapOidToFilenumber</a>, but reads the mapping from the indicated<br/></li>
<li></span><span class="Comment"> * path instead of using the one for the current database.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RelFileNumber<br/></li>
<li><a id="L265">&#x200c;</a><span class="linkable">RelationMapOidToFilenumberForDatabase</span>(<span class="Type">char</span> *dbpath, Oid relationId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a>&nbsp; &nbsp; map;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Read the relmap file from the source database. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L784" title="utils/cache/relmapper.c:784">read_relmap_file</a>(&amp;map, dbpath, <span class="Constant">false</span>, ERROR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Iterate over the relmap entries to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the input relation OID. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; map.num_mappings; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relationId == map.mappings[i].mapoid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> map.mappings[i].mapfilenumber;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> InvalidRelFileNumber;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L292" title="utils/cache/relmapper.c:292">RelationMapCopy</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copy relmapfile from source db path to the destination db path and WAL log<br/></li>
<li></span><span class="Comment"> * the operation. This is intended for use in creating a new relmap file<br/></li>
<li></span><span class="Comment"> * for a database that doesn't have one yet, not for replacing an existing<br/></li>
<li></span><span class="Comment"> * relmap file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L292">&#x200c;</a></span><span class="linkable">RelationMapCopy</span>(Oid dbid, Oid tsid, <span class="Type">char</span> *srcdbpath, <span class="Type">char</span> *dstdbpath)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a>&nbsp; &nbsp; map;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read the relmap file from the source database.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L784" title="utils/cache/relmapper.c:784">read_relmap_file</a>(&amp;map, srcdbpath, <span class="Constant">false</span>, ERROR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Write the same data into the destination database's relmap file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No sinval is needed because no one can be connected to the destination<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * database yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There's no point in trying to preserve files here. The new database<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * isn't usable yet anyway, and won't ever be if we can't install a relmap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(RelationMappingLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L889" title="utils/cache/relmapper.c:889">write_relmap_file</a>(&amp;map, <span class="Constant">true</span>, <span class="Constant">false</span>, <span class="Constant">false</span>, dbid, tsid, dstdbpath);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(RelationMappingLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L325" title="utils/cache/relmapper.c:325">RelationMapUpdateMap</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Install a new relfilenumber mapping for the specified relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If immediate is true (or we're bootstrapping), the mapping is activated<br/></li>
<li></span><span class="Comment"> * immediately.&nbsp; Otherwise it is made pending until <a href="../../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L325">&#x200c;</a></span><span class="linkable">RelationMapUpdateMap</span>(Oid relationId, RelFileNumber fileNumber, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> shared,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> immediate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a> *map;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In bootstrap mode, the mapping gets installed in permanent map.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map = &amp;<a href="#L112" title="utils/cache/relmapper.c:112">shared_map</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map = &amp;<a href="#L113" title="utils/cache/relmapper.c:113">local_map</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't currently support map changes within subtransactions, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when in parallel mode.&nbsp; This could be done with more bookkeeping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * infrastructure, but it doesn't presently seem worth it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L926" title="access/transam/xact.c:926">GetCurrentTransactionNestLevel</a>() &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot change relation mapping within subtransaction&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot change relation mapping in parallel mode&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (immediate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make it active, but only locally */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map = &amp;<a href="#L131" title="utils/cache/relmapper.c:131">active_shared_updates</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map = &amp;<a href="#L132" title="utils/cache/relmapper.c:132">active_local_updates</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make it pending */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map = &amp;<a href="#L133" title="utils/cache/relmapper.c:133">pending_shared_updates</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map = &amp;<a href="#L134" title="utils/cache/relmapper.c:134">pending_local_updates</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L383" title="utils/cache/relmapper.c:383">apply_map_update</a>(map, relationId, fileNumber, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L383" title="utils/cache/relmapper.c:383">apply_map_update</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> a new mapping into the given map variable, replacing <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing<br/></li>
<li></span><span class="Comment"> * mapping for the same relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In some cases the caller knows there must be an existing mapping; pass<br/></li>
<li></span><span class="Comment"> * add_okay = false to draw an error if not.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L383">&#x200c;</a></span><span class="linkable">apply_map_update</span>(<a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a> *map, Oid relationId, RelFileNumber fileNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> add_okay)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Replace <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing mapping */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; map-&gt;num_mappings; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relationId == map-&gt;mappings[i].mapoid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map-&gt;mappings[i].mapfilenumber = fileNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nope, need to add a new mapping */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!add_okay)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;attempt to apply a mapping to unmapped relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relationId);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (map-&gt;num_mappings &gt;= <a href="#L81" title="utils/cache/relmapper.c:81">MAX_MAPPINGS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;ran out of space in relation map&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; map-&gt;mappings[map-&gt;num_mappings].mapoid = relationId;<br/></li>
<li>&nbsp; &nbsp; map-&gt;mappings[map-&gt;num_mappings].mapfilenumber = fileNumber;<br/></li>
<li>&nbsp; &nbsp; map-&gt;num_mappings++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L416" title="utils/cache/relmapper.c:416">merge_map_updates</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Merge all the updates in the given pending-update map into the target map.<br/></li>
<li></span><span class="Comment"> * This is just a bulk form of <a href="#L383" title="utils/cache/relmapper.c:383">apply_map_update</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L416">&#x200c;</a></span><span class="linkable">merge_map_updates</span>(<a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a> *map, <span class="Type">const</span> <a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a> *updates, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> add_okay)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; updates-&gt;num_mappings; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L383" title="utils/cache/relmapper.c:383">apply_map_update</a>(map,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; updates-&gt;mappings[i].mapoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; updates-&gt;mappings[i].mapfilenumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; add_okay);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L438" title="utils/cache/relmapper.c:438">RelationMapRemoveMapping</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Remove a relation's entry in the map.&nbsp; This is only allowed for &quot;active&quot;<br/></li>
<li></span><span class="Comment"> * (but not committed) local mappings.&nbsp; We need it so we can back out the<br/></li>
<li></span><span class="Comment"> * entry for the transient target file when doing VACUUM FULL/CLUSTER on<br/></li>
<li></span><span class="Comment"> * a mapped relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L438">&#x200c;</a></span><span class="linkable">RelationMapRemoveMapping</span>(Oid relationId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a> *map = &amp;<a href="#L132" title="utils/cache/relmapper.c:132">active_local_updates</a>;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; map-&gt;num_mappings; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relationId == map-&gt;mappings[i].mapoid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found it, collapse it out */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map-&gt;mappings[i] = map-&gt;mappings[map-&gt;num_mappings - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map-&gt;num_mappings--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> temporary mapping for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relationId);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L468" title="utils/cache/relmapper.c:468">RelationMapInvalidate</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine is invoked for SI cache flush messages.&nbsp; We must re-read<br/></li>
<li></span><span class="Comment"> * the indicated map file.&nbsp; However, we might receive a SI message in a<br/></li>
<li></span><span class="Comment"> * process that hasn't yet, and might never, load the mapping files;<br/></li>
<li></span><span class="Comment"> * for example the autovacuum launcher, which *must not* try to read<br/></li>
<li></span><span class="Comment"> * a local map since it is attached to no particular database.<br/></li>
<li></span><span class="Comment"> * So, re-read only if the map is valid <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L468">&#x200c;</a></span><span class="linkable">RelationMapInvalidate</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> shared)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (shared)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L112" title="utils/cache/relmapper.c:112">shared_map</a>.magic == <a href="#L73" title="utils/cache/relmapper.c:73">RELMAPPER_FILEMAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L765" title="utils/cache/relmapper.c:765">load_relmap_file</a>(<span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L113" title="utils/cache/relmapper.c:113">local_map</a>.magic == <a href="#L73" title="utils/cache/relmapper.c:73">RELMAPPER_FILEMAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L765" title="utils/cache/relmapper.c:765">load_relmap_file</a>(<span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L490" title="utils/cache/relmapper.c:490">RelationMapInvalidateAll</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Reload all map files.&nbsp; This is used to recover from SI message buffer<br/></li>
<li></span><span class="Comment"> * overflow: we can't be sure if we missed an inval message.<br/></li>
<li></span><span class="Comment"> * Again, reload only currently-valid <a href="../mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L490">&#x200c;</a></span><span class="linkable">RelationMapInvalidateAll</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L112" title="utils/cache/relmapper.c:112">shared_map</a>.magic == <a href="#L73" title="utils/cache/relmapper.c:73">RELMAPPER_FILEMAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L765" title="utils/cache/relmapper.c:765">load_relmap_file</a>(<span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L113" title="utils/cache/relmapper.c:113">local_map</a>.magic == <a href="#L73" title="utils/cache/relmapper.c:73">RELMAPPER_FILEMAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L765" title="utils/cache/relmapper.c:765">load_relmap_file</a>(<span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L504" title="utils/cache/relmapper.c:504">AtCCI_RelationMap</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Activate <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> &quot;pending&quot; relation map updates at <a href="../../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a> time.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L504">&#x200c;</a></span><span class="linkable">AtCCI_RelationMap</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L133" title="utils/cache/relmapper.c:133">pending_shared_updates</a>.num_mappings != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L416" title="utils/cache/relmapper.c:416">merge_map_updates</a>(&amp;<a href="#L131" title="utils/cache/relmapper.c:131">active_shared_updates</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L133" title="utils/cache/relmapper.c:133">pending_shared_updates</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L133" title="utils/cache/relmapper.c:133">pending_shared_updates</a>.num_mappings = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L134" title="utils/cache/relmapper.c:134">pending_local_updates</a>.num_mappings != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L416" title="utils/cache/relmapper.c:416">merge_map_updates</a>(&amp;<a href="#L132" title="utils/cache/relmapper.c:132">active_local_updates</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L134" title="utils/cache/relmapper.c:134">pending_local_updates</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L134" title="utils/cache/relmapper.c:134">pending_local_updates</a>.num_mappings = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L541" title="utils/cache/relmapper.c:541">AtEOXact_RelationMap</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Handle relation mapping at <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a>-transaction commit or abort.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * During commit, this must be called as late as possible <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the actual<br/></li>
<li></span><span class="Comment"> * transaction commit, so as to minimize the window where the transaction<br/></li>
<li></span><span class="Comment"> * could still roll back after committing map changes.&nbsp; Although nothing<br/></li>
<li></span><span class="Comment"> * critically bad happens in such a case, we still would prefer that it<br/></li>
<li></span><span class="Comment"> * not happen, since we'd possibly be losing useful updates to the relations'<br/></li>
<li></span><span class="Comment"> * pg_class row(s).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * During abort, we just have to throw away <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending map changes.<br/></li>
<li></span><span class="Comment"> * Normal post-abort <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> will take care of fixing relcache entries.<br/></li>
<li></span><span class="Comment"> * Parallel worker commit/abort is handled by resetting active mappings<br/></li>
<li></span><span class="Comment"> * that may have been received from the leader process.&nbsp; (There should be<br/></li>
<li></span><span class="Comment"> * no pending updates in parallel workers.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L541">&#x200c;</a></span><span class="linkable">AtEOXact_RelationMap</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isParallelWorker)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isCommit &amp;&amp; !isParallelWorker)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should not get here with <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> &quot;pending&quot; updates.&nbsp; (We could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * logically choose to treat such as committed, but in the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * code this should never happen.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L133" title="utils/cache/relmapper.c:133">pending_shared_updates</a>.num_mappings == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L134" title="utils/cache/relmapper.c:134">pending_local_updates</a>.num_mappings == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Write <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> active updates to the actual map files, then reset them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L131" title="utils/cache/relmapper.c:131">active_shared_updates</a>.num_mappings != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1039" title="utils/cache/relmapper.c:1039">perform_relmap_update</a>(<span class="Constant">true</span>, &amp;<a href="#L131" title="utils/cache/relmapper.c:131">active_shared_updates</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="utils/cache/relmapper.c:131">active_shared_updates</a>.num_mappings = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L132" title="utils/cache/relmapper.c:132">active_local_updates</a>.num_mappings != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1039" title="utils/cache/relmapper.c:1039">perform_relmap_update</a>(<span class="Constant">false</span>, &amp;<a href="#L132" title="utils/cache/relmapper.c:132">active_local_updates</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L132" title="utils/cache/relmapper.c:132">active_local_updates</a>.num_mappings = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Abort or parallel worker --- drop all local and pending updates */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!isParallelWorker || <a href="#L133" title="utils/cache/relmapper.c:133">pending_shared_updates</a>.num_mappings == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!isParallelWorker || <a href="#L134" title="utils/cache/relmapper.c:134">pending_local_updates</a>.num_mappings == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="utils/cache/relmapper.c:131">active_shared_updates</a>.num_mappings = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L132" title="utils/cache/relmapper.c:132">active_local_updates</a>.num_mappings = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L133" title="utils/cache/relmapper.c:133">pending_shared_updates</a>.num_mappings = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L134" title="utils/cache/relmapper.c:134">pending_local_updates</a>.num_mappings = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L588" title="utils/cache/relmapper.c:588">AtPrepare_RelationMap</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Handle relation mapping at PREPARE.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently, we don't support preparing <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transaction that changes the map.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L588">&#x200c;</a></span><span class="linkable">AtPrepare_RelationMap</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L131" title="utils/cache/relmapper.c:131">active_shared_updates</a>.num_mappings != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L132" title="utils/cache/relmapper.c:132">active_local_updates</a>.num_mappings != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L133" title="utils/cache/relmapper.c:133">pending_shared_updates</a>.num_mappings != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L134" title="utils/cache/relmapper.c:134">pending_local_updates</a>.num_mappings != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot PREPARE a transaction that modified relation mapping&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L611" title="utils/cache/relmapper.c:611">CheckPointRelationMap</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called during a checkpoint.&nbsp; It must ensure that <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> relation map<br/></li>
<li></span><span class="Comment"> * updates that were WAL-logged <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the start of the checkpoint are<br/></li>
<li></span><span class="Comment"> * securely flushed to disk and will not need to be replayed later.&nbsp; This<br/></li>
<li></span><span class="Comment"> * seems unlikely to be a performance-critical issue, so we use a simple<br/></li>
<li></span><span class="Comment"> * method: we just take and release the RelationMappingLock.&nbsp; This ensures<br/></li>
<li></span><span class="Comment"> * that <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> already-logged map update is complete, because <a href="#L889" title="utils/cache/relmapper.c:889">write_relmap_file</a><br/></li>
<li></span><span class="Comment"> * will fsync the map file <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the lock is released.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L611">&#x200c;</a></span><span class="linkable">CheckPointRelationMap</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(RelationMappingLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(RelationMappingLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L625" title="utils/cache/relmapper.c:625">RelationMapFinishBootstrap</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Write out the initial relation mapping files at the completion of<br/></li>
<li></span><span class="Comment"> * bootstrap.&nbsp; All the mapped files should have been made known to us<br/></li>
<li></span><span class="Comment"> * via <a href="#L325" title="utils/cache/relmapper.c:325">RelationMapUpdateMap</a> calls.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L625">&#x200c;</a></span><span class="linkable">RelationMapFinishBootstrap</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(IsBootstrapProcessingMode());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shouldn't be anything &quot;pending&quot; ... */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L131" title="utils/cache/relmapper.c:131">active_shared_updates</a>.num_mappings == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L132" title="utils/cache/relmapper.c:132">active_local_updates</a>.num_mappings == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L133" title="utils/cache/relmapper.c:133">pending_shared_updates</a>.num_mappings == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L134" title="utils/cache/relmapper.c:134">pending_local_updates</a>.num_mappings == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Write the files; no WAL or sinval needed */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(RelationMappingLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L889" title="utils/cache/relmapper.c:889">write_relmap_file</a>(&amp;<a href="#L112" title="utils/cache/relmapper.c:112">shared_map</a>, <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid, GLOBALTABLESPACE_OID, <span class="Constant">&quot;global&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L889" title="utils/cache/relmapper.c:889">write_relmap_file</a>(&amp;<a href="#L113" title="utils/cache/relmapper.c:113">local_map</a>, <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>, <a href="../init/globals.c.html#L93" title="utils/init/globals.c:93">MyDatabaseTableSpace</a>, <a href="../init/globals.c.html#L101" title="utils/init/globals.c:101">DatabasePath</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(RelationMappingLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L651" title="utils/cache/relmapper.c:651">RelationMapInitialize</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This initializes the mapper module at process startup.&nbsp; We can't access the<br/></li>
<li></span><span class="Comment"> * database yet, so just make sure the <a href="../mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> are empty.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L651">&#x200c;</a></span><span class="linkable">RelationMapInitialize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The static variables should <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> to zeroes, but let's be sure */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L112" title="utils/cache/relmapper.c:112">shared_map</a>.magic = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mark it not loaded */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L113" title="utils/cache/relmapper.c:113">local_map</a>.magic = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L112" title="utils/cache/relmapper.c:112">shared_map</a>.num_mappings = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L113" title="utils/cache/relmapper.c:113">local_map</a>.num_mappings = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L131" title="utils/cache/relmapper.c:131">active_shared_updates</a>.num_mappings = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L132" title="utils/cache/relmapper.c:132">active_local_updates</a>.num_mappings = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L133" title="utils/cache/relmapper.c:133">pending_shared_updates</a>.num_mappings = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L134" title="utils/cache/relmapper.c:134">pending_local_updates</a>.num_mappings = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L671" title="utils/cache/relmapper.c:671">RelationMapInitializePhase2</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called to prepare for access to pg_database during startup.<br/></li>
<li></span><span class="Comment"> * We should be able to read the shared map file <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L671">&#x200c;</a></span><span class="linkable">RelationMapInitializePhase2</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In bootstrap mode, the map file isn't there yet, so do nothing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Load the shared map file, <a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> on error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L765" title="utils/cache/relmapper.c:765">load_relmap_file</a>(<span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L692" title="utils/cache/relmapper.c:692">RelationMapInitializePhase3</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called as soon as we have determined <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a> and set up<br/></li>
<li></span><span class="Comment"> * <a href="../init/globals.c.html#L101" title="utils/init/globals.c:101">DatabasePath</a>.&nbsp; At this point we should be able to read the local map file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L692">&#x200c;</a></span><span class="linkable">RelationMapInitializePhase3</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In bootstrap mode, the map file isn't there yet, so do nothing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Load the local map file, <a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> on error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L765" title="utils/cache/relmapper.c:765">load_relmap_file</a>(<span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L713" title="utils/cache/relmapper.c:713">EstimateRelationMapSpace</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Estimate space needed to pass active shared and local relmaps to parallel<br/></li>
<li></span><span class="Comment"> * workers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L713">&#x200c;</a><span class="linkable">EstimateRelationMapSpace</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L101" title="utils/cache/relmapper.c:101">SerializedActiveRelMaps</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L724" title="utils/cache/relmapper.c:724">SerializeRelationMap</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Serialize active shared and local relmap state for parallel workers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L724">&#x200c;</a></span><span class="linkable">SerializeRelationMap</span>(Size maxSize, <span class="Type">char</span> *startAddress)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/cache/relmapper.c:101">SerializedActiveRelMaps</a> *relmaps;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(maxSize &gt;= <a href="#L713" title="utils/cache/relmapper.c:713">EstimateRelationMapSpace</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relmaps = (<a href="#L101" title="utils/cache/relmapper.c:101">SerializedActiveRelMaps</a> *) startAddress;<br/></li>
<li>&nbsp; &nbsp; relmaps-&gt;<a href="#L131" title="utils/cache/relmapper.c:131">active_shared_updates</a> = <a href="#L131" title="utils/cache/relmapper.c:131">active_shared_updates</a>;<br/></li>
<li>&nbsp; &nbsp; relmaps-&gt;<a href="#L132" title="utils/cache/relmapper.c:132">active_local_updates</a> = <a href="#L132" title="utils/cache/relmapper.c:132">active_local_updates</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L741" title="utils/cache/relmapper.c:741">RestoreRelationMap</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Restore active shared and local relmap state within a parallel worker.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L741">&#x200c;</a></span><span class="linkable">RestoreRelationMap</span>(<span class="Type">char</span> *startAddress)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="utils/cache/relmapper.c:101">SerializedActiveRelMaps</a> *relmaps;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L131" title="utils/cache/relmapper.c:131">active_shared_updates</a>.num_mappings != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L132" title="utils/cache/relmapper.c:132">active_local_updates</a>.num_mappings != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L133" title="utils/cache/relmapper.c:133">pending_shared_updates</a>.num_mappings != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L134" title="utils/cache/relmapper.c:134">pending_local_updates</a>.num_mappings != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;parallel worker has existing mappings&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relmaps = (<a href="#L101" title="utils/cache/relmapper.c:101">SerializedActiveRelMaps</a> *) startAddress;<br/></li>
<li>&nbsp; &nbsp; <a href="#L131" title="utils/cache/relmapper.c:131">active_shared_updates</a> = relmaps-&gt;<a href="#L131" title="utils/cache/relmapper.c:131">active_shared_updates</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L132" title="utils/cache/relmapper.c:132">active_local_updates</a> = relmaps-&gt;<a href="#L132" title="utils/cache/relmapper.c:132">active_local_updates</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L765" title="utils/cache/relmapper.c:765">load_relmap_file</a> -- load the shared or local map file<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Because these files are essential for access to core system catalogs,<br/></li>
<li></span><span class="Comment"> * failure to load either of them is a fatal error.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the local case requires <a href="../init/globals.c.html#L101" title="utils/init/globals.c:101">DatabasePath</a> to be set up.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L765">&#x200c;</a></span><span class="linkable">load_relmap_file</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> shared, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> lock_held)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (shared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L784" title="utils/cache/relmapper.c:784">read_relmap_file</a>(&amp;<a href="#L112" title="utils/cache/relmapper.c:112">shared_map</a>, <span class="Constant">&quot;global&quot;</span>, lock_held, FATAL);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L784" title="utils/cache/relmapper.c:784">read_relmap_file</a>(&amp;<a href="#L113" title="utils/cache/relmapper.c:113">local_map</a>, <a href="../init/globals.c.html#L101" title="utils/init/globals.c:101">DatabasePath</a>, lock_held, FATAL);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L784" title="utils/cache/relmapper.c:784">read_relmap_file</a> -- load data from <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> relation mapper file<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * dbpath must be the relevant database path, or &quot;global&quot; for shared relations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * RelationMappingLock will be acquired released unless lock_held = true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Errors will be reported at the indicated elevel, which should be at least<br/></li>
<li></span><span class="Comment"> * ERROR.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L784">&#x200c;</a></span><span class="linkable">read_relmap_file</span>(<a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a> *map, <span class="Type">char</span> *dbpath, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> lock_held, <span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; mapfilename[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; pg_crc32c&nbsp; &nbsp; crc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(elevel &gt;= ERROR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Grab the lock to prevent the file from being updated while we read it,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unless the caller is already holding the lock.&nbsp; If the file is updated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shortly after we look, the sinval signaling mechanism will make us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * re-read it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we are able to access <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> relation that's affected by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the change.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!lock_held)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(RelationMappingLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open the target file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because Windows isn't happy about the idea of renaming over a file that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * someone has open, we only open this file after acquiring the lock, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the same reason, we close it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing the lock. That way,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by the time <a href="#L889" title="utils/cache/relmapper.c:889">write_relmap_file</a>() acquires an exclusive lock, no one else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will have it open.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snprintf(mapfilename, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(mapfilename), <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, dbpath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L70" title="utils/cache/relmapper.c:70">RELMAPPER_FILENAME</a>);<br/></li>
<li>&nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(mapfilename, O_RDONLY | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapfilename)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now read the data. */<br/></li>
<li></span>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_READ);<br/></li>
<li>&nbsp; &nbsp; r = read(fd, map, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (r != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, mapfilename)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: read </span><span class="Special">%d</span><span class="Constant"> of </span><span class="Special">%zu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapfilename, r, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a>))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapfilename)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!lock_held)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(RelationMappingLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for correct magic number, etc */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (map-&gt;magic != <a href="#L73" title="utils/cache/relmapper.c:73">RELMAPPER_FILEMAGIC</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; map-&gt;num_mappings &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; map-&gt;num_mappings &gt; <a href="#L81" title="utils/cache/relmapper.c:81">MAX_MAPPINGS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation mapping file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> contains invalid data&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapfilename)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* verify the CRC */<br/></li>
<li></span>&nbsp; &nbsp; INIT_CRC32C(crc);<br/></li>
<li>&nbsp; &nbsp; COMP_CRC32C(crc, (<span class="Type">char</span> *) map, offsetof(<a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a>, crc));<br/></li>
<li>&nbsp; &nbsp; FIN_CRC32C(crc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!EQ_CRC32C(crc, map-&gt;crc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation mapping file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> contains incorrect checksum&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapfilename)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write out a new shared or local map file with the given contents.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The magic number and CRC are automatically updated in *newmap.&nbsp; On<br/></li>
<li></span><span class="Comment"> * success, we copy the data to the appropriate permanent static variable.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If write_wal is true then an appropriate WAL message is emitted.<br/></li>
<li></span><span class="Comment"> * (It will be false for bootstrap and WAL replay cases.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If send_sinval is true then a SI invalidation message is sent.<br/></li>
<li></span><span class="Comment"> * (This should be true except in bootstrap case.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If preserve_files is true then the storage manager is warned not to<br/></li>
<li></span><span class="Comment"> * delete the files listed in the map.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Because this may be called during WAL replay when <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>,<br/></li>
<li></span><span class="Comment"> * <a href="../init/globals.c.html#L101" title="utils/init/globals.c:101">DatabasePath</a>, etc aren't valid, we require the caller to pass in suitable<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. Pass dbpath as &quot;global&quot; for the shared map.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller is also responsible for being sure no concurrent map update<br/></li>
<li></span><span class="Comment"> * could be happening.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L889">&#x200c;</a></span><span class="linkable">write_relmap_file</span>(<a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a> *newmap, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> write_wal, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> send_sinval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> preserve_files, Oid dbid, Oid tsid, <span class="Type">const</span> <span class="Type">char</span> *dbpath)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; mapfilename[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; maptempfilename[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Even without concurrent use of this map, <a href="#L611" title="utils/cache/relmapper.c:611">CheckPointRelationMap</a>() relies<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on this locking.&nbsp; Without it, a restore of a base backup taken after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this function's <a href="../../access/transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>() and <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> its <a href="../../storage/file/fd.c.html#L782" title="storage/file/fd.c:782">durable_rename</a>() would not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have the changes.&nbsp; <a href="../../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a>=minimal doesn't need the lock, but this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * isn't performance-critical enough for such a micro-optimization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a>(RelationMappingLock, LW_EXCLUSIVE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill in the overhead fields and update CRC.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newmap-&gt;magic = <a href="#L73" title="utils/cache/relmapper.c:73">RELMAPPER_FILEMAGIC</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newmap-&gt;num_mappings &lt; <span class="Constant">0</span> || newmap-&gt;num_mappings &gt; <a href="#L81" title="utils/cache/relmapper.c:81">MAX_MAPPINGS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;attempt to write bogus relation mapping&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; INIT_CRC32C(newmap-&gt;crc);<br/></li>
<li>&nbsp; &nbsp; COMP_CRC32C(newmap-&gt;crc, (<span class="Type">char</span> *) newmap, offsetof(<a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a>, crc));<br/></li>
<li>&nbsp; &nbsp; FIN_CRC32C(newmap-&gt;crc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct filenames -- a temporary file that we'll create to write the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data initially, and then the permanent name to which we will rename it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snprintf(mapfilename, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(mapfilename), <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dbpath, <a href="#L70" title="utils/cache/relmapper.c:70">RELMAPPER_FILENAME</a>);<br/></li>
<li>&nbsp; &nbsp; snprintf(maptempfilename, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(maptempfilename), <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dbpath, <a href="#L71" title="utils/cache/relmapper.c:71">RELMAPPER_TEMP_FILENAME</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open a temporary file. If a file already exists with this name, it must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be left over from a previous crash, so we can overwrite it. Concurrent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calls to this function are not allowed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(maptempfilename,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; O_WRONLY | O_CREAT | O_TRUNC | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maptempfilename)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Write new data to the file. */<br/></li>
<li></span>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_WRITE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (write(fd, newmap, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a>)) != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if write didn't set errno, assume problem is no disk space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ENOSPC</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maptempfilename)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And close the file. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maptempfilename)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (write_wal)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_relmap_update xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> errors are fatal ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.dbid = dbid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.tsid = tsid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.nbytes = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xlrec), MinSizeOfRelmapUpdate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) newmap, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lsn = <a href="../../access/transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_RELMAP_ID, XLOG_RELMAP_UPDATE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* As always, WAL must hit the disk <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the data update does */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>(lsn);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L782" title="storage/file/fd.c:782">durable_rename</a>() does all the hard work of making sure that we rename<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the temporary file into place in a crash-safe manner.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: Although we instruct <a href="../../storage/file/fd.c.html#L782" title="storage/file/fd.c:782">durable_rename</a>() to use ERROR, we will often<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be in a critical section at this point; if so, ERROR will become PANIC.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_RELATION_MAP_REPLACE);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L782" title="storage/file/fd.c:782">durable_rename</a>(maptempfilename, mapfilename, ERROR);<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that the file is safely on disk, <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> sinval message to let other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backends know to re-read it.&nbsp; We must do this inside the critical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * section: if for some reason we fail to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the message, we have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * force a database-wide PANIC.&nbsp; Otherwise other backends might continue<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * execution with stale mapping information, which would be catastrophic<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as soon as others began to use the <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-committed data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (send_sinval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="inval.c.html#L1489" title="utils/cache/inval.c:1489">CacheInvalidateRelmap</a>(dbid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure that the files listed in the map are not deleted if the outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction aborts.&nbsp; This had better be within the critical section<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * too: it's not likely to fail, but if it did, we'd arrive at transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * abort with the files still vulnerable.&nbsp; PANICing will leave things in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * good state on-disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we're cheating a little <a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> here by assuming that mapped files<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are either in pg_global or the database's default tablespace.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (preserve_files)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; newmap-&gt;num_mappings; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlocator.spcOid = tsid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlocator.dbOid = dbid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlocator.relNumber = newmap-&gt;mappings[i].mapfilenumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/storage.c.html#L251" title="catalog/storage.c:251">RelationPreserveStorage</a>(rlocator, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Critical section done */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (write_wal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Merge the specified updates into the appropriate &quot;real&quot; map,<br/></li>
<li></span><span class="Comment"> * and write out the changes.&nbsp; This function must be used for committing<br/></li>
<li></span><span class="Comment"> * updates during normal multiuser operation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1039">&#x200c;</a></span><span class="linkable">perform_relmap_update</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> shared, <span class="Type">const</span> <a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a> *updates)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a>&nbsp; &nbsp; newmap;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Anyone updating a relation's mapping info should take exclusive lock on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that rel and hold it until commit.&nbsp; This ensures that there will not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concurrent updates on the same mapping value; but there could easily be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concurrent updates on different <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the same file. We cover that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by acquiring the RelationMappingLock, re-reading the target file to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensure it's up to date, applying the updates, and writing the data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing RelationMappingLock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There is only one RelationMappingLock.&nbsp; In principle we could try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have one per mapping file, but it seems unlikely to be worth the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trouble.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(RelationMappingLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Be certain we see <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other updates just made */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L765" title="utils/cache/relmapper.c:765">load_relmap_file</a>(shared, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare updated data in a local variable */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (shared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;newmap, &amp;<a href="#L112" title="utils/cache/relmapper.c:112">shared_map</a>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;newmap, &amp;<a href="#L113" title="utils/cache/relmapper.c:113">local_map</a>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Apply the updates to newmap.&nbsp; No new mappings should appear, unless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * somebody is adding indexes to system catalogs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L416" title="utils/cache/relmapper.c:416">merge_map_updates</a>(&amp;newmap, updates, <a href="../init/globals.c.html#L127" title="utils/init/globals.c:127">allowSystemTableMods</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Write out the updated map and do other necessary tasks */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L889" title="utils/cache/relmapper.c:889">write_relmap_file</a>(&amp;newmap, <span class="Constant">true</span>, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (shared ? InvalidOid : <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (shared ? GLOBALTABLESPACE_OID : <a href="../init/globals.c.html#L93" title="utils/init/globals.c:93">MyDatabaseTableSpace</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (shared ? <span class="Constant">&quot;global&quot;</span> : <a href="../init/globals.c.html#L101" title="utils/init/globals.c:101">DatabasePath</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We successfully wrote the updated file, so it's <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> safe to rely on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in this process, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (shared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;<a href="#L112" title="utils/cache/relmapper.c:112">shared_map</a>, &amp;newmap, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;<a href="#L113" title="utils/cache/relmapper.c:113">local_map</a>, &amp;newmap, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we can release the lock */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(RelationMappingLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * RELMAP resource manager's routines<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1096">&#x200c;</a></span><span class="linkable">relmap_redo</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = XLogRecGetInfo(record) &amp; ~XLR_INFO_MASK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Backup blocks are not used in relmap <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!XLogRecHasAnyBlockRefs(record));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (info == XLOG_RELMAP_UPDATE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_relmap_update *xlrec = (xl_relmap_update *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a>&nbsp; &nbsp; newmap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *dbpath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;nbytes != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L89" title="utils/cache/relmapper.c:89">RelMapFile</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;<a href="#L1096" title="utils/cache/relmapper.c:1096">relmap_redo</a>: wrong size </span><span class="Special">%u</span><span class="Constant"> in relmap update record&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;nbytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;newmap, xlrec-&gt;data, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(newmap));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We need to construct the pathname for this database */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dbpath = GetDatabasePath(xlrec-&gt;dbid, xlrec-&gt;tsid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Write out the new map and <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> sinval, but of course don't write a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new WAL entry.&nbsp; There's no surrounding transaction to tell to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * preserve files, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There shouldn't be anyone else updating relmaps during WAL replay,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but grab the lock to interlock against <a href="#L765" title="utils/cache/relmapper.c:765">load_relmap_file</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we use the same WAL record for updating the relmap of an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * existing database as we do for creating a new database. In the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * latter case, taking the relmap log and sending sinval messages is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unnecessary, but harmless. If we wanted to avoid it, we could add a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * flag to the WAL record to indicate which operation is being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * performed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(RelationMappingLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L889" title="utils/cache/relmapper.c:889">write_relmap_file</a>(&amp;newmap, <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec-&gt;dbid, xlrec-&gt;tsid, dbpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(RelationMappingLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(dbpath);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;<a href="#L1096" title="utils/cache/relmapper.c:1096">relmap_redo</a>: unknown op code </span><span class="Special">%u</span><span class="Constant">&quot;</span>, info);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
