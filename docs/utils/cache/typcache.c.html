<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/cache/typcache.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/cache/typcache.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L287">NextRecordTypmod</a></li>
<li><a href="#L285">RecordCacheArray</a></li>
<li><a href="#L286">RecordCacheArrayLen</a></li>
<li><a href="#L276">RecordCacheHash</a></li>
<li><a href="#L78">TypeCacheHash</a></li>
<li><a href="#L81">firstDomainTypeEntry</a></li>
<li><a href="#L256">srtr_record_table_params</a></li>
<li><a href="#L266">srtr_typmod_table_params</a></li>
<li><a href="#L294">tupledesc_id_counter</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L124">DomainConstraintCache</a></li>
<li><a href="#L136">EnumItem</a></li>
<li><a href="#L278">RecordCacheArrayEntry</a></li>
<li><a href="#L282">RecordCacheArrayEntry</a></li>
<li><a href="#L157">RecordCacheEntry</a></li>
<li><a href="#L160">RecordCacheEntry</a></li>
<li><a href="#L196">SharedRecordTableEntry</a></li>
<li><a href="#L199">SharedRecordTableEntry</a></li>
<li><a href="#L182">SharedRecordTableKey</a></li>
<li><a href="#L190">SharedRecordTableKey</a></li>
<li><a href="#L166">SharedRecordTypmodRegistry</a></li>
<li><a href="#L205">SharedTypmodTableEntry</a></li>
<li><a href="#L209">SharedTypmodTableEntry</a></li>
<li><a href="#L138">TypeCacheEnumData</a></li>
<li><a href="#L144">TypeCacheEnumData</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1400">DomainHasConstraints</a></li>
<li><a href="#L1313">InitDomainConstraintRef</a></li>
<li><a href="#L2207">SharedRecordTypmodRegistryAttach</a></li>
<li><a href="#L2086">SharedRecordTypmodRegistryEstimate</a></li>
<li><a href="#L2108">SharedRecordTypmodRegistryInit</a></li>
<li><a href="#L2424">TypeCacheConstrCallback</a></li>
<li><a href="#L2395">TypeCacheOpcCallback</a></li>
<li><a href="#L2290">TypeCacheRelCallback</a></li>
<li><a href="#L2355">TypeCacheTypCallback</a></li>
<li><a href="#L1351">UpdateDomainConstraintRef</a></li>
<li><a href="#L1435">array_element_has_compare</a></li>
<li><a href="#L1427">array_element_has_equality</a></li>
<li><a href="#L1451">array_element_has_extended_hashing</a></li>
<li><a href="#L1443">array_element_has_hashing</a></li>
<li><a href="#L2045">assign_record_type_identifier</a></li>
<li><a href="#L1953">assign_record_type_typmod</a></li>
<li><a href="#L1459">cache_array_element_properties</a></li>
<li><a href="#L1682">cache_multirange_element_properties</a></li>
<li><a href="#L1642">cache_range_element_properties</a></li>
<li><a href="#L1521">cache_record_field_properties</a></li>
<li><a href="#L2477">compare_values_of_enum</a></li>
<li><a href="#L1254">dccref_deletion_callback</a></li>
<li><a href="#L1230">dcs_cmp</a></li>
<li><a href="#L1243">decr_dcc_refcount</a></li>
<li><a href="#L1710">ensure_record_cache_typmod_slot_exists</a></li>
<li><a href="#L2448">enum_known_sorted</a></li>
<li><a href="#L2722">enum_oid_cmp</a></li>
<li><a href="#L2705">find_enumitem</a></li>
<li><a href="#L2756">find_or_make_matching_shared_tupledesc</a></li>
<li><a href="#L994">load_domaintype_info</a></li>
<li><a href="#L2550">load_enum_cache_data</a></li>
<li><a href="#L972">load_multirangetype_info</a></li>
<li><a href="#L914">load_rangetype_info</a></li>
<li><a href="#L880">load_typcache_tupdesc</a></li>
<li><a href="#L1833">lookup_rowtype_tupdesc</a></li>
<li><a href="#L1867">lookup_rowtype_tupdesc_copy</a></li>
<li><a href="#L1889">lookup_rowtype_tupdesc_domain</a></li>
<li><a href="#L1739">lookup_rowtype_tupdesc_internal</a></li>
<li><a href="#L1850">lookup_rowtype_tupdesc_noerror</a></li>
<li><a href="#L346">lookup_type_cache</a></li>
<li><a href="#L1674">multirange_element_has_extended_hashing</a></li>
<li><a href="#L1666">multirange_element_has_hashing</a></li>
<li><a href="#L1275">prep_domain_constraints</a></li>
<li><a href="#L1634">range_element_has_extended_hashing</a></li>
<li><a href="#L1626">range_element_has_hashing</a></li>
<li><a href="#L1497">record_fields_have_compare</a></li>
<li><a href="#L1489">record_fields_have_equality</a></li>
<li><a href="#L1513">record_fields_have_extended_hashing</a></li>
<li><a href="#L1505">record_fields_have_hashing</a></li>
<li><a href="#L1937">record_type_typmod_compare</a></li>
<li><a href="#L1926">record_type_typmod_hash</a></li>
<li><a href="#L2735">share_tupledesc</a></li>
<li><a href="#L215">shared_record_table_compare</a></li>
<li><a href="#L241">shared_record_table_hash</a></li>
<li><a href="#L2868">shared_record_typmod_registry_detach</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L85">TCFLAGS_CHECKED_BTREE_OPCLASS</a></li>
<li><a href="#L90">TCFLAGS_CHECKED_CMP_PROC</a></li>
<li><a href="#L103">TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS</a></li>
<li><a href="#L93">TCFLAGS_CHECKED_ELEM_PROPERTIES</a></li>
<li><a href="#L87">TCFLAGS_CHECKED_EQ_OPR</a></li>
<li><a href="#L98">TCFLAGS_CHECKED_FIELD_PROPERTIES</a></li>
<li><a href="#L89">TCFLAGS_CHECKED_GT_OPR</a></li>
<li><a href="#L92">TCFLAGS_CHECKED_HASH_EXTENDED_PROC</a></li>
<li><a href="#L86">TCFLAGS_CHECKED_HASH_OPCLASS</a></li>
<li><a href="#L91">TCFLAGS_CHECKED_HASH_PROC</a></li>
<li><a href="#L88">TCFLAGS_CHECKED_LT_OPR</a></li>
<li><a href="#L104">TCFLAGS_DOMAIN_BASE_IS_COMPOSITE</a></li>
<li><a href="#L95">TCFLAGS_HAVE_ELEM_COMPARE</a></li>
<li><a href="#L94">TCFLAGS_HAVE_ELEM_EQUALITY</a></li>
<li><a href="#L97">TCFLAGS_HAVE_ELEM_EXTENDED_HASHING</a></li>
<li><a href="#L96">TCFLAGS_HAVE_ELEM_HASHING</a></li>
<li><a href="#L100">TCFLAGS_HAVE_FIELD_COMPARE</a></li>
<li><a href="#L99">TCFLAGS_HAVE_FIELD_EQUALITY</a></li>
<li><a href="#L102">TCFLAGS_HAVE_FIELD_EXTENDED_HASHING</a></li>
<li><a href="#L101">TCFLAGS_HAVE_FIELD_HASHING</a></li>
<li><a href="#L84">TCFLAGS_HAVE_PG_TYPE_DATA</a></li>
<li><a href="#L107">TCFLAGS_OPERATOR_FLAGS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * typcache.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; POSTGRES type cache code<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The type cache exists to speed lookup of certain information about data<br/></li>
<li></span><span class="Comment"> * types that is not directly available from a type's pg_type row.&nbsp; For<br/></li>
<li></span><span class="Comment"> * example, we use a type's default btree opclass, or the default <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment"> * opclass if no btree opclass exists, to determine which operators should<br/></li>
<li></span><span class="Comment"> * be used for grouping and sorting the type (GROUP BY, ORDER BY ASC/DESC).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Several seemingly-odd choices have been made to support use of the type<br/></li>
<li></span><span class="Comment"> * cache by generic array and record handling routines, such as <a href="../adt/arrayfuncs.c.html#L3795" title="utils/adt/arrayfuncs.c:3795">array_eq</a>(),<br/></li>
<li></span><span class="Comment"> * <a href="../adt/rowtypes.c.html#L823" title="utils/adt/rowtypes.c:823">record_cmp</a>(), and <a href="../adt/arrayfuncs.c.html#L4139" title="utils/adt/arrayfuncs.c:4139">hash_array</a>().&nbsp; Because those routines are used as index<br/></li>
<li></span><span class="Comment"> * support operations, they cannot leak memory.&nbsp; To allow them to execute<br/></li>
<li></span><span class="Comment"> * efficiently, all information that they would like to re-use across calls<br/></li>
<li></span><span class="Comment"> * is kept in the type cache.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Once created, a type cache entry lives as long as the backend does, so<br/></li>
<li></span><span class="Comment"> * there is no need for a call to release a cache entry.&nbsp; If the type is<br/></li>
<li></span><span class="Comment"> * dropped, the cache entry simply becomes wasted storage.&nbsp; This is not<br/></li>
<li></span><span class="Comment"> * expected to happen often, and assuming that typcache entries are good<br/></li>
<li></span><span class="Comment"> * permanently allows caching pointers to them in long-lived places.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We have some provisions for updating cache entries if the stored data<br/></li>
<li></span><span class="Comment"> * becomes obsolete.&nbsp; Core data extracted from the pg_type row is updated<br/></li>
<li></span><span class="Comment"> * when we detect updates to pg_type.&nbsp; Information dependent on opclasses is<br/></li>
<li></span><span class="Comment"> * cleared if we detect updates to pg_opclass.&nbsp; We also support clearing the<br/></li>
<li></span><span class="Comment"> * tuple descriptor and operator/function parts of a rowtype's cache entry,<br/></li>
<li></span><span class="Comment"> * since those may need to change as a consequence of ALTER TABLE.&nbsp; Domain<br/></li>
<li></span><span class="Comment"> * constraint changes are also tracked properly.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/cache/typcache.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/nbtree.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/parallel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/relation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/session.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_am.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_constraint.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_enum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_operator.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_range.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/defrem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/int.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/dshash.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lwlock.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/catcache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgroids.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/typcache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* The <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> type cache hashtable searched by <a href="#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a> */<br/></li>
<li><a id="L78">&#x200c;</a></span><span class="Type">static</span> <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">TypeCacheHash</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* List of type cache entries for domain types */<br/></li>
<li><a id="L81">&#x200c;</a></span><span class="Type">static</span> TypeCacheEntry *<span class="linkable">firstDomainTypeEntry</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Private flag bits in the TypeCacheEntry.flags field */<br/></li>
<li><a id="L84">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TCFLAGS_HAVE_PG_TYPE_DATA</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x000001<br/></li>
<li><a id="L85">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TCFLAGS_CHECKED_BTREE_OPCLASS</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x000002<br/></li>
<li><a id="L86">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TCFLAGS_CHECKED_HASH_OPCLASS</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x000004<br/></li>
<li><a id="L87">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TCFLAGS_CHECKED_EQ_OPR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x000008<br/></li>
<li><a id="L88">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TCFLAGS_CHECKED_LT_OPR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x000010<br/></li>
<li><a id="L89">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TCFLAGS_CHECKED_GT_OPR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x000020<br/></li>
<li><a id="L90">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TCFLAGS_CHECKED_CMP_PROC</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x000040<br/></li>
<li><a id="L91">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TCFLAGS_CHECKED_HASH_PROC</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x000080<br/></li>
<li><a id="L92">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TCFLAGS_CHECKED_HASH_EXTENDED_PROC</span>&nbsp; &nbsp; </span><span class="Constant">0x000100<br/></li>
<li><a id="L93">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TCFLAGS_CHECKED_ELEM_PROPERTIES</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x000200<br/></li>
<li><a id="L94">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TCFLAGS_HAVE_ELEM_EQUALITY</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x000400<br/></li>
<li><a id="L95">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TCFLAGS_HAVE_ELEM_COMPARE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x000800<br/></li>
<li><a id="L96">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TCFLAGS_HAVE_ELEM_HASHING</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x001000<br/></li>
<li><a id="L97">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TCFLAGS_HAVE_ELEM_EXTENDED_HASHING</span>&nbsp; &nbsp; </span><span class="Constant">0x002000<br/></li>
<li><a id="L98">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TCFLAGS_CHECKED_FIELD_PROPERTIES</span>&nbsp; &nbsp; </span><span class="Constant">0x004000<br/></li>
<li><a id="L99">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TCFLAGS_HAVE_FIELD_EQUALITY</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x008000<br/></li>
<li><a id="L100">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TCFLAGS_HAVE_FIELD_COMPARE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x010000<br/></li>
<li><a id="L101">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TCFLAGS_HAVE_FIELD_HASHING</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x020000<br/></li>
<li><a id="L102">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TCFLAGS_HAVE_FIELD_EXTENDED_HASHING</span>&nbsp; &nbsp; </span><span class="Constant">0x040000<br/></li>
<li><a id="L103">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS</span>&nbsp; &nbsp; </span><span class="Constant">0x080000<br/></li>
<li><a id="L104">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TCFLAGS_DOMAIN_BASE_IS_COMPOSITE</span>&nbsp; &nbsp; </span><span class="Constant">0x100000<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* The flags associated with equality/comparison/hashing are all but these: */<br/></li>
<li><a id="L107">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TCFLAGS_OPERATOR_FLAGS</span> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (~(<a href="#L84" title="utils/cache/typcache.c:84">TCFLAGS_HAVE_PG_TYPE_DATA</a> | \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp;&nbsp; <a href="#L103" title="utils/cache/typcache.c:103">TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS</a> | \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp;&nbsp; <a href="#L104" title="utils/cache/typcache.c:104">TCFLAGS_DOMAIN_BASE_IS_COMPOSITE</a>))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Data stored about a domain type's constraints.&nbsp; Note that we do not create<br/></li>
<li></span><span class="Comment"> * this struct for the common case of a constraint-less domain; we just set<br/></li>
<li></span><span class="Comment"> * domainData to NULL to indicate that.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Within a <a href="#L124" title="utils/cache/typcache.c:124">DomainConstraintCache</a>, we store expression plan trees, but the<br/></li>
<li></span><span class="Comment"> * check_exprstate fields of the DomainConstraintState nodes are just NULL.<br/></li>
<li></span><span class="Comment"> * When needed, expression evaluation nodes are built by flat-copying the<br/></li>
<li></span><span class="Comment"> * DomainConstraintState nodes and applying <a href="../../executor/execExpr.c.html#L134" title="executor/execExpr.c:134">ExecInitExpr</a> to check_expr.<br/></li>
<li></span><span class="Comment"> * Such a node tree is not part of the <a href="#L124" title="utils/cache/typcache.c:124">DomainConstraintCache</a>, but is<br/></li>
<li></span><span class="Comment"> * considered to belong to a DomainConstraintRef.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L124">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">DomainConstraintCache</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *constraints;&nbsp; &nbsp; <span class="Comment">/* list of DomainConstraintState nodes */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext dccContext;&nbsp; &nbsp; <span class="Comment">/* memory context holding all associated data */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; dccRefCount;&nbsp; &nbsp; <span class="Comment">/* number of references to this struct */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Private information to support comparisons of enum <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; enum_oid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OID of one enum value */<br/></li>
<li></span>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; sort_order;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* its sort position */<br/></li>
<li><a id="L136">&#x200c;</a></span>} <span class="linkable">EnumItem</span>;<br/></li>
<li><br/></li>
<li><a id="L138">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">TypeCacheEnumData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmap_base;&nbsp; &nbsp; <span class="Comment">/* OID corresponding to <a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> 0 of bitmapset */<br/></li>
<li></span>&nbsp; &nbsp; Bitmapset&nbsp; *sorted_values;&nbsp; &nbsp; <span class="Comment">/* Set of OIDs known to be in order */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_values;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* total number of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in enum */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L136" title="utils/cache/typcache.c:136">EnumItem</a>&nbsp; &nbsp; enum_values[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L144">&#x200c;</a>} <span class="linkable">TypeCacheEnumData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We use a separate table for storing the definitions of non-anonymous<br/></li>
<li></span><span class="Comment"> * record types.&nbsp; Once defined, a record type will be remembered for the<br/></li>
<li></span><span class="Comment"> * life of the backend.&nbsp; Subsequent uses of the &quot;same&quot; record type (where<br/></li>
<li></span><span class="Comment"> * sameness means <a href="../../access/common/tupdesc.c.html#L586" title="access/common/tupdesc.c:586">equalRowTypes</a>) will refer to the existing table entry.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Stored record types are remembered in a linear array of TupleDescs,<br/></li>
<li></span><span class="Comment"> * which can be indexed quickly with the assigned typmod.&nbsp; There is also<br/></li>
<li></span><span class="Comment"> * a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table to speed searches for matching TupleDescs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L157">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">RecordCacheEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li><a id="L160">&#x200c;</a>} <span class="linkable">RecordCacheEntry</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * To deal with non-anonymous record types that are exchanged by backends<br/></li>
<li></span><span class="Comment"> * involved in a parallel query, we also need a shared version of the above.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L166">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">SharedRecordTypmodRegistry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* A <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table for finding a matching TupleDesc. */<br/></li>
<li></span>&nbsp; &nbsp; dshash_table_handle record_table_handle;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* A <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table for finding a TupleDesc by typmod. */<br/></li>
<li></span>&nbsp; &nbsp; dshash_table_handle typmod_table_handle;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* A source of new record typmod numbers. */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_uint32 next_typmod;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When using shared tuple descriptors as <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table keys we need a way to be<br/></li>
<li></span><span class="Comment"> * able to search for an <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> shared TupleDesc using a backend-local<br/></li>
<li></span><span class="Comment"> * TupleDesc.&nbsp; So we use this type which can hold either, and <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> and <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a><br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that know how to handle both.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L182">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">SharedRecordTableKey</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">union<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; local_tupdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dsa_pointer shared_tupdesc;<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; shared;<br/></li>
<li><a id="L190">&#x200c;</a>} <span class="linkable">SharedRecordTableKey</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The shared version of <a href="#L157" title="utils/cache/typcache.c:157">RecordCacheEntry</a>.&nbsp; This lets us look up a typmod<br/></li>
<li></span><span class="Comment"> * using a TupleDesc which may be in local or shared memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L196">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">SharedRecordTableEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L182" title="utils/cache/typcache.c:182">SharedRecordTableKey</a> key;<br/></li>
<li><a id="L199">&#x200c;</a>} <span class="linkable">SharedRecordTableEntry</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * An entry in <a href="#L166" title="utils/cache/typcache.c:166">SharedRecordTypmodRegistry</a>'s typmod table.&nbsp; This lets us look<br/></li>
<li></span><span class="Comment"> * up a TupleDesc in shared memory using a typmod.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L205">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">SharedTypmodTableEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; typmod;<br/></li>
<li>&nbsp; &nbsp; dsa_pointer shared_tupdesc;<br/></li>
<li><a id="L209">&#x200c;</a>} <span class="linkable">SharedTypmodTableEntry</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A comparator function for <a href="#L182" title="utils/cache/typcache.c:182">SharedRecordTableKey</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L215">&#x200c;</a></span><span class="linkable">shared_record_table_compare</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b, <span class="Type">size_t</span> size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a>&nbsp;&nbsp; *area = (<a href="../mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *) arg;<br/></li>
<li>&nbsp; &nbsp; <a href="#L182" title="utils/cache/typcache.c:182">SharedRecordTableKey</a> *k1 = (<a href="#L182" title="utils/cache/typcache.c:182">SharedRecordTableKey</a> *) a;<br/></li>
<li>&nbsp; &nbsp; <a href="#L182" title="utils/cache/typcache.c:182">SharedRecordTableKey</a> *k2 = (<a href="#L182" title="utils/cache/typcache.c:182">SharedRecordTableKey</a> *) b;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; t1;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; t2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (k1-&gt;shared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; t1 = (TupleDesc) <a href="../mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, k1-&gt;u.shared_tupdesc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; t1 = k1-&gt;u.local_tupdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (k2-&gt;shared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; t2 = (TupleDesc) <a href="../mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, k2-&gt;u.shared_tupdesc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; t2 = k2-&gt;u.local_tupdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../access/common/tupdesc.c.html#L586" title="access/common/tupdesc.c:586">equalRowTypes</a>(t1, t2) ? <span class="Constant">0</span> : <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function for <a href="#L182" title="utils/cache/typcache.c:182">SharedRecordTableKey</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint32<br/></li>
<li><a id="L241">&#x200c;</a><span class="linkable">shared_record_table_hash</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">size_t</span> size, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a>&nbsp;&nbsp; *area = (<a href="../mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *) arg;<br/></li>
<li>&nbsp; &nbsp; <a href="#L182" title="utils/cache/typcache.c:182">SharedRecordTableKey</a> *k = (<a href="#L182" title="utils/cache/typcache.c:182">SharedRecordTableKey</a> *) a;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; t;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (k-&gt;shared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; t = (TupleDesc) <a href="../mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, k-&gt;u.shared_tupdesc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; t = k-&gt;u.local_tupdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../access/common/tupdesc.c.html#L622" title="access/common/tupdesc.c:622">hashRowType</a>(t);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Parameters for <a href="#L166" title="utils/cache/typcache.c:166">SharedRecordTypmodRegistry</a>'s TupleDesc table. */<br/></li>
<li><a id="L256">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> dshash_parameters <span class="linkable">srtr_record_table_params</span> = {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L182" title="utils/cache/typcache.c:182">SharedRecordTableKey</a>),&nbsp; &nbsp; <span class="Comment">/* unused */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L196" title="utils/cache/typcache.c:196">SharedRecordTableEntry</a>),<br/></li>
<li>&nbsp; &nbsp; <a href="#L215" title="utils/cache/typcache.c:215">shared_record_table_compare</a>,<br/></li>
<li>&nbsp; &nbsp; <a href="#L241" title="utils/cache/typcache.c:241">shared_record_table_hash</a>,<br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/dshash.c.html#L590" title="lib/dshash.c:590">dshash_memcpy</a>,<br/></li>
<li>&nbsp; &nbsp; LWTRANCHE_PER_SESSION_RECORD_TYPE<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Parameters for <a href="#L166" title="utils/cache/typcache.c:166">SharedRecordTypmodRegistry</a>'s typmod <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table. */<br/></li>
<li><a id="L266">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> dshash_parameters <span class="linkable">srtr_typmod_table_params</span> = {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32),<br/></li>
<li>&nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L205" title="utils/cache/typcache.c:205">SharedTypmodTableEntry</a>),<br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/dshash.c.html#L572" title="lib/dshash.c:572">dshash_memcmp</a>,<br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/dshash.c.html#L581" title="lib/dshash.c:581">dshash_memhash</a>,<br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/dshash.c.html#L590" title="lib/dshash.c:590">dshash_memcpy</a>,<br/></li>
<li>&nbsp; &nbsp; LWTRANCHE_PER_SESSION_RECORD_TYPMOD<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* hashtable for recognizing registered record types */<br/></li>
<li><a id="L276">&#x200c;</a></span><span class="Type">static</span> <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">RecordCacheHash</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><a id="L278">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">RecordCacheArrayEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; id;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li><a id="L282">&#x200c;</a>} <span class="linkable">RecordCacheArrayEntry</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* array of info about registered record types, indexed by assigned typmod */<br/></li>
<li><a id="L285">&#x200c;</a></span><span class="Type">static</span> <a href="#L278" title="utils/cache/typcache.c:278">RecordCacheArrayEntry</a> *<span class="linkable">RecordCacheArray</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L286">&#x200c;</a><span class="Type">static</span> int32 <span class="linkable">RecordCacheArrayLen</span> = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* allocated length of above array */<br/></li>
<li><a id="L287">&#x200c;</a></span><span class="Type">static</span> int32 <span class="linkable">NextRecordTypmod</span> = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* number of entries used */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process-wide counter for generating unique tupledesc identifiers.<br/></li>
<li></span><span class="Comment"> * Zero and one (INVALID_TUPLEDESC_IDENTIFIER) aren't allowed to be chosen<br/></li>
<li></span><span class="Comment"> * as identifiers, so we start the counter at INVALID_TUPLEDESC_IDENTIFIER.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L294">&#x200c;</a></span><span class="Type">static</span> uint64 <span class="linkable">tupledesc_id_counter</span> = INVALID_TUPLEDESC_IDENTIFIER;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L880" title="utils/cache/typcache.c:880">load_typcache_tupdesc</a>(TypeCacheEntry *typentry);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L914" title="utils/cache/typcache.c:914">load_rangetype_info</a>(TypeCacheEntry *typentry);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L972" title="utils/cache/typcache.c:972">load_multirangetype_info</a>(TypeCacheEntry *typentry);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L994" title="utils/cache/typcache.c:994">load_domaintype_info</a>(TypeCacheEntry *typentry);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1230" title="utils/cache/typcache.c:1230">dcs_cmp</a>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1243" title="utils/cache/typcache.c:1243">decr_dcc_refcount</a>(<a href="#L124" title="utils/cache/typcache.c:124">DomainConstraintCache</a> *dcc);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1254" title="utils/cache/typcache.c:1254">dccref_deletion_callback</a>(<span class="Type">void</span> *arg);<br/></li>
<li><span class="Type">static</span> List *<a href="#L1275" title="utils/cache/typcache.c:1275">prep_domain_constraints</a>(List *constraints, MemoryContext execctx);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1427" title="utils/cache/typcache.c:1427">array_element_has_equality</a>(TypeCacheEntry *typentry);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1435" title="utils/cache/typcache.c:1435">array_element_has_compare</a>(TypeCacheEntry *typentry);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1443" title="utils/cache/typcache.c:1443">array_element_has_hashing</a>(TypeCacheEntry *typentry);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1451" title="utils/cache/typcache.c:1451">array_element_has_extended_hashing</a>(TypeCacheEntry *typentry);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1459" title="utils/cache/typcache.c:1459">cache_array_element_properties</a>(TypeCacheEntry *typentry);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1489" title="utils/cache/typcache.c:1489">record_fields_have_equality</a>(TypeCacheEntry *typentry);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1497" title="utils/cache/typcache.c:1497">record_fields_have_compare</a>(TypeCacheEntry *typentry);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1505" title="utils/cache/typcache.c:1505">record_fields_have_hashing</a>(TypeCacheEntry *typentry);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1513" title="utils/cache/typcache.c:1513">record_fields_have_extended_hashing</a>(TypeCacheEntry *typentry);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1521" title="utils/cache/typcache.c:1521">cache_record_field_properties</a>(TypeCacheEntry *typentry);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1626" title="utils/cache/typcache.c:1626">range_element_has_hashing</a>(TypeCacheEntry *typentry);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1634" title="utils/cache/typcache.c:1634">range_element_has_extended_hashing</a>(TypeCacheEntry *typentry);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1642" title="utils/cache/typcache.c:1642">cache_range_element_properties</a>(TypeCacheEntry *typentry);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1666" title="utils/cache/typcache.c:1666">multirange_element_has_hashing</a>(TypeCacheEntry *typentry);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1674" title="utils/cache/typcache.c:1674">multirange_element_has_extended_hashing</a>(TypeCacheEntry *typentry);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1682" title="utils/cache/typcache.c:1682">cache_multirange_element_properties</a>(TypeCacheEntry *typentry);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2290" title="utils/cache/typcache.c:2290">TypeCacheRelCallback</a>(Datum arg, Oid relid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2355" title="utils/cache/typcache.c:2355">TypeCacheTypCallback</a>(Datum arg, <span class="Type">int</span> cacheid, uint32 hashvalue);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2395" title="utils/cache/typcache.c:2395">TypeCacheOpcCallback</a>(Datum arg, <span class="Type">int</span> cacheid, uint32 hashvalue);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2424" title="utils/cache/typcache.c:2424">TypeCacheConstrCallback</a>(Datum arg, <span class="Type">int</span> cacheid, uint32 hashvalue);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2550" title="utils/cache/typcache.c:2550">load_enum_cache_data</a>(TypeCacheEntry *tcache);<br/></li>
<li><span class="Type">static</span> <a href="#L136" title="utils/cache/typcache.c:136">EnumItem</a> *<a href="#L2705" title="utils/cache/typcache.c:2705">find_enumitem</a>(<a href="#L138" title="utils/cache/typcache.c:138">TypeCacheEnumData</a> *enumdata, Oid arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2722" title="utils/cache/typcache.c:2722">enum_oid_cmp</a>(<span class="Type">const</span> <span class="Type">void</span> *left, <span class="Type">const</span> <span class="Type">void</span> *right);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2868" title="utils/cache/typcache.c:2868">shared_record_typmod_registry_detach</a>(<a href="../../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *segment,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum datum);<br/></li>
<li><span class="Type">static</span> TupleDesc <a href="#L2756" title="utils/cache/typcache.c:2756">find_or_make_matching_shared_tupledesc</a>(TupleDesc tupdesc);<br/></li>
<li><span class="Type">static</span> dsa_pointer <a href="#L2735" title="utils/cache/typcache.c:2735">share_tupledesc</a>(<a href="../mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, TupleDesc tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 typmod);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Fetch the type cache entry for the specified datatype, and make sure that<br/></li>
<li></span><span class="Comment"> * all the fields requested by bits in 'flags' are valid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is never NULL --- we will ereport() if the passed type OID is<br/></li>
<li></span><span class="Comment"> * invalid.&nbsp; Note however that we may fail to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one or more of the<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> requested by 'flags'; the caller needs to check whether the fields<br/></li>
<li></span><span class="Comment"> * are InvalidOid or not.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TypeCacheEntry *<br/></li>
<li><a id="L346">&#x200c;</a><span class="linkable">lookup_type_cache</span>(Oid type_id, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L78" title="utils/cache/typcache.c:78">TypeCacheHash</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First time through: <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TypeCacheEntry);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="utils/cache/typcache.c:78">TypeCacheHash</a> = <a href="../hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;Type information cache&quot;</span>, <span class="Constant">64</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;ctl, HASH_ELEM | HASH_BLOBS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Also set up callbacks for SI invalidations */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="inval.c.html#L1558" title="utils/cache/inval.c:1558">CacheRegisterRelcacheCallback</a>(<a href="#L2290" title="utils/cache/typcache.c:2290">TypeCacheRelCallback</a>, (Datum) <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(TYPEOID, <a href="#L2355" title="utils/cache/typcache.c:2355">TypeCacheTypCallback</a>, (Datum) <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(CLAOID, <a href="#L2395" title="utils/cache/typcache.c:2395">TypeCacheOpcCallback</a>, (Datum) <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(CONSTROID, <a href="#L2424" title="utils/cache/typcache.c:2424">TypeCacheConstrCallback</a>, (Datum) <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Also make sure <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a> exists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="catcache.c.html#L679" title="utils/cache/catcache.c:679">CreateCacheMemoryContext</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to look up an existing entry */<br/></li>
<li></span>&nbsp; &nbsp; typentry = (TypeCacheEntry *) <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L78" title="utils/cache/typcache.c:78">TypeCacheHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;type_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typentry == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one, we want to make one.&nbsp; But first look up the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_type row, just to make sure we don't make a cache entry for an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * invalid type OID.&nbsp; If the type OID is not valid, present a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * user-facing error, since some code paths such as <a href="../adt/domains.c.html#L227" title="utils/adt/domains.c:227">domain_in</a>() allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this function to be reached with a user-supplied OID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_type typtup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(type_id));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;type with OID </span><span class="Special">%u</span><span class="Constant"> does not exist&quot;</span>, type_id)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typtup = (Form_pg_type) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!typtup-&gt;typisdefined)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;type </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is only a shell&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(typtup-&gt;typname))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now make the typcache entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typentry = (TypeCacheEntry *) <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L78" title="utils/cache/typcache.c:78">TypeCacheHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;type_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!found);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it wasn't there a moment ago */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(typentry, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TypeCacheEntry));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* These fields can never change, by definition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;type_id = type_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;type_id_hash = GetSysCacheHashValue1(TYPEOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(type_id));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Keep this part in sync with the code below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typlen = typtup-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typbyval = typtup-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typalign = typtup-&gt;typalign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typstorage = typtup-&gt;typstorage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typtype = typtup-&gt;typtype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typrelid = typtup-&gt;typrelid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typsubscript = typtup-&gt;typsubscript;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typelem = typtup-&gt;typelem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typcollation = typtup-&gt;typcollation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags |= <a href="#L84" title="utils/cache/typcache.c:84">TCFLAGS_HAVE_PG_TYPE_DATA</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's a domain, immediately thread it into the domain cache list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;typtype == TYPTYPE_DOMAIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;nextDomain = <a href="#L81" title="utils/cache/typcache.c:81">firstDomainTypeEntry</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L81" title="utils/cache/typcache.c:81">firstDomainTypeEntry</a> = typentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!(typentry-&gt;flags &amp; <a href="#L84" title="utils/cache/typcache.c:84">TCFLAGS_HAVE_PG_TYPE_DATA</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have an entry, but its pg_type row got changed, so reload the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * data obtained directly from pg_type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_type typtup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tp = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(type_id));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;type with OID </span><span class="Special">%u</span><span class="Constant"> does not exist&quot;</span>, type_id)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typtup = (Form_pg_type) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!typtup-&gt;typisdefined)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;type </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is only a shell&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(typtup-&gt;typname))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Keep this part in sync with the code above.&nbsp; Many of these fields<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shouldn't ever change, particularly typtype, but copy 'em anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typlen = typtup-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typbyval = typtup-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typalign = typtup-&gt;typalign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typstorage = typtup-&gt;typstorage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typtype = typtup-&gt;typtype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typrelid = typtup-&gt;typrelid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typsubscript = typtup-&gt;typsubscript;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typelem = typtup-&gt;typelem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typcollation = typtup-&gt;typcollation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags |= <a href="#L84" title="utils/cache/typcache.c:84">TCFLAGS_HAVE_PG_TYPE_DATA</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up opclasses if we haven't already and <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> dependent info is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requested.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPECACHE_CMP_PROC |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPECACHE_BTREE_OPFAMILY)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !(typentry-&gt;flags &amp; <a href="#L85" title="utils/cache/typcache.c:85">TCFLAGS_CHECKED_BTREE_OPCLASS</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opclass;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opclass = <a href="../../commands/indexcmds.c.html#L2338" title="commands/indexcmds.c:2338">GetDefaultOpClass</a>(type_id, BTREE_AM_OID);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(opclass))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;btree_opf = <a href="lsyscache.c.html#L1190" title="utils/cache/lsyscache.c:1190">get_opclass_family</a>(opclass);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;btree_opintype = <a href="lsyscache.c.html#L1212" title="utils/cache/lsyscache.c:1212">get_opclass_input_type</a>(opclass);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;btree_opf = typentry-&gt;btree_opintype = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset information derived from btree opclass.&nbsp; Note in particular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that we'll redetermine the eq_opr even if we previously found one;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this matters in case a btree opclass has been added to a type that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * previously had only a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> opclass.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags &amp;= ~(<a href="#L87" title="utils/cache/typcache.c:87">TCFLAGS_CHECKED_EQ_OPR</a> |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L88" title="utils/cache/typcache.c:88">TCFLAGS_CHECKED_LT_OPR</a> |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L89" title="utils/cache/typcache.c:89">TCFLAGS_CHECKED_GT_OPR</a> |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L90" title="utils/cache/typcache.c:90">TCFLAGS_CHECKED_CMP_PROC</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags |= <a href="#L85" title="utils/cache/typcache.c:85">TCFLAGS_CHECKED_BTREE_OPCLASS</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we need to look up equality operator, and there's no btree opclass,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * force lookup of <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> opclass.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !(typentry-&gt;flags &amp; <a href="#L87" title="utils/cache/typcache.c:87">TCFLAGS_CHECKED_EQ_OPR</a>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;btree_opf == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flags |= TYPECACHE_HASH_OPFAMILY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPECACHE_HASH_EXTENDED_PROC |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPECACHE_HASH_EXTENDED_PROC_FINFO |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPECACHE_HASH_OPFAMILY)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !(typentry-&gt;flags &amp; <a href="#L86" title="utils/cache/typcache.c:86">TCFLAGS_CHECKED_HASH_OPCLASS</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opclass;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opclass = <a href="../../commands/indexcmds.c.html#L2338" title="commands/indexcmds.c:2338">GetDefaultOpClass</a>(type_id, HASH_AM_OID);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(opclass))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;hash_opf = <a href="lsyscache.c.html#L1190" title="utils/cache/lsyscache.c:1190">get_opclass_family</a>(opclass);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;hash_opintype = <a href="lsyscache.c.html#L1212" title="utils/cache/lsyscache.c:1212">get_opclass_input_type</a>(opclass);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;hash_opf = typentry-&gt;hash_opintype = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset information derived from <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> opclass.&nbsp; We do *not* reset the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * eq_opr; if we already found one from the btree opclass, that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decision is still good.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags &amp;= ~(<a href="#L91" title="utils/cache/typcache.c:91">TCFLAGS_CHECKED_HASH_PROC</a> |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L92" title="utils/cache/typcache.c:92">TCFLAGS_CHECKED_HASH_EXTENDED_PROC</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags |= <a href="#L86" title="utils/cache/typcache.c:86">TCFLAGS_CHECKED_HASH_OPCLASS</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look for requested operators and <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, if we haven't already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !(typentry-&gt;flags &amp; <a href="#L87" title="utils/cache/typcache.c:87">TCFLAGS_CHECKED_EQ_OPR</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eq_opr = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;btree_opf != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eq_opr = <a href="lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(typentry-&gt;btree_opf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typentry-&gt;btree_opintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typentry-&gt;btree_opintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTEqualStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (eq_opr == InvalidOid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;hash_opf != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eq_opr = <a href="lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(typentry-&gt;hash_opf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typentry-&gt;hash_opintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typentry-&gt;hash_opintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HTEqualStrategyNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the proposed equality operator is <a href="../adt/arrayfuncs.c.html#L3795" title="utils/adt/arrayfuncs.c:3795">array_eq</a> or <a href="../adt/rowtypes.c.html#L1067" title="utils/adt/rowtypes.c:1067">record_eq</a>, check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to see if the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type or column types support equality.&nbsp; If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not, <a href="../adt/arrayfuncs.c.html#L3795" title="utils/adt/arrayfuncs.c:3795">array_eq</a> or <a href="../adt/rowtypes.c.html#L1067" title="utils/adt/rowtypes.c:1067">record_eq</a> would fail at runtime, so we don't want<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to report that the type has equality.&nbsp; (We can omit similar<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checking for ranges and multiranges because ranges can't be created<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the first place unless their subtypes support equality.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (eq_opr == ARRAY_EQ_OP &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L1427" title="utils/cache/typcache.c:1427">array_element_has_equality</a>(typentry))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eq_opr = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (eq_opr == RECORD_EQ_OP &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="#L1489" title="utils/cache/typcache.c:1489">record_fields_have_equality</a>(typentry))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eq_opr = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Force update of eq_opr_finfo only if we're changing state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;eq_opr != eq_opr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;eq_opr_finfo.fn_oid = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;eq_opr = eq_opr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset info about <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> whenever we pick up new info about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * equality operator.&nbsp; This is so we can ensure that the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> match the operator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags &amp;= ~(<a href="#L91" title="utils/cache/typcache.c:91">TCFLAGS_CHECKED_HASH_PROC</a> |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L92" title="utils/cache/typcache.c:92">TCFLAGS_CHECKED_HASH_EXTENDED_PROC</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags |= <a href="#L87" title="utils/cache/typcache.c:87">TCFLAGS_CHECKED_EQ_OPR</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; TYPECACHE_LT_OPR) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !(typentry-&gt;flags &amp; <a href="#L88" title="utils/cache/typcache.c:88">TCFLAGS_CHECKED_LT_OPR</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lt_opr = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;btree_opf != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lt_opr = <a href="lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(typentry-&gt;btree_opf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typentry-&gt;btree_opintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typentry-&gt;btree_opintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTLessStrategyNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As above, make sure <a href="../adt/arrayfuncs.c.html#L3966" title="utils/adt/arrayfuncs.c:3966">array_cmp</a> or <a href="../adt/rowtypes.c.html#L823" title="utils/adt/rowtypes.c:823">record_cmp</a> will succeed; but again<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we need no special check for ranges or multiranges.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lt_opr == ARRAY_LT_OP &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L1435" title="utils/cache/typcache.c:1435">array_element_has_compare</a>(typentry))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lt_opr = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (lt_opr == RECORD_LT_OP &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="#L1497" title="utils/cache/typcache.c:1497">record_fields_have_compare</a>(typentry))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lt_opr = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;lt_opr = lt_opr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags |= <a href="#L88" title="utils/cache/typcache.c:88">TCFLAGS_CHECKED_LT_OPR</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; TYPECACHE_GT_OPR) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !(typentry-&gt;flags &amp; <a href="#L89" title="utils/cache/typcache.c:89">TCFLAGS_CHECKED_GT_OPR</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gt_opr = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;btree_opf != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gt_opr = <a href="lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(typentry-&gt;btree_opf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typentry-&gt;btree_opintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typentry-&gt;btree_opintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTGreaterStrategyNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As above, make sure <a href="../adt/arrayfuncs.c.html#L3966" title="utils/adt/arrayfuncs.c:3966">array_cmp</a> or <a href="../adt/rowtypes.c.html#L823" title="utils/adt/rowtypes.c:823">record_cmp</a> will succeed; but again<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we need no special check for ranges or multiranges.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (gt_opr == ARRAY_GT_OP &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L1435" title="utils/cache/typcache.c:1435">array_element_has_compare</a>(typentry))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gt_opr = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (gt_opr == RECORD_GT_OP &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="#L1497" title="utils/cache/typcache.c:1497">record_fields_have_compare</a>(typentry))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gt_opr = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;gt_opr = gt_opr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags |= <a href="#L89" title="utils/cache/typcache.c:89">TCFLAGS_CHECKED_GT_OPR</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !(typentry-&gt;flags &amp; <a href="#L90" title="utils/cache/typcache.c:90">TCFLAGS_CHECKED_CMP_PROC</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmp_proc = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;btree_opf != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmp_proc = <a href="lsyscache.c.html#L796" title="utils/cache/lsyscache.c:796">get_opfamily_proc</a>(typentry-&gt;btree_opf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typentry-&gt;btree_opintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typentry-&gt;btree_opintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTORDER_PROC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As above, make sure <a href="../adt/arrayfuncs.c.html#L3966" title="utils/adt/arrayfuncs.c:3966">array_cmp</a> or <a href="../adt/rowtypes.c.html#L823" title="utils/adt/rowtypes.c:823">record_cmp</a> will succeed; but again<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we need no special check for ranges or multiranges.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cmp_proc == F_BTARRAYCMP &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L1435" title="utils/cache/typcache.c:1435">array_element_has_compare</a>(typentry))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmp_proc = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (cmp_proc == F_BTRECORDCMP &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="#L1497" title="utils/cache/typcache.c:1497">record_fields_have_compare</a>(typentry))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmp_proc = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Force update of cmp_proc_finfo only if we're changing state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;cmp_proc != cmp_proc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;cmp_proc_finfo.fn_oid = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;cmp_proc = cmp_proc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags |= <a href="#L90" title="utils/cache/typcache.c:90">TCFLAGS_CHECKED_CMP_PROC</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !(typentry-&gt;flags &amp; <a href="#L91" title="utils/cache/typcache.c:91">TCFLAGS_CHECKED_HASH_PROC</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash_proc = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We insist that the eq_opr, if one has been determined, match the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> opclass; else report there is no <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;hash_opf != InvalidOid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (!OidIsValid(typentry-&gt;eq_opr) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typentry-&gt;eq_opr == <a href="lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(typentry-&gt;hash_opf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typentry-&gt;hash_opintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typentry-&gt;hash_opintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HTEqualStrategyNumber)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash_proc = <a href="lsyscache.c.html#L796" title="utils/cache/lsyscache.c:796">get_opfamily_proc</a>(typentry-&gt;hash_opf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;hash_opintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;hash_opintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASHSTANDARD_PROC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As above, make sure <a href="../adt/arrayfuncs.c.html#L4139" title="utils/adt/arrayfuncs.c:4139">hash_array</a>, <a href="../adt/rowtypes.c.html#L1794" title="utils/adt/rowtypes.c:1794">hash_record</a>, or <a href="../adt/rangetypes.c.html#L1330" title="utils/adt/rangetypes.c:1330">hash_range</a> will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * succeed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hash_proc == F_HASH_ARRAY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L1443" title="utils/cache/typcache.c:1443">array_element_has_hashing</a>(typentry))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash_proc = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (hash_proc == F_HASH_RECORD &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="#L1505" title="utils/cache/typcache.c:1505">record_fields_have_hashing</a>(typentry))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash_proc = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (hash_proc == F_HASH_RANGE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="#L1626" title="utils/cache/typcache.c:1626">range_element_has_hashing</a>(typentry))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash_proc = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Likewise for <a href="../adt/multirangetypes.c.html#L2787" title="utils/adt/multirangetypes.c:2787">hash_multirange</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hash_proc == F_HASH_MULTIRANGE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L1666" title="utils/cache/typcache.c:1666">multirange_element_has_hashing</a>(typentry))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash_proc = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Force update of hash_proc_finfo only if we're changing state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;hash_proc != hash_proc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;hash_proc_finfo.fn_oid = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;hash_proc = hash_proc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags |= <a href="#L91" title="utils/cache/typcache.c:91">TCFLAGS_CHECKED_HASH_PROC</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; (TYPECACHE_HASH_EXTENDED_PROC |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !(typentry-&gt;flags &amp; <a href="#L92" title="utils/cache/typcache.c:92">TCFLAGS_CHECKED_HASH_EXTENDED_PROC</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash_extended_proc = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We insist that the eq_opr, if one has been determined, match the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> opclass; else report there is no <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;hash_opf != InvalidOid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (!OidIsValid(typentry-&gt;eq_opr) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typentry-&gt;eq_opr == <a href="lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(typentry-&gt;hash_opf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typentry-&gt;hash_opintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typentry-&gt;hash_opintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HTEqualStrategyNumber)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash_extended_proc = <a href="lsyscache.c.html#L796" title="utils/cache/lsyscache.c:796">get_opfamily_proc</a>(typentry-&gt;hash_opf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typentry-&gt;hash_opintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typentry-&gt;hash_opintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASHEXTENDED_PROC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As above, make sure <a href="../adt/arrayfuncs.c.html#L4272" title="utils/adt/arrayfuncs.c:4272">hash_array_extended</a>, <a href="../adt/rowtypes.c.html#L1914" title="utils/adt/rowtypes.c:1914">hash_record_extended</a>, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../adt/rangetypes.c.html#L1396" title="utils/adt/rangetypes.c:1396">hash_range_extended</a> will succeed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hash_extended_proc == F_HASH_ARRAY_EXTENDED &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L1451" title="utils/cache/typcache.c:1451">array_element_has_extended_hashing</a>(typentry))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash_extended_proc = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (hash_extended_proc == F_HASH_RECORD_EXTENDED &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="#L1513" title="utils/cache/typcache.c:1513">record_fields_have_extended_hashing</a>(typentry))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash_extended_proc = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (hash_extended_proc == F_HASH_RANGE_EXTENDED &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="#L1634" title="utils/cache/typcache.c:1634">range_element_has_extended_hashing</a>(typentry))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash_extended_proc = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Likewise for <a href="../adt/multirangetypes.c.html#L2858" title="utils/adt/multirangetypes.c:2858">hash_multirange_extended</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hash_extended_proc == F_HASH_MULTIRANGE_EXTENDED &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L1674" title="utils/cache/typcache.c:1674">multirange_element_has_extended_hashing</a>(typentry))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash_extended_proc = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Force update of proc finfo only if we're changing state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;hash_extended_proc != hash_extended_proc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;hash_extended_proc_finfo.fn_oid = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;hash_extended_proc = hash_extended_proc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags |= <a href="#L92" title="utils/cache/typcache.c:92">TCFLAGS_CHECKED_HASH_EXTENDED_PROC</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up fmgr lookup info as requested<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we tell fmgr the finfo structures live in <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which is not quite right (they're really in the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table's private<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory context) but this will do for our purposes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: the code above avoids invalidating the finfo structs unless the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * referenced operator/function OID actually changes.&nbsp; This is to prevent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unnecessary leakage of <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subsidiary data attached to an finfo, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that would cause session-lifespan memory leaks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; TYPECACHE_EQ_OPR_FINFO) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;eq_opr_finfo.fn_oid == InvalidOid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;eq_opr != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eq_opr_func;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eq_opr_func = <a href="lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(typentry-&gt;eq_opr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (eq_opr_func != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(eq_opr_func, &amp;typentry-&gt;eq_opr_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; TYPECACHE_CMP_PROC_FINFO) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;cmp_proc_finfo.fn_oid == InvalidOid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;cmp_proc != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(typentry-&gt;cmp_proc, &amp;typentry-&gt;cmp_proc_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; TYPECACHE_HASH_PROC_FINFO) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;hash_proc_finfo.fn_oid == InvalidOid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;hash_proc != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(typentry-&gt;hash_proc, &amp;typentry-&gt;hash_proc_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; TYPECACHE_HASH_EXTENDED_PROC_FINFO) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;hash_extended_proc_finfo.fn_oid == InvalidOid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;hash_extended_proc != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(typentry-&gt;hash_extended_proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;typentry-&gt;hash_extended_proc_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's a composite type (row type), get tupdesc if requested<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; TYPECACHE_TUPDESC) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;tupDesc == <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typtype == TYPTYPE_COMPOSITE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L880" title="utils/cache/typcache.c:880">load_typcache_tupdesc</a>(typentry);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If requested, get information about a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This includes making sure that the basic info about the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * type is up-to-date.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; TYPECACHE_RANGE_INFO) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typtype == TYPTYPE_RANGE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;rngelemtype == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L914" title="utils/cache/typcache.c:914">load_rangetype_info</a>(typentry);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!(typentry-&gt;rngelemtype-&gt;flags &amp; <a href="#L84" title="utils/cache/typcache.c:84">TCFLAGS_HAVE_PG_TYPE_DATA</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(typentry-&gt;rngelemtype-&gt;type_id, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If requested, get information about a multirange type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; TYPECACHE_MULTIRANGE_INFO) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;rngtype == <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typtype == TYPTYPE_MULTIRANGE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L972" title="utils/cache/typcache.c:972">load_multirangetype_info</a>(typentry);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If requested, get information about a domain type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; TYPECACHE_DOMAIN_BASE_INFO) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;domainBaseType == InvalidOid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typtype == TYPTYPE_DOMAIN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;domainBaseTypmod = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;domainBaseType =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lsyscache.c.html#L2538" title="utils/cache/lsyscache.c:2538">getBaseTypeAndTypmod</a>(type_id, &amp;typentry-&gt;domainBaseTypmod);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; TYPECACHE_DOMAIN_CONSTR_INFO) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (typentry-&gt;flags &amp; <a href="#L103" title="utils/cache/typcache.c:103">TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS</a>) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typtype == TYPTYPE_DOMAIN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L994" title="utils/cache/typcache.c:994">load_domaintype_info</a>(typentry);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> typentry;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L880" title="utils/cache/typcache.c:880">load_typcache_tupdesc</a> --- helper routine to set up composite type's tupDesc<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L880">&#x200c;</a></span><span class="linkable">load_typcache_tupdesc</span>(TypeCacheEntry *typentry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(typentry-&gt;typrelid))&nbsp; &nbsp; <span class="Comment">/* should not happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid typrelid for composite type </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typentry-&gt;type_id);<br/></li>
<li>&nbsp; &nbsp; rel = <a href="../../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(typentry-&gt;typrelid, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; Assert(rel-&gt;rd_rel-&gt;reltype == typentry-&gt;type_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Link to the tupdesc and increment its refcount (we assert it's a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * refcounted descriptor).&nbsp; We don't use <a href="../../access/common/tupdesc.c.html#L388" title="access/common/tupdesc.c:388">IncrTupleDescRefCount</a>() for this,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because the reference mustn't be entered in the current resource owner;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it can outlive the current query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; typentry-&gt;tupDesc = RelationGetDescr(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(typentry-&gt;tupDesc-&gt;tdrefcount &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; typentry-&gt;tupDesc-&gt;tdrefcount++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In future, we could take some pains to not change tupDesc_identifier if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the tupdesc didn't really change; but for <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> it's not worth it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; typentry-&gt;tupDesc_identifier = ++<a href="#L294" title="utils/cache/typcache.c:294">tupledesc_id_counter</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(rel, AccessShareLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L914" title="utils/cache/typcache.c:914">load_rangetype_info</a> --- helper routine to set up <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type information<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L914">&#x200c;</a></span><span class="linkable">load_rangetype_info</span>(TypeCacheEntry *typentry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Form_pg_range pg_range;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subtypeOid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opclassOid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; canonicalOid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subdiffOid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfamilyOid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcintype;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmpFnOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* get information from pg_range */<br/></li>
<li></span>&nbsp; &nbsp; tup = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RANGETYPE, ObjectIdGetDatum(typentry-&gt;type_id));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* should not fail, since we already checked typtype ... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typentry-&gt;type_id);<br/></li>
<li>&nbsp; &nbsp; pg_range = (Form_pg_range) GETSTRUCT(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; subtypeOid = pg_range-&gt;rngsubtype;<br/></li>
<li>&nbsp; &nbsp; typentry-&gt;rng_collation = pg_range-&gt;rngcollation;<br/></li>
<li>&nbsp; &nbsp; opclassOid = pg_range-&gt;rngsubopc;<br/></li>
<li>&nbsp; &nbsp; canonicalOid = pg_range-&gt;rngcanonical;<br/></li>
<li>&nbsp; &nbsp; subdiffOid = pg_range-&gt;rngsubdiff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* get opclass properties and look up the comparison function */<br/></li>
<li></span>&nbsp; &nbsp; opfamilyOid = <a href="lsyscache.c.html#L1190" title="utils/cache/lsyscache.c:1190">get_opclass_family</a>(opclassOid);<br/></li>
<li>&nbsp; &nbsp; opcintype = <a href="lsyscache.c.html#L1212" title="utils/cache/lsyscache.c:1212">get_opclass_input_type</a>(opclassOid);<br/></li>
<li>&nbsp; &nbsp; typentry-&gt;rng_opfamily = opfamilyOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cmpFnOid = <a href="lsyscache.c.html#L796" title="utils/cache/lsyscache.c:796">get_opfamily_proc</a>(opfamilyOid, opcintype, opcintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTORDER_PROC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!RegProcedureIsValid(cmpFnOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing support function </span><span class="Special">%d</span><span class="Constant">(</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) in opfamily </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTORDER_PROC, opcintype, opcintype, opfamilyOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set up cached fmgrinfo structs */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(cmpFnOid, &amp;typentry-&gt;rng_cmp_proc_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(canonicalOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(canonicalOid, &amp;typentry-&gt;rng_canonical_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(subdiffOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(subdiffOid, &amp;typentry-&gt;rng_subdiff_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Lastly, set up link to the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type --- this marks data valid */<br/></li>
<li></span>&nbsp; &nbsp; typentry-&gt;rngelemtype = <a href="#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(subtypeOid, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L972" title="utils/cache/typcache.c:972">load_multirangetype_info</a> --- helper routine to set up multirange type<br/></li>
<li></span><span class="Comment"> * information<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L972">&#x200c;</a></span><span class="linkable">load_multirangetype_info</span>(TypeCacheEntry *typentry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rangetypeOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rangetypeOid = <a href="lsyscache.c.html#L3483" title="utils/cache/lsyscache.c:3483">get_multirange_range</a>(typentry-&gt;type_id);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(rangetypeOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for multirange type </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typentry-&gt;type_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typentry-&gt;rngtype = <a href="#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(rangetypeOid, TYPECACHE_RANGE_INFO);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L994" title="utils/cache/typcache.c:994">load_domaintype_info</a> --- helper routine to set up domain constraint info<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we assume we're called in a relatively short-lived context, so it's<br/></li>
<li></span><span class="Comment"> * okay to leak data into the current context while scanning pg_constraint.<br/></li>
<li></span><span class="Comment"> * We build the new <a href="#L124" title="utils/cache/typcache.c:124">DomainConstraintCache</a> data in a context underneath<br/></li>
<li></span><span class="Comment"> * <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>, and reparent it under <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a> when<br/></li>
<li></span><span class="Comment"> * complete.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L994">&#x200c;</a></span><span class="linkable">load_domaintype_info</span>(TypeCacheEntry *typentry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeOid = typentry-&gt;type_id;<br/></li>
<li>&nbsp; &nbsp; <a href="#L124" title="utils/cache/typcache.c:124">DomainConstraintCache</a> *dcc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; notNull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; DomainConstraintState **ccons;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cconslen;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; conRel;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're here, <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing constraint info is stale, so release it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For safety, be sure to null the link <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> trying to delete the data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;domainData)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dcc = typentry-&gt;domainData;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;domainData = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1243" title="utils/cache/typcache.c:1243">decr_dcc_refcount</a>(dcc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We try to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> the common case of no domain constraints, so don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create the dcc object and context until we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a constraint.&nbsp; Likewise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the temp sorting array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dcc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ccons = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; cconslen = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan pg_constraint for relevant constraints.&nbsp; We want to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraints for not just this domain, but <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> ancestor domains, so the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outer loop crawls up the domain stack.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; conRel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(ConstraintRelationId, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; conTup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_type typTup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nccons = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKeyData key[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup = <a href="syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(typeOid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, typeOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typTup = (Form_pg_type) GETSTRUCT(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typTup-&gt;typtype != TYPTYPE_DOMAIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not a domain, so done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Test for NOT NULL Constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typTup-&gt;typnotnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notNull = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Look for CHECK Constraints on this domain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_constraint_contypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(typeOid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan = <a href="../../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(conRel, ConstraintTypidIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">1</span>, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(conTup = <a href="../../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint c = (Form_pg_constraint) GETSTRUCT(conTup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *constring;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *check_expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DomainConstraintState *r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore non-CHECK constraints */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (c-&gt;contype != CONSTRAINT_CHECK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not expecting conbin to be NULL, but we'll test for it anyway */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = fastgetattr(conTup, Anum_pg_constraint_conbin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conRel-&gt;rd_att, &amp;isNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;domain </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has NULL conbin&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(typTup-&gt;typname), NameStr(c-&gt;conname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Convert conbin to C string in caller context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constring = TextDatumGetCString(val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create the <a href="#L124" title="utils/cache/typcache.c:124">DomainConstraintCache</a> object and context if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dcc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext cxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt = AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Domain constraints&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_SMALL_SIZES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dcc = (<a href="#L124" title="utils/cache/typcache.c:124">DomainConstraintCache</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(cxt, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L124" title="utils/cache/typcache.c:124">DomainConstraintCache</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dcc-&gt;constraints = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dcc-&gt;dccContext = cxt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dcc-&gt;dccRefCount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create node trees in <a href="#L124" title="utils/cache/typcache.c:124">DomainConstraintCache</a>'s context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(dcc-&gt;dccContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; check_expr = (Expr *) <a href="../../nodes/read.c.html#L90" title="nodes/read.c:90">stringToNode</a>(constring);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Plan the expression, since <a href="../../executor/execExpr.c.html#L134" title="executor/execExpr.c:134">ExecInitExpr</a> will expect that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: caching the result of <a href="../../optimizer/plan/planner.c.html#L6457" title="optimizer/plan/planner.c:6457">expression_planner</a>() is not very<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * good practice.&nbsp; Ideally we'd use a CachedExpression here so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that we would react promptly to, eg, changes in inlined<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; However, because we don't support mutable domain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * CHECK constraints, it's not really clear that it's worth the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * extra overhead to do that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; check_expr = <a href="../../optimizer/plan/planner.c.html#L6457" title="optimizer/plan/planner.c:6457">expression_planner</a>(check_expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = makeNode(DomainConstraintState);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r-&gt;constrainttype = DOM_CONSTRAINT_CHECK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r-&gt;name = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(c-&gt;conname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r-&gt;check_expr = check_expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r-&gt;check_exprstate = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Accumulate constraints in an array, for sorting below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ccons == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cconslen = <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ccons = (DomainConstraintState **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(cconslen * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(DomainConstraintState *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (nccons &gt;= cconslen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cconslen *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ccons = (DomainConstraintState **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(ccons, cconslen * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(DomainConstraintState *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ccons[nccons++] = r;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nccons &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sort the items for this domain, so that CHECKs are applied in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deterministic order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nccons &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qsort(ccons, nccons, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(DomainConstraintState *), <a href="#L1230" title="utils/cache/typcache.c:1230">dcs_cmp</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now attach them to the overall list.&nbsp; Use <a href="../../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>() here because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraints of parent domains should be applied earlier.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(dcc-&gt;dccContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (nccons &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dcc-&gt;constraints = <a href="../../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(ccons[--nccons], dcc-&gt;constraints);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* loop to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> domain in stack */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typeOid = typTup-&gt;typbasetype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(conRel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Only need to add one NOT NULL check regardless of how many domains in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the stack request it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (notNull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DomainConstraintState *r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create the <a href="#L124" title="utils/cache/typcache.c:124">DomainConstraintCache</a> object and context if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dcc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext cxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt = AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Domain constraints&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_SMALL_SIZES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dcc = (<a href="#L124" title="utils/cache/typcache.c:124">DomainConstraintCache</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(cxt, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L124" title="utils/cache/typcache.c:124">DomainConstraintCache</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dcc-&gt;constraints = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dcc-&gt;dccContext = cxt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dcc-&gt;dccRefCount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create node trees in <a href="#L124" title="utils/cache/typcache.c:124">DomainConstraintCache</a>'s context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(dcc-&gt;dccContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r = makeNode(DomainConstraintState);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r-&gt;constrainttype = DOM_CONSTRAINT_NOTNULL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r-&gt;name = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;NOT NULL&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r-&gt;check_expr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r-&gt;check_exprstate = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a> to apply the nullness check FIRST */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dcc-&gt;constraints = <a href="../../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(r, dcc-&gt;constraints);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we made a constraint object, move it into <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a> and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attach it to the typcache entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dcc)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L637" title="utils/mmgr/mcxt.c:637">MemoryContextSetParent</a>(dcc-&gt;dccContext, <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;domainData = dcc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dcc-&gt;dccRefCount++;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* count the typcache's reference */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Either way, the typcache entry's domain data is <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> valid. */<br/></li>
<li></span>&nbsp; &nbsp; typentry-&gt;flags |= <a href="#L103" title="utils/cache/typcache.c:103">TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * qsort comparator to sort DomainConstraintState pointers by name<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1230">&#x200c;</a></span><span class="linkable">dcs_cmp</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> DomainConstraintState *<span class="Type">const</span> *ca = (<span class="Type">const</span> DomainConstraintState *<span class="Type">const</span> *) a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> DomainConstraintState *<span class="Type">const</span> *cb = (<span class="Type">const</span> DomainConstraintState *<span class="Type">const</span> *) b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> strcmp((*ca)-&gt;name, (*cb)-&gt;name);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1243" title="utils/cache/typcache.c:1243">decr_dcc_refcount</a> --- decrement a <a href="#L124" title="utils/cache/typcache.c:124">DomainConstraintCache</a>'s refcount,<br/></li>
<li></span><span class="Comment"> * and free it if no references remain<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1243">&#x200c;</a></span><span class="linkable">decr_dcc_refcount</span>(<a href="#L124" title="utils/cache/typcache.c:124">DomainConstraintCache</a> *dcc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(dcc-&gt;dccRefCount &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (--(dcc-&gt;dccRefCount) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(dcc-&gt;dccContext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Context reset/delete callback for a DomainConstraintRef<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1254">&#x200c;</a></span><span class="linkable">dccref_deletion_callback</span>(<span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DomainConstraintRef *ref = (DomainConstraintRef *) arg;<br/></li>
<li>&nbsp; &nbsp; <a href="#L124" title="utils/cache/typcache.c:124">DomainConstraintCache</a> *dcc = ref-&gt;dcc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Paranoia --- be sure link is nulled <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> trying to release */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dcc)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ref-&gt;constraints = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ref-&gt;dcc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1243" title="utils/cache/typcache.c:1243">decr_dcc_refcount</a>(dcc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1275" title="utils/cache/typcache.c:1275">prep_domain_constraints</a> --- prepare domain constraints for execution<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The expression trees stored in the <a href="#L124" title="utils/cache/typcache.c:124">DomainConstraintCache</a>'s list are<br/></li>
<li></span><span class="Comment"> * converted to executable expression state trees stored in execctx.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L1275">&#x200c;</a><span class="linkable">prep_domain_constraints</span>(List *constraints, MemoryContext execctx)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(execctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, constraints)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DomainConstraintState *r = (DomainConstraintState *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DomainConstraintState *newr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newr = makeNode(DomainConstraintState);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newr-&gt;constrainttype = r-&gt;constrainttype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newr-&gt;name = r-&gt;name;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newr-&gt;check_expr = r-&gt;check_expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newr-&gt;check_exprstate = <a href="../../executor/execExpr.c.html#L134" title="executor/execExpr.c:134">ExecInitExpr</a>(r-&gt;check_expr, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, newr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1313" title="utils/cache/typcache.c:1313">InitDomainConstraintRef</a> --- <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> a DomainConstraintRef struct<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must tell us the MemoryContext in which the DomainConstraintRef<br/></li>
<li></span><span class="Comment"> * lives.&nbsp; The ref will be cleaned up when that context is reset/deleted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must also tell us whether it wants check_exprstate fields to be<br/></li>
<li></span><span class="Comment"> * computed in the DomainConstraintState nodes attached to this ref.<br/></li>
<li></span><span class="Comment"> * If it doesn't, we need not make a copy of the DomainConstraintState list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1313">&#x200c;</a></span><span class="linkable">InitDomainConstraintRef</span>(Oid type_id, DomainConstraintRef *ref,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext refctx, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> need_exprstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look up the typcache entry --- we assume it survives indefinitely */<br/></li>
<li></span>&nbsp; &nbsp; ref-&gt;tcache = <a href="#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(type_id, TYPECACHE_DOMAIN_CONSTR_INFO);<br/></li>
<li>&nbsp; &nbsp; ref-&gt;need_exprstate = need_exprstate;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For safety, establish the callback <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> acquiring a refcount */<br/></li>
<li></span>&nbsp; &nbsp; ref-&gt;refctx = refctx;<br/></li>
<li>&nbsp; &nbsp; ref-&gt;dcc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ref-&gt;callback.func = <a href="#L1254" title="utils/cache/typcache.c:1254">dccref_deletion_callback</a>;<br/></li>
<li>&nbsp; &nbsp; ref-&gt;callback.arg = (<span class="Type">void</span> *) ref;<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L568" title="utils/mmgr/mcxt.c:568">MemoryContextRegisterResetCallback</a>(refctx, &amp;ref-&gt;callback);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Acquire refcount if there are constraints, and set up exported list */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ref-&gt;tcache-&gt;domainData)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ref-&gt;dcc = ref-&gt;tcache-&gt;domainData;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ref-&gt;dcc-&gt;dccRefCount++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ref-&gt;need_exprstate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ref-&gt;constraints = <a href="#L1275" title="utils/cache/typcache.c:1275">prep_domain_constraints</a>(ref-&gt;dcc-&gt;constraints,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ref-&gt;refctx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ref-&gt;constraints = ref-&gt;dcc-&gt;constraints;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ref-&gt;constraints = NIL;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1351" title="utils/cache/typcache.c:1351">UpdateDomainConstraintRef</a> --- recheck validity of domain constraint info<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the domain's constraint set changed, ref-&gt;constraints is updated to<br/></li>
<li></span><span class="Comment"> * point at a new list of cached constraints.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the normal case where nothing happened to the domain, this is cheap<br/></li>
<li></span><span class="Comment"> * enough that it's reasonable (and expected) to check <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> *each* use<br/></li>
<li></span><span class="Comment"> * of the constraint info.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1351">&#x200c;</a></span><span class="linkable">UpdateDomainConstraintRef</span>(DomainConstraintRef *ref)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typentry = ref-&gt;tcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure typcache entry's data is up to date */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((typentry-&gt;flags &amp; <a href="#L103" title="utils/cache/typcache.c:103">TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS</a>) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typtype == TYPTYPE_DOMAIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L994" title="utils/cache/typcache.c:994">load_domaintype_info</a>(typentry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Transfer to ref object if there's new info, adjusting refcounts */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ref-&gt;dcc != typentry-&gt;domainData)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Paranoia --- be sure link is nulled <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> trying to release */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L124" title="utils/cache/typcache.c:124">DomainConstraintCache</a> *dcc = ref-&gt;dcc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dcc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: we just leak the previous list of executable domain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraints.&nbsp; Alternatively, we could keep those in a child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * context of ref-&gt;refctx and free that context at this point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, in practice this code path will be taken so seldom<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that the extra bookkeeping for a child context doesn't seem<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * worthwhile; we'll just allow a leak for the lifespan of refctx.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ref-&gt;constraints = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ref-&gt;dcc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1243" title="utils/cache/typcache.c:1243">decr_dcc_refcount</a>(dcc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dcc = typentry-&gt;domainData;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dcc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ref-&gt;dcc = dcc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dcc-&gt;dccRefCount++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ref-&gt;need_exprstate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ref-&gt;constraints = <a href="#L1275" title="utils/cache/typcache.c:1275">prep_domain_constraints</a>(dcc-&gt;constraints,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ref-&gt;refctx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ref-&gt;constraints = dcc-&gt;constraints;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1400" title="utils/cache/typcache.c:1400">DomainHasConstraints</a> --- utility routine to check if a domain has constraints<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is defined to return false, not fail, if type is not a domain.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1400">&#x200c;</a></span><span class="linkable">DomainHasConstraints</span>(Oid type_id)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: a side effect is to cause the typcache's domain data to become<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * valid.&nbsp; This is fine since we'll likely need it soon if there is <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; typentry = <a href="#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(type_id, TYPECACHE_DOMAIN_CONSTR_INFO);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (typentry-&gt;domainData != <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1427" title="utils/cache/typcache.c:1427">array_element_has_equality</a> and friends are helper routines to check<br/></li>
<li></span><span class="Comment"> * whether we should believe that <a href="../adt/arrayfuncs.c.html#L3795" title="utils/adt/arrayfuncs.c:3795">array_eq</a> and related <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> will work<br/></li>
<li></span><span class="Comment"> * on the given array type or composite type.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The logic above may call these repeatedly on the same type entry, so we<br/></li>
<li></span><span class="Comment"> * make use of the typentry-&gt;flags field to cache the results once known.<br/></li>
<li></span><span class="Comment"> * Also, we assume that we'll probably want all these facts about the type<br/></li>
<li></span><span class="Comment"> * if we want <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, so we cache them all using only one lookup of the<br/></li>
<li></span><span class="Comment"> * component datatype(s).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1427">&#x200c;</a></span><span class="linkable">array_element_has_equality</span>(TypeCacheEntry *typentry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(typentry-&gt;flags &amp; <a href="#L93" title="utils/cache/typcache.c:93">TCFLAGS_CHECKED_ELEM_PROPERTIES</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1459" title="utils/cache/typcache.c:1459">cache_array_element_properties</a>(typentry);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (typentry-&gt;flags &amp; <a href="#L94" title="utils/cache/typcache.c:94">TCFLAGS_HAVE_ELEM_EQUALITY</a>) != <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1435">&#x200c;</a></span><span class="linkable">array_element_has_compare</span>(TypeCacheEntry *typentry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(typentry-&gt;flags &amp; <a href="#L93" title="utils/cache/typcache.c:93">TCFLAGS_CHECKED_ELEM_PROPERTIES</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1459" title="utils/cache/typcache.c:1459">cache_array_element_properties</a>(typentry);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (typentry-&gt;flags &amp; <a href="#L95" title="utils/cache/typcache.c:95">TCFLAGS_HAVE_ELEM_COMPARE</a>) != <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1443">&#x200c;</a></span><span class="linkable">array_element_has_hashing</span>(TypeCacheEntry *typentry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(typentry-&gt;flags &amp; <a href="#L93" title="utils/cache/typcache.c:93">TCFLAGS_CHECKED_ELEM_PROPERTIES</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1459" title="utils/cache/typcache.c:1459">cache_array_element_properties</a>(typentry);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (typentry-&gt;flags &amp; <a href="#L96" title="utils/cache/typcache.c:96">TCFLAGS_HAVE_ELEM_HASHING</a>) != <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1451">&#x200c;</a></span><span class="linkable">array_element_has_extended_hashing</span>(TypeCacheEntry *typentry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(typentry-&gt;flags &amp; <a href="#L93" title="utils/cache/typcache.c:93">TCFLAGS_CHECKED_ELEM_PROPERTIES</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1459" title="utils/cache/typcache.c:1459">cache_array_element_properties</a>(typentry);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (typentry-&gt;flags &amp; <a href="#L97" title="utils/cache/typcache.c:97">TCFLAGS_HAVE_ELEM_EXTENDED_HASHING</a>) != <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1459">&#x200c;</a></span><span class="linkable">cache_array_element_properties</span>(TypeCacheEntry *typentry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elem_type = <a href="lsyscache.c.html#L2832" title="utils/cache/lsyscache.c:2832">get_base_element_type</a>(typentry-&gt;type_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(elem_type))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *elementry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elementry = <a href="#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(elem_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPECACHE_EQ_OPR |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPECACHE_CMP_PROC |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPECACHE_HASH_PROC |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPECACHE_HASH_EXTENDED_PROC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(elementry-&gt;eq_opr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags |= <a href="#L94" title="utils/cache/typcache.c:94">TCFLAGS_HAVE_ELEM_EQUALITY</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(elementry-&gt;cmp_proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags |= <a href="#L95" title="utils/cache/typcache.c:95">TCFLAGS_HAVE_ELEM_COMPARE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(elementry-&gt;hash_proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags |= <a href="#L96" title="utils/cache/typcache.c:96">TCFLAGS_HAVE_ELEM_HASHING</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(elementry-&gt;hash_extended_proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags |= <a href="#L97" title="utils/cache/typcache.c:97">TCFLAGS_HAVE_ELEM_EXTENDED_HASHING</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; typentry-&gt;flags |= <a href="#L93" title="utils/cache/typcache.c:93">TCFLAGS_CHECKED_ELEM_PROPERTIES</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Likewise, some helper <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for composite types.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1489">&#x200c;</a></span><span class="linkable">record_fields_have_equality</span>(TypeCacheEntry *typentry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(typentry-&gt;flags &amp; <a href="#L98" title="utils/cache/typcache.c:98">TCFLAGS_CHECKED_FIELD_PROPERTIES</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1521" title="utils/cache/typcache.c:1521">cache_record_field_properties</a>(typentry);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (typentry-&gt;flags &amp; <a href="#L99" title="utils/cache/typcache.c:99">TCFLAGS_HAVE_FIELD_EQUALITY</a>) != <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1497">&#x200c;</a></span><span class="linkable">record_fields_have_compare</span>(TypeCacheEntry *typentry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(typentry-&gt;flags &amp; <a href="#L98" title="utils/cache/typcache.c:98">TCFLAGS_CHECKED_FIELD_PROPERTIES</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1521" title="utils/cache/typcache.c:1521">cache_record_field_properties</a>(typentry);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (typentry-&gt;flags &amp; <a href="#L100" title="utils/cache/typcache.c:100">TCFLAGS_HAVE_FIELD_COMPARE</a>) != <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1505">&#x200c;</a></span><span class="linkable">record_fields_have_hashing</span>(TypeCacheEntry *typentry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(typentry-&gt;flags &amp; <a href="#L98" title="utils/cache/typcache.c:98">TCFLAGS_CHECKED_FIELD_PROPERTIES</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1521" title="utils/cache/typcache.c:1521">cache_record_field_properties</a>(typentry);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (typentry-&gt;flags &amp; <a href="#L101" title="utils/cache/typcache.c:101">TCFLAGS_HAVE_FIELD_HASHING</a>) != <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1513">&#x200c;</a></span><span class="linkable">record_fields_have_extended_hashing</span>(TypeCacheEntry *typentry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(typentry-&gt;flags &amp; <a href="#L98" title="utils/cache/typcache.c:98">TCFLAGS_CHECKED_FIELD_PROPERTIES</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1521" title="utils/cache/typcache.c:1521">cache_record_field_properties</a>(typentry);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (typentry-&gt;flags &amp; <a href="#L102" title="utils/cache/typcache.c:102">TCFLAGS_HAVE_FIELD_EXTENDED_HASHING</a>) != <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1521">&#x200c;</a></span><span class="linkable">cache_record_field_properties</span>(TypeCacheEntry *typentry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For type RECORD, we can't really tell what will work, since we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have access here to the specific anonymous type.&nbsp; Just assume that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * equality and comparison will (we may get a failure at runtime).&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could also claim that hashing works, but then if code that has the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * option between a comparison-based (sort-based) and a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>-based plan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * chooses hashing, stuff could fail that would otherwise work if it chose<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a comparison-based plan.&nbsp; In practice more types support comparison<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than hashing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;type_id == RECORDOID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags |= (<a href="#L99" title="utils/cache/typcache.c:99">TCFLAGS_HAVE_FIELD_EQUALITY</a> |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L100" title="utils/cache/typcache.c:100">TCFLAGS_HAVE_FIELD_COMPARE</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (typentry-&gt;typtype == TYPTYPE_COMPOSITE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newflags;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch composite type's tupdesc if we don't have it already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;tupDesc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L880" title="utils/cache/typcache.c:880">load_typcache_tupdesc</a>(typentry);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupdesc = typentry-&gt;tupDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must bump the refcount while we do additional catalog lookups */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L388" title="access/common/tupdesc.c:388">IncrTupleDescRefCount</a>(tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Have each property if all non-dropped fields have the property */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newflags = (<a href="#L99" title="utils/cache/typcache.c:99">TCFLAGS_HAVE_FIELD_EQUALITY</a> |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L100" title="utils/cache/typcache.c:100">TCFLAGS_HAVE_FIELD_COMPARE</a> |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L101" title="utils/cache/typcache.c:101">TCFLAGS_HAVE_FIELD_HASHING</a> |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L102" title="utils/cache/typcache.c:102">TCFLAGS_HAVE_FIELD_EXTENDED_HASHING</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; tupdesc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *fieldentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr = TupleDescAttr(tupdesc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attr-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldentry = <a href="#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(attr-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_EQ_OPR |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_CMP_PROC |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_HASH_PROC |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_HASH_EXTENDED_PROC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(fieldentry-&gt;eq_opr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newflags &amp;= ~<a href="#L99" title="utils/cache/typcache.c:99">TCFLAGS_HAVE_FIELD_EQUALITY</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(fieldentry-&gt;cmp_proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newflags &amp;= ~<a href="#L100" title="utils/cache/typcache.c:100">TCFLAGS_HAVE_FIELD_COMPARE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(fieldentry-&gt;hash_proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newflags &amp;= ~<a href="#L101" title="utils/cache/typcache.c:101">TCFLAGS_HAVE_FIELD_HASHING</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(fieldentry-&gt;hash_extended_proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newflags &amp;= ~<a href="#L102" title="utils/cache/typcache.c:102">TCFLAGS_HAVE_FIELD_EXTENDED_HASHING</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can drop out of the loop once we disprove all bits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newflags == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags |= newflags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L406" title="access/common/tupdesc.c:406">DecrTupleDescRefCount</a>(tupdesc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (typentry-&gt;typtype == TYPTYPE_DOMAIN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's domain over composite, copy base type's properties */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *baseentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* load up basetype info if we didn't already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;domainBaseType == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;domainBaseTypmod = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;domainBaseType =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lsyscache.c.html#L2538" title="utils/cache/lsyscache.c:2538">getBaseTypeAndTypmod</a>(typentry-&gt;type_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;typentry-&gt;domainBaseTypmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; baseentry = <a href="#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(typentry-&gt;domainBaseType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPECACHE_EQ_OPR |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPECACHE_CMP_PROC |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPECACHE_HASH_PROC |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPECACHE_HASH_EXTENDED_PROC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (baseentry-&gt;typtype == TYPTYPE_COMPOSITE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags |= <a href="#L104" title="utils/cache/typcache.c:104">TCFLAGS_DOMAIN_BASE_IS_COMPOSITE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags |= baseentry-&gt;flags &amp; (<a href="#L99" title="utils/cache/typcache.c:99">TCFLAGS_HAVE_FIELD_EQUALITY</a> |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L100" title="utils/cache/typcache.c:100">TCFLAGS_HAVE_FIELD_COMPARE</a> |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L101" title="utils/cache/typcache.c:101">TCFLAGS_HAVE_FIELD_HASHING</a> |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L102" title="utils/cache/typcache.c:102">TCFLAGS_HAVE_FIELD_EXTENDED_HASHING</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; typentry-&gt;flags |= <a href="#L98" title="utils/cache/typcache.c:98">TCFLAGS_CHECKED_FIELD_PROPERTIES</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Likewise, some helper <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> and multirange types.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We can borrow the flag bits for array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> properties to use for <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> properties, since those flag bits otherwise have no use in a<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> or multirange type's typcache entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1626">&#x200c;</a></span><span class="linkable">range_element_has_hashing</span>(TypeCacheEntry *typentry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(typentry-&gt;flags &amp; <a href="#L93" title="utils/cache/typcache.c:93">TCFLAGS_CHECKED_ELEM_PROPERTIES</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1642" title="utils/cache/typcache.c:1642">cache_range_element_properties</a>(typentry);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (typentry-&gt;flags &amp; <a href="#L96" title="utils/cache/typcache.c:96">TCFLAGS_HAVE_ELEM_HASHING</a>) != <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1634">&#x200c;</a></span><span class="linkable">range_element_has_extended_hashing</span>(TypeCacheEntry *typentry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(typentry-&gt;flags &amp; <a href="#L93" title="utils/cache/typcache.c:93">TCFLAGS_CHECKED_ELEM_PROPERTIES</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1642" title="utils/cache/typcache.c:1642">cache_range_element_properties</a>(typentry);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (typentry-&gt;flags &amp; <a href="#L97" title="utils/cache/typcache.c:97">TCFLAGS_HAVE_ELEM_EXTENDED_HASHING</a>) != <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1642">&#x200c;</a></span><span class="linkable">cache_range_element_properties</span>(TypeCacheEntry *typentry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* load up subtype link if we didn't already */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;rngelemtype == <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typtype == TYPTYPE_RANGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L914" title="utils/cache/typcache.c:914">load_rangetype_info</a>(typentry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;rngelemtype != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *elementry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* might need to calculate subtype's <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function properties */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elementry = <a href="#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(typentry-&gt;rngelemtype-&gt;type_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPECACHE_HASH_PROC |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPECACHE_HASH_EXTENDED_PROC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(elementry-&gt;hash_proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags |= <a href="#L96" title="utils/cache/typcache.c:96">TCFLAGS_HAVE_ELEM_HASHING</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(elementry-&gt;hash_extended_proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags |= <a href="#L97" title="utils/cache/typcache.c:97">TCFLAGS_HAVE_ELEM_EXTENDED_HASHING</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; typentry-&gt;flags |= <a href="#L93" title="utils/cache/typcache.c:93">TCFLAGS_CHECKED_ELEM_PROPERTIES</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1666">&#x200c;</a></span><span class="linkable">multirange_element_has_hashing</span>(TypeCacheEntry *typentry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(typentry-&gt;flags &amp; <a href="#L93" title="utils/cache/typcache.c:93">TCFLAGS_CHECKED_ELEM_PROPERTIES</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1682" title="utils/cache/typcache.c:1682">cache_multirange_element_properties</a>(typentry);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (typentry-&gt;flags &amp; <a href="#L96" title="utils/cache/typcache.c:96">TCFLAGS_HAVE_ELEM_HASHING</a>) != <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1674">&#x200c;</a></span><span class="linkable">multirange_element_has_extended_hashing</span>(TypeCacheEntry *typentry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(typentry-&gt;flags &amp; <a href="#L93" title="utils/cache/typcache.c:93">TCFLAGS_CHECKED_ELEM_PROPERTIES</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1682" title="utils/cache/typcache.c:1682">cache_multirange_element_properties</a>(typentry);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (typentry-&gt;flags &amp; <a href="#L97" title="utils/cache/typcache.c:97">TCFLAGS_HAVE_ELEM_EXTENDED_HASHING</a>) != <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1682">&#x200c;</a></span><span class="linkable">cache_multirange_element_properties</span>(TypeCacheEntry *typentry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* load up <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> link if we didn't already */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;rngtype == <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;typtype == TYPTYPE_MULTIRANGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L972" title="utils/cache/typcache.c:972">load_multirangetype_info</a>(typentry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;rngtype != <span class="Constant">NULL</span> &amp;&amp; typentry-&gt;rngtype-&gt;rngelemtype != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *elementry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* might need to calculate subtype's <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function properties */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elementry = <a href="#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(typentry-&gt;rngtype-&gt;rngelemtype-&gt;type_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPECACHE_HASH_PROC |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPECACHE_HASH_EXTENDED_PROC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(elementry-&gt;hash_proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags |= <a href="#L96" title="utils/cache/typcache.c:96">TCFLAGS_HAVE_ELEM_HASHING</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(elementry-&gt;hash_extended_proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags |= <a href="#L97" title="utils/cache/typcache.c:97">TCFLAGS_HAVE_ELEM_EXTENDED_HASHING</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; typentry-&gt;flags |= <a href="#L93" title="utils/cache/typcache.c:93">TCFLAGS_CHECKED_ELEM_PROPERTIES</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make sure that <a href="#L285" title="utils/cache/typcache.c:285">RecordCacheArray</a> and RecordIdentifierArray are large enough<br/></li>
<li></span><span class="Comment"> * to store 'typmod'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1710">&#x200c;</a></span><span class="linkable">ensure_record_cache_typmod_slot_exists</span>(int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L285" title="utils/cache/typcache.c:285">RecordCacheArray</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L285" title="utils/cache/typcache.c:285">RecordCacheArray</a> = (<a href="#L278" title="utils/cache/typcache.c:278">RecordCacheArrayEntry</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">64</span> * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L278" title="utils/cache/typcache.c:278">RecordCacheArrayEntry</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L286" title="utils/cache/typcache.c:286">RecordCacheArrayLen</a> = <span class="Constant">64</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typmod &gt;= <a href="#L286" title="utils/cache/typcache.c:286">RecordCacheArrayLen</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; newlen = pg_nextpower2_32(typmod + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L285" title="utils/cache/typcache.c:285">RecordCacheArray</a> = repalloc0_array(<a href="#L285" title="utils/cache/typcache.c:285">RecordCacheArray</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L278" title="utils/cache/typcache.c:278">RecordCacheArrayEntry</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L286" title="utils/cache/typcache.c:286">RecordCacheArrayLen</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L286" title="utils/cache/typcache.c:286">RecordCacheArrayLen</a> = newlen;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1739" title="utils/cache/typcache.c:1739">lookup_rowtype_tupdesc_internal</a> --- <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> routine to lookup a rowtype<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Same API as <a href="#L1850" title="utils/cache/typcache.c:1850">lookup_rowtype_tupdesc_noerror</a>, but the returned tupdesc<br/></li>
<li></span><span class="Comment"> * hasn't had its refcount bumped.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TupleDesc<br/></li>
<li><a id="L1739">&#x200c;</a><span class="linkable">lookup_rowtype_tupdesc_internal</span>(Oid type_id, int32 typmod, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> noError)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type_id != RECORDOID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's a named composite type, so use the regular typcache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(type_id, TYPECACHE_TUPDESC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;tupDesc == <span class="Constant">NULL</span> &amp;&amp; !noError)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;type </span><span class="Special">%s</span><span class="Constant"> is not composite&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(type_id))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> typentry-&gt;tupDesc;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's a transient record type, so look in our record-type table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typmod &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It is already in our local cache? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typmod &lt; <a href="#L286" title="utils/cache/typcache.c:286">RecordCacheArrayLen</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L285" title="utils/cache/typcache.c:285">RecordCacheArray</a>[typmod].tupdesc != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L285" title="utils/cache/typcache.c:285">RecordCacheArray</a>[typmod].tupdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Are we attached to a shared record typmod registry? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_typmod_registry != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L205" title="utils/cache/typcache.c:205">SharedTypmodTableEntry</a> *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it in the shared typmod index. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry = <a href="../../lib/dshash.c.html#L390" title="lib/dshash.c:390">dshash_find</a>(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_typmod_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;typmod, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupdesc = (TupleDesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;area,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;shared_tupdesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(typmod == tupdesc-&gt;tdtypmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We may need to extend the local <a href="#L285" title="utils/cache/typcache.c:285">RecordCacheArray</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1710" title="utils/cache/typcache.c:1710">ensure_record_cache_typmod_slot_exists</a>(typmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Our local array can <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> point directly to the TupleDesc<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in shared memory, which is non-reference-counted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L285" title="utils/cache/typcache.c:285">RecordCacheArray</a>[typmod].tupdesc = tupdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(tupdesc-&gt;tdrefcount == -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't share tupdesc identifiers across processes, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assign one locally.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L285" title="utils/cache/typcache.c:285">RecordCacheArray</a>[typmod].id = ++<a href="#L294" title="utils/cache/typcache.c:294">tupledesc_id_counter</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/dshash.c.html#L558" title="lib/dshash.c:558">dshash_release_lock</a>(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_typmod_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L285" title="utils/cache/typcache.c:285">RecordCacheArray</a>[typmod].tupdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!noError)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;record type has not been registered&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given a typeid/typmod that should describe a known composite type,<br/></li>
<li></span><span class="Comment"> * return the tuple descriptor for the type.&nbsp; Will ereport on failure.<br/></li>
<li></span><span class="Comment"> * (Use ereport because this is reachable with user-specified OIDs,<br/></li>
<li></span><span class="Comment"> * for example from <a href="../adt/rowtypes.c.html#L74" title="utils/adt/rowtypes.c:74">record_in</a>().)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: on success, we increment the refcount of the returned TupleDesc,<br/></li>
<li></span><span class="Comment"> * and log the reference in <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>.&nbsp; Caller must call<br/></li>
<li></span><span class="Comment"> * ReleaseTupleDesc when done using the tupdesc.&nbsp; (There are some<br/></li>
<li></span><span class="Comment"> * cases in which the returned tupdesc is not refcounted, in which<br/></li>
<li></span><span class="Comment"> * case PinTupleDesc/ReleaseTupleDesc are no-ops; but in these cases<br/></li>
<li></span><span class="Comment"> * the tupdesc is guaranteed to live till process exit.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleDesc<br/></li>
<li><a id="L1833">&#x200c;</a><span class="linkable">lookup_rowtype_tupdesc</span>(Oid type_id, int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tupDesc = <a href="#L1739" title="utils/cache/typcache.c:1739">lookup_rowtype_tupdesc_internal</a>(type_id, typmod, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; PinTupleDesc(tupDesc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tupDesc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1850" title="utils/cache/typcache.c:1850">lookup_rowtype_tupdesc_noerror</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As above, but if the type is not a known composite type and noError<br/></li>
<li></span><span class="Comment"> * is true, returns NULL instead of ereport'ing.&nbsp; (Note that if a bogus<br/></li>
<li></span><span class="Comment"> * type_id is passed, you'll get an ereport anyway.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleDesc<br/></li>
<li><a id="L1850">&#x200c;</a><span class="linkable">lookup_rowtype_tupdesc_noerror</span>(Oid type_id, int32 typmod, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> noError)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tupDesc = <a href="#L1739" title="utils/cache/typcache.c:1739">lookup_rowtype_tupdesc_internal</a>(type_id, typmod, noError);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tupDesc != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PinTupleDesc(tupDesc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tupDesc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1867" title="utils/cache/typcache.c:1867">lookup_rowtype_tupdesc_copy</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Like <a href="#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(), but the returned TupleDesc has been<br/></li>
<li></span><span class="Comment"> * copied into the <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> and is not reference-counted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleDesc<br/></li>
<li><a id="L1867">&#x200c;</a><span class="linkable">lookup_rowtype_tupdesc_copy</span>(Oid type_id, int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tmp = <a href="#L1739" title="utils/cache/typcache.c:1739">lookup_rowtype_tupdesc_internal</a>(type_id, typmod, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../access/common/tupdesc.c.html#L173" title="access/common/tupdesc.c:173">CreateTupleDescCopyConstr</a>(tmp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1889" title="utils/cache/typcache.c:1889">lookup_rowtype_tupdesc_domain</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Same as <a href="#L1850" title="utils/cache/typcache.c:1850">lookup_rowtype_tupdesc_noerror</a>(), except that the type can also be<br/></li>
<li></span><span class="Comment"> * a domain over a named composite type; so this is effectively equivalent to<br/></li>
<li></span><span class="Comment"> * <a href="#L1850" title="utils/cache/typcache.c:1850">lookup_rowtype_tupdesc_noerror</a>(<a href="lsyscache.c.html#L2521" title="utils/cache/lsyscache.c:2521">getBaseType</a>(type_id), typmod, noError)<br/></li>
<li></span><span class="Comment"> * except for being a tad faster.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the reason we don't fold the look-through-domain behavior into plain<br/></li>
<li></span><span class="Comment"> * <a href="#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>() is that we want callers to know they might be<br/></li>
<li></span><span class="Comment"> * dealing with a domain.&nbsp; Otherwise they might construct a tuple that should<br/></li>
<li></span><span class="Comment"> * be of the domain type, but not apply domain constraints.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleDesc<br/></li>
<li><a id="L1889">&#x200c;</a><span class="linkable">lookup_rowtype_tupdesc_domain</span>(Oid type_id, int32 typmod, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> noError)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type_id != RECORDOID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for domain or named composite type.&nbsp; We might as well load<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whichever data is needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(type_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_TUPDESC |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_DOMAIN_BASE_INFO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;typtype == TYPTYPE_DOMAIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1850" title="utils/cache/typcache.c:1850">lookup_rowtype_tupdesc_noerror</a>(typentry-&gt;domainBaseType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;domainBaseTypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; noError);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;tupDesc == <span class="Constant">NULL</span> &amp;&amp; !noError)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;type </span><span class="Special">%s</span><span class="Constant"> is not composite&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(type_id))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupDesc = typentry-&gt;tupDesc;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tupDesc = <a href="#L1739" title="utils/cache/typcache.c:1739">lookup_rowtype_tupdesc_internal</a>(type_id, typmod, noError);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tupDesc != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PinTupleDesc(tupDesc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tupDesc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Hash function for the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table of <a href="#L157" title="utils/cache/typcache.c:157">RecordCacheEntry</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint32<br/></li>
<li><a id="L1926">&#x200c;</a><span class="linkable">record_type_typmod_hash</span>(<span class="Type">const</span> <span class="Type">void</span> *data, <span class="Type">size_t</span> size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L157" title="utils/cache/typcache.c:157">RecordCacheEntry</a> *entry = (<a href="#L157" title="utils/cache/typcache.c:157">RecordCacheEntry</a> *) data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../access/common/tupdesc.c.html#L622" title="access/common/tupdesc.c:622">hashRowType</a>(entry-&gt;tupdesc);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Match function for the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table of <a href="#L157" title="utils/cache/typcache.c:157">RecordCacheEntry</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1937">&#x200c;</a></span><span class="linkable">record_type_typmod_compare</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b, <span class="Type">size_t</span> size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L157" title="utils/cache/typcache.c:157">RecordCacheEntry</a> *left = (<a href="#L157" title="utils/cache/typcache.c:157">RecordCacheEntry</a> *) a;<br/></li>
<li>&nbsp; &nbsp; <a href="#L157" title="utils/cache/typcache.c:157">RecordCacheEntry</a> *right = (<a href="#L157" title="utils/cache/typcache.c:157">RecordCacheEntry</a> *) b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../access/common/tupdesc.c.html#L586" title="access/common/tupdesc.c:586">equalRowTypes</a>(left-&gt;tupdesc, right-&gt;tupdesc) ? <span class="Constant">0</span> : <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1953" title="utils/cache/typcache.c:1953">assign_record_type_typmod</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given a tuple descriptor for a RECORD type, <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> or create a cache entry<br/></li>
<li></span><span class="Comment"> * for the type, and set the tupdesc's tdtypmod field to a value that will<br/></li>
<li></span><span class="Comment"> * identify this cache entry to <a href="#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1953">&#x200c;</a></span><span class="linkable">assign_record_type_typmod</span>(TupleDesc tupDesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L157" title="utils/cache/typcache.c:157">RecordCacheEntry</a> *recentry;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; entDesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(tupDesc-&gt;tdtypeid == RECORDOID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L276" title="utils/cache/typcache.c:276">RecordCacheHash</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First time through: <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TupleDesc);&nbsp; &nbsp; <span class="Comment">/* just the pointer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L157" title="utils/cache/typcache.c:157">RecordCacheEntry</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = <a href="#L1926" title="utils/cache/typcache.c:1926">record_type_typmod_hash</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.match = <a href="#L1937" title="utils/cache/typcache.c:1937">record_type_typmod_compare</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L276" title="utils/cache/typcache.c:276">RecordCacheHash</a> = <a href="../hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;Record information cache&quot;</span>, <span class="Constant">64</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_FUNCTION | HASH_COMPARE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Also make sure <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a> exists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="catcache.c.html#L679" title="utils/cache/catcache.c:679">CreateCacheMemoryContext</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find a hashtable entry for this tuple descriptor. We don't use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * HASH_ENTER yet, because if it's missing, we need to make sure that all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the allocations succeed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we create the new entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; recentry = (<a href="#L157" title="utils/cache/typcache.c:157">RecordCacheEntry</a> *) <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L276" title="utils/cache/typcache.c:276">RecordCacheHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;tupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND, &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (found &amp;&amp; recentry-&gt;tupdesc != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupDesc-&gt;tdtypmod = recentry-&gt;tupdesc-&gt;tdtypmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Not present, so need to manufacture an entry */<br/></li>
<li></span>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look in the <a href="#L166" title="utils/cache/typcache.c:166">SharedRecordTypmodRegistry</a>, if attached */<br/></li>
<li></span>&nbsp; &nbsp; entDesc = <a href="#L2756" title="utils/cache/typcache.c:2756">find_or_make_matching_shared_tupledesc</a>(tupDesc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entDesc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure we have room <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we <a href="../../access/common/tupdesc.c.html#L133" title="access/common/tupdesc.c:133">CreateTupleDescCopy</a>() or advance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L287" title="utils/cache/typcache.c:287">NextRecordTypmod</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1710" title="utils/cache/typcache.c:1710">ensure_record_cache_typmod_slot_exists</a>(<a href="#L287" title="utils/cache/typcache.c:287">NextRecordTypmod</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reference-counted local cache only. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; entDesc = <a href="../../access/common/tupdesc.c.html#L133" title="access/common/tupdesc.c:133">CreateTupleDescCopy</a>(tupDesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entDesc-&gt;tdrefcount = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entDesc-&gt;tdtypmod = <a href="#L287" title="utils/cache/typcache.c:287">NextRecordTypmod</a>++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1710" title="utils/cache/typcache.c:1710">ensure_record_cache_typmod_slot_exists</a>(entDesc-&gt;tdtypmod);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L285" title="utils/cache/typcache.c:285">RecordCacheArray</a>[entDesc-&gt;tdtypmod].tupdesc = entDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assign a unique tupdesc identifier, too. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L285" title="utils/cache/typcache.c:285">RecordCacheArray</a>[entDesc-&gt;tdtypmod].id = ++<a href="#L294" title="utils/cache/typcache.c:294">tupledesc_id_counter</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fully initialized; create the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table entry */<br/></li>
<li></span>&nbsp; &nbsp; recentry = (<a href="#L157" title="utils/cache/typcache.c:157">RecordCacheEntry</a> *) <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L276" title="utils/cache/typcache.c:276">RecordCacheHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;tupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; recentry-&gt;tupdesc = entDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update the caller's tuple descriptor. */<br/></li>
<li></span>&nbsp; &nbsp; tupDesc-&gt;tdtypmod = entDesc-&gt;tdtypmod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2045" title="utils/cache/typcache.c:2045">assign_record_type_identifier</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Get an identifier, which will be unique over the lifespan of this backend<br/></li>
<li></span><span class="Comment"> * process, for the current tuple descriptor of the specified composite type.<br/></li>
<li></span><span class="Comment"> * For named composite types, the value is guaranteed to change if the type's<br/></li>
<li></span><span class="Comment"> * definition does.&nbsp; For registered RECORD types, the value will not change<br/></li>
<li></span><span class="Comment"> * once assigned, since the registered type won't either.&nbsp; If an anonymous<br/></li>
<li></span><span class="Comment"> * RECORD type is specified, we return a new identifier on each call.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint64<br/></li>
<li><a id="L2045">&#x200c;</a><span class="linkable">assign_record_type_identifier</span>(Oid type_id, int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type_id != RECORDOID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's a named composite type, so use the regular typcache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(type_id, TYPECACHE_TUPDESC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;tupDesc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;type </span><span class="Special">%s</span><span class="Constant"> is not composite&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(type_id))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(typentry-&gt;tupDesc_identifier != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> typentry-&gt;tupDesc_identifier;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's a transient record type, so look in our record-type table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typmod &gt;= <span class="Constant">0</span> &amp;&amp; typmod &lt; <a href="#L286" title="utils/cache/typcache.c:286">RecordCacheArrayLen</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L285" title="utils/cache/typcache.c:285">RecordCacheArray</a>[typmod].tupdesc != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L285" title="utils/cache/typcache.c:285">RecordCacheArray</a>[typmod].id != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L285" title="utils/cache/typcache.c:285">RecordCacheArray</a>[typmod].id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* For anonymous or unrecognized record type, generate a new ID */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ++<a href="#L294" title="utils/cache/typcache.c:294">tupledesc_id_counter</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the amount of shmem required to hold a <a href="#L166" title="utils/cache/typcache.c:166">SharedRecordTypmodRegistry</a>.<br/></li>
<li></span><span class="Comment"> * This exists only to avoid exposing private innards of<br/></li>
<li></span><span class="Comment"> * <a href="#L166" title="utils/cache/typcache.c:166">SharedRecordTypmodRegistry</a> in a header.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">size_t<br/></li>
<li><a id="L2086">&#x200c;</a></span><span class="linkable">SharedRecordTypmodRegistryEstimate</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L166" title="utils/cache/typcache.c:166">SharedRecordTypmodRegistry</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize 'registry' in a pre-existing shared memory region, which must be<br/></li>
<li></span><span class="Comment"> * maximally aligned and have space for <a href="#L2086" title="utils/cache/typcache.c:2086">SharedRecordTypmodRegistryEstimate</a>()<br/></li>
<li></span><span class="Comment"> * bytes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'area' will be used to allocate shared memory space as required for the<br/></li>
<li></span><span class="Comment"> * typemod registration.&nbsp; The current process, expected to be a leader process<br/></li>
<li></span><span class="Comment"> * in a parallel query, will be attached automatically and its current record<br/></li>
<li></span><span class="Comment"> * types will be loaded into *registry.&nbsp; While attached, all calls to<br/></li>
<li></span><span class="Comment"> * <a href="#L1953" title="utils/cache/typcache.c:1953">assign_record_type_typmod</a> will use the shared registry.&nbsp; Worker backends<br/></li>
<li></span><span class="Comment"> * will need to attach explicitly.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this function takes 'area' and 'segment' as arguments rather than<br/></li>
<li></span><span class="Comment"> * accessing them via <a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>, because they aren't installed there<br/></li>
<li></span><span class="Comment"> * until after this function runs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2108">&#x200c;</a></span><span class="linkable">SharedRecordTypmodRegistryInit</span>(<a href="#L166" title="utils/cache/typcache.c:166">SharedRecordTypmodRegistry</a> *registry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *segment,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext old_context;<br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/dshash.c.html#L103" title="lib/dshash.c:103">dshash_table</a> *record_table;<br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/dshash.c.html#L103" title="lib/dshash.c:103">dshash_table</a> *typmod_table;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!IsParallelWorker());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can't already be attached to a shared registry. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_typmod_registry == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_record_table == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_typmod_table == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; old_context = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table of tuple descriptors indexed by themselves. */<br/></li>
<li></span>&nbsp; &nbsp; record_table = <a href="../../lib/dshash.c.html#L206" title="lib/dshash.c:206">dshash_create</a>(area, &amp;<a href="#L256" title="utils/cache/typcache.c:256">srtr_record_table_params</a>, area);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table of tuple descriptors indexed by typmod. */<br/></li>
<li></span>&nbsp; &nbsp; typmod_table = <a href="../../lib/dshash.c.html#L206" title="lib/dshash.c:206">dshash_create</a>(area, &amp;<a href="#L266" title="utils/cache/typcache.c:266">srtr_typmod_table_params</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the <a href="#L166" title="utils/cache/typcache.c:166">SharedRecordTypmodRegistry</a>. */<br/></li>
<li></span>&nbsp; &nbsp; registry-&gt;record_table_handle = <a href="../../lib/dshash.c.html#L367" title="lib/dshash.c:367">dshash_get_hash_table_handle</a>(record_table);<br/></li>
<li>&nbsp; &nbsp; registry-&gt;typmod_table_handle = <a href="../../lib/dshash.c.html#L367" title="lib/dshash.c:367">dshash_get_hash_table_handle</a>(typmod_table);<br/></li>
<li>&nbsp; &nbsp; pg_atomic_init_u32(&amp;registry-&gt;next_typmod, <a href="#L287" title="utils/cache/typcache.c:287">NextRecordTypmod</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy all entries from this backend's private registry into the shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * registry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (typmod = <span class="Constant">0</span>; typmod &lt; <a href="#L287" title="utils/cache/typcache.c:287">NextRecordTypmod</a>; ++typmod)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L205" title="utils/cache/typcache.c:205">SharedTypmodTableEntry</a> *typmod_table_entry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L196" title="utils/cache/typcache.c:196">SharedRecordTableEntry</a> *record_table_entry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L182" title="utils/cache/typcache.c:182">SharedRecordTableKey</a> record_table_key;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dsa_pointer shared_dp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupdesc = <a href="#L285" title="utils/cache/typcache.c:285">RecordCacheArray</a>[typmod].tupdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tupdesc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy the TupleDesc into shared memory. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; shared_dp = <a href="#L2735" title="utils/cache/typcache.c:2735">share_tupledesc</a>(area, tupdesc, typmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> into the typmod table. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typmod_table_entry = <a href="../../lib/dshash.c.html#L433" title="lib/dshash.c:433">dshash_find_or_insert</a>(typmod_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;tupdesc-&gt;tdtypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot create duplicate shared record typmod&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typmod_table_entry-&gt;typmod = tupdesc-&gt;tdtypmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typmod_table_entry-&gt;shared_tupdesc = shared_dp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/dshash.c.html#L558" title="lib/dshash.c:558">dshash_release_lock</a>(typmod_table, typmod_table_entry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> into the record table. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; record_table_key.shared = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record_table_key.u.local_tupdesc = tupdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record_table_entry = <a href="../../lib/dshash.c.html#L433" title="lib/dshash.c:433">dshash_find_or_insert</a>(record_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;record_table_key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record_table_entry-&gt;key.shared = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record_table_entry-&gt;key.u.shared_tupdesc = shared_dp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/dshash.c.html#L558" title="lib/dshash.c:558">dshash_release_lock</a>(record_table, record_table_entry);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up the global state that will tell <a href="#L1953" title="utils/cache/typcache.c:1953">assign_record_type_typmod</a> and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1739" title="utils/cache/typcache.c:1739">lookup_rowtype_tupdesc_internal</a> about the shared registry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_record_table = record_table;<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_typmod_table = typmod_table;<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_typmod_registry = registry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We install a detach hook in the leader, but only to handle <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * failure during <a href="../../access/common/session.c.html#L70" title="access/common/session.c:70">GetSessionDsmHandle</a>().&nbsp; Once <a href="../../access/common/session.c.html#L70" title="access/common/session.c:70">GetSessionDsmHandle</a>() pins<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the memory, the leader process will use a shared registry until it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L1132" title="storage/ipc/dsm.c:1132">on_dsm_detach</a>(segment, <a href="#L2868" title="utils/cache/typcache.c:2868">shared_record_typmod_registry_detach</a>, (Datum) <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attach to 'registry', which must have been initialized already by another<br/></li>
<li></span><span class="Comment"> * backend.&nbsp; Future calls to <a href="#L1953" title="utils/cache/typcache.c:1953">assign_record_type_typmod</a> and<br/></li>
<li></span><span class="Comment"> * <a href="#L1739" title="utils/cache/typcache.c:1739">lookup_rowtype_tupdesc_internal</a> will use the shared registry until the<br/></li>
<li></span><span class="Comment"> * current session is detached.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2207">&#x200c;</a></span><span class="linkable">SharedRecordTypmodRegistryAttach</span>(<a href="#L166" title="utils/cache/typcache.c:166">SharedRecordTypmodRegistry</a> *registry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext old_context;<br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/dshash.c.html#L103" title="lib/dshash.c:103">dshash_table</a> *record_table;<br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/dshash.c.html#L103" title="lib/dshash.c:103">dshash_table</a> *typmod_table;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(IsParallelWorker());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can't already be attached to a shared registry. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;segment != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;area != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_typmod_registry == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_record_table == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_typmod_table == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't already have typmods in our local cache, because they'd clash<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with those imported by <a href="#L2108" title="utils/cache/typcache.c:2108">SharedRecordTypmodRegistryInit</a>.&nbsp; This should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a freshly started parallel worker.&nbsp; If we ever support worker<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recycling, a worker would need to zap its local cache in between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * servicing different queries, in order to be able to call this and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * synchronize typmods with a new leader; but that's problematic because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we can't be very sure that record-typmod-related state hasn't escaped<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to anywhere else in the process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L287" title="utils/cache/typcache.c:287">NextRecordTypmod</a> == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; old_context = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Attach to the two <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables. */<br/></li>
<li></span>&nbsp; &nbsp; record_table = <a href="../../lib/dshash.c.html#L270" title="lib/dshash.c:270">dshash_attach</a>(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;area,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="#L256" title="utils/cache/typcache.c:256">srtr_record_table_params</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; registry-&gt;record_table_handle,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;area);<br/></li>
<li>&nbsp; &nbsp; typmod_table = <a href="../../lib/dshash.c.html#L270" title="lib/dshash.c:270">dshash_attach</a>(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;area,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="#L266" title="utils/cache/typcache.c:266">srtr_typmod_table_params</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; registry-&gt;typmod_table_handle,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up detach hook to run at worker exit.&nbsp; Currently this is the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as the leader's detach hook, but in future they might need to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * different.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L1132" title="storage/ipc/dsm.c:1132">on_dsm_detach</a>(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;segment,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2868" title="utils/cache/typcache.c:2868">shared_record_typmod_registry_detach</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(registry));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up the session state that will tell <a href="#L1953" title="utils/cache/typcache.c:1953">assign_record_type_typmod</a> and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1739" title="utils/cache/typcache.c:1739">lookup_rowtype_tupdesc_internal</a> about the shared registry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_typmod_registry = registry;<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_record_table = record_table;<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_typmod_table = typmod_table;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2290" title="utils/cache/typcache.c:2290">TypeCacheRelCallback</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Relcache inval callback function<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> the cached tuple descriptor (if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) for the given rel's composite<br/></li>
<li></span><span class="Comment"> * type, or for all composite types if relid == InvalidOid.&nbsp; Also reset<br/></li>
<li></span><span class="Comment"> * whatever info we have cached about the composite type's comparability.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called when a relcache invalidation event occurs for the given<br/></li>
<li></span><span class="Comment"> * relid.&nbsp; We must scan the whole typcache <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> since we don't know the<br/></li>
<li></span><span class="Comment"> * type OID corresponding to the relid.&nbsp; We could do a direct search if this<br/></li>
<li></span><span class="Comment"> * were a syscache-flush callback on pg_type, but then we would need all<br/></li>
<li></span><span class="Comment"> * ALTER-TABLE-like commands that could modify a rowtype to issue syscache<br/></li>
<li></span><span class="Comment"> * invals against the rel's pg_type OID.&nbsp; The extra SI signaling could very<br/></li>
<li></span><span class="Comment"> * well cost more than we'd save, since in most usages there are not very<br/></li>
<li></span><span class="Comment"> * many entries in a backend's typcache.&nbsp; The risk of bugs-of-omission seems<br/></li>
<li></span><span class="Comment"> * high, too.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Another possibility, with only localized impact, is to maintain a second<br/></li>
<li></span><span class="Comment"> * hashtable that indexes composite-type typcache entries by their typrelid.<br/></li>
<li></span><span class="Comment"> * But it's still not clear it's worth the trouble.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2290">&#x200c;</a></span><span class="linkable">TypeCacheRelCallback</span>(Datum arg, Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L78" title="utils/cache/typcache.c:78">TypeCacheHash</a> must exist, else this callback wouldn't be registered */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L78" title="utils/cache/typcache.c:78">TypeCacheHash</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((typentry = (TypeCacheEntry *) <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;typtype == TYPTYPE_COMPOSITE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip if no match, unless we're zapping all composite types */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relid != typentry-&gt;typrelid &amp;&amp; relid != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> tupdesc if we have it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;tupDesc != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Release our refcount, and free the tupdesc if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> remain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Can't use <a href="../../access/common/tupdesc.c.html#L406" title="access/common/tupdesc.c:406">DecrTupleDescRefCount</a> because this reference is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not logged in current resource owner.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(typentry-&gt;tupDesc-&gt;tdrefcount &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (--typentry-&gt;tupDesc-&gt;tdrefcount == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L331" title="access/common/tupdesc.c:331">FreeTupleDesc</a>(typentry-&gt;tupDesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;tupDesc = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also clear tupDesc_identifier, so that anything watching<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that will realize that the tupdesc has possibly changed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Alternatively, we could specify that to detect possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tupdesc change, one must check for tupDesc != NULL as well<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as tupDesc_identifier being the same as what was previously<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * seen.&nbsp; That seems error-prone.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;tupDesc_identifier = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset equality/comparison/hashing validity information */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags &amp;= ~<a href="#L107" title="utils/cache/typcache.c:107">TCFLAGS_OPERATOR_FLAGS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (typentry-&gt;typtype == TYPTYPE_DOMAIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's domain over composite, reset flags.&nbsp; (We don't bother<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * trying to determine whether the specific base type needs a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reset.)&nbsp; Note that if we haven't determined whether the base<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * type is composite, we don't need to reset anything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;flags &amp; <a href="#L104" title="utils/cache/typcache.c:104">TCFLAGS_DOMAIN_BASE_IS_COMPOSITE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags &amp;= ~<a href="#L107" title="utils/cache/typcache.c:107">TCFLAGS_OPERATOR_FLAGS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2355" title="utils/cache/typcache.c:2355">TypeCacheTypCallback</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Syscache inval callback function<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called when a syscache invalidation event occurs for <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * pg_type row.&nbsp; If we have information cached about that type, mark<br/></li>
<li></span><span class="Comment"> * it as needing to be reloaded.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2355">&#x200c;</a></span><span class="linkable">TypeCacheTypCallback</span>(Datum arg, <span class="Type">int</span> cacheid, uint32 hashvalue)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L78" title="utils/cache/typcache.c:78">TypeCacheHash</a> must exist, else this callback wouldn't be registered */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L78" title="utils/cache/typcache.c:78">TypeCacheHash</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((typentry = (TypeCacheEntry *) <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Is this the targeted type row (or it's a total cache flush)? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hashvalue == <span class="Constant">0</span> || typentry-&gt;type_id_hash == hashvalue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Mark the data obtained directly from pg_type as invalid.&nbsp; Also,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if it's a domain, typnotnull might've changed, so we'll need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recalculate its constraints.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags &amp;= ~(<a href="#L84" title="utils/cache/typcache.c:84">TCFLAGS_HAVE_PG_TYPE_DATA</a> |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L103" title="utils/cache/typcache.c:103">TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2395" title="utils/cache/typcache.c:2395">TypeCacheOpcCallback</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Syscache inval callback function<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called when a syscache invalidation event occurs for <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pg_opclass<br/></li>
<li></span><span class="Comment"> * row.&nbsp; In principle we could probably just invalidate data dependent on the<br/></li>
<li></span><span class="Comment"> * particular opclass, but since updates on pg_opclass are rare in production<br/></li>
<li></span><span class="Comment"> * it doesn't seem worth a lot of complication: we just mark all cached data<br/></li>
<li></span><span class="Comment"> * invalid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we don't bother watching for updates on pg_amop or pg_amproc.<br/></li>
<li></span><span class="Comment"> * This should be safe because ALTER OPERATOR FAMILY ADD/DROP OPERATOR/FUNCTION<br/></li>
<li></span><span class="Comment"> * is not allowed to be used to add/drop the primary operators and <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> * of an opclass, only cross-type members of a family; and the latter sorts<br/></li>
<li></span><span class="Comment"> * of members are not going to get cached here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2395">&#x200c;</a></span><span class="linkable">TypeCacheOpcCallback</span>(Datum arg, <span class="Type">int</span> cacheid, uint32 hashvalue)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L78" title="utils/cache/typcache.c:78">TypeCacheHash</a> must exist, else this callback wouldn't be registered */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L78" title="utils/cache/typcache.c:78">TypeCacheHash</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((typentry = (TypeCacheEntry *) <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset equality/comparison/hashing validity information */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags &amp;= ~<a href="#L107" title="utils/cache/typcache.c:107">TCFLAGS_OPERATOR_FLAGS</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2424" title="utils/cache/typcache.c:2424">TypeCacheConstrCallback</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Syscache inval callback function<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called when a syscache invalidation event occurs for <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * pg_constraint row.&nbsp; We flush information about domain constraints<br/></li>
<li></span><span class="Comment"> * when this happens.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It's slightly annoying that we can't tell whether the inval event was for<br/></li>
<li></span><span class="Comment"> * a domain constraint record or not; there's usually more update traffic<br/></li>
<li></span><span class="Comment"> * for table constraints than domain constraints, so we'll do a lot of<br/></li>
<li></span><span class="Comment"> * useless flushes.&nbsp; Still, this is better than the old no-caching-at-all<br/></li>
<li></span><span class="Comment"> * approach to domain constraints.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2424">&#x200c;</a></span><span class="linkable">TypeCacheConstrCallback</span>(Datum arg, <span class="Type">int</span> cacheid, uint32 hashvalue)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because this is called very frequently, and typically very few of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * typcache entries are for domains, we don't use <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a> here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Instead we thread all the domain-type entries together so that we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * visit them cheaply.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (typentry = <a href="#L81" title="utils/cache/typcache.c:81">firstDomainTypeEntry</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typentry != <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typentry = typentry-&gt;nextDomain)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset domain constraint validity information */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;flags &amp;= ~<a href="#L103" title="utils/cache/typcache.c:103">TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if given OID is part of the <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> that's sortable by comparisons<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2448">&#x200c;</a></span><span class="linkable">enum_known_sorted</span>(<a href="#L138" title="utils/cache/typcache.c:138">TypeCacheEnumData</a> *enumdata, Oid arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arg &lt; enumdata-&gt;bitmap_base)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; offset = arg - enumdata-&gt;bitmap_base;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (offset &gt; (Oid) <span class="Constant">INT_MAX</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>((<span class="Type">int</span>) offset, enumdata-&gt;sorted_values);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2477" title="utils/cache/typcache.c:2477">compare_values_of_enum</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Compare two members of an enum type.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return &lt;0, 0, or &gt;0 according as arg1 &lt;, =, or &gt; arg2.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: currently, the enumData cache is refreshed only if we are asked<br/></li>
<li></span><span class="Comment"> * to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> an enum value that is not already in the cache.&nbsp; This is okay<br/></li>
<li></span><span class="Comment"> * because there is no support for re-ordering existing <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, so comparisons<br/></li>
<li></span><span class="Comment"> * of previously cached <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> will return the right answer even if other<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> have been added since we last loaded the cache.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the enum logic has a special-case rule about even-numbered versus<br/></li>
<li></span><span class="Comment"> * odd-numbered OIDs, but we take no account of that rule here; this<br/></li>
<li></span><span class="Comment"> * routine shouldn't even get called when that rule applies.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2477">&#x200c;</a></span><span class="linkable">compare_values_of_enum</span>(TypeCacheEntry *tcache, Oid arg1, Oid arg2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L138" title="utils/cache/typcache.c:138">TypeCacheEnumData</a> *enumdata;<br/></li>
<li>&nbsp; &nbsp; <a href="#L136" title="utils/cache/typcache.c:136">EnumItem</a>&nbsp;&nbsp; *item1;<br/></li>
<li>&nbsp; &nbsp; <a href="#L136" title="utils/cache/typcache.c:136">EnumItem</a>&nbsp;&nbsp; *item2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Equal OIDs are certainly <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> --- this case was probably handled by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * our caller, but we may as well check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (arg1 == arg2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Load up the cache if first time through */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tcache-&gt;enumData == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2550" title="utils/cache/typcache.c:2550">load_enum_cache_data</a>(tcache);<br/></li>
<li>&nbsp; &nbsp; enumdata = tcache-&gt;enumData;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If both OIDs are known-sorted, we can just <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> them directly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2448" title="utils/cache/typcache.c:2448">enum_known_sorted</a>(enumdata, arg1) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2448" title="utils/cache/typcache.c:2448">enum_known_sorted</a>(enumdata, arg2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arg1 &lt; arg2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Slow path: we have to identify their actual sort-order positions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; item1 = <a href="#L2705" title="utils/cache/typcache.c:2705">find_enumitem</a>(enumdata, arg1);<br/></li>
<li>&nbsp; &nbsp; item2 = <a href="#L2705" title="utils/cache/typcache.c:2705">find_enumitem</a>(enumdata, arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (item1 == <span class="Constant">NULL</span> || item2 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We couldn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one or both <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; That means the enum has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changed under us, so re-<a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the cache and try again. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't bother retrying the known-sorted case in this path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2550" title="utils/cache/typcache.c:2550">load_enum_cache_data</a>(tcache);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; enumdata = tcache-&gt;enumData;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item1 = <a href="#L2705" title="utils/cache/typcache.c:2705">find_enumitem</a>(enumdata, arg1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item2 = <a href="#L2705" title="utils/cache/typcache.c:2705">find_enumitem</a>(enumdata, arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we still can't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, complain: we must have corrupt<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item1 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;enum value </span><span class="Special">%u</span><span class="Constant"> not found in cache for enum </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; arg1, <a href="../adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(tcache-&gt;type_id));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item2 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;enum value </span><span class="Special">%u</span><span class="Constant"> not found in cache for enum </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; arg2, <a href="../adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(tcache-&gt;type_id));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (item1-&gt;sort_order &lt; item2-&gt;sort_order)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (item1-&gt;sort_order &gt; item2-&gt;sort_order)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Load (or re-load) the enumData member of the typcache entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2550">&#x200c;</a></span><span class="linkable">load_enum_cache_data</span>(TypeCacheEntry *tcache)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L138" title="utils/cache/typcache.c:138">TypeCacheEnumData</a> *enumdata;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; enum_rel;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc enum_scan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; enum_tuple;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData skey;<br/></li>
<li>&nbsp; &nbsp; <a href="#L136" title="utils/cache/typcache.c:136">EnumItem</a>&nbsp;&nbsp; *items;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numitems;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxitems;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmap_base;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *bitmap;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bm_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start_pos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that this is actually an enum */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tcache-&gt;typtype != TYPTYPE_ENUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> is not an enum&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(tcache-&gt;type_id))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read all the information for members of the enum type.&nbsp; We collect the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * info in working memory in the caller's context, and then transfer it to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * permanent memory in <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>.&nbsp; This minimizes the risk of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leaking memory from <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a> in the event of an error partway<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * through.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; maxitems = <span class="Constant">64</span>;<br/></li>
<li>&nbsp; &nbsp; items = (<a href="#L136" title="utils/cache/typcache.c:136">EnumItem</a> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L136" title="utils/cache/typcache.c:136">EnumItem</a>) * maxitems);<br/></li>
<li>&nbsp; &nbsp; numitems = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan pg_enum for the members of the target enum type. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_enum_enumtypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(tcache-&gt;type_id));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; enum_rel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(EnumRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; enum_scan = <a href="../../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(enum_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EnumTypIdLabelIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>, &amp;skey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(enum_tuple = <a href="../../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(enum_scan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_enum en = (Form_pg_enum) GETSTRUCT(enum_tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (numitems &gt;= maxitems)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxitems *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; items = (<a href="#L136" title="utils/cache/typcache.c:136">EnumItem</a> *) <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(items, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L136" title="utils/cache/typcache.c:136">EnumItem</a>) * maxitems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; items[numitems].enum_oid = en-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; items[numitems].sort_order = en-&gt;enumsortorder;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numitems++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(enum_scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(enum_rel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort the items into OID order */<br/></li>
<li></span>&nbsp; &nbsp; qsort(items, numitems, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L136" title="utils/cache/typcache.c:136">EnumItem</a>), <a href="#L2722" title="utils/cache/typcache.c:2722">enum_oid_cmp</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Here, we create a bitmap listing a <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of the enum's OIDs that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * known to be in order and can thus be compared with just OID comparison.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The point of this is that the enum's initial OIDs were certainly in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * order, so there is some <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> that can be compared via OID comparison;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and we'd rather not do binary searches unnecessarily.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is somewhat heuristic, and might identify a <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of OIDs that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * isn't exactly what the type started with.&nbsp; That's okay as long as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> is correctly sorted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bitmap_base = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; bitmap = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; bm_size = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* only save sets of at least 2 OIDs */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (start_pos = <span class="Constant">0</span>; start_pos &lt; numitems - <span class="Constant">1</span>; start_pos++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Identify <a href="../../regex/rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a> sorted subsequence starting at start_pos<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *this_bitmap = <a href="../../nodes/bitmapset.c.html#L216" title="nodes/bitmapset.c:216">bms_make_singleton</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_bm_size = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start_oid = items[start_pos].enum_oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; prev_order = items[start_pos].sort_order;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = start_pos + <span class="Constant">1</span>; i &lt; numitems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset = items[i].enum_oid - start_oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* quit if bitmap would be too large; cutoff is arbitrary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offset &gt;= <span class="Constant">8192</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* include the item if it's in-order */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (items[i].sort_order &gt; prev_order)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev_order = items[i].sort_order;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_bitmap = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(this_bitmap, (<span class="Type">int</span>) offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_bm_size++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remember it if larger than previous best */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (this_bm_size &gt; bm_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(bitmap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmap_base = start_oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmap = this_bitmap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bm_size = this_bm_size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(this_bitmap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Done if it's not possible to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a longer sequence in the rest of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the list.&nbsp; In typical cases this will happen on the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * iteration, which is why we create the bitmaps on the fly instead of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doing a second pass over the list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bm_size &gt;= (numitems - start_pos - <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, copy the data into <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a> */<br/></li>
<li></span>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; enumdata = (<a href="#L138" title="utils/cache/typcache.c:138">TypeCacheEnumData</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(offsetof(<a href="#L138" title="utils/cache/typcache.c:138">TypeCacheEnumData</a>, enum_values) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numitems * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L136" title="utils/cache/typcache.c:136">EnumItem</a>));<br/></li>
<li>&nbsp; &nbsp; enumdata-&gt;bitmap_base = bitmap_base;<br/></li>
<li>&nbsp; &nbsp; enumdata-&gt;sorted_values = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(bitmap);<br/></li>
<li>&nbsp; &nbsp; enumdata-&gt;num_values = numitems;<br/></li>
<li>&nbsp; &nbsp; memcpy(enumdata-&gt;enum_values, items, numitems * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L136" title="utils/cache/typcache.c:136">EnumItem</a>));<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(items);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(bitmap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And link the finished cache struct into the typcache */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tcache-&gt;enumData != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tcache-&gt;enumData);<br/></li>
<li>&nbsp; &nbsp; tcache-&gt;enumData = enumdata;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Locate the <a href="#L136" title="utils/cache/typcache.c:136">EnumItem</a> with the given OID, if present<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L136" title="utils/cache/typcache.c:136">EnumItem</a> *<br/></li>
<li><a id="L2705">&#x200c;</a><span class="linkable">find_enumitem</span>(<a href="#L138" title="utils/cache/typcache.c:138">TypeCacheEnumData</a> *enumdata, Oid arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L136" title="utils/cache/typcache.c:136">EnumItem</a>&nbsp; &nbsp; srch;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* On some versions of Solaris, bsearch of zero items dumps core */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (enumdata-&gt;num_values &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; srch.enum_oid = arg;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> bsearch(&amp;srch, enumdata-&gt;enum_values, enumdata-&gt;num_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L136" title="utils/cache/typcache.c:136">EnumItem</a>), <a href="#L2722" title="utils/cache/typcache.c:2722">enum_oid_cmp</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * qsort comparison function for OID-ordered EnumItems<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2722">&#x200c;</a></span><span class="linkable">enum_oid_cmp</span>(<span class="Type">const</span> <span class="Type">void</span> *left, <span class="Type">const</span> <span class="Type">void</span> *right)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L136" title="utils/cache/typcache.c:136">EnumItem</a> *l = (<span class="Type">const</span> <a href="#L136" title="utils/cache/typcache.c:136">EnumItem</a> *) left;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L136" title="utils/cache/typcache.c:136">EnumItem</a> *r = (<span class="Type">const</span> <a href="#L136" title="utils/cache/typcache.c:136">EnumItem</a> *) right;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_cmp_u32(l-&gt;enum_oid, r-&gt;enum_oid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copy 'tupdesc' into newly allocated shared memory in 'area', set its typmod<br/></li>
<li></span><span class="Comment"> * to the given value and return a dsa_pointer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> dsa_pointer<br/></li>
<li><a id="L2735">&#x200c;</a><span class="linkable">share_tupledesc</span>(<a href="../mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, TupleDesc tupdesc, uint32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dsa_pointer shared_dp;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; shared;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; shared_dp = dsa_allocate(area, TupleDescSize(tupdesc));<br/></li>
<li>&nbsp; &nbsp; shared = (TupleDesc) <a href="../mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, shared_dp);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L251" title="access/common/tupdesc.c:251">TupleDescCopy</a>(shared, tupdesc);<br/></li>
<li>&nbsp; &nbsp; shared-&gt;tdtypmod = typmod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> shared_dp;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If we are attached to a <a href="#L166" title="utils/cache/typcache.c:166">SharedRecordTypmodRegistry</a>, use it to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> or<br/></li>
<li></span><span class="Comment"> * create a shared TupleDesc that matches 'tupdesc'.&nbsp; Otherwise return NULL.<br/></li>
<li></span><span class="Comment"> * Tuple descriptors returned by this function are not reference counted, and<br/></li>
<li></span><span class="Comment"> * will exist at least as long as the current backend remained attached to the<br/></li>
<li></span><span class="Comment"> * current session.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TupleDesc<br/></li>
<li><a id="L2756">&#x200c;</a><span class="linkable">find_or_make_matching_shared_tupledesc</span>(TupleDesc tupdesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <a href="#L182" title="utils/cache/typcache.c:182">SharedRecordTableKey</a> key;<br/></li>
<li>&nbsp; &nbsp; <a href="#L196" title="utils/cache/typcache.c:196">SharedRecordTableEntry</a> *record_table_entry;<br/></li>
<li>&nbsp; &nbsp; <a href="#L205" title="utils/cache/typcache.c:205">SharedTypmodTableEntry</a> *typmod_table_entry;<br/></li>
<li>&nbsp; &nbsp; dsa_pointer shared_dp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; typmod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If not even attached, nothing to do. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_typmod_registry == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a matching tuple descriptor in the record table. */<br/></li>
<li></span>&nbsp; &nbsp; key.shared = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; key.u.local_tupdesc = tupdesc;<br/></li>
<li>&nbsp; &nbsp; record_table_entry = (<a href="#L196" title="utils/cache/typcache.c:196">SharedRecordTableEntry</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/dshash.c.html#L390" title="lib/dshash.c:390">dshash_find</a>(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_record_table, &amp;key, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (record_table_entry)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(record_table_entry-&gt;key.shared);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/dshash.c.html#L558" title="lib/dshash.c:558">dshash_release_lock</a>(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_record_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record_table_entry);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (TupleDesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;area,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record_table_entry-&gt;key.u.shared_tupdesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(result-&gt;tdrefcount == -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate a new typmod number.&nbsp; This will be wasted if we error out. */<br/></li>
<li></span>&nbsp; &nbsp; typmod = (<span class="Type">int</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_fetch_add_u32(&amp;<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_typmod_registry-&gt;next_typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy the TupleDesc into shared memory. */<br/></li>
<li></span>&nbsp; &nbsp; shared_dp = <a href="#L2735" title="utils/cache/typcache.c:2735">share_tupledesc</a>(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;area, tupdesc, typmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create an entry in the typmod table so that others will understand this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * typmod number.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typmod_table_entry = (<a href="#L205" title="utils/cache/typcache.c:205">SharedTypmodTableEntry</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/dshash.c.html#L433" title="lib/dshash.c:433">dshash_find_or_insert</a>(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_typmod_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;typmod, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot create duplicate shared record typmod&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/dsa.c.html#L826" title="utils/mmgr/dsa.c:826">dsa_free</a>(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;area, shared_dp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_TRY();<br/></li>
<li>&nbsp; &nbsp; typmod_table_entry-&gt;typmod = typmod;<br/></li>
<li>&nbsp; &nbsp; typmod_table_entry-&gt;shared_tupdesc = shared_dp;<br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/dshash.c.html#L558" title="lib/dshash.c:558">dshash_release_lock</a>(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_typmod_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typmod_table_entry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finally create an entry in the record table so others with matching<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple descriptors can reuse the typmod.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; record_table_entry = (<a href="#L196" title="utils/cache/typcache.c:196">SharedRecordTableEntry</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/dshash.c.html#L433" title="lib/dshash.c:433">dshash_find_or_insert</a>(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_record_table, &amp;key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Someone concurrently inserted a matching tuple descriptor since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first time we checked.&nbsp; Use that one instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/dshash.c.html#L558" title="lib/dshash.c:558">dshash_release_lock</a>(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_record_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record_table_entry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Might as well free up the space used by the one we created. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <a href="../../lib/dshash.c.html#L503" title="lib/dshash.c:503">dshash_delete_key</a>(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_typmod_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/dsa.c.html#L826" title="utils/mmgr/dsa.c:826">dsa_free</a>(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;area, shared_dp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Return the one we found. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(record_table_entry-&gt;key.shared);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (TupleDesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;area,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record_table_entry-&gt;key.u.shared_tupdesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(result-&gt;tdrefcount == -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store it and return it. */<br/></li>
<li></span>&nbsp; &nbsp; record_table_entry-&gt;key.shared = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; record_table_entry-&gt;key.u.shared_tupdesc = shared_dp;<br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/dshash.c.html#L558" title="lib/dshash.c:558">dshash_release_lock</a>(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_record_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record_table_entry);<br/></li>
<li>&nbsp; &nbsp; result = (TupleDesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;area, shared_dp);<br/></li>
<li>&nbsp; &nbsp; Assert(result-&gt;tdrefcount == -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * On-DSM-detach hook to forget about the current shared record typmod<br/></li>
<li></span><span class="Comment"> * infrastructure.&nbsp; This is currently used by both leader and workers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2868">&#x200c;</a></span><span class="linkable">shared_record_typmod_registry_detach</span>(<a href="../../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *segment, Datum datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Be cautious here: maybe we didn't finish initializing. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_record_table != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/dshash.c.html#L307" title="lib/dshash.c:307">dshash_detach</a>(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_record_table);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_record_table = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_typmod_table != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/dshash.c.html#L307" title="lib/dshash.c:307">dshash_detach</a>(<a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_typmod_table);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_typmod_table = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/session.c.html#L48" title="access/common/session.c:48">CurrentSession</a>-&gt;shared_typmod_registry = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
