<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/cache/plancache.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/cache/plancache.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L100">cached_expression_list</a></li>
<li><a href="#L147">plan_cache_mode</a></li>
<li><a href="#L124">planref_resowner_desc</a></li>
<li><a href="#L95">saved_plan_list</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1772">AcquireExecutorLocks</a></li>
<li><a href="#L1828">AcquirePlannerLocks</a></li>
<li><a href="#L906">BuildCachedPlan</a></li>
<li><a href="#L1336">CachedPlanAllowsSimpleValidityCheck</a></li>
<li><a href="#L1640">CachedPlanGetTargetList</a></li>
<li><a href="#L1451">CachedPlanIsSimplyValid</a></li>
<li><a href="#L1627">CachedPlanIsValid</a></li>
<li><a href="#L1498">CachedPlanSetParentContext</a></li>
<li><a href="#L822">CheckCachedPlan</a></li>
<li><a href="#L366">CompleteCachedPlan</a></li>
<li><a href="#L1536">CopyCachedPlan</a></li>
<li><a href="#L192">CreateCachedPlan</a></li>
<li><a href="#L276">CreateOneShotCachedPlan</a></li>
<li><a href="#L526">DropCachedPlan</a></li>
<li><a href="#L1734">FreeCachedExpression</a></li>
<li><a href="#L1677">GetCachedExpression</a></li>
<li><a href="#L1168">GetCachedPlan</a></li>
<li><a href="#L155">InitPlanCache</a></li>
<li><a href="#L1949">PlanCacheComputeResultDesc</a></li>
<li><a href="#L2069">PlanCacheObjectCallback</a></li>
<li><a href="#L1985">PlanCacheRelCallback</a></li>
<li><a href="#L2178">PlanCacheSysCallback</a></li>
<li><a href="#L1753">QueryListGetPrimaryStmt</a></li>
<li><a href="#L2234">ReleaseAllPlanCacheRefsInOwner</a></li>
<li><a href="#L1291">ReleaseCachedPlan</a></li>
<li><a href="#L555">ReleaseGenericPlan</a></li>
<li><a href="#L2242">ResOwnerReleaseCachedPlan</a></li>
<li><a href="#L2187">ResetPlanCache</a></li>
<li><a href="#L140">ResourceOwnerForgetPlanCacheRef</a></li>
<li><a href="#L135">ResourceOwnerRememberPlanCacheRef</a></li>
<li><a href="#L583">RevalidateCachedQuery</a></li>
<li><a href="#L482">SaveCachedPlan</a></li>
<li><a href="#L1853">ScanQueryForLocks</a></li>
<li><a href="#L1920">ScanQueryWalker</a></li>
<li><a href="#L1103">cached_plan_cost</a></li>
<li><a href="#L1046">choose_custom_plan</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L85">StmtPlanRequiresRevalidation</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * plancache.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Plan cache management.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The plan cache manager has two principal responsibilities: deciding when<br/></li>
<li></span><span class="Comment"> * to use a generic plan versus a custom (parameter-value-specific) plan,<br/></li>
<li></span><span class="Comment"> * and tracking whether cached plans need to be invalidated because of schema<br/></li>
<li></span><span class="Comment"> * changes in the objects they depend on.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The logic for choosing generic or custom plans is in <a href="#L1046" title="utils/cache/plancache.c:1046">choose_custom_plan</a>,<br/></li>
<li></span><span class="Comment"> * which see for comments.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Cache invalidation is driven off sinval events.&nbsp; Any CachedPlanSource<br/></li>
<li></span><span class="Comment"> * that matches the event is marked invalid, as is its generic CachedPlan<br/></li>
<li></span><span class="Comment"> * if it has one.&nbsp; When (and if) the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> demand for a cached plan occurs,<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis and rewrite is repeated to build a new valid query tree,<br/></li>
<li></span><span class="Comment"> * and then planning is performed as normal.&nbsp; We also force re-analysis and<br/></li>
<li></span><span class="Comment"> * re-planning if the active search_path is different from the previous time<br/></li>
<li></span><span class="Comment"> * or, if RLS is involved, if the user changes or the RLS environment changes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that if the sinval was a result of user DDL actions, <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis<br/></li>
<li></span><span class="Comment"> * could throw an error, for example if a column referenced by the query is<br/></li>
<li></span><span class="Comment"> * no longer present.&nbsp; Another possibility is for the query's output tupdesc<br/></li>
<li></span><span class="Comment"> * to change (for instance &quot;SELECT *&quot; might expand differently than <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>).<br/></li>
<li></span><span class="Comment"> * The creator of a cached plan can specify whether it is allowable for the<br/></li>
<li></span><span class="Comment"> * query to change output tupdesc on replan --- if so, it's up to the<br/></li>
<li></span><span class="Comment"> * caller to notice changes and cope with them.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently, we track exactly the dependencies of plans on relations,<br/></li>
<li></span><span class="Comment"> * user-defined <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, and domains.&nbsp; On relcache invalidation events or<br/></li>
<li></span><span class="Comment"> * pg_proc or pg_type syscache invalidation events, we invalidate just those<br/></li>
<li></span><span class="Comment"> * plans that depend on the particular object being modified.&nbsp; (Note: this<br/></li>
<li></span><span class="Comment"> * scheme assumes that <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> table modification that requires replanning will<br/></li>
<li></span><span class="Comment"> * generate a relcache inval event.)&nbsp; We also watch for inval events on<br/></li>
<li></span><span class="Comment"> * certain other system catalogs, such as pg_namespace; but for them, our<br/></li>
<li></span><span class="Comment"> * response is just to invalidate all plans.&nbsp; We expect updates on those<br/></li>
<li></span><span class="Comment"> * catalogs to be infrequent enough that more-detailed tracking is not worth<br/></li>
<li></span><span class="Comment"> * the effort.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In addition to full-fledged query plans, we provide a facility for<br/></li>
<li></span><span class="Comment"> * detecting invalidations of simple scalar expressions.&nbsp; This is fairly<br/></li>
<li></span><span class="Comment"> * bare-bones; it's the caller's responsibility to build a new expression<br/></li>
<li></span><span class="Comment"> * if the old one gets invalidated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/cache/plancache.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/<a href="../../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/pquery.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/utility.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/resowner.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rls.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We must <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> &quot;overhead&quot; operations that involve database access when the<br/></li>
<li></span><span class="Comment"> * cached plan's subject statement is a transaction control command or one<br/></li>
<li></span><span class="Comment"> * that requires a snapshot not to be set yet (such as <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> or LOCK).&nbsp; More<br/></li>
<li></span><span class="Comment"> * generally, statements that do not require <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis/rewrite/plan<br/></li>
<li></span><span class="Comment"> * activity never need to be revalidated, so we can treat them all like that.<br/></li>
<li></span><span class="Comment"> * For the convenience of postgres.c, treat empty statements that way too.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L85">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">StmtPlanRequiresRevalidation</span>(plansource)&nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((plansource)-&gt;raw_parse_tree != </span><span class="Constant">NULL</span><span class="PreProc"> &amp;&amp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; <a href="../../parser/analyze.c.html#L441" title="parser/analyze.c:441">stmt_requires_parse_analysis</a>((plansource)-&gt;raw_parse_tree))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This is the head of the backend's list of &quot;saved&quot; CachedPlanSources (i.e.,<br/></li>
<li></span><span class="Comment"> * those that are in long-lived storage and are examined for sinval events).<br/></li>
<li></span><span class="Comment"> * We use a dlist instead of separate List cells so that we can guarantee<br/></li>
<li></span><span class="Comment"> * to save a CachedPlanSource without error.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L95">&#x200c;</a></span><span class="Type">static</span> dlist_head <span class="linkable">saved_plan_list</span> = DLIST_STATIC_INIT(<span class="linkable">saved_plan_list</span>);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This is the head of the backend's list of CachedExpressions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L100">&#x200c;</a></span><span class="Type">static</span> dlist_head <span class="linkable">cached_expression_list</span> = DLIST_STATIC_INIT(<span class="linkable">cached_expression_list</span>);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L555" title="utils/cache/plancache.c:555">ReleaseGenericPlan</a>(CachedPlanSource *plansource);<br/></li>
<li><span class="Type">static</span> List *<a href="#L583" title="utils/cache/plancache.c:583">RevalidateCachedQuery</a>(CachedPlanSource *plansource,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../misc/queryenvironment.c.html#L32" title="utils/misc/queryenvironment.c:32">QueryEnvironment</a> *queryEnv);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L822" title="utils/cache/plancache.c:822">CheckCachedPlan</a>(CachedPlanSource *plansource);<br/></li>
<li><span class="Type">static</span> CachedPlan *<a href="#L906" title="utils/cache/plancache.c:906">BuildCachedPlan</a>(CachedPlanSource *plansource, List *qlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ParamListInfo boundParams, <a href="../misc/queryenvironment.c.html#L32" title="utils/misc/queryenvironment.c:32">QueryEnvironment</a> *queryEnv);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1046" title="utils/cache/plancache.c:1046">choose_custom_plan</a>(CachedPlanSource *plansource,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ParamListInfo boundParams);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L1103" title="utils/cache/plancache.c:1103">cached_plan_cost</a>(CachedPlan *plan, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> include_planner);<br/></li>
<li><span class="Type">static</span> Query *<a href="#L1753" title="utils/cache/plancache.c:1753">QueryListGetPrimaryStmt</a>(List *stmts);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1772" title="utils/cache/plancache.c:1772">AcquireExecutorLocks</a>(List *stmt_list, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> acquire);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1828" title="utils/cache/plancache.c:1828">AcquirePlannerLocks</a>(List *stmt_list, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> acquire);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1853" title="utils/cache/plancache.c:1853">ScanQueryForLocks</a>(Query *parsetree, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> acquire);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1920" title="utils/cache/plancache.c:1920">ScanQueryWalker</a>(Node *node, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *acquire);<br/></li>
<li><span class="Type">static</span> TupleDesc <a href="#L1949" title="utils/cache/plancache.c:1949">PlanCacheComputeResultDesc</a>(List *stmt_list);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1985" title="utils/cache/plancache.c:1985">PlanCacheRelCallback</a>(Datum arg, Oid relid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2069" title="utils/cache/plancache.c:2069">PlanCacheObjectCallback</a>(Datum arg, <span class="Type">int</span> cacheid, uint32 hashvalue);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2178" title="utils/cache/plancache.c:2178">PlanCacheSysCallback</a>(Datum arg, <span class="Type">int</span> cacheid, uint32 hashvalue);<br/></li>
<li><br/></li>
<li><span class="Comment">/* ResourceOwner callbacks to track plancache references */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L2242" title="utils/cache/plancache.c:2242">ResOwnerReleaseCachedPlan</a>(Datum res);<br/></li>
<li><br/></li>
<li><a id="L124">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> ResourceOwnerDesc <span class="linkable">planref_resowner_desc</span> =<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; .name = <span class="Constant">&quot;plancache reference&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; .release_phase = RESOURCE_RELEASE_AFTER_LOCKS,<br/></li>
<li>&nbsp; &nbsp; .release_priority = RELEASE_PRIO_PLANCACHE_REFS,<br/></li>
<li>&nbsp; &nbsp; .ReleaseResource = <a href="#L2242" title="utils/cache/plancache.c:2242">ResOwnerReleaseCachedPlan</a>,<br/></li>
<li>&nbsp; &nbsp; .DebugPrint = <span class="Constant">NULL</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the default message is fine */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Convenience wrappers over <a href="../resowner/resowner.c.html#L514" title="utils/resowner/resowner.c:514">ResourceOwnerRemember</a>/Forget */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L135">&#x200c;</a></span><span class="linkable">ResourceOwnerRememberPlanCacheRef</span>(ResourceOwner owner, CachedPlan *plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../resowner/resowner.c.html#L514" title="utils/resowner/resowner.c:514">ResourceOwnerRemember</a>(owner, PointerGetDatum(plan), &amp;<a href="#L124" title="utils/cache/plancache.c:124">planref_resowner_desc</a>);<br/></li>
<li>}<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L140">&#x200c;</a></span><span class="linkable">ResourceOwnerForgetPlanCacheRef</span>(ResourceOwner owner, CachedPlan *plan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../resowner/resowner.c.html#L554" title="utils/resowner/resowner.c:554">ResourceOwnerForget</a>(owner, PointerGetDatum(plan), &amp;<a href="#L124" title="utils/cache/plancache.c:124">planref_resowner_desc</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* GUC parameter */<br/></li>
<li><a id="L147">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">plan_cache_mode</span> = PLAN_CACHE_MODE_AUTO;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L155" title="utils/cache/plancache.c:155">InitPlanCache</a>: <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> module during <a href="../init/postinit.c.html#L736" title="utils/init/postinit.c:736">InitPostgres</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All we need to do is hook into inval.c's callback lists.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L155">&#x200c;</a></span><span class="linkable">InitPlanCache</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="inval.c.html#L1558" title="utils/cache/inval.c:1558">CacheRegisterRelcacheCallback</a>(<a href="#L1985" title="utils/cache/plancache.c:1985">PlanCacheRelCallback</a>, (Datum) <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(PROCOID, <a href="#L2069" title="utils/cache/plancache.c:2069">PlanCacheObjectCallback</a>, (Datum) <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(TYPEOID, <a href="#L2069" title="utils/cache/plancache.c:2069">PlanCacheObjectCallback</a>, (Datum) <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(NAMESPACEOID, <a href="#L2178" title="utils/cache/plancache.c:2178">PlanCacheSysCallback</a>, (Datum) <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(OPEROID, <a href="#L2178" title="utils/cache/plancache.c:2178">PlanCacheSysCallback</a>, (Datum) <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(AMOPOPID, <a href="#L2178" title="utils/cache/plancache.c:2178">PlanCacheSysCallback</a>, (Datum) <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(FOREIGNSERVEROID, <a href="#L2178" title="utils/cache/plancache.c:2178">PlanCacheSysCallback</a>, (Datum) <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(FOREIGNDATAWRAPPEROID, <a href="#L2178" title="utils/cache/plancache.c:2178">PlanCacheSysCallback</a>, (Datum) <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L192" title="utils/cache/plancache.c:192">CreateCachedPlan</a>: initially create a plan cache entry.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Creation of a cached plan is divided into two steps, <a href="#L192" title="utils/cache/plancache.c:192">CreateCachedPlan</a> and<br/></li>
<li></span><span class="Comment"> * <a href="#L366" title="utils/cache/plancache.c:366">CompleteCachedPlan</a>.&nbsp; <a href="#L192" title="utils/cache/plancache.c:192">CreateCachedPlan</a> should be called after running the<br/></li>
<li></span><span class="Comment"> * query through <a href="../../parser/parser.c.html#L42" title="parser/parser.c:42">raw_parser</a>, but <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> doing <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis and rewrite;<br/></li>
<li></span><span class="Comment"> * <a href="#L366" title="utils/cache/plancache.c:366">CompleteCachedPlan</a> is called after that.&nbsp; The reason for this arrangement<br/></li>
<li></span><span class="Comment"> * is that it can save one round of copying of the raw <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree, since<br/></li>
<li></span><span class="Comment"> * the parser will normally scribble on the raw <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree.&nbsp; Callers would<br/></li>
<li></span><span class="Comment"> * otherwise need to make an extra copy of the <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree to ensure they<br/></li>
<li></span><span class="Comment"> * still had a clean copy to present at plan cache creation time.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All arguments presented to <a href="#L192" title="utils/cache/plancache.c:192">CreateCachedPlan</a> are copied into a memory<br/></li>
<li></span><span class="Comment"> * context created as a child of the call-time <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>, which<br/></li>
<li></span><span class="Comment"> * should be a reasonably short-lived working context that will go away in<br/></li>
<li></span><span class="Comment"> * event of an error.&nbsp; This ensures that the cached plan data structure will<br/></li>
<li></span><span class="Comment"> * likewise disappear if an error occurs <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we have fully constructed it.<br/></li>
<li></span><span class="Comment"> * Once constructed, the cached plan can be made longer-lived, if needed,<br/></li>
<li></span><span class="Comment"> * by calling <a href="#L482" title="utils/cache/plancache.c:482">SaveCachedPlan</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * raw_parse_tree: output of <a href="../../parser/parser.c.html#L42" title="parser/parser.c:42">raw_parser</a>(), or NULL if empty query<br/></li>
<li></span><span class="Comment"> * query_string: original query text<br/></li>
<li></span><span class="Comment"> * commandTag: command tag for query, or UNKNOWN if empty query<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>CachedPlanSource *<br/></li>
<li><a id="L192">&#x200c;</a><span class="linkable">CreateCachedPlan</span>(RawStmt *raw_parse_tree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *query_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CommandTag commandTag)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CachedPlanSource *plansource;<br/></li>
<li>&nbsp; &nbsp; MemoryContext source_context;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(query_string != <span class="Constant">NULL</span>);&nbsp; &nbsp; <span class="Comment">/* required as of 8.4 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make a dedicated memory context for the CachedPlanSource and its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * permanent subsidiary data.&nbsp; It's probably not going to be large, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just in case, allow it to grow large.&nbsp; Initially it's a child of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * caller's context (which we assume to be transient), so that it will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cleaned up on error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; source_context = AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;CachedPlanSource&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_START_SMALL_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create and fill the CachedPlanSource struct within the new context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Most fields are just left empty for the moment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(source_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plansource = (CachedPlanSource *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CachedPlanSource));<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;magic = CACHEDPLANSOURCE_MAGIC;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;raw_parse_tree = copyObject(raw_parse_tree);<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;query_string = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(query_string);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L612" title="utils/mmgr/mcxt.c:612">MemoryContextSetIdentifier</a>(source_context, plansource-&gt;query_string);<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;commandTag = commandTag;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;param_types = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;num_params = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;parserSetup = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;parserSetupArg = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;cursor_options = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;fixed_result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;resultDesc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;context = source_context;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;query_list = NIL;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;relationOids = NIL;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;invalItems = NIL;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;search_path = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;query_context = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;rewriteRoleId = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;rewriteRowSecurity = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;dependsOnRLS = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;gplan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;is_oneshot = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;is_complete = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;is_saved = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;is_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;generation = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;generic_cost = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;total_custom_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;num_generic_plans = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;num_custom_plans = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plansource;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L276" title="utils/cache/plancache.c:276">CreateOneShotCachedPlan</a>: initially create a one-shot plan cache entry.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This variant of <a href="#L192" title="utils/cache/plancache.c:192">CreateCachedPlan</a> creates a plan cache entry that is meant<br/></li>
<li></span><span class="Comment"> * to be used only once.&nbsp; No data copying occurs: all data structures remain<br/></li>
<li></span><span class="Comment"> * in the caller's memory context (which typically should get cleared after<br/></li>
<li></span><span class="Comment"> * completing execution).&nbsp; The CachedPlanSource struct itself is also created<br/></li>
<li></span><span class="Comment"> * in that context.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A one-shot plan cannot be saved or copied, since we make no effort to<br/></li>
<li></span><span class="Comment"> * preserve the raw <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree unmodified.&nbsp; There is also no support for<br/></li>
<li></span><span class="Comment"> * invalidation, so plan use must be completed in the current transaction,<br/></li>
<li></span><span class="Comment"> * and DDL that might invalidate the querytree_list must be avoided as well.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * raw_parse_tree: output of <a href="../../parser/parser.c.html#L42" title="parser/parser.c:42">raw_parser</a>(), or NULL if empty query<br/></li>
<li></span><span class="Comment"> * query_string: original query text<br/></li>
<li></span><span class="Comment"> * commandTag: command tag for query, or NULL if empty query<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>CachedPlanSource *<br/></li>
<li><a id="L276">&#x200c;</a><span class="linkable">CreateOneShotCachedPlan</span>(RawStmt *raw_parse_tree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *query_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CommandTag commandTag)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CachedPlanSource *plansource;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(query_string != <span class="Constant">NULL</span>);&nbsp; &nbsp; <span class="Comment">/* required as of 8.4 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create and fill the CachedPlanSource struct within the caller's memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * context.&nbsp; Most fields are just left empty for the moment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; plansource = (CachedPlanSource *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CachedPlanSource));<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;magic = CACHEDPLANSOURCE_MAGIC;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;raw_parse_tree = raw_parse_tree;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;query_string = query_string;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;commandTag = commandTag;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;param_types = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;num_params = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;parserSetup = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;parserSetupArg = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;cursor_options = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;fixed_result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;resultDesc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;context = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;query_list = NIL;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;relationOids = NIL;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;invalItems = NIL;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;search_path = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;query_context = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;rewriteRoleId = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;rewriteRowSecurity = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;dependsOnRLS = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;gplan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;is_oneshot = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;is_complete = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;is_saved = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;is_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;generation = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;generic_cost = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;total_custom_cost = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;num_generic_plans = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;num_custom_plans = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plansource;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L366" title="utils/cache/plancache.c:366">CompleteCachedPlan</a>: second step of creating a plan cache entry.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Pass in the analyzed-and-rewritten form of the query, as well as the<br/></li>
<li></span><span class="Comment"> * required subsidiary data about parameters and such.&nbsp; All passed <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> will<br/></li>
<li></span><span class="Comment"> * be copied into the CachedPlanSource's memory, except as specified below.<br/></li>
<li></span><span class="Comment"> * After this is called, <a href="#L1168" title="utils/cache/plancache.c:1168">GetCachedPlan</a> can be called to obtain a plan, and<br/></li>
<li></span><span class="Comment"> * optionally the CachedPlanSource can be saved using <a href="#L482" title="utils/cache/plancache.c:482">SaveCachedPlan</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If querytree_context is not NULL, the querytree_list must be stored in that<br/></li>
<li></span><span class="Comment"> * context (but the other parameters need not be).&nbsp; The querytree_list is not<br/></li>
<li></span><span class="Comment"> * copied, rather the given context is kept as the initial query_context of<br/></li>
<li></span><span class="Comment"> * the CachedPlanSource.&nbsp; (It should have been created as a child of the<br/></li>
<li></span><span class="Comment"> * caller's working memory context, but it will <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> be reparented to belong<br/></li>
<li></span><span class="Comment"> * to the CachedPlanSource.)&nbsp; The querytree_context is normally the context in<br/></li>
<li></span><span class="Comment"> * which the caller did raw parsing and <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis.&nbsp; This approach saves<br/></li>
<li></span><span class="Comment"> * one tree copying step compared to passing NULL, but leaves lots of extra<br/></li>
<li></span><span class="Comment"> * cruft in the query_context, namely whatever extraneous stuff <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis<br/></li>
<li></span><span class="Comment"> * created, as well as whatever went unused from the raw <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree.&nbsp; Using<br/></li>
<li></span><span class="Comment"> * this option is a space-for-time tradeoff that is appropriate if the<br/></li>
<li></span><span class="Comment"> * CachedPlanSource is not expected to survive long.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * plancache.c cannot know how to copy the data referenced by parserSetupArg,<br/></li>
<li></span><span class="Comment"> * and it would often be inappropriate to do so anyway.&nbsp; When using that<br/></li>
<li></span><span class="Comment"> * option, it is caller's responsibility that the referenced data remains<br/></li>
<li></span><span class="Comment"> * valid for as long as the CachedPlanSource exists.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the CachedPlanSource is a &quot;oneshot&quot; plan, then no querytree copying<br/></li>
<li></span><span class="Comment"> * occurs at all, and querytree_context is ignored; it is caller's<br/></li>
<li></span><span class="Comment"> * responsibility that the passed querytree_list is sufficiently long-lived.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * plansource: structure returned by <a href="#L192" title="utils/cache/plancache.c:192">CreateCachedPlan</a><br/></li>
<li></span><span class="Comment"> * querytree_list: analyzed-and-rewritten form of query (list of Query nodes)<br/></li>
<li></span><span class="Comment"> * querytree_context: memory context containing querytree_list,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or NULL to copy querytree_list into a fresh context<br/></li>
<li></span><span class="Comment"> * param_types: array of fixed parameter type OIDs, or NULL if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a><br/></li>
<li></span><span class="Comment"> * num_params: number of fixed parameters<br/></li>
<li></span><span class="Comment"> * parserSetup: alternate method for handling query parameters<br/></li>
<li></span><span class="Comment"> * parserSetupArg: data to pass to parserSetup<br/></li>
<li></span><span class="Comment"> * cursor_options: options bitmask to pass to <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a><br/></li>
<li></span><span class="Comment"> * fixed_result: true to disallow future changes in query's result tupdesc<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L366">&#x200c;</a></span><span class="linkable">CompleteCachedPlan</span>(CachedPlanSource *plansource,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *querytree_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MemoryContext querytree_context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *param_types,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> num_params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ParserSetupHook parserSetup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *parserSetupArg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> cursor_options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> fixed_result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext source_context = plansource-&gt;context;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assert caller is doing things in a sane order */<br/></li>
<li></span>&nbsp; &nbsp; Assert(plansource-&gt;magic == CACHEDPLANSOURCE_MAGIC);<br/></li>
<li>&nbsp; &nbsp; Assert(!plansource-&gt;is_complete);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If caller supplied a querytree_context, reparent it underneath the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CachedPlanSource's context; otherwise, create a suitable context and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copy the querytree_list into it.&nbsp; But no data copying should be done<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for one-shot plans; for those, assume the passed querytree_list is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sufficiently long-lived.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;is_oneshot)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; querytree_context = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (querytree_context != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L637" title="utils/mmgr/mcxt.c:637">MemoryContextSetParent</a>(querytree_context, source_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(querytree_context);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Again, it's a good bet the querytree_context can be small */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; querytree_context = AllocSetContextCreate(source_context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;CachedPlanQuery&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_START_SMALL_SIZES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(querytree_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; querytree_list = copyObject(querytree_list);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plansource-&gt;query_context = querytree_context;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;query_list = querytree_list;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!plansource-&gt;is_oneshot &amp;&amp; <a href="#L85" title="utils/cache/plancache.c:85">StmtPlanRequiresRevalidation</a>(plansource))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use the <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> machinery to extract dependencies.&nbsp; Data is saved<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in query_context.&nbsp; (We assume that not a lot of extra cruft is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * created by this call.)&nbsp; We can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this for one-shot plans, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * plans not needing revalidation have no such dependencies anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/plan/setrefs.c.html#L3541" title="optimizer/plan/setrefs.c:3541">extract_query_dependencies</a>((Node *) querytree_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;plansource-&gt;relationOids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;plansource-&gt;invalItems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;plansource-&gt;dependsOnRLS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update RLS info as well. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;rewriteRoleId = <a href="../init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;rewriteRowSecurity = <a href="../misc/guc_tables.c.html#L513" title="utils/misc/guc_tables.c:513">row_security</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also save the current search_path in the query_context.&nbsp; (This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should not generate much extra cruft either, since almost certainly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the path is already valid.)&nbsp; &nbsp; Again, we don't really need this for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one-shot plans; and we *must* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this for transaction control<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * commands, because this could result in catalog accesses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;search_path = <a href="../../catalog/namespace.c.html#L3837" title="catalog/namespace.c:3837">GetSearchPathMatcher</a>(querytree_context);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Save the final parameter types (or other parameter specification data)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into the source_context, as well as our other parameters.&nbsp; Also save<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the result tuple descriptor.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(source_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (num_params &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;param_types = (Oid *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(num_params * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(plansource-&gt;param_types, param_types, num_params * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;param_types = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;num_params = num_params;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;parserSetup = parserSetup;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;parserSetupArg = parserSetupArg;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;cursor_options = cursor_options;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;fixed_result = fixed_result;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;resultDesc = <a href="#L1949" title="utils/cache/plancache.c:1949">PlanCacheComputeResultDesc</a>(querytree_list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plansource-&gt;is_complete = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;is_valid = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L482" title="utils/cache/plancache.c:482">SaveCachedPlan</a>: save a cached plan permanently<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function moves the cached plan underneath <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a> (making<br/></li>
<li></span><span class="Comment"> * it live for the life of the backend, unless explicitly dropped), and adds<br/></li>
<li></span><span class="Comment"> * it to the list of cached plans that are checked for invalidation when an<br/></li>
<li></span><span class="Comment"> * sinval event occurs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is guaranteed not to throw error, except for the caller-error case<br/></li>
<li></span><span class="Comment"> * of trying to save a one-shot plan.&nbsp; Callers typically depend on that<br/></li>
<li></span><span class="Comment"> * since this is called just <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> or just after adding a pointer to the<br/></li>
<li></span><span class="Comment"> * CachedPlanSource to some permanent data structure of their own.&nbsp; Up until<br/></li>
<li></span><span class="Comment"> * this is done, a CachedPlanSource is just transient data that will go away<br/></li>
<li></span><span class="Comment"> * automatically on transaction abort.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L482">&#x200c;</a></span><span class="linkable">SaveCachedPlan</span>(CachedPlanSource *plansource)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assert caller is doing things in a sane order */<br/></li>
<li></span>&nbsp; &nbsp; Assert(plansource-&gt;magic == CACHEDPLANSOURCE_MAGIC);<br/></li>
<li>&nbsp; &nbsp; Assert(plansource-&gt;is_complete);<br/></li>
<li>&nbsp; &nbsp; Assert(!plansource-&gt;is_saved);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This seems worth a real test, though */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;is_oneshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot save one-shot cached plan&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In typical use, this function would be called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> generating <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plans from the CachedPlanSource.&nbsp; If there is a generic plan, moving it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a> would be pretty risky since it's unclear<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whether the caller has taken suitable care with making references<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * long-lived.&nbsp; Best thing to do seems to be to discard the plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L555" title="utils/cache/plancache.c:555">ReleaseGenericPlan</a>(plansource);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reparent the source memory context under <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a> so that it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will live indefinitely.&nbsp; The query_context follows along since it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already a child of the other one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L637" title="utils/mmgr/mcxt.c:637">MemoryContextSetParent</a>(plansource-&gt;context, <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add the entry to the global list of cached plans.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dlist_push_tail(&amp;<a href="#L95" title="utils/cache/plancache.c:95">saved_plan_list</a>, &amp;plansource-&gt;node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plansource-&gt;is_saved = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L526" title="utils/cache/plancache.c:526">DropCachedPlan</a>: destroy a cached plan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Actually this only destroys the CachedPlanSource: <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> referenced CachedPlan<br/></li>
<li></span><span class="Comment"> * is released, but not destroyed until its refcount goes to zero.&nbsp; That<br/></li>
<li></span><span class="Comment"> * handles the situation where <a href="#L526" title="utils/cache/plancache.c:526">DropCachedPlan</a> is called while the plan is<br/></li>
<li></span><span class="Comment"> * still in use.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L526">&#x200c;</a></span><span class="linkable">DropCachedPlan</span>(CachedPlanSource *plansource)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(plansource-&gt;magic == CACHEDPLANSOURCE_MAGIC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If it's been saved, remove it from the list */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;is_saved)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;plansource-&gt;node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;is_saved = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Decrement generic CachedPlan's refcount and drop if no longer needed */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L555" title="utils/cache/plancache.c:555">ReleaseGenericPlan</a>(plansource);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark it no longer valid */<br/></li>
<li></span>&nbsp; &nbsp; plansource-&gt;magic = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove the CachedPlanSource and all subsidiary data (including the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * query_context if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>).&nbsp; But if it's a one-shot we can't free anything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!plansource-&gt;is_oneshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(plansource-&gt;context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L555" title="utils/cache/plancache.c:555">ReleaseGenericPlan</a>: release a CachedPlanSource's generic plan, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L555">&#x200c;</a></span><span class="linkable">ReleaseGenericPlan</span>(CachedPlanSource *plansource)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Be paranoid about the possibility that <a href="#L1291" title="utils/cache/plancache.c:1291">ReleaseCachedPlan</a> fails */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;gplan)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CachedPlan *plan = plansource-&gt;gplan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(plan-&gt;magic == CACHEDPLAN_MAGIC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;gplan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1291" title="utils/cache/plancache.c:1291">ReleaseCachedPlan</a>(plan, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L583" title="utils/cache/plancache.c:583">RevalidateCachedQuery</a>: ensure validity of analyzed-and-rewritten query tree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * What we do here is re-acquire locks and redo <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis if necessary.<br/></li>
<li></span><span class="Comment"> * On return, the query_list is valid and we have sufficient locks to begin<br/></li>
<li></span><span class="Comment"> * planning.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis activity is required, the caller's memory context is<br/></li>
<li></span><span class="Comment"> * used for that work.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result value is the transient analyzed-and-rewritten query tree if we<br/></li>
<li></span><span class="Comment"> * had to do re-analysis, and NIL otherwise.&nbsp; (This is returned just to save<br/></li>
<li></span><span class="Comment"> * a tree copying step in a subsequent <a href="#L906" title="utils/cache/plancache.c:906">BuildCachedPlan</a> call.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L583">&#x200c;</a><span class="linkable">RevalidateCachedQuery</span>(CachedPlanSource *plansource,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/queryenvironment.c.html#L32" title="utils/misc/queryenvironment.c:32">QueryEnvironment</a> *queryEnv)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; snapshot_set;<br/></li>
<li>&nbsp; &nbsp; RawStmt&nbsp; &nbsp; *rawtree;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* transient query-tree list */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *qlist;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* permanent query-tree list */<br/></li>
<li></span>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; resultDesc;<br/></li>
<li>&nbsp; &nbsp; MemoryContext querytree_context;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For one-shot plans, we do not support revalidation checking; it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assumed the query is parsed, planned, and executed in one transaction,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so that no lock re-acquisition is necessary.&nbsp; Also, if the statement<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * type can't require revalidation, we needn't do anything (and we mustn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * risk catalog accesses when handling, eg, transaction control commands).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;is_oneshot || !<a href="#L85" title="utils/cache/plancache.c:85">StmtPlanRequiresRevalidation</a>(plansource))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(plansource-&gt;is_valid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the query is currently valid, we should have a saved search_path ---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check to see if that matches the current environment.&nbsp; If not, we want<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to force replan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;is_valid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(plansource-&gt;search_path != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../catalog/namespace.c.html#L3896" title="catalog/namespace.c:3896">SearchPathMatchesCurrentEnvironment</a>(plansource-&gt;search_path))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Invalidate the querytree and generic plan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;is_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;gplan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;gplan-&gt;is_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the query rewrite phase had a possible RLS dependency, we must redo<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it if either the role or the <a href="../misc/guc_tables.c.html#L513" title="utils/misc/guc_tables.c:513">row_security</a> setting has changed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;is_valid &amp;&amp; plansource-&gt;dependsOnRLS &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (plansource-&gt;rewriteRoleId != <a href="../init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>() ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plansource-&gt;rewriteRowSecurity != <a href="../misc/guc_tables.c.html#L513" title="utils/misc/guc_tables.c:513">row_security</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;is_valid = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the query is currently valid, acquire locks on the referenced<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * objects; then check again.&nbsp; We need to do it this way to cover the race<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * condition that an invalidation message arrives <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we get the locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;is_valid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1828" title="utils/cache/plancache.c:1828">AcquirePlannerLocks</a>(plansource-&gt;query_list, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * By <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> invalidation has happened, the inval callback<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> will have marked the query invalid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;is_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Successfully revalidated and locked the query. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Oops, the race case happened.&nbsp; Release useless locks. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1828" title="utils/cache/plancache.c:1828">AcquirePlannerLocks</a>(plansource-&gt;query_list, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Discard the no-longer-useful query tree.&nbsp; (Note: we don't want to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> earlier, else we'd not have been able to release locks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * correctly in the race condition case.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; plansource-&gt;is_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;query_list = NIL;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;relationOids = NIL;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;invalItems = NIL;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;search_path = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Free the query_context.&nbsp; We don't really expect <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fail, but just in case, make sure the CachedPlanSource is left in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reasonably sane state.&nbsp; (The generic plan won't get unlinked yet, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that's acceptable.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;query_context)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext qcxt = plansource-&gt;query_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;query_context = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(qcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Drop the generic plan reference if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L555" title="utils/cache/plancache.c:555">ReleaseGenericPlan</a>(plansource);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now re-do <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis and rewrite.&nbsp; This not incidentally acquires<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the locks we need to do planning safely.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(plansource-&gt;is_complete);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If a snapshot is already set (the normal case), we can just use that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for parsing/planning.&nbsp; But if it isn't, install one.&nbsp; Note: no point in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checking whether <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis requires a snapshot; utility commands<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't have invalidatable plans, so we'd not get here for such a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * command.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snapshot_set = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../time/snapmgr.c.html#L782" title="utils/time/snapmgr.c:782">ActiveSnapshotSet</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../time/snapmgr.c.html#L648" title="utils/time/snapmgr.c:648">PushActiveSnapshot</a>(<a href="../time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snapshot_set = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Run <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis and rule rewriting.&nbsp; The parser tends to scribble on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its input, so we must copy the raw <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree to prevent corruption of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the cache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rawtree = copyObject(plansource-&gt;raw_parse_tree);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rawtree == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tlist = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (plansource-&gt;parserSetup != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tlist = <a href="../../tcop/postgres.c.html#L764" title="tcop/postgres.c:764">pg_analyze_and_rewrite_withcb</a>(rawtree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;query_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;parserSetup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;parserSetupArg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryEnv);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tlist = <a href="../../tcop/postgres.c.html#L671" title="tcop/postgres.c:671">pg_analyze_and_rewrite_fixedparams</a>(rawtree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plansource-&gt;query_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plansource-&gt;param_types,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plansource-&gt;num_params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; queryEnv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release snapshot if we got one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (snapshot_set)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check or update the result tupdesc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We assume the parameter types didn't change from the first time, so no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to update that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; resultDesc = <a href="#L1949" title="utils/cache/plancache.c:1949">PlanCacheComputeResultDesc</a>(tlist);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (resultDesc == <span class="Constant">NULL</span> &amp;&amp; plansource-&gt;resultDesc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, doesn't return tuples */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (resultDesc == <span class="Constant">NULL</span> || plansource-&gt;resultDesc == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="../../access/common/tupdesc.c.html#L586" title="access/common/tupdesc.c:586">equalRowTypes</a>(resultDesc, plansource-&gt;resultDesc))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can we give a better error message? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;fixed_result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cached plan must not change result type&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(plansource-&gt;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (resultDesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resultDesc = <a href="../../access/common/tupdesc.c.html#L133" title="access/common/tupdesc.c:133">CreateTupleDescCopy</a>(resultDesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;resultDesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L331" title="access/common/tupdesc.c:331">FreeTupleDesc</a>(plansource-&gt;resultDesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;resultDesc = resultDesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate new query_context and copy the completed querytree into it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's transient until we complete the copying and dependency extraction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; querytree_context = AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;CachedPlanQuery&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_START_SMALL_SIZES);<br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(querytree_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qlist = copyObject(tlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use the <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> machinery to extract dependencies.&nbsp; Data is saved in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * query_context.&nbsp; (We assume that not a lot of extra cruft is created by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this call.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../optimizer/plan/setrefs.c.html#L3541" title="optimizer/plan/setrefs.c:3541">extract_query_dependencies</a>((Node *) qlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;plansource-&gt;relationOids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;plansource-&gt;invalItems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;plansource-&gt;dependsOnRLS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update RLS info as well. */<br/></li>
<li></span>&nbsp; &nbsp; plansource-&gt;rewriteRoleId = <a href="../init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>();<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;rewriteRowSecurity = <a href="../misc/guc_tables.c.html#L513" title="utils/misc/guc_tables.c:513">row_security</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also save the current search_path in the query_context.&nbsp; (This should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not generate much extra cruft either, since almost certainly the path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is already valid.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; plansource-&gt;search_path = <a href="../../catalog/namespace.c.html#L3837" title="catalog/namespace.c:3837">GetSearchPathMatcher</a>(querytree_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now reparent the finished query_context and save the links */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L637" title="utils/mmgr/mcxt.c:637">MemoryContextSetParent</a>(querytree_context, plansource-&gt;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plansource-&gt;query_context = querytree_context;<br/></li>
<li>&nbsp; &nbsp; plansource-&gt;query_list = qlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we do not reset generic_cost or total_custom_cost, although we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could choose to do so.&nbsp; If the DDL or statistics change that prompted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the invalidation meant a significant change in the cost estimates, it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would be better to reset those variables and start fresh; but often it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't, and we're better retaining our hard-won knowledge about the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relative costs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; plansource-&gt;is_valid = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return transient copy of querytrees for possible use in planning */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> tlist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L822" title="utils/cache/plancache.c:822">CheckCachedPlan</a>: see if the CachedPlanSource's generic plan is valid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must have already called <a href="#L583" title="utils/cache/plancache.c:583">RevalidateCachedQuery</a> to verify that the<br/></li>
<li></span><span class="Comment"> * querytree is up to date.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On a &quot;true&quot; return, we have acquired the locks needed to run the plan.<br/></li>
<li></span><span class="Comment"> * (We must do this for the &quot;true&quot; result to be race-condition-free.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L822">&#x200c;</a></span><span class="linkable">CheckCachedPlan</span>(CachedPlanSource *plansource)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CachedPlan *plan = plansource-&gt;gplan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assert that caller checked the querytree */<br/></li>
<li></span>&nbsp; &nbsp; Assert(plansource-&gt;is_valid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there's no generic plan, just say &quot;false&quot; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!plan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(plan-&gt;magic == CACHEDPLAN_MAGIC);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Generic plans are never one-shot */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!plan-&gt;is_oneshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If plan isn't valid for current role, we can't use it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plan-&gt;is_valid &amp;&amp; plan-&gt;dependsOnRole &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;planRoleId != <a href="../init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;is_valid = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it appears valid, acquire locks and recheck; this is much the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * logic as in <a href="#L583" title="utils/cache/plancache.c:583">RevalidateCachedQuery</a>, but for a plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plan-&gt;is_valid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Plan must have positive refcount because it is referenced by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * plansource; so no need to fear it disappears under us here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(plan-&gt;refcount &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1772" title="utils/cache/plancache.c:1772">AcquireExecutorLocks</a>(plan-&gt;stmt_list, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If plan was transient, check to see if <a href="../time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a> has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * advanced, and if so invalidate it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plan-&gt;is_valid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionIdIsValid(plan-&gt;saved_xmin) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !TransactionIdEquals(plan-&gt;saved_xmin, <a href="../time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;is_valid = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * By <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> invalidation has happened, the inval callback<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> will have marked the plan invalid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plan-&gt;is_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Successfully revalidated and locked the query. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Oops, the race case happened.&nbsp; Release useless locks. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1772" title="utils/cache/plancache.c:1772">AcquireExecutorLocks</a>(plan-&gt;stmt_list, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Plan has been invalidated, so unlink it from the parent and release it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L555" title="utils/cache/plancache.c:555">ReleaseGenericPlan</a>(plansource);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L906" title="utils/cache/plancache.c:906">BuildCachedPlan</a>: construct a new CachedPlan from a CachedPlanSource.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * qlist should be the result value from a previous <a href="#L583" title="utils/cache/plancache.c:583">RevalidateCachedQuery</a>,<br/></li>
<li></span><span class="Comment"> * or it can be set to NIL if we need to re-copy the plansource's query_list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To build a generic, parameter-value-independent plan, pass NULL for<br/></li>
<li></span><span class="Comment"> * boundParams.&nbsp; To build a custom plan, pass the actual parameter <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> via<br/></li>
<li></span><span class="Comment"> * boundParams.&nbsp; For best effect, the PARAM_FLAG_CONST flag should be set on<br/></li>
<li></span><span class="Comment"> * each parameter value; otherwise the <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> will treat the value as a<br/></li>
<li></span><span class="Comment"> * hint rather than a hard constant.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Planning work is done in the caller's memory context.&nbsp; The finished plan<br/></li>
<li></span><span class="Comment"> * is in a child memory context, which typically should get reparented<br/></li>
<li></span><span class="Comment"> * (unless this is a one-shot plan, in which case we don't copy the plan).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> CachedPlan *<br/></li>
<li><a id="L906">&#x200c;</a><span class="linkable">BuildCachedPlan</span>(CachedPlanSource *plansource, List *qlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParamListInfo boundParams, <a href="../misc/queryenvironment.c.html#L32" title="utils/misc/queryenvironment.c:32">QueryEnvironment</a> *queryEnv)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CachedPlan *plan;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *plist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; snapshot_set;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_transient;<br/></li>
<li>&nbsp; &nbsp; MemoryContext plan_context;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normally the querytree should be valid already, but if it's not,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rebuild it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: <a href="#L1168" title="utils/cache/plancache.c:1168">GetCachedPlan</a> should have called <a href="#L583" title="utils/cache/plancache.c:583">RevalidateCachedQuery</a> first, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we ought to be holding sufficient locks to prevent <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> invalidation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, if we're building a custom plan after having built and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rejected a generic plan, it's possible to reach here with is_valid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * false due to an invalidation while making the generic plan.&nbsp; In theory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the invalidation must be a false positive, perhaps a consequence of an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sinval reset event or the <a href="inval.c.html#L240" title="utils/cache/inval.c:240">debug_discard_caches</a> code.&nbsp; But for safety,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * let's treat it as real and redo the <a href="#L583" title="utils/cache/plancache.c:583">RevalidateCachedQuery</a> call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!plansource-&gt;is_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qlist = <a href="#L583" title="utils/cache/plancache.c:583">RevalidateCachedQuery</a>(plansource, queryEnv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we don't already have a copy of the querytree list that can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scribbled on by the <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>, make one.&nbsp; For a one-shot plan, we assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's okay to scribble on the original query_list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (qlist == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!plansource-&gt;is_oneshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qlist = copyObject(plansource-&gt;query_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qlist = plansource-&gt;query_list;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If a snapshot is already set (the normal case), we can just use that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for planning.&nbsp; But if it isn't, and we need one, install one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snapshot_set = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../time/snapmgr.c.html#L782" title="utils/time/snapmgr.c:782">ActiveSnapshotSet</a>() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;raw_parse_tree &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../parser/analyze.c.html#L485" title="parser/analyze.c:485">analyze_requires_snapshot</a>(plansource-&gt;raw_parse_tree))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../time/snapmgr.c.html#L648" title="utils/time/snapmgr.c:648">PushActiveSnapshot</a>(<a href="../time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snapshot_set = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate the plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; plist = <a href="../../tcop/postgres.c.html#L972" title="tcop/postgres.c:972">pg_plan_queries</a>(qlist, plansource-&gt;query_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;cursor_options, boundParams);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release snapshot if we got one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (snapshot_set)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normally we make a dedicated memory context for the CachedPlan and its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subsidiary data.&nbsp; (It's probably not going to be large, but just in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case, allow it to grow large.&nbsp; It's transient for the moment.)&nbsp; But for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a one-shot plan, we just leave it in the caller's memory context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!plansource-&gt;is_oneshot)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan_context = AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;CachedPlan&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_START_SMALL_SIZES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextCopyAndSetIdentifier(plan_context, plansource-&gt;query_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy plan into the new context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(plan_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plist = copyObject(plist);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; plan_context = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create and fill the CachedPlan struct within the new context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; plan = (CachedPlan *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CachedPlan));<br/></li>
<li>&nbsp; &nbsp; plan-&gt;magic = CACHEDPLAN_MAGIC;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;stmt_list = plist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CachedPlan is dependent on role either if RLS affected the rewrite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * phase or if a role dependency was injected during planning.&nbsp; And it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transient if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> plan is marked so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; plan-&gt;planRoleId = <a href="../init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>();<br/></li>
<li>&nbsp; &nbsp; plan-&gt;dependsOnRole = plansource-&gt;dependsOnRLS;<br/></li>
<li>&nbsp; &nbsp; is_transient = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, plist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlannedStmt *plannedstmt = lfirst_node(PlannedStmt, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plannedstmt-&gt;commandType == CMD_UTILITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore utility statements */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plannedstmt-&gt;transientPlan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_transient = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plannedstmt-&gt;dependsOnRole)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;dependsOnRole = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_transient)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsNormal(<a href="../time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;saved_xmin = <a href="../time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;saved_xmin = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;refcount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;context = plan_context;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;is_oneshot = plansource-&gt;is_oneshot;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;is_saved = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;is_valid = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* assign generation number to new plan */<br/></li>
<li></span>&nbsp; &nbsp; plan-&gt;generation = ++(plansource-&gt;generation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1046" title="utils/cache/plancache.c:1046">choose_custom_plan</a>: choose whether to use custom or generic plan<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This defines the policy followed by <a href="#L1168" title="utils/cache/plancache.c:1168">GetCachedPlan</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1046">&#x200c;</a></span><span class="linkable">choose_custom_plan</span>(CachedPlanSource *plansource, ParamListInfo boundParams)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; avg_custom_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* One-shot plans will always be considered custom */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;is_oneshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise, never <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> point in a custom plan if there's no parameters */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (boundParams == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... nor when planning would be a no-op */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L85" title="utils/cache/plancache.c:85">StmtPlanRequiresRevalidation</a>(plansource))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Let settings force the decision */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L147" title="utils/cache/plancache.c:147">plan_cache_mode</a> == PLAN_CACHE_MODE_FORCE_GENERIC_PLAN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L147" title="utils/cache/plancache.c:147">plan_cache_mode</a> == PLAN_CACHE_MODE_FORCE_CUSTOM_PLAN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See if caller wants to force the decision */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;cursor_options &amp; CURSOR_OPT_GENERIC_PLAN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;cursor_options &amp; CURSOR_OPT_CUSTOM_PLAN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Generate custom plans until we have done at least 5 (arbitrary) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;num_custom_plans &lt; <span class="Constant">5</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; avg_custom_cost = plansource-&gt;total_custom_cost / plansource-&gt;num_custom_plans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prefer generic plan if it's less expensive than the average custom<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plan.&nbsp; (Because we include a <a href="../adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> for cost of planning in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * custom-plan costs, this means the generic plan only has to be less<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expensive than the execution cost plus replan cost of the custom<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plans.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that if generic_cost is -1 (indicating we've not yet determined<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the generic plan cost), we'll always prefer generic at this point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;generic_cost &lt; avg_custom_cost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1103" title="utils/cache/plancache.c:1103">cached_plan_cost</a>: calculate estimated cost of a plan<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If include_planner is true, also include the estimated cost of constructing<br/></li>
<li></span><span class="Comment"> * the plan.&nbsp; (We must factor that into the cost of using a custom plan, but<br/></li>
<li></span><span class="Comment"> * we don't count it for a generic plan.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L1103">&#x200c;</a></span><span class="linkable">cached_plan_cost</span>(CachedPlan *plan, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> include_planner)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, plan-&gt;stmt_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlannedStmt *plannedstmt = lfirst_node(PlannedStmt, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plannedstmt-&gt;commandType == CMD_UTILITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore utility statements */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result += plannedstmt-&gt;planTree-&gt;total_cost;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (include_planner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Currently we use a very crude estimate of planning effort based<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on the number of relations in the finished plan's rangetable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Join planning effort actually scales much worse than linearly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the number of relations --- but only until the join collapse<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * limits kick in.&nbsp; Also, while inheritance child relations surely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * add to planning effort, they don't make the join situation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * worse.&nbsp; So the actual shape of the planning cost curve versus<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * number of relations isn't all that obvious.&nbsp; It will take<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * considerable work to arrive at a less crude estimate, and for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> it's not clear that's worth doing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The other big difficulty here is that we don't have <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> very<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * good model of how planning cost compares to execution costs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The current multiplier of 1000 * <a href="../../optimizer/path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> is probably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on the low side, but we'll try this for awhile <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> making a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more aggressive correction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we ever do write a more complicated estimator, it should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * probably live in src/backend/optimizer/ not here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrelations = list_length(plannedstmt-&gt;rtable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result += <span class="Constant">1000.0</span> * <a href="../../optimizer/path/costsize.c.html#L123" title="optimizer/path/costsize.c:123">cpu_operator_cost</a> * (nrelations + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1168" title="utils/cache/plancache.c:1168">GetCachedPlan</a>: get a cached plan from a CachedPlanSource.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function hides the logic that decides whether to use a generic<br/></li>
<li></span><span class="Comment"> * plan or a custom plan for the given parameters: the caller does not know<br/></li>
<li></span><span class="Comment"> * which it will get.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On return, the plan is valid and we have sufficient locks to begin<br/></li>
<li></span><span class="Comment"> * execution.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On return, the refcount of the plan has been incremented; a later<br/></li>
<li></span><span class="Comment"> * <a href="#L1291" title="utils/cache/plancache.c:1291">ReleaseCachedPlan</a>() call is expected.&nbsp; If &quot;owner&quot; is not NULL then<br/></li>
<li></span><span class="Comment"> * the refcount has been reported to that ResourceOwner (note that this<br/></li>
<li></span><span class="Comment"> * is only supported for &quot;saved&quot; CachedPlanSources).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> replanning activity is required, the caller's memory context<br/></li>
<li></span><span class="Comment"> * is used for that work.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>CachedPlan *<br/></li>
<li><a id="L1168">&#x200c;</a><span class="linkable">GetCachedPlan</span>(CachedPlanSource *plansource, ParamListInfo boundParams,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResourceOwner owner, <a href="../misc/queryenvironment.c.html#L32" title="utils/misc/queryenvironment.c:32">QueryEnvironment</a> *queryEnv)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CachedPlan *plan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *qlist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; customplan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assert caller is doing things in a sane order */<br/></li>
<li></span>&nbsp; &nbsp; Assert(plansource-&gt;magic == CACHEDPLANSOURCE_MAGIC);<br/></li>
<li>&nbsp; &nbsp; Assert(plansource-&gt;is_complete);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This seems worth a real test, though */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (owner &amp;&amp; !plansource-&gt;is_saved)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot apply ResourceOwner to non-saved cached plan&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure the querytree list is valid and we have <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-time locks */<br/></li>
<li></span>&nbsp; &nbsp; qlist = <a href="#L583" title="utils/cache/plancache.c:583">RevalidateCachedQuery</a>(plansource, queryEnv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Decide whether to use a custom plan */<br/></li>
<li></span>&nbsp; &nbsp; customplan = <a href="#L1046" title="utils/cache/plancache.c:1046">choose_custom_plan</a>(plansource, boundParams);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!customplan)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L822" title="utils/cache/plancache.c:822">CheckCachedPlan</a>(plansource))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We want a generic plan, and we already have a valid one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = plansource-&gt;gplan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(plan-&gt;magic == CACHEDPLAN_MAGIC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Build a new generic plan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = <a href="#L906" title="utils/cache/plancache.c:906">BuildCachedPlan</a>(plansource, qlist, <span class="Constant">NULL</span>, queryEnv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Just make real sure plansource-&gt;gplan is clear */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L555" title="utils/cache/plancache.c:555">ReleaseGenericPlan</a>(plansource);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Link the new generic plan into the plansource */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;gplan = plan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;refcount++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Immediately reparent into appropriate context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;is_saved)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* saved plans all live under <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L637" title="utils/mmgr/mcxt.c:637">MemoryContextSetParent</a>(plan-&gt;context, <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;is_saved = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise, it should be a sibling of the plansource */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L637" title="utils/mmgr/mcxt.c:637">MemoryContextSetParent</a>(plan-&gt;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../mmgr/mcxt.c.html#L731" title="utils/mmgr/mcxt.c:731">MemoryContextGetParent</a>(plansource-&gt;context));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update generic_cost whenever we make a new generic plan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;generic_cost = <a href="#L1103" title="utils/cache/plancache.c:1103">cached_plan_cost</a>(plan, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If, based on the <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-known value of generic_cost, we'd not have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * chosen to use a generic plan, then forget it and make a custom<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * plan.&nbsp; This is a <a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of a wart but is necessary to avoid a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * glitch in behavior when the custom plans are consistently big<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * winners; at some point we'll experiment with a generic plan and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it's a loser, but we don't want to actually execute that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; customplan = <a href="#L1046" title="utils/cache/plancache.c:1046">choose_custom_plan</a>(plansource, boundParams);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we choose to plan again, we need to re-copy the query_list,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since the <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> probably scribbled on it.&nbsp; We can force<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L906" title="utils/cache/plancache.c:906">BuildCachedPlan</a> to do that by passing NIL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qlist = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (customplan)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Build a custom plan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; plan = <a href="#L906" title="utils/cache/plancache.c:906">BuildCachedPlan</a>(plansource, qlist, boundParams, queryEnv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Accumulate total costs of custom plans */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;total_custom_cost += <a href="#L1103" title="utils/cache/plancache.c:1103">cached_plan_cost</a>(plan, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;num_custom_plans++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;num_generic_plans++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(plan != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Flag the plan as in use by caller */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (owner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(owner);<br/></li>
<li>&nbsp; &nbsp; plan-&gt;refcount++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (owner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="utils/cache/plancache.c:135">ResourceOwnerRememberPlanCacheRef</a>(owner, plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Saved plans should be under <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a> so they will not go away<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * until their reference count goes to zero.&nbsp; In the generic-plan cases we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already took care of that, but for a custom plan, do it as soon as we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have created a reference-counted link.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (customplan &amp;&amp; plansource-&gt;is_saved)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L637" title="utils/mmgr/mcxt.c:637">MemoryContextSetParent</a>(plan-&gt;context, <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;is_saved = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1291" title="utils/cache/plancache.c:1291">ReleaseCachedPlan</a>: release active use of a cached plan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This decrements the reference count, and frees the plan if the count<br/></li>
<li></span><span class="Comment"> * has thereby gone to zero.&nbsp; If &quot;owner&quot; is not NULL, it is assumed that<br/></li>
<li></span><span class="Comment"> * the reference count is managed by that ResourceOwner.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: owner == NULL is used for releasing references that are in<br/></li>
<li></span><span class="Comment"> * persistent data structures, such as the parent CachedPlanSource or a<br/></li>
<li></span><span class="Comment"> * Portal.&nbsp; Transient references should be protected by a resource owner.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1291">&#x200c;</a></span><span class="linkable">ReleaseCachedPlan</span>(CachedPlan *plan, ResourceOwner owner)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(plan-&gt;magic == CACHEDPLAN_MAGIC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (owner)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(plan-&gt;is_saved);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="utils/cache/plancache.c:140">ResourceOwnerForgetPlanCacheRef</a>(owner, plan);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(plan-&gt;refcount &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; plan-&gt;refcount--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan-&gt;refcount == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark it no longer valid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;magic = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* One-shot plans do not own their context, so we can't free them */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!plan-&gt;is_oneshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(plan-&gt;context);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1336" title="utils/cache/plancache.c:1336">CachedPlanAllowsSimpleValidityCheck</a>: can we use <a href="#L1451" title="utils/cache/plancache.c:1451">CachedPlanIsSimplyValid</a>?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function, together with <a href="#L1451" title="utils/cache/plancache.c:1451">CachedPlanIsSimplyValid</a>, provides a fast path<br/></li>
<li></span><span class="Comment"> * for revalidating &quot;simple&quot; generic plans.&nbsp; The core requirement to be simple<br/></li>
<li></span><span class="Comment"> * is that the plan must not require taking <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> locks, which translates to<br/></li>
<li></span><span class="Comment"> * not touching <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tables; this happens to match up well with an important<br/></li>
<li></span><span class="Comment"> * use-case in PL/pgSQL.&nbsp; This function tests whether that's true, along<br/></li>
<li></span><span class="Comment"> * with checking some other corner cases that we'd rather not bother with<br/></li>
<li></span><span class="Comment"> * handling in the fast path.&nbsp; (Note that it's still possible for such a plan<br/></li>
<li></span><span class="Comment"> * to be invalidated, for example due to a change in a function that was<br/></li>
<li></span><span class="Comment"> * inlined into the plan.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the plan is simply valid, and &quot;owner&quot; is not NULL, record a refcount on<br/></li>
<li></span><span class="Comment"> * the plan in that resowner <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning.&nbsp; It is caller's responsibility<br/></li>
<li></span><span class="Comment"> * to be sure that a refcount is held on <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> plan that's being actively used.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This must only be called on known-valid generic plans (eg, ones just<br/></li>
<li></span><span class="Comment"> * returned by <a href="#L1168" title="utils/cache/plancache.c:1168">GetCachedPlan</a>).&nbsp; If it returns true, the caller may re-use<br/></li>
<li></span><span class="Comment"> * the cached plan as long as <a href="#L1451" title="utils/cache/plancache.c:1451">CachedPlanIsSimplyValid</a> returns true; that<br/></li>
<li></span><span class="Comment"> * check is much cheaper than the full revalidation done by <a href="#L1168" title="utils/cache/plancache.c:1168">GetCachedPlan</a>.<br/></li>
<li></span><span class="Comment"> * Nonetheless, no required checks are omitted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1336">&#x200c;</a></span><span class="linkable">CachedPlanAllowsSimpleValidityCheck</span>(CachedPlanSource *plansource,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CachedPlan *plan, ResourceOwner owner)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sanity-check that the caller gave us a validated generic plan.&nbsp; Notice<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we *don't* assert plansource-&gt;is_valid as you might expect; that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because it's possible that that's already false when <a href="#L1168" title="utils/cache/plancache.c:1168">GetCachedPlan</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * returns, e.g. because <a href="#L2187" title="utils/cache/plancache.c:2187">ResetPlanCache</a> happened partway through.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> the plan as long as plan-&gt;is_valid is true, and expect to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replan after the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="#L1451" title="utils/cache/plancache.c:1451">CachedPlanIsSimplyValid</a> call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(plansource-&gt;magic == CACHEDPLANSOURCE_MAGIC);<br/></li>
<li>&nbsp; &nbsp; Assert(plan-&gt;magic == CACHEDPLAN_MAGIC);<br/></li>
<li>&nbsp; &nbsp; Assert(plan-&gt;is_valid);<br/></li>
<li>&nbsp; &nbsp; Assert(plan == plansource-&gt;gplan);<br/></li>
<li>&nbsp; &nbsp; Assert(plansource-&gt;search_path != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../catalog/namespace.c.html#L3896" title="catalog/namespace.c:3896">SearchPathMatchesCurrentEnvironment</a>(plansource-&gt;search_path));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We don't support oneshot plans here. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;is_oneshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; Assert(!plan-&gt;is_oneshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the plan is dependent on RLS considerations, or it's transient,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reject.&nbsp; These things probably can't ever happen for table-free<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * queries, but for safety's sake let's check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;dependsOnRLS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan-&gt;dependsOnRole)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(plan-&gt;saved_xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reject if <a href="#L1828" title="utils/cache/plancache.c:1828">AcquirePlannerLocks</a> would have anything to do.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * simplistic, but there's no need to inquire <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more carefully; indeed,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for current callers it shouldn't even be possible to hit <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of these<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, plansource-&gt;query_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query = lfirst_node(Query, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;commandType == CMD_UTILITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;rtable || query-&gt;cteList || query-&gt;hasSubLinks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reject if <a href="#L1772" title="utils/cache/plancache.c:1772">AcquireExecutorLocks</a> would have anything to do.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * probably unnecessary given the previous check, but let's be safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, plan-&gt;stmt_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlannedStmt *plannedstmt = lfirst_node(PlannedStmt, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plannedstmt-&gt;commandType == CMD_UTILITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to grovel through the rtable because it's likely to contain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an RTE_RESULT relation, rather than being totally empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, plannedstmt-&gt;rtable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = (RangeTblEntry *) lfirst(lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind == RTE_RELATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Okay, it's simple.&nbsp; Note that what we've primarily established here is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that no locks need be taken <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> checking the plan's is_valid flag.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Bump refcount if requested. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (owner)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(owner);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;refcount++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="utils/cache/plancache.c:135">ResourceOwnerRememberPlanCacheRef</a>(owner, plan);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1451" title="utils/cache/plancache.c:1451">CachedPlanIsSimplyValid</a>: quick check for plan still being valid<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function must not be used unless <a href="#L1336" title="utils/cache/plancache.c:1336">CachedPlanAllowsSimpleValidityCheck</a><br/></li>
<li></span><span class="Comment"> * previously said it was OK.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the plan is valid, and &quot;owner&quot; is not NULL, record a refcount on<br/></li>
<li></span><span class="Comment"> * the plan in that resowner <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning.&nbsp; It is caller's responsibility<br/></li>
<li></span><span class="Comment"> * to be sure that a refcount is held on <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> plan that's being actively used.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The code here is unconditionally safe as long as the only use of this<br/></li>
<li></span><span class="Comment"> * CachedPlanSource is in connection with the particular CachedPlan pointer<br/></li>
<li></span><span class="Comment"> * that's passed in.&nbsp; If the plansource were being used for other purposes,<br/></li>
<li></span><span class="Comment"> * it's possible that its generic plan could be invalidated and regenerated<br/></li>
<li></span><span class="Comment"> * while the current caller wasn't looking, and then there could be a chance<br/></li>
<li></span><span class="Comment"> * collision of address between this caller's <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-stale plan pointer and the<br/></li>
<li></span><span class="Comment"> * actual address of the new generic plan.&nbsp; For current uses, that scenario<br/></li>
<li></span><span class="Comment"> * can't happen; but with a plansource shared across multiple uses, it'd be<br/></li>
<li></span><span class="Comment"> * advisable to also save plan-&gt;generation and verify that that still matches.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1451">&#x200c;</a></span><span class="linkable">CachedPlanIsSimplyValid</span>(CachedPlanSource *plansource, CachedPlan *plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResourceOwner owner)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Careful here: since the caller doesn't necessarily hold a refcount on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the plan to start with, it's possible that &quot;plan&quot; is a dangling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pointer.&nbsp; Don't dereference it until we've verified that it still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matches the plansource's gplan (which is either valid or NULL).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(plansource-&gt;magic == CACHEDPLANSOURCE_MAGIC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Has cache invalidation fired on this plan?&nbsp; We can check this right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * away since there are no locks that we'd need to acquire first.&nbsp; Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that here we *do* check plansource-&gt;is_valid, so as to force plan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rebuild if that's become false.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!plansource-&gt;is_valid ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan == <span class="Constant">NULL</span> || plan != plansource-&gt;gplan ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !plan-&gt;is_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(plan-&gt;magic == CACHEDPLAN_MAGIC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Is the search_path still the same as when we made it? */<br/></li>
<li></span>&nbsp; &nbsp; Assert(plansource-&gt;search_path != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../catalog/namespace.c.html#L3896" title="catalog/namespace.c:3896">SearchPathMatchesCurrentEnvironment</a>(plansource-&gt;search_path))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* It's still good.&nbsp; Bump refcount if requested. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (owner)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(owner);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;refcount++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="utils/cache/plancache.c:135">ResourceOwnerRememberPlanCacheRef</a>(owner, plan);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1498" title="utils/cache/plancache.c:1498">CachedPlanSetParentContext</a>: move a CachedPlanSource to a new memory context<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This can only be applied to unsaved plans; once saved, a plan always<br/></li>
<li></span><span class="Comment"> * lives underneath <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1498">&#x200c;</a></span><span class="linkable">CachedPlanSetParentContext</span>(CachedPlanSource *plansource,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MemoryContext newcontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assert caller is doing things in a sane order */<br/></li>
<li></span>&nbsp; &nbsp; Assert(plansource-&gt;magic == CACHEDPLANSOURCE_MAGIC);<br/></li>
<li>&nbsp; &nbsp; Assert(plansource-&gt;is_complete);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* These seem worth real tests, though */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;is_saved)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot move a saved cached plan to another context&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;is_oneshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot move a one-shot cached plan to another context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, let the caller keep the plan where he wishes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L637" title="utils/mmgr/mcxt.c:637">MemoryContextSetParent</a>(plansource-&gt;context, newcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The query_context needs no special handling, since it's a child of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plansource-&gt;context.&nbsp; But if there's a generic plan, it should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * maintained as a sibling of plansource-&gt;context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;gplan)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(plansource-&gt;gplan-&gt;magic == CACHEDPLAN_MAGIC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L637" title="utils/mmgr/mcxt.c:637">MemoryContextSetParent</a>(plansource-&gt;gplan-&gt;context, newcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1536" title="utils/cache/plancache.c:1536">CopyCachedPlan</a>: make a copy of a CachedPlanSource<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a convenience routine that does the equivalent of<br/></li>
<li></span><span class="Comment"> * <a href="#L192" title="utils/cache/plancache.c:192">CreateCachedPlan</a> + <a href="#L366" title="utils/cache/plancache.c:366">CompleteCachedPlan</a>, using the data stored in the<br/></li>
<li></span><span class="Comment"> * input CachedPlanSource.&nbsp; The result is therefore &quot;unsaved&quot; (regardless<br/></li>
<li></span><span class="Comment"> * of the state of the source), and we don't copy <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> generic plan either.<br/></li>
<li></span><span class="Comment"> * The result will be currently valid, or not, the same as the source.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>CachedPlanSource *<br/></li>
<li><a id="L1536">&#x200c;</a><span class="linkable">CopyCachedPlan</span>(CachedPlanSource *plansource)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CachedPlanSource *newsource;<br/></li>
<li>&nbsp; &nbsp; MemoryContext source_context;<br/></li>
<li>&nbsp; &nbsp; MemoryContext querytree_context;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(plansource-&gt;magic == CACHEDPLANSOURCE_MAGIC);<br/></li>
<li>&nbsp; &nbsp; Assert(plansource-&gt;is_complete);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * One-shot plans can't be copied, because we haven't taken care that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parsing/planning didn't scribble on the raw <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree or querytrees.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;is_oneshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot copy a one-shot cached plan&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; source_context = AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;CachedPlanSource&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_START_SMALL_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(source_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newsource = (CachedPlanSource *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CachedPlanSource));<br/></li>
<li>&nbsp; &nbsp; newsource-&gt;magic = CACHEDPLANSOURCE_MAGIC;<br/></li>
<li>&nbsp; &nbsp; newsource-&gt;raw_parse_tree = copyObject(plansource-&gt;raw_parse_tree);<br/></li>
<li>&nbsp; &nbsp; newsource-&gt;query_string = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(plansource-&gt;query_string);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L612" title="utils/mmgr/mcxt.c:612">MemoryContextSetIdentifier</a>(source_context, newsource-&gt;query_string);<br/></li>
<li>&nbsp; &nbsp; newsource-&gt;commandTag = plansource-&gt;commandTag;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;num_params &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newsource-&gt;param_types = (Oid *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(plansource-&gt;num_params * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(newsource-&gt;param_types, plansource-&gt;param_types,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; plansource-&gt;num_params * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newsource-&gt;param_types = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; newsource-&gt;num_params = plansource-&gt;num_params;<br/></li>
<li>&nbsp; &nbsp; newsource-&gt;parserSetup = plansource-&gt;parserSetup;<br/></li>
<li>&nbsp; &nbsp; newsource-&gt;parserSetupArg = plansource-&gt;parserSetupArg;<br/></li>
<li>&nbsp; &nbsp; newsource-&gt;cursor_options = plansource-&gt;cursor_options;<br/></li>
<li>&nbsp; &nbsp; newsource-&gt;fixed_result = plansource-&gt;fixed_result;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;resultDesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newsource-&gt;resultDesc = <a href="../../access/common/tupdesc.c.html#L133" title="access/common/tupdesc.c:133">CreateTupleDescCopy</a>(plansource-&gt;resultDesc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newsource-&gt;resultDesc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; newsource-&gt;context = source_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; querytree_context = AllocSetContextCreate(source_context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;CachedPlanQuery&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_START_SMALL_SIZES);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(querytree_context);<br/></li>
<li>&nbsp; &nbsp; newsource-&gt;query_list = copyObject(plansource-&gt;query_list);<br/></li>
<li>&nbsp; &nbsp; newsource-&gt;relationOids = copyObject(plansource-&gt;relationOids);<br/></li>
<li>&nbsp; &nbsp; newsource-&gt;invalItems = copyObject(plansource-&gt;invalItems);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;search_path)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newsource-&gt;search_path = <a href="../../catalog/namespace.c.html#L3874" title="catalog/namespace.c:3874">CopySearchPathMatcher</a>(plansource-&gt;search_path);<br/></li>
<li>&nbsp; &nbsp; newsource-&gt;query_context = querytree_context;<br/></li>
<li>&nbsp; &nbsp; newsource-&gt;rewriteRoleId = plansource-&gt;rewriteRoleId;<br/></li>
<li>&nbsp; &nbsp; newsource-&gt;rewriteRowSecurity = plansource-&gt;rewriteRowSecurity;<br/></li>
<li>&nbsp; &nbsp; newsource-&gt;dependsOnRLS = plansource-&gt;dependsOnRLS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newsource-&gt;gplan = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newsource-&gt;is_oneshot = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; newsource-&gt;is_complete = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; newsource-&gt;is_saved = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; newsource-&gt;is_valid = plansource-&gt;is_valid;<br/></li>
<li>&nbsp; &nbsp; newsource-&gt;generation = plansource-&gt;generation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We may as well copy <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> acquired cost knowledge */<br/></li>
<li></span>&nbsp; &nbsp; newsource-&gt;generic_cost = plansource-&gt;generic_cost;<br/></li>
<li>&nbsp; &nbsp; newsource-&gt;total_custom_cost = plansource-&gt;total_custom_cost;<br/></li>
<li>&nbsp; &nbsp; newsource-&gt;num_generic_plans = plansource-&gt;num_generic_plans;<br/></li>
<li>&nbsp; &nbsp; newsource-&gt;num_custom_plans = plansource-&gt;num_custom_plans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newsource;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1627" title="utils/cache/plancache.c:1627">CachedPlanIsValid</a>: test whether the rewritten querytree within a<br/></li>
<li></span><span class="Comment"> * CachedPlanSource is currently valid (that is, not marked as being in need<br/></li>
<li></span><span class="Comment"> * of revalidation).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This result is only trustworthy (ie, free from race conditions) if<br/></li>
<li></span><span class="Comment"> * the caller has acquired locks on all the relations used in the plan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1627">&#x200c;</a></span><span class="linkable">CachedPlanIsValid</span>(CachedPlanSource *plansource)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(plansource-&gt;magic == CACHEDPLANSOURCE_MAGIC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plansource-&gt;is_valid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1640" title="utils/cache/plancache.c:1640">CachedPlanGetTargetList</a>: return tlist, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, describing plan's output<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is guaranteed up-to-date.&nbsp; However, it is local storage<br/></li>
<li></span><span class="Comment"> * within the cached plan, and may disappear <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time the plan is updated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1640">&#x200c;</a><span class="linkable">CachedPlanGetTargetList</span>(CachedPlanSource *plansource,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/queryenvironment.c.html#L32" title="utils/misc/queryenvironment.c:32">QueryEnvironment</a> *queryEnv)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *pstmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assert caller is doing things in a sane order */<br/></li>
<li></span>&nbsp; &nbsp; Assert(plansource-&gt;magic == CACHEDPLANSOURCE_MAGIC);<br/></li>
<li>&nbsp; &nbsp; Assert(plansource-&gt;is_complete);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No work needed if statement doesn't return tuples (we assume this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * feature cannot be changed by an invalidation)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;resultDesc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure the querytree list is valid and we have <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-time locks */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L583" title="utils/cache/plancache.c:583">RevalidateCachedQuery</a>(plansource, queryEnv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the primary statement and <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out what it returns */<br/></li>
<li></span>&nbsp; &nbsp; pstmt = <a href="#L1753" title="utils/cache/plancache.c:1753">QueryListGetPrimaryStmt</a>(plansource-&gt;query_list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../tcop/pquery.c.html#L348" title="tcop/pquery.c:348">FetchStatementTargetList</a>((Node *) pstmt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1677" title="utils/cache/plancache.c:1677">GetCachedExpression</a>: construct a CachedExpression for an expression.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This performs the same transformations on the expression as<br/></li>
<li></span><span class="Comment"> * <a href="../../optimizer/plan/planner.c.html#L6457" title="optimizer/plan/planner.c:6457">expression_planner</a>(), ie, convert an expression as emitted by <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a><br/></li>
<li></span><span class="Comment"> * analysis to be ready to pass to the executor.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is stashed in a private, long-lived memory context.<br/></li>
<li></span><span class="Comment"> * (Note that this might leak a good deal of memory in the caller's<br/></li>
<li></span><span class="Comment"> * context <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> that.)&nbsp; The passed-in expr tree is not modified.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>CachedExpression *<br/></li>
<li><a id="L1677">&#x200c;</a><span class="linkable">GetCachedExpression</span>(Node *expr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CachedExpression *cexpr;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *relationOids;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *invalItems;<br/></li>
<li>&nbsp; &nbsp; MemoryContext cexpr_context;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Pass the expression through the <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>, and collect dependencies.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Everything built here is leaked in the caller's context; that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * intentional to minimize the size of the permanent data structure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; expr = (Node *) <a href="../../optimizer/plan/planner.c.html#L6484" title="optimizer/plan/planner.c:6484">expression_planner_with_deps</a>((Expr *) expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;relationOids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;invalItems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make a private memory context, and copy what we need into that.&nbsp; To<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoid leaking a long-lived context if we fail while copying data, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initially make the context under the caller's context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cexpr_context = AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;CachedExpression&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_SMALL_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(cexpr_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cexpr = (CachedExpression *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CachedExpression));<br/></li>
<li>&nbsp; &nbsp; cexpr-&gt;magic = CACHEDEXPR_MAGIC;<br/></li>
<li>&nbsp; &nbsp; cexpr-&gt;expr = copyObject(expr);<br/></li>
<li>&nbsp; &nbsp; cexpr-&gt;is_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; cexpr-&gt;relationOids = copyObject(relationOids);<br/></li>
<li>&nbsp; &nbsp; cexpr-&gt;invalItems = copyObject(invalItems);<br/></li>
<li>&nbsp; &nbsp; cexpr-&gt;context = cexpr_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reparent the expr's memory context under <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a> so that it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will live indefinitely.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L637" title="utils/mmgr/mcxt.c:637">MemoryContextSetParent</a>(cexpr_context, <a href="../mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add the entry to the global list of cached expressions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dlist_push_tail(&amp;<a href="#L100" title="utils/cache/plancache.c:100">cached_expression_list</a>, &amp;cexpr-&gt;node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cexpr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1734" title="utils/cache/plancache.c:1734">FreeCachedExpression</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> a CachedExpression.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1734">&#x200c;</a></span><span class="linkable">FreeCachedExpression</span>(CachedExpression *cexpr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sanity check */<br/></li>
<li></span>&nbsp; &nbsp; Assert(cexpr-&gt;magic == CACHEDEXPR_MAGIC);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unlink from global list */<br/></li>
<li></span>&nbsp; &nbsp; dlist_delete(&amp;cexpr-&gt;node);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Free all storage associated with CachedExpression */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(cexpr-&gt;context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1753" title="utils/cache/plancache.c:1753">QueryListGetPrimaryStmt</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get the &quot;primary&quot; stmt within a list, ie, the one marked canSetTag.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns NULL if no such stmt.&nbsp; If multiple queries within the list are<br/></li>
<li></span><span class="Comment"> * marked canSetTag, returns the first one.&nbsp; Neither of these cases should<br/></li>
<li></span><span class="Comment"> * occur in present usages of this function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Query *<br/></li>
<li><a id="L1753">&#x200c;</a><span class="linkable">QueryListGetPrimaryStmt</span>(List *stmts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, stmts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *stmt = lfirst_node(Query, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;canSetTag)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> stmt;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1772" title="utils/cache/plancache.c:1772">AcquireExecutorLocks</a>: acquire locks needed for execution of a cached plan;<br/></li>
<li></span><span class="Comment"> * or release them if acquire is false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1772">&#x200c;</a></span><span class="linkable">AcquireExecutorLocks</span>(List *stmt_list, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> acquire)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc1, stmt_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlannedStmt *plannedstmt = lfirst_node(PlannedStmt, lc1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plannedstmt-&gt;commandType == CMD_UTILITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore utility statements, except those (such as EXPLAIN) that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contain a parsed-but-not-planned query.&nbsp; Note: it's okay to use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1853" title="utils/cache/plancache.c:1853">ScanQueryForLocks</a>, even though the query hasn't been through<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rule rewriting, because rewriting doesn't change the query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * representation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query = <a href="../../tcop/utility.c.html#L2176" title="tcop/utility.c:2176">UtilityContainsQuery</a>(plannedstmt-&gt;utilityStmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (query)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1853" title="utils/cache/plancache.c:1853">ScanQueryForLocks</a>(query, acquire);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, plannedstmt-&gt;rtable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = (RangeTblEntry *) lfirst(lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(rte-&gt;rtekind == RTE_RELATION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (rte-&gt;rtekind == RTE_SUBQUERY &amp;&amp; OidIsValid(rte-&gt;relid))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Acquire the appropriate type of lock on each relation OID. Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that we don't actually try to open the rel, and hence will not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fail if it's been dropped entirely --- we'll just transiently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * acquire a non-conflicting lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (acquire)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a>(rte-&gt;relid, rte-&gt;rellockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L227" title="storage/lmgr/lmgr.c:227">UnlockRelationOid</a>(rte-&gt;relid, rte-&gt;rellockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1828" title="utils/cache/plancache.c:1828">AcquirePlannerLocks</a>: acquire locks needed for planning of a querytree list;<br/></li>
<li></span><span class="Comment"> * or release them if acquire is false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we don't actually try to open the relations, and hence will not<br/></li>
<li></span><span class="Comment"> * fail if one has been dropped entirely --- we'll just transiently acquire<br/></li>
<li></span><span class="Comment"> * a non-conflicting lock.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1828">&#x200c;</a></span><span class="linkable">AcquirePlannerLocks</span>(List *stmt_list, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> acquire)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, stmt_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query = lfirst_node(Query, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;commandType == CMD_UTILITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore utility statements, unless they contain a Query */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query = <a href="../../tcop/utility.c.html#L2176" title="tcop/utility.c:2176">UtilityContainsQuery</a>(query-&gt;utilityStmt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (query)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1853" title="utils/cache/plancache.c:1853">ScanQueryForLocks</a>(query, acquire);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1853" title="utils/cache/plancache.c:1853">ScanQueryForLocks</a>(query, acquire);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1853" title="utils/cache/plancache.c:1853">ScanQueryForLocks</a>: recursively scan one Query for <a href="#L1828" title="utils/cache/plancache.c:1828">AcquirePlannerLocks</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1853">&#x200c;</a></span><span class="linkable">ScanQueryForLocks</span>(Query *parsetree, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> acquire)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shouldn't get called on utility commands */<br/></li>
<li></span>&nbsp; &nbsp; Assert(parsetree-&gt;commandType != CMD_UTILITY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, process RTEs of the current query level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, parsetree-&gt;rtable)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = (RangeTblEntry *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (rte-&gt;rtekind)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Acquire or release the appropriate type of lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (acquire)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a>(rte-&gt;relid, rte-&gt;rellockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L227" title="storage/lmgr/lmgr.c:227">UnlockRelationOid</a>(rte-&gt;relid, rte-&gt;rellockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_SUBQUERY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If this was a view, must lock/unlock the view */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(rte-&gt;relid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (acquire)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a>(rte-&gt;relid, rte-&gt;rellockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L227" title="storage/lmgr/lmgr.c:227">UnlockRelationOid</a>(rte-&gt;relid, rte-&gt;rellockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse into subquery-in-FROM */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1853" title="utils/cache/plancache.c:1853">ScanQueryForLocks</a>(rte-&gt;subquery, acquire);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore other types of RTEs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Recurse into subquery-in-WITH */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, parsetree-&gt;cteList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CommonTableExpr *cte = lfirst_node(CommonTableExpr, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1853" title="utils/cache/plancache.c:1853">ScanQueryForLocks</a>(castNode(Query, cte-&gt;ctequery), acquire);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Recurse into sublink subqueries, too.&nbsp; But we already did the ones in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the rtable and cteList.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;hasSubLinks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query_tree_walker(parsetree, <a href="#L1920" title="utils/cache/plancache.c:1920">ScanQueryWalker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) &amp;acquire,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QTW_IGNORE_RC_SUBQUERIES);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Walker to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> sublink subqueries for <a href="#L1853" title="utils/cache/plancache.c:1853">ScanQueryForLocks</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1920">&#x200c;</a></span><span class="linkable">ScanQueryWalker</span>(Node *node, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *acquire)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, SubLink))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SubLink&nbsp; &nbsp; *sub = (SubLink *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do what we came for */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1853" title="utils/cache/plancache.c:1853">ScanQueryForLocks</a>(castNode(Query, sub-&gt;subselect), *acquire);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fall through to process lefthand args of SubLink */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do NOT recurse into Query nodes, because <a href="#L1853" title="utils/cache/plancache.c:1853">ScanQueryForLocks</a> already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processed subselects of subselects for us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L1920" title="utils/cache/plancache.c:1920">ScanQueryWalker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) acquire);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1949" title="utils/cache/plancache.c:1949">PlanCacheComputeResultDesc</a>: given a list of analyzed-and-rewritten Queries,<br/></li>
<li></span><span class="Comment"> * determine the result tupledesc it will produce.&nbsp; Returns NULL if the<br/></li>
<li></span><span class="Comment"> * execution will not return tuples.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the result is created or copied into current memory context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TupleDesc<br/></li>
<li><a id="L1949">&#x200c;</a><span class="linkable">PlanCacheComputeResultDesc</span>(List *stmt_list)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="../../tcop/pquery.c.html#L209" title="tcop/pquery.c:209">ChoosePortalStrategy</a>(stmt_list))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PORTAL_ONE_SELECT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PORTAL_ONE_MOD_WITH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query = linitial_node(Query, stmt_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../executor/execTuples.c.html#L2037" title="executor/execTuples.c:2037">ExecCleanTypeFromTL</a>(query-&gt;targetList);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PORTAL_ONE_RETURNING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query = <a href="#L1753" title="utils/cache/plancache.c:1753">QueryListGetPrimaryStmt</a>(stmt_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(query-&gt;returningList);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../executor/execTuples.c.html#L2037" title="executor/execTuples.c:2037">ExecCleanTypeFromTL</a>(query-&gt;returningList);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PORTAL_UTIL_SELECT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query = linitial_node(Query, stmt_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(query-&gt;utilityStmt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../tcop/utility.c.html#L2081" title="tcop/utility.c:2081">UtilityTupleDescriptor</a>(query-&gt;utilityStmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PORTAL_MULTI_QUERY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* will not return tuples */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1985" title="utils/cache/plancache.c:1985">PlanCacheRelCallback</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Relcache inval callback function<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Invalidate all plans mentioning the given rel, or all plans mentioning<br/></li>
<li></span><span class="Comment"> * <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> rel at all if relid == InvalidOid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1985">&#x200c;</a></span><span class="linkable">PlanCacheRelCallback</span>(Datum arg, Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach(iter, &amp;<a href="#L95" title="utils/cache/plancache.c:95">saved_plan_list</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CachedPlanSource *plansource = dlist_container(CachedPlanSource,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(plansource-&gt;magic == CACHEDPLANSOURCE_MAGIC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No work if it's already invalidated */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!plansource-&gt;is_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Never invalidate if <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>/plan would be a no-op anyway */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L85" title="utils/cache/plancache.c:85">StmtPlanRequiresRevalidation</a>(plansource))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check the dependency list for the rewritten querytree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((relid == InvalidOid) ? plansource-&gt;relationOids != NIL :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(plansource-&gt;relationOids, relid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Invalidate the querytree and generic plan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;is_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;gplan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;gplan-&gt;is_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The generic plan, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, could have more dependencies than the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * querytree does, so we have to check it too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;gplan &amp;&amp; plansource-&gt;gplan-&gt;is_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, plansource-&gt;gplan-&gt;stmt_list)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlannedStmt *plannedstmt = lfirst_node(PlannedStmt, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plannedstmt-&gt;commandType == CMD_UTILITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; <span class="Comment">/* Ignore utility statements */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((relid == InvalidOid) ? plannedstmt-&gt;relationOids != NIL :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(plannedstmt-&gt;relationOids, relid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Invalidate the generic plan only */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;gplan-&gt;is_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* out of stmt_list scan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Likewise check cached expressions */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach(iter, &amp;<a href="#L100" title="utils/cache/plancache.c:100">cached_expression_list</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CachedExpression *cexpr = dlist_container(CachedExpression,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(cexpr-&gt;magic == CACHEDEXPR_MAGIC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No work if it's already invalidated */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!cexpr-&gt;is_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((relid == InvalidOid) ? cexpr-&gt;relationOids != NIL :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(cexpr-&gt;relationOids, relid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cexpr-&gt;is_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2069" title="utils/cache/plancache.c:2069">PlanCacheObjectCallback</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Syscache inval callback function for PROCOID and TYPEOID caches<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Invalidate all plans mentioning the object with the specified <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value,<br/></li>
<li></span><span class="Comment"> * or all plans mentioning <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> member of this cache if hashvalue == 0.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2069">&#x200c;</a></span><span class="linkable">PlanCacheObjectCallback</span>(Datum arg, <span class="Type">int</span> cacheid, uint32 hashvalue)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach(iter, &amp;<a href="#L95" title="utils/cache/plancache.c:95">saved_plan_list</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CachedPlanSource *plansource = dlist_container(CachedPlanSource,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(plansource-&gt;magic == CACHEDPLANSOURCE_MAGIC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No work if it's already invalidated */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!plansource-&gt;is_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Never invalidate if <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>/plan would be a no-op anyway */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L85" title="utils/cache/plancache.c:85">StmtPlanRequiresRevalidation</a>(plansource))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check the dependency list for the rewritten querytree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, plansource-&gt;invalItems)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlanInvalItem *item = (PlanInvalItem *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item-&gt;cacheId != cacheid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hashvalue == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;hashValue == hashvalue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Invalidate the querytree and generic plan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;is_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;gplan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;gplan-&gt;is_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The generic plan, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, could have more dependencies than the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * querytree does, so we have to check it too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;gplan &amp;&amp; plansource-&gt;gplan-&gt;is_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, plansource-&gt;gplan-&gt;stmt_list)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlannedStmt *plannedstmt = lfirst_node(PlannedStmt, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc3;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plannedstmt-&gt;commandType == CMD_UTILITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; <span class="Comment">/* Ignore utility statements */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc3, plannedstmt-&gt;invalItems)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlanInvalItem *item = (PlanInvalItem *) lfirst(lc3);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item-&gt;cacheId != cacheid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hashvalue == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;hashValue == hashvalue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Invalidate the generic plan only */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;gplan-&gt;is_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; <span class="Comment">/* out of invalItems scan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!plansource-&gt;gplan-&gt;is_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* out of stmt_list scan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Likewise check cached expressions */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach(iter, &amp;<a href="#L100" title="utils/cache/plancache.c:100">cached_expression_list</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CachedExpression *cexpr = dlist_container(CachedExpression,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(cexpr-&gt;magic == CACHEDEXPR_MAGIC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No work if it's already invalidated */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!cexpr-&gt;is_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, cexpr-&gt;invalItems)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlanInvalItem *item = (PlanInvalItem *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item-&gt;cacheId != cacheid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hashvalue == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;hashValue == hashvalue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cexpr-&gt;is_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2178" title="utils/cache/plancache.c:2178">PlanCacheSysCallback</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Syscache inval callback function for other caches<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Just invalidate everything...<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2178">&#x200c;</a></span><span class="linkable">PlanCacheSysCallback</span>(Datum arg, <span class="Type">int</span> cacheid, uint32 hashvalue)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L2187" title="utils/cache/plancache.c:2187">ResetPlanCache</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2187" title="utils/cache/plancache.c:2187">ResetPlanCache</a>: invalidate all cached plans.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2187">&#x200c;</a></span><span class="linkable">ResetPlanCache</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach(iter, &amp;<a href="#L95" title="utils/cache/plancache.c:95">saved_plan_list</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CachedPlanSource *plansource = dlist_container(CachedPlanSource,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(plansource-&gt;magic == CACHEDPLANSOURCE_MAGIC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No work if it's already invalidated */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!plansource-&gt;is_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We *must not* mark transaction control statements as invalid,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * particularly not ROLLBACK, because they may need to be executed in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aborted transactions when we can't revalidate them (cf bug #5269).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In general there's no point in invalidating statements for which a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis/rewrite/plan cycle would certainly give the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * results.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L85" title="utils/cache/plancache.c:85">StmtPlanRequiresRevalidation</a>(plansource))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;is_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plansource-&gt;gplan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plansource-&gt;gplan-&gt;is_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Likewise invalidate cached expressions */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach(iter, &amp;<a href="#L100" title="utils/cache/plancache.c:100">cached_expression_list</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CachedExpression *cexpr = dlist_container(CachedExpression,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(cexpr-&gt;magic == CACHEDEXPR_MAGIC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cexpr-&gt;is_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Release all CachedPlans remembered by 'owner'<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2234">&#x200c;</a></span><span class="linkable">ReleaseAllPlanCacheRefsInOwner</span>(ResourceOwner owner)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../resowner/resowner.c.html#L801" title="utils/resowner/resowner.c:801">ResourceOwnerReleaseAllOfKind</a>(owner, &amp;<a href="#L124" title="utils/cache/plancache.c:124">planref_resowner_desc</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ResourceOwner callbacks */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2242">&#x200c;</a></span><span class="linkable">ResOwnerReleaseCachedPlan</span>(Datum res)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1291" title="utils/cache/plancache.c:1291">ReleaseCachedPlan</a>((CachedPlan *) DatumGetPointer(res), <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
