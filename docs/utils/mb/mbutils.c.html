<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/mb/mbutils.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/mb/mbutils.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L80">ClientEncoding</a></li>
<li><a href="#L61">ConvProcList</a></li>
<li><a href="#L81">DatabaseEncoding</a></li>
<li><a href="#L82">MessageEncoding</a></li>
<li><a href="#L68">ToClientConvProc</a></li>
<li><a href="#L67">ToServerConvProc</a></li>
<li><a href="#L75">Utf8ToServerConvProc</a></li>
<li><a href="#L90">backend_startup_complete</a></li>
<li><a href="#L91">pending_client_encoding</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L53">ConvProcInfo</a></li>
<li><a href="#L59">ConvProcInfo</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1261">GetDatabaseEncoding</a></li>
<li><a href="#L1267">GetDatabaseEncodingName</a></li>
<li><a href="#L1308">GetMessageEncoding</a></li>
<li><a href="#L281">InitializeClientEncoding</a></li>
<li><a href="#L1285">PG_char_to_encoding</a></li>
<li><a href="#L1293">PG_encoding_to_char</a></li>
<li><a href="#L110">PrepareClientEncoding</a></li>
<li><a href="#L208">SetClientEncoding</a></li>
<li><a href="#L1161">SetDatabaseEncoding</a></li>
<li><a href="#L1171">SetMessageEncoding</a></li>
<li><a href="#L1669">check_encoding_conversion_args</a></li>
<li><a href="#L1150">cliplen</a></li>
<li><a href="#L1273">getdatabaseencoding</a></li>
<li><a href="#L615">length_in_encoding</a></li>
<li><a href="#L783">perform_default_encoding_conversion</a></li>
<li><a href="#L676">pg_any_to_server</a></li>
<li><a href="#L1226">pg_bind_textdomain_codeset</a></li>
<li><a href="#L1279">pg_client_encoding</a></li>
<li><a href="#L660">pg_client_to_server</a></li>
<li><a href="#L553">pg_convert</a></li>
<li><a href="#L526">pg_convert_from</a></li>
<li><a href="#L501">pg_convert_to</a></li>
<li><a href="#L1523">pg_database_encoding_character_incrementer</a></li>
<li><a href="#L1546">pg_database_encoding_max_length</a></li>
<li><a href="#L356">pg_do_encoding_conversion</a></li>
<li><a href="#L469">pg_do_encoding_conversion_buf</a></li>
<li><a href="#L1030">pg_dsplen</a></li>
<li><a href="#L644">pg_encoding_max_length_sql</a></li>
<li><a href="#L993">pg_encoding_mb2wchar_with_len</a></li>
<li><a href="#L1093">pg_encoding_mbcliplen</a></li>
<li><a href="#L1015">pg_encoding_wchar2mb_with_len</a></li>
<li><a href="#L1437">pg_eucjp_increment</a></li>
<li><a href="#L1325">pg_generic_charinc</a></li>
<li><a href="#L336">pg_get_client_encoding</a></li>
<li><a href="#L345">pg_get_client_encoding_name</a></li>
<li><a href="#L979">pg_mb2wchar</a></li>
<li><a href="#L986">pg_mb2wchar_with_len</a></li>
<li><a href="#L1125">pg_mbcharcliplen</a></li>
<li><a href="#L1083">pg_mbcliplen</a></li>
<li><a href="#L1023">pg_mblen</a></li>
<li><a href="#L1037">pg_mbstrlen</a></li>
<li><a href="#L1057">pg_mbstrlen_with_len</a></li>
<li><a href="#L749">pg_server_to_any</a></li>
<li><a href="#L738">pg_server_to_client</a></li>
<li><a href="#L864">pg_unicode_to_server</a></li>
<li><a href="#L926">pg_unicode_to_server_noerror</a></li>
<li><a href="#L1359">pg_utf8_increment</a></li>
<li><a href="#L1566">pg_verify_mbstr</a></li>
<li><a href="#L1597">pg_verify_mbstr_len</a></li>
<li><a href="#L1556">pg_verifymbstr</a></li>
<li><a href="#L1001">pg_wchar2mb</a></li>
<li><a href="#L1008">pg_wchar2mb_with_len</a></li>
<li><a href="#L1766">pgwin32_message_to_UTF16</a></li>
<li><a href="#L1187">raw_pg_bind_textdomain_codeset</a></li>
<li><a href="#L1698">report_invalid_encoding</a></li>
<li><a href="#L1730">report_untranslatable_char</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * mbutils.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; This file contains <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for encoding conversion.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The string-conversion <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in this file share some API quirks.<br/></li>
<li></span><span class="Comment"> * Note the following:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> return a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d, null-terminated string if conversion<br/></li>
<li></span><span class="Comment"> * is required.&nbsp; However, if no conversion is performed, the given source<br/></li>
<li></span><span class="Comment"> * string pointer is returned as-is.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Although the presence of a length argument means that callers can pass<br/></li>
<li></span><span class="Comment"> * non-null-terminated strings, care is required because the same string<br/></li>
<li></span><span class="Comment"> * will be passed back if no conversion occurs.&nbsp; Such callers *must* check<br/></li>
<li></span><span class="Comment"> * whether result == src and handle that case differently.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the source and destination encodings are the same, the source string<br/></li>
<li></span><span class="Comment"> * is returned without <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> verification; it's assumed to be valid data.<br/></li>
<li></span><span class="Comment"> * If that might not be the case, the caller is responsible for validating<br/></li>
<li></span><span class="Comment"> * the string using a separate call to <a href="#L1566" title="utils/mb/mbutils.c:1566">pg_verify_mbstr</a>().&nbsp; Whenever the<br/></li>
<li></span><span class="Comment"> * source and destination encodings are different, the <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> ensure that<br/></li>
<li></span><span class="Comment"> * the result is validly encoded according to the destination encoding.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/mb/mbutils.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;mb/pg_wchar.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;varatt.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We maintain a simple linked list caching the fmgr lookup info for the<br/></li>
<li></span><span class="Comment"> * currently selected conversion <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, as well as <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> that have been<br/></li>
<li></span><span class="Comment"> * selected previously in the current session.&nbsp; (We remember previous<br/></li>
<li></span><span class="Comment"> * settings because we must be able to restore a previous setting during<br/></li>
<li></span><span class="Comment"> * transaction rollback, without doing <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fresh catalog accesses.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since we'll never release this data, we just keep it in <a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L53">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ConvProcInfo</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s_encoding;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* server and client encoding IDs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c_encoding;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; to_server_info; <span class="Comment">/* lookup info for conversion procs */<br/></li>
<li></span>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; to_client_info;<br/></li>
<li><a id="L59">&#x200c;</a>} <span class="linkable">ConvProcInfo</span>;<br/></li>
<li><br/></li>
<li><a id="L61">&#x200c;</a><span class="Type">static</span> List *<span class="linkable">ConvProcList</span> = NIL;&nbsp; &nbsp; <span class="Comment">/* List of <a href="#L53" title="utils/mb/mbutils.c:53">ConvProcInfo</a> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These variables point to the currently active conversion <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>,<br/></li>
<li></span><span class="Comment"> * or are NULL when no conversion is needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L67">&#x200c;</a></span><span class="Type">static</span> FmgrInfo *<span class="linkable">ToServerConvProc</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L68">&#x200c;</a><span class="Type">static</span> FmgrInfo *<span class="linkable">ToClientConvProc</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This variable stores the conversion function to convert from UTF-8<br/></li>
<li></span><span class="Comment"> * to the server encoding.&nbsp; It's NULL if the server encoding *is* UTF-8,<br/></li>
<li></span><span class="Comment"> * or if we lack a conversion function for this.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L75">&#x200c;</a></span><span class="Type">static</span> FmgrInfo *<span class="linkable">Utf8ToServerConvProc</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These variables track the currently-selected encodings.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L80">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> pg_enc2name *<span class="linkable">ClientEncoding</span> = &amp;pg_enc2name_tbl[PG_SQL_ASCII];<br/></li>
<li><a id="L81">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> pg_enc2name *<span class="linkable">DatabaseEncoding</span> = &amp;pg_enc2name_tbl[PG_SQL_ASCII];<br/></li>
<li><a id="L82">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> pg_enc2name *<span class="linkable">MessageEncoding</span> = &amp;pg_enc2name_tbl[PG_SQL_ASCII];<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * During backend startup we can't set client encoding because we (a)<br/></li>
<li></span><span class="Comment"> * can't look up the conversion <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, and (b) may not know the database<br/></li>
<li></span><span class="Comment"> * encoding yet either.&nbsp; So <a href="#L208" title="utils/mb/mbutils.c:208">SetClientEncoding</a>() just accepts anything and<br/></li>
<li></span><span class="Comment"> * remembers it for <a href="#L281" title="utils/mb/mbutils.c:281">InitializeClientEncoding</a>() to apply later.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L90">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">backend_startup_complete</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L91">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">pending_client_encoding</span> = PG_SQL_ASCII;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* Internal <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<a href="#L783" title="utils/mb/mbutils.c:783">perform_default_encoding_conversion</a>(<span class="Type">const</span> <span class="Type">char</span> *src,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> len, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_client_to_server);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1150" title="utils/mb/mbutils.c:1150">cliplen</a>(<span class="Type">const</span> <span class="Type">char</span> *str, <span class="Type">int</span> len, <span class="Type">int</span> limit);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare for a future call to <a href="#L208" title="utils/mb/mbutils.c:208">SetClientEncoding</a>.&nbsp; Success should mean<br/></li>
<li></span><span class="Comment"> * that <a href="#L208" title="utils/mb/mbutils.c:208">SetClientEncoding</a> is guaranteed to succeed for this encoding request.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (But note that success <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="#L90" title="utils/mb/mbutils.c:90">backend_startup_complete</a> does not guarantee<br/></li>
<li></span><span class="Comment"> * success after ...)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns 0 if okay, -1 if not (bad encoding or can't support conversion)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L110">&#x200c;</a></span><span class="linkable">PrepareClientEncoding</span>(<span class="Type">int</span> encoding)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_server_encoding;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_VALID_FE_ENCODING(encoding))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't do anything during startup, per notes above */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L90" title="utils/mb/mbutils.c:90">backend_startup_complete</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; current_server_encoding = <a href="#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for cases that require no conversion function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (current_server_encoding == encoding ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; current_server_encoding == PG_SQL_ASCII ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; encoding == PG_SQL_ASCII)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're in a live transaction, it's safe to access the catalogs,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so look up the <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; We <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> the lookup even if the info is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already cached, so that we can react to changes in the contents of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_conversion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to_server_proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to_client_proc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L53" title="utils/mb/mbutils.c:53">ConvProcInfo</a> *convinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; to_server_proc = <a href="../../catalog/namespace.c.html#L4065" title="catalog/namespace.c:4065">FindDefaultConversionProc</a>(encoding,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; current_server_encoding);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(to_server_proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; to_client_proc = <a href="../../catalog/namespace.c.html#L4065" title="catalog/namespace.c:4065">FindDefaultConversionProc</a>(current_server_encoding,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; encoding);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(to_client_proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Load the fmgr info into <a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a> (could still fail here)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; convinfo = (<a href="#L53" title="utils/mb/mbutils.c:53">ConvProcInfo</a> *) <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L53" title="utils/mb/mbutils.c:53">ConvProcInfo</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; convinfo-&gt;s_encoding = current_server_encoding;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; convinfo-&gt;c_encoding = encoding;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(to_server_proc, &amp;convinfo-&gt;to_server_info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(to_client_proc, &amp;convinfo-&gt;to_client_info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Attach new info to head of list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L61" title="utils/mb/mbutils.c:61">ConvProcList</a> = <a href="../../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(convinfo, <a href="#L61" title="utils/mb/mbutils.c:61">ConvProcList</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We cannot yet remove <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> older entry for the same encoding pair,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since it could still be in use.&nbsp; <a href="#L208" title="utils/mb/mbutils.c:208">SetClientEncoding</a> will clean up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* success */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're not in a live transaction, the only thing we can do is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * restore a previous setting using the cache.&nbsp; This covers all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction-rollback cases.&nbsp; The only case it might not work for is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * trying to change client_encoding on the fly by editing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * postgresql.conf and SIGHUP'ing.&nbsp; Which would probably be a stupid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * thing to do anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, <a href="#L61" title="utils/mb/mbutils.c:61">ConvProcList</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L53" title="utils/mb/mbutils.c:53">ConvProcInfo</a> *oldinfo = (<a href="#L53" title="utils/mb/mbutils.c:53">ConvProcInfo</a> *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldinfo-&gt;s_encoding == current_server_encoding &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldinfo-&gt;c_encoding == encoding)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it's not cached, so fail */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set the active client encoding and set up the conversion-function pointers.<br/></li>
<li></span><span class="Comment"> * <a href="#L110" title="utils/mb/mbutils.c:110">PrepareClientEncoding</a> should have been called previously for this encoding.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns 0 if okay, -1 if not (bad encoding or can't support conversion)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L208">&#x200c;</a></span><span class="linkable">SetClientEncoding</span>(<span class="Type">int</span> encoding)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_server_encoding;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_VALID_FE_ENCODING(encoding))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't do anything during startup, per notes above */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L90" title="utils/mb/mbutils.c:90">backend_startup_complete</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L91" title="utils/mb/mbutils.c:91">pending_client_encoding</a> = encoding;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; current_server_encoding = <a href="#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for cases that require no conversion function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (current_server_encoding == encoding ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; current_server_encoding == PG_SQL_ASCII ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; encoding == PG_SQL_ASCII)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L80" title="utils/mb/mbutils.c:80">ClientEncoding</a> = &amp;pg_enc2name_tbl[encoding];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L67" title="utils/mb/mbutils.c:67">ToServerConvProc</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L68" title="utils/mb/mbutils.c:68">ToClientConvProc</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Search the cache for the entry previously prepared by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L110" title="utils/mb/mbutils.c:110">PrepareClientEncoding</a>; if there isn't one, we lose.&nbsp; While at it,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * release <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> duplicate entries so that repeated Prepare/Set cycles don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leak memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, <a href="#L61" title="utils/mb/mbutils.c:61">ConvProcList</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L53" title="utils/mb/mbutils.c:53">ConvProcInfo</a> *convinfo = (<a href="#L53" title="utils/mb/mbutils.c:53">ConvProcInfo</a> *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (convinfo-&gt;s_encoding == current_server_encoding &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; convinfo-&gt;c_encoding == encoding)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found newest entry, so set up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L80" title="utils/mb/mbutils.c:80">ClientEncoding</a> = &amp;pg_enc2name_tbl[encoding];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L67" title="utils/mb/mbutils.c:67">ToServerConvProc</a> = &amp;convinfo-&gt;to_server_info;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L68" title="utils/mb/mbutils.c:68">ToClientConvProc</a> = &amp;convinfo-&gt;to_client_info;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Duplicate entry, release it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L61" title="utils/mb/mbutils.c:61">ConvProcList</a> = foreach_delete_current(<a href="#L61" title="utils/mb/mbutils.c:61">ConvProcList</a>, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(convinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* success */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it's not cached, so fail */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize client encoding conversions.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Called from <a href="../init/postinit.c.html#L736" title="utils/init/postinit.c:736">InitPostgres</a>() once during backend startup.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L281">&#x200c;</a></span><span class="linkable">InitializeClientEncoding</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_server_encoding;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L90" title="utils/mb/mbutils.c:90">backend_startup_complete</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L90" title="utils/mb/mbutils.c:90">backend_startup_complete</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L110" title="utils/mb/mbutils.c:110">PrepareClientEncoding</a>(<a href="#L91" title="utils/mb/mbutils.c:91">pending_client_encoding</a>) &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L208" title="utils/mb/mbutils.c:208">SetClientEncoding</a>(<a href="#L91" title="utils/mb/mbutils.c:91">pending_client_encoding</a>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Oops, the requested conversion is not available. We couldn't fail<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>, but we can <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;conversion between </span><span class="Special">%s</span><span class="Constant"> and </span><span class="Special">%s</span><span class="Constant"> is not supported&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_enc2name_tbl[<a href="#L91" title="utils/mb/mbutils.c:91">pending_client_encoding</a>].name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1267" title="utils/mb/mbutils.c:1267">GetDatabaseEncodingName</a>())));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also look up the UTF8-to-server conversion function if needed.&nbsp; Since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the server encoding is fixed within <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one backend process, we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have to do this more than once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; current_server_encoding = <a href="#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (current_server_encoding != PG_UTF8 &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; current_server_encoding != PG_SQL_ASCII)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; utf8_to_server_proc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; utf8_to_server_proc =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/namespace.c.html#L4065" title="catalog/namespace.c:4065">FindDefaultConversionProc</a>(PG_UTF8,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_server_encoding);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If there's no such conversion, just leave the pointer as NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(utf8_to_server_proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *finfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo = (FmgrInfo *) <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FmgrInfo));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(utf8_to_server_proc, finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set <a href="#L75" title="utils/mb/mbutils.c:75">Utf8ToServerConvProc</a> only after data is fully valid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L75" title="utils/mb/mbutils.c:75">Utf8ToServerConvProc</a> = finfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * returns the current client encoding<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L336">&#x200c;</a></span><span class="linkable">pg_get_client_encoding</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L80" title="utils/mb/mbutils.c:80">ClientEncoding</a>-&gt;encoding;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * returns the current client encoding name<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L345">&#x200c;</a><span class="linkable">pg_get_client_encoding_name</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L80" title="utils/mb/mbutils.c:80">ClientEncoding</a>-&gt;name;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert src string to another encoding (general case).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See the notes about string conversion <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> at the top of this file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">unsigned</span> <span class="Type">char</span> *<br/></li>
<li><a id="L356">&#x200c;</a><span class="linkable">pg_do_encoding_conversion</span>(<span class="Type">unsigned</span> <span class="Type">char</span> *src, <span class="Type">int</span> len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> src_encoding, <span class="Type">int</span> dest_encoding)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *result;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> src;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* empty string is always valid */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (src_encoding == dest_encoding)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> src;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no conversion required, assume valid */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dest_encoding == PG_SQL_ASCII)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> src;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> string is valid in SQL_ASCII */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (src_encoding == PG_SQL_ASCII)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No conversion is possible, but we must validate the result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1566" title="utils/mb/mbutils.c:1566">pg_verify_mbstr</a>(dest_encoding, (<span class="Type">const</span> <span class="Type">char</span> *) src, len, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> src;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>())&nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot perform encoding conversion outside a transaction&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; proc = <a href="../../catalog/namespace.c.html#L4065" title="catalog/namespace.c:4065">FindDefaultConversionProc</a>(src_encoding, dest_encoding);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;default conversion function for encoding </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_encoding_to_char(src_encoding),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_encoding_to_char(dest_encoding))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate space for conversion result, being wary of integer overflow.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * len * MAX_CONVERSION_GROWTH is typically a vast overestimate of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * required space, so it might exceed MaxAllocSize even though the result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would actually fit.&nbsp; We do not want to hand back a result string that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exceeds MaxAllocSize, because callers might not cope gracefully --- but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we just allocate more than that, and don't use it, that's fine.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((Size) len &gt;= (MaxAllocHugeSize / (Size) MAX_CONVERSION_GROWTH))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;String of </span><span class="Special">%d</span><span class="Constant"> bytes is too long for encoding conversion.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; len)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (<span class="Type">unsigned</span> <span class="Type">char</span> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1639" title="utils/mmgr/mcxt.c:1639">MemoryContextAllocHuge</a>(<a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Size) len * MAX_CONVERSION_GROWTH + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) OidFunctionCall6(proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(src_encoding),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(dest_encoding),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum((<span class="Type">char</span> *) src),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum((<span class="Type">char</span> *) result),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(len),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BoolGetDatum(<span class="Constant">false</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the result is large, it's worth <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>'ing to release <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> extra<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * space we asked for.&nbsp; The cutoff here is somewhat arbitrary, but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * *must* check when len * MAX_CONVERSION_GROWTH exceeds MaxAllocSize.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (len &gt; <span class="Constant">1000000</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; resultlen = strlen((<span class="Type">char</span> *) result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (resultlen &gt;= MaxAllocSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;String of </span><span class="Special">%d</span><span class="Constant"> bytes is too long for encoding conversion.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; len)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (<span class="Type">unsigned</span> <span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(result, resultlen + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert src string to another encoding.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function has a different API than the other conversion <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> * The caller should've looked up the conversion function using<br/></li>
<li></span><span class="Comment"> * <a href="../../catalog/namespace.c.html#L4065" title="catalog/namespace.c:4065">FindDefaultConversionProc</a>().&nbsp; Unlike the other <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, the converted<br/></li>
<li></span><span class="Comment"> * result is not <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d.&nbsp; It is written to the caller-supplied buffer<br/></li>
<li></span><span class="Comment"> * instead.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * src_encoding&nbsp;&nbsp; - encoding to convert from<br/></li>
<li></span><span class="Comment"> * dest_encoding&nbsp; - encoding to convert to<br/></li>
<li></span><span class="Comment"> * src, srclen&nbsp; &nbsp; - input buffer and its length in bytes<br/></li>
<li></span><span class="Comment"> * dest, destlen&nbsp; - destination buffer and its size in bytes<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The output is null-terminated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If destlen &lt; srclen * MAX_CONVERSION_INPUT_LENGTH + 1, the converted output<br/></li>
<li></span><span class="Comment"> * wouldn't necessarily fit in the output buffer, and the function will not<br/></li>
<li></span><span class="Comment"> * convert the whole input.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">TODO</span><span class="Comment">: The conversion function interface is not great.&nbsp; Firstly, it<br/></li>
<li></span><span class="Comment"> * would be nice to pass through the destination buffer size to the<br/></li>
<li></span><span class="Comment"> * conversion function, so that if you pass a shorter destination buffer, it<br/></li>
<li></span><span class="Comment"> * could still continue to fill up the whole buffer.&nbsp; Currently, we have to<br/></li>
<li></span><span class="Comment"> * assume worst case expansion and stop the conversion short, even if there<br/></li>
<li></span><span class="Comment"> * is in fact space left in the destination buffer.&nbsp; Secondly, it would be<br/></li>
<li></span><span class="Comment"> * nice to return the number of bytes written to the caller, to avoid a call<br/></li>
<li></span><span class="Comment"> * to strlen().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L469">&#x200c;</a></span><span class="linkable">pg_do_encoding_conversion_buf</span>(Oid proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> src_encoding,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> dest_encoding,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *src, <span class="Type">int</span> srclen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *dest, <span class="Type">int</span> destlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> noError)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the destination buffer is not large enough to hold the result in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worst case, limit the input size passed to the conversion function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((Size) srclen &gt;= ((destlen - <span class="Constant">1</span>) / (Size) MAX_CONVERSION_GROWTH))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; srclen = ((destlen - <span class="Constant">1</span>) / (Size) MAX_CONVERSION_GROWTH);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = OidFunctionCall6(proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(src_encoding),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(dest_encoding),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum((<span class="Type">char</span> *) src),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum((<span class="Type">char</span> *) dest),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(srclen),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BoolGetDatum(noError));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetInt32(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert string to encoding encoding_name. The source<br/></li>
<li></span><span class="Comment"> * encoding is the DB encoding.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * BYTEA convert_to(TEXT string, NAME encoding_name) */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L501">&#x200c;</a><span class="linkable">pg_convert_to</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; string = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; dest_encoding_name = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; src_encoding_name = DirectFunctionCall1(<a href="../adt/name.c.html#L48" title="utils/adt/name.c:48">namein</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum(<a href="#L81" title="utils/mb/mbutils.c:81">DatabaseEncoding</a>-&gt;name));<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L553" title="utils/mb/mbutils.c:553">pg_convert</a> expects a bytea as its first argument. We're passing it a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * text argument here, relying on the fact that they are both in fact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * varlena types, and thus structurally identical.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = DirectFunctionCall3(<a href="#L553" title="utils/mb/mbutils.c:553">pg_convert</a>, string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; src_encoding_name, dest_encoding_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert string from encoding encoding_name. The destination<br/></li>
<li></span><span class="Comment"> * encoding is the DB encoding.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * TEXT convert_from(BYTEA string, NAME encoding_name) */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L526">&#x200c;</a><span class="linkable">pg_convert_from</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; string = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; src_encoding_name = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; dest_encoding_name = DirectFunctionCall1(<a href="../adt/name.c.html#L48" title="utils/adt/name.c:48">namein</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CStringGetDatum(<a href="#L81" title="utils/mb/mbutils.c:81">DatabaseEncoding</a>-&gt;name));<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = DirectFunctionCall3(<a href="#L553" title="utils/mb/mbutils.c:553">pg_convert</a>, string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; src_encoding_name, dest_encoding_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L553" title="utils/mb/mbutils.c:553">pg_convert</a> returns a bytea, which we in turn return as text, relying on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the fact that they are both in fact varlena types, and thus<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * structurally identical. Although not all bytea <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are valid text,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in this case it will be because we've told <a href="#L553" title="utils/mb/mbutils.c:553">pg_convert</a> to return one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that is valid as text in the current database encoding.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_DATUM(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert string between two arbitrary encodings.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * BYTEA convert(BYTEA string, NAME src_encoding_name, NAME dest_encoding_name)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L553">&#x200c;</a><span class="linkable">pg_convert</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *string = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *src_encoding_name = NameStr(*PG_GETARG_NAME(<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src_encoding = pg_char_to_encoding(src_encoding_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *dest_encoding_name = NameStr(*PG_GETARG_NAME(<span class="Constant">2</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dest_encoding = pg_char_to_encoding(dest_encoding_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *src_str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *dest_str;<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *retval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (src_encoding &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid source encoding name </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src_encoding_name)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dest_encoding &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid destination encoding name </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dest_encoding_name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure that source string is valid */<br/></li>
<li></span>&nbsp; &nbsp; len = VARSIZE_ANY_EXHDR(string);<br/></li>
<li>&nbsp; &nbsp; src_str = VARDATA_ANY(string);<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1566" title="utils/mb/mbutils.c:1566">pg_verify_mbstr</a>(src_encoding, src_str, len, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* perform conversion */<br/></li>
<li></span>&nbsp; &nbsp; dest_str = (<span class="Type">char</span> *) <a href="#L356" title="utils/mb/mbutils.c:356">pg_do_encoding_conversion</a>((<span class="Type">unsigned</span> <span class="Type">char</span> *) unconstify(<span class="Type">char</span> *, src_str),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src_encoding,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dest_encoding);<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* return source string if no conversion happened */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dest_str == src_str)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BYTEA_P(string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * build bytea data type structure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; len = strlen(dest_str);<br/></li>
<li>&nbsp; &nbsp; retval = (bytea *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(retval, len + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; memcpy(VARDATA(retval), dest_str, len);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(dest_str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* free memory if allocated by the toaster */<br/></li>
<li></span>&nbsp; &nbsp; PG_FREE_IF_COPY(string, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(retval);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * get the length of the string considered as text in the specified<br/></li>
<li></span><span class="Comment"> * encoding. Raises an error if the data is not valid in that<br/></li>
<li></span><span class="Comment"> * encoding.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * INT4 length (BYTEA string, NAME src_encoding_name)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L615">&#x200c;</a><span class="linkable">length_in_encoding</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *string = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *src_encoding_name = NameStr(*PG_GETARG_NAME(<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src_encoding = pg_char_to_encoding(src_encoding_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *src_str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (src_encoding &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid encoding name </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src_encoding_name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = VARSIZE_ANY_EXHDR(string);<br/></li>
<li>&nbsp; &nbsp; src_str = VARDATA_ANY(string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; retval = <a href="#L1597" title="utils/mb/mbutils.c:1597">pg_verify_mbstr_len</a>(src_encoding, src_str, len, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(retval);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get maximum multibyte character length in the specified encoding.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note encoding is specified numerically, not by name as above.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L644">&#x200c;</a><span class="linkable">pg_encoding_max_length_sql</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encoding = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_VALID_ENCODING(encoding))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32(pg_wchar_table[encoding].maxmblen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert client encoding to server encoding.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See the notes about string conversion <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> at the top of this file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L660">&#x200c;</a><span class="linkable">pg_client_to_server</span>(<span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L676" title="utils/mb/mbutils.c:676">pg_any_to_server</a>(s, len, <a href="#L80" title="utils/mb/mbutils.c:80">ClientEncoding</a>-&gt;encoding);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> encoding to server encoding.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See the notes about string conversion <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> at the top of this file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike the other string conversion <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, this will apply validation<br/></li>
<li></span><span class="Comment"> * even if encoding == <a href="#L81" title="utils/mb/mbutils.c:81">DatabaseEncoding</a>-&gt;encoding.&nbsp; This is because this is<br/></li>
<li></span><span class="Comment"> * used to process data coming in from outside the database, and we never<br/></li>
<li></span><span class="Comment"> * want to just assume validity.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L676">&#x200c;</a><span class="linkable">pg_any_to_server</span>(<span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">int</span> len, <span class="Type">int</span> encoding)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> unconstify(<span class="Type">char</span> *, s);&nbsp; &nbsp; <span class="Comment">/* empty string is always valid */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (encoding == <a href="#L81" title="utils/mb/mbutils.c:81">DatabaseEncoding</a>-&gt;encoding ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; encoding == PG_SQL_ASCII)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No conversion is needed, but we must still validate the data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1566" title="utils/mb/mbutils.c:1566">pg_verify_mbstr</a>(<a href="#L81" title="utils/mb/mbutils.c:81">DatabaseEncoding</a>-&gt;encoding, s, len, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> unconstify(<span class="Type">char</span> *, s);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L81" title="utils/mb/mbutils.c:81">DatabaseEncoding</a>-&gt;encoding == PG_SQL_ASCII)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No conversion is possible, but we must still validate the data,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because the client-side code might have done string escaping using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the selected client_encoding.&nbsp; If the client encoding is ASCII-safe<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then we just do a straight validation under that encoding.&nbsp; For an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ASCII-unsafe encoding we have a problem: we dare not pass such data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the parser but we have no way to convert it.&nbsp; We compromise by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rejecting the data if it contains <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-ASCII characters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PG_VALID_BE_ENCODING(encoding))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1566" title="utils/mb/mbutils.c:1566">pg_verify_mbstr</a>(encoding, s, len, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; len; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s[i] == <span class="Special">'\0'</span> || IS_HIGHBIT_SET(s[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid byte value for encoding </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: 0x</span><span class="Special">%02x</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_enc2name_tbl[PG_SQL_ASCII].name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">char</span>) s[i])));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> unconstify(<span class="Type">char</span> *, s);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fast path if we can use cached conversion function */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (encoding == <a href="#L80" title="utils/mb/mbutils.c:80">ClientEncoding</a>-&gt;encoding)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L783" title="utils/mb/mbutils.c:783">perform_default_encoding_conversion</a>(s, len, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* General case ... will not work outside transactions */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">char</span> *) <a href="#L356" title="utils/mb/mbutils.c:356">pg_do_encoding_conversion</a>((<span class="Type">unsigned</span> <span class="Type">char</span> *) unconstify(<span class="Type">char</span> *, s),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encoding,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L81" title="utils/mb/mbutils.c:81">DatabaseEncoding</a>-&gt;encoding);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert server encoding to client encoding.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See the notes about string conversion <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> at the top of this file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L738">&#x200c;</a><span class="linkable">pg_server_to_client</span>(<span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L749" title="utils/mb/mbutils.c:749">pg_server_to_any</a>(s, len, <a href="#L80" title="utils/mb/mbutils.c:80">ClientEncoding</a>-&gt;encoding);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert server encoding to <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> encoding.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See the notes about string conversion <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> at the top of this file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L749">&#x200c;</a><span class="linkable">pg_server_to_any</span>(<span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">int</span> len, <span class="Type">int</span> encoding)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> unconstify(<span class="Type">char</span> *, s);&nbsp; &nbsp; <span class="Comment">/* empty string is always valid */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (encoding == <a href="#L81" title="utils/mb/mbutils.c:81">DatabaseEncoding</a>-&gt;encoding ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; encoding == PG_SQL_ASCII)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> unconstify(<span class="Type">char</span> *, s);&nbsp; &nbsp; <span class="Comment">/* assume data is valid */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L81" title="utils/mb/mbutils.c:81">DatabaseEncoding</a>-&gt;encoding == PG_SQL_ASCII)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No conversion is possible, but we must validate the result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1566" title="utils/mb/mbutils.c:1566">pg_verify_mbstr</a>(encoding, s, len, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> unconstify(<span class="Type">char</span> *, s);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fast path if we can use cached conversion function */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (encoding == <a href="#L80" title="utils/mb/mbutils.c:80">ClientEncoding</a>-&gt;encoding)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L783" title="utils/mb/mbutils.c:783">perform_default_encoding_conversion</a>(s, len, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* General case ... will not work outside transactions */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">char</span> *) <a href="#L356" title="utils/mb/mbutils.c:356">pg_do_encoding_conversion</a>((<span class="Type">unsigned</span> <span class="Type">char</span> *) unconstify(<span class="Type">char</span> *, s),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L81" title="utils/mb/mbutils.c:81">DatabaseEncoding</a>-&gt;encoding,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encoding);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Perform default encoding conversion using cached FmgrInfo. Since<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; this function does not access database at all, it is safe to call<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; outside transactions.&nbsp; If the conversion has not been set up by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L208" title="utils/mb/mbutils.c:208">SetClientEncoding</a>(), no conversion is performed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L783">&#x200c;</a><span class="linkable">perform_default_encoding_conversion</span>(<span class="Type">const</span> <span class="Type">char</span> *src, <span class="Type">int</span> len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_client_to_server)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src_encoding,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dest_encoding;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *flinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_client_to_server)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; src_encoding = <a href="#L80" title="utils/mb/mbutils.c:80">ClientEncoding</a>-&gt;encoding;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dest_encoding = <a href="#L81" title="utils/mb/mbutils.c:81">DatabaseEncoding</a>-&gt;encoding;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flinfo = <a href="#L67" title="utils/mb/mbutils.c:67">ToServerConvProc</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; src_encoding = <a href="#L81" title="utils/mb/mbutils.c:81">DatabaseEncoding</a>-&gt;encoding;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dest_encoding = <a href="#L80" title="utils/mb/mbutils.c:80">ClientEncoding</a>-&gt;encoding;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flinfo = <a href="#L68" title="utils/mb/mbutils.c:68">ToClientConvProc</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flinfo == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> unconstify(<span class="Type">char</span> *, src);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate space for conversion result, being wary of integer overflow.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See comments in <a href="#L356" title="utils/mb/mbutils.c:356">pg_do_encoding_conversion</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((Size) len &gt;= (MaxAllocHugeSize / (Size) MAX_CONVERSION_GROWTH))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;String of </span><span class="Special">%d</span><span class="Constant"> bytes is too long for encoding conversion.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; len)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (<span class="Type">char</span> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1639" title="utils/mmgr/mcxt.c:1639">MemoryContextAllocHuge</a>(<a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Size) len * MAX_CONVERSION_GROWTH + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; FunctionCall6(flinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(src_encoding),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(dest_encoding),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum(src),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum(result),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(len),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BoolGetDatum(<span class="Constant">false</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release extra space if there might be a lot --- see comments in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L356" title="utils/mb/mbutils.c:356">pg_do_encoding_conversion</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (len &gt; <span class="Constant">1000000</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; resultlen = strlen(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (resultlen &gt;= MaxAllocSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;String of </span><span class="Special">%d</span><span class="Constant"> bytes is too long for encoding conversion.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; len)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(result, resultlen + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert a single Unicode code point into a string in the server encoding.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The code point given by &quot;c&quot; is converted and stored at *s, which must<br/></li>
<li></span><span class="Comment"> * have at least MAX_UNICODE_EQUIVALENT_STRING+1 bytes available.<br/></li>
<li></span><span class="Comment"> * The output will have a trailing '\0'.&nbsp; Throws error if the conversion<br/></li>
<li></span><span class="Comment"> * cannot be performed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this relies on having previously looked up <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> required<br/></li>
<li></span><span class="Comment"> * conversion function.&nbsp; That's partly for speed but mostly because the parser<br/></li>
<li></span><span class="Comment"> * may call this outside <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transaction, or in an aborted transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L864">&#x200c;</a></span><span class="linkable">pg_unicode_to_server</span>(pg_wchar c, <span class="Type">unsigned</span> <span class="Type">char</span> *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> c_as_utf8[MAX_MULTIBYTE_CHAR_LEN + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c_as_utf8_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server_encoding;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Complain if invalid Unicode code point.&nbsp; The choice of <a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a> here is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * debatable, but really our caller should have checked this anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!is_valid_unicode_codepoint(c))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid Unicode code point&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise, if it's in ASCII <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, conversion is trivial */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (c &lt;= <span class="Constant">0x7F</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s[<span class="Constant">0</span>] = (<span class="Type">unsigned</span> <span class="Type">char</span>) c;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s[<span class="Constant">1</span>] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If the server encoding is UTF-8, we just need to reformat the code */<br/></li>
<li></span>&nbsp; &nbsp; server_encoding = <a href="#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (server_encoding == PG_UTF8)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unicode_to_utf8(c, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s[pg_utf_mblen(s)] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For all other cases, we must have a conversion function available */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L75" title="utils/mb/mbutils.c:75">Utf8ToServerConvProc</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;conversion between </span><span class="Special">%s</span><span class="Constant"> and </span><span class="Special">%s</span><span class="Constant"> is not supported&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_enc2name_tbl[PG_UTF8].name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1267" title="utils/mb/mbutils.c:1267">GetDatabaseEncodingName</a>())));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Construct UTF-8 source string */<br/></li>
<li></span>&nbsp; &nbsp; unicode_to_utf8(c, c_as_utf8);<br/></li>
<li>&nbsp; &nbsp; c_as_utf8_len = pg_utf_mblen(c_as_utf8);<br/></li>
<li>&nbsp; &nbsp; c_as_utf8[c_as_utf8_len] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert, or throw error if we can't */<br/></li>
<li></span>&nbsp; &nbsp; FunctionCall6(<a href="#L75" title="utils/mb/mbutils.c:75">Utf8ToServerConvProc</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(PG_UTF8),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(server_encoding),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum((<span class="Type">char</span> *) c_as_utf8),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum((<span class="Type">char</span> *) s),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(c_as_utf8_len),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BoolGetDatum(<span class="Constant">false</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert a single Unicode code point into a string in the server encoding.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Same as <a href="#L864" title="utils/mb/mbutils.c:864">pg_unicode_to_server</a>(), except that we don't throw errors,<br/></li>
<li></span><span class="Comment"> * but simply return false on conversion failure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L926">&#x200c;</a></span><span class="linkable">pg_unicode_to_server_noerror</span>(pg_wchar c, <span class="Type">unsigned</span> <span class="Type">char</span> *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> c_as_utf8[MAX_MULTIBYTE_CHAR_LEN + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c_as_utf8_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; converted_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server_encoding;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fail if invalid Unicode code point */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!is_valid_unicode_codepoint(c))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise, if it's in ASCII <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, conversion is trivial */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (c &lt;= <span class="Constant">0x7F</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s[<span class="Constant">0</span>] = (<span class="Type">unsigned</span> <span class="Type">char</span>) c;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s[<span class="Constant">1</span>] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If the server encoding is UTF-8, we just need to reformat the code */<br/></li>
<li></span>&nbsp; &nbsp; server_encoding = <a href="#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (server_encoding == PG_UTF8)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unicode_to_utf8(c, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s[pg_utf_mblen(s)] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For all other cases, we must have a conversion function available */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L75" title="utils/mb/mbutils.c:75">Utf8ToServerConvProc</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Construct UTF-8 source string */<br/></li>
<li></span>&nbsp; &nbsp; unicode_to_utf8(c, c_as_utf8);<br/></li>
<li>&nbsp; &nbsp; c_as_utf8_len = pg_utf_mblen(c_as_utf8);<br/></li>
<li>&nbsp; &nbsp; c_as_utf8[c_as_utf8_len] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert, but without throwing error if we can't */<br/></li>
<li></span>&nbsp; &nbsp; converted_len = DatumGetInt32(FunctionCall6(<a href="#L75" title="utils/mb/mbutils.c:75">Utf8ToServerConvProc</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(PG_UTF8),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(server_encoding),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum((<span class="Type">char</span> *) c_as_utf8),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum((<span class="Type">char</span> *) s),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(c_as_utf8_len),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BoolGetDatum(<span class="Constant">true</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Conversion was successful iff it consumed the whole input */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (converted_len == c_as_utf8_len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* convert a multibyte string to a wchar */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L979">&#x200c;</a></span><span class="linkable">pg_mb2wchar</span>(<span class="Type">const</span> <span class="Type">char</span> *from, pg_wchar *to)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_wchar_table[<a href="#L81" title="utils/mb/mbutils.c:81">DatabaseEncoding</a>-&gt;encoding].mb2wchar_with_len((<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span> *) from, to, strlen(from));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* convert a multibyte string to a wchar with a limited length */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L986">&#x200c;</a></span><span class="linkable">pg_mb2wchar_with_len</span>(<span class="Type">const</span> <span class="Type">char</span> *from, pg_wchar *to, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_wchar_table[<a href="#L81" title="utils/mb/mbutils.c:81">DatabaseEncoding</a>-&gt;encoding].mb2wchar_with_len((<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span> *) from, to, len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* same, with <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> encoding */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L993">&#x200c;</a></span><span class="linkable">pg_encoding_mb2wchar_with_len</span>(<span class="Type">int</span> encoding,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *from, pg_wchar *to, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_wchar_table[encoding].mb2wchar_with_len((<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span> *) from, to, len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* convert a wchar string to a multibyte */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1001">&#x200c;</a></span><span class="linkable">pg_wchar2mb</span>(<span class="Type">const</span> pg_wchar *from, <span class="Type">char</span> *to)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_wchar_table[<a href="#L81" title="utils/mb/mbutils.c:81">DatabaseEncoding</a>-&gt;encoding].wchar2mb_with_len(from, (<span class="Type">unsigned</span> <span class="Type">char</span> *) to, <a href="wstrncmp.c.html#L70" title="utils/mb/wstrncmp.c:70">pg_wchar_strlen</a>(from));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* convert a wchar string to a multibyte with a limited length */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1008">&#x200c;</a></span><span class="linkable">pg_wchar2mb_with_len</span>(<span class="Type">const</span> pg_wchar *from, <span class="Type">char</span> *to, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_wchar_table[<a href="#L81" title="utils/mb/mbutils.c:81">DatabaseEncoding</a>-&gt;encoding].wchar2mb_with_len(from, (<span class="Type">unsigned</span> <span class="Type">char</span> *) to, len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* same, with <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> encoding */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1015">&#x200c;</a></span><span class="linkable">pg_encoding_wchar2mb_with_len</span>(<span class="Type">int</span> encoding,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> pg_wchar *from, <span class="Type">char</span> *to, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_wchar_table[encoding].wchar2mb_with_len(from, (<span class="Type">unsigned</span> <span class="Type">char</span> *) to, len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* returns the byte length of a multibyte character */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1023">&#x200c;</a></span><span class="linkable">pg_mblen</span>(<span class="Type">const</span> <span class="Type">char</span> *mbstr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_wchar_table[<a href="#L81" title="utils/mb/mbutils.c:81">DatabaseEncoding</a>-&gt;encoding].mblen((<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span> *) mbstr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* returns the display length of a multibyte character */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1030">&#x200c;</a></span><span class="linkable">pg_dsplen</span>(<span class="Type">const</span> <span class="Type">char</span> *mbstr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_wchar_table[<a href="#L81" title="utils/mb/mbutils.c:81">DatabaseEncoding</a>-&gt;encoding].dsplen((<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span> *) mbstr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* returns the length (counted in wchars) of a multibyte string */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1037">&#x200c;</a></span><span class="linkable">pg_mbstrlen</span>(<span class="Type">const</span> <span class="Type">char</span> *mbstr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* optimization for single byte encoding */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1546" title="utils/mb/mbutils.c:1546">pg_database_encoding_max_length</a>() == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> strlen(mbstr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (*mbstr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mbstr += <a href="#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(mbstr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> len;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* returns the length (counted in wchars) of a multibyte string<br/></li>
<li></span><span class="Comment"> * (not necessarily NULL terminated)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1057">&#x200c;</a></span><span class="linkable">pg_mbstrlen_with_len</span>(<span class="Type">const</span> <span class="Type">char</span> *mbstr, <span class="Type">int</span> limit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* optimization for single byte encoding */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1546" title="utils/mb/mbutils.c:1546">pg_database_encoding_max_length</a>() == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> limit;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (limit &gt; <span class="Constant">0</span> &amp;&amp; *mbstr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l = <a href="#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(mbstr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; limit -= l;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mbstr += l;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> len;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * returns the byte length of a multibyte string<br/></li>
<li></span><span class="Comment"> * (not necessarily NULL terminated)<br/></li>
<li></span><span class="Comment"> * that is no longer than limit.<br/></li>
<li></span><span class="Comment"> * this function does not break multibyte character boundary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1083">&#x200c;</a></span><span class="linkable">pg_mbcliplen</span>(<span class="Type">const</span> <span class="Type">char</span> *mbstr, <span class="Type">int</span> len, <span class="Type">int</span> limit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1093" title="utils/mb/mbutils.c:1093">pg_encoding_mbcliplen</a>(<a href="#L81" title="utils/mb/mbutils.c:81">DatabaseEncoding</a>-&gt;encoding, mbstr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; len, limit);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1083" title="utils/mb/mbutils.c:1083">pg_mbcliplen</a> with specified encoding<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1093">&#x200c;</a></span><span class="linkable">pg_encoding_mbcliplen</span>(<span class="Type">int</span> encoding, <span class="Type">const</span> <span class="Type">char</span> *mbstr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> len, <span class="Type">int</span> limit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; mblen_converter mblen_fn;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* optimization for single byte encoding */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pg_encoding_max_length(encoding) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1150" title="utils/mb/mbutils.c:1150">cliplen</a>(mbstr, len, limit);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mblen_fn = pg_wchar_table[encoding].mblen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (len &gt; <span class="Constant">0</span> &amp;&amp; *mbstr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; l = (*mblen_fn) ((<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span> *) mbstr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((clen + l) &gt; limit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; clen += l;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (clen == limit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len -= l;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mbstr += l;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> clen;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Similar to <a href="#L1083" title="utils/mb/mbutils.c:1083">pg_mbcliplen</a> except the limit parameter specifies the<br/></li>
<li></span><span class="Comment"> * character length, not the byte length.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1125">&#x200c;</a></span><span class="linkable">pg_mbcharcliplen</span>(<span class="Type">const</span> <span class="Type">char</span> *mbstr, <span class="Type">int</span> len, <span class="Type">int</span> limit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nch = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* optimization for single byte encoding */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1546" title="utils/mb/mbutils.c:1546">pg_database_encoding_max_length</a>() == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1150" title="utils/mb/mbutils.c:1150">cliplen</a>(mbstr, len, limit);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (len &gt; <span class="Constant">0</span> &amp;&amp; *mbstr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; l = <a href="#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(mbstr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nch++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nch &gt; limit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; clen += l;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len -= l;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mbstr += l;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> clen;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* mbcliplen for <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> single-byte encoding */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1150">&#x200c;</a></span><span class="linkable">cliplen</span>(<span class="Type">const</span> <span class="Type">char</span> *str, <span class="Type">int</span> len, <span class="Type">int</span> limit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(len, limit);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (l &lt; len &amp;&amp; str[l])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; l++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> l;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1161">&#x200c;</a></span><span class="linkable">SetDatabaseEncoding</span>(<span class="Type">int</span> encoding)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_VALID_BE_ENCODING(encoding))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid database encoding: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, encoding);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L81" title="utils/mb/mbutils.c:81">DatabaseEncoding</a> = &amp;pg_enc2name_tbl[encoding];<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L81" title="utils/mb/mbutils.c:81">DatabaseEncoding</a>-&gt;encoding == encoding);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1171">&#x200c;</a></span><span class="linkable">SetMessageEncoding</span>(<span class="Type">int</span> encoding)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Some calls happen <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can elog()! */<br/></li>
<li></span>&nbsp; &nbsp; Assert(PG_VALID_ENCODING(encoding));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L82" title="utils/mb/mbutils.c:82">MessageEncoding</a> = &amp;pg_enc2name_tbl[encoding];<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L82" title="utils/mb/mbutils.c:82">MessageEncoding</a>-&gt;encoding == encoding);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef ENABLE_NLS<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make one bind_textdomain_codeset() call, translating a pg_enc to a gettext<br/></li>
<li></span><span class="Comment"> * codeset.&nbsp; Fails for MULE_INTERNAL, an encoding unknown to gettext; can also<br/></li>
<li></span><span class="Comment"> * fail for gettext-<a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> causes like out-of-memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1187">&#x200c;</a></span><span class="linkable">raw_pg_bind_textdomain_codeset</span>(<span class="Type">const</span> <span class="Type">char</span> *domainname, <span class="Type">int</span> encoding)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; elog_ok = (<a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_VALID_ENCODING(encoding) || pg_enc2gettext_tbl[encoding] == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bind_textdomain_codeset(domainname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_enc2gettext_tbl[encoding]) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (elog_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;bind_textdomain_codeset failed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L3707" title="utils/error/elog.c:3707">write_stderr</a>(<span class="Constant">&quot;bind_textdomain_codeset failed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Bind a gettext message domain to the codeset corresponding to the database<br/></li>
<li></span><span class="Comment"> * encoding.&nbsp; For SQL_ASCII, instead <a href="../../port/win32/socket.c.html#L32" title="port/win32/socket.c:32">bind</a> to the codeset implied by LC_CTYPE.<br/></li>
<li></span><span class="Comment"> * Return the <a href="#L82" title="utils/mb/mbutils.c:82">MessageEncoding</a> implied by the new settings.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On most platforms, gettext defaults to the codeset implied by LC_CTYPE.<br/></li>
<li></span><span class="Comment"> * When that matches the database encoding, we don't need to do anything.&nbsp; In<br/></li>
<li></span><span class="Comment"> * CREATE DATABASE, we enforce or trust that the locale's codeset matches the<br/></li>
<li></span><span class="Comment"> * database encoding, except for the C locale.&nbsp; (On Windows, we also permit a<br/></li>
<li></span><span class="Comment"> * discrepancy under the UTF8 encoding.)&nbsp; For the C locale, explicitly <a href="../../port/win32/socket.c.html#L32" title="port/win32/socket.c:32">bind</a><br/></li>
<li></span><span class="Comment"> * gettext to the right codeset.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On Windows, gettext defaults to the Windows ANSI code page.&nbsp; This is a<br/></li>
<li></span><span class="Comment"> * convenient departure for software that passes the strings to Windows ANSI<br/></li>
<li></span><span class="Comment"> * APIs, but we don't do that.&nbsp; Compel gettext to use database encoding or,<br/></li>
<li></span><span class="Comment"> * failing that, the LC_CTYPE encoding as it would on other platforms.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> elog() and <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>() are usable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1226">&#x200c;</a></span><span class="linkable">pg_bind_textdomain_codeset</span>(<span class="Type">const</span> <span class="Type">char</span> *domainname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; elog_ok = (<a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encoding = <a href="#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_msgenc;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *ctype = setlocale(<span class="Constant">LC_CTYPE</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_strcasecmp(ctype, <span class="Constant">&quot;C&quot;</span>) == <span class="Constant">0</span> || pg_strcasecmp(ctype, <span class="Constant">&quot;POSIX&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (encoding != PG_SQL_ASCII &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1187" title="utils/mb/mbutils.c:1187">raw_pg_bind_textdomain_codeset</a>(domainname, encoding))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> encoding;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; new_msgenc = pg_get_encoding_from_locale(<span class="Constant">NULL</span>, elog_ok);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (new_msgenc &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_msgenc = PG_SQL_ASCII;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1187" title="utils/mb/mbutils.c:1187">raw_pg_bind_textdomain_codeset</a>(domainname, new_msgenc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* On failure, the old message encoding remains valid. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1308" title="utils/mb/mbutils.c:1308">GetMessageEncoding</a>();<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> new_msgenc;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The database encoding, also called the server encoding, represents the<br/></li>
<li></span><span class="Comment"> * encoding of data stored in text-like data types.&nbsp; Affected types include<br/></li>
<li></span><span class="Comment"> * cstring, text, <a href="../adt/varchar.c.html#L609" title="utils/adt/varchar.c:609">varchar</a>, name, xml, and json.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1261">&#x200c;</a></span><span class="linkable">GetDatabaseEncoding</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L81" title="utils/mb/mbutils.c:81">DatabaseEncoding</a>-&gt;encoding;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1267">&#x200c;</a><span class="linkable">GetDatabaseEncodingName</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L81" title="utils/mb/mbutils.c:81">DatabaseEncoding</a>-&gt;name;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1273">&#x200c;</a><span class="linkable">getdatabaseencoding</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall1(<a href="../adt/name.c.html#L48" title="utils/adt/name.c:48">namein</a>, CStringGetDatum(<a href="#L81" title="utils/mb/mbutils.c:81">DatabaseEncoding</a>-&gt;name));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1279">&#x200c;</a><span class="linkable">pg_client_encoding</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall1(<a href="../adt/name.c.html#L48" title="utils/adt/name.c:48">namein</a>, CStringGetDatum(<a href="#L80" title="utils/mb/mbutils.c:80">ClientEncoding</a>-&gt;name));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1285">&#x200c;</a><span class="linkable">PG_char_to_encoding</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; s = PG_GETARG_NAME(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(pg_char_to_encoding(NameStr(*s)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1293">&#x200c;</a><span class="linkable">PG_encoding_to_char</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; encoding = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *encoding_name = pg_encoding_to_char(encoding);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall1(<a href="../adt/name.c.html#L48" title="utils/adt/name.c:48">namein</a>, CStringGetDatum(encoding_name));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * gettext() returns messages in this encoding.&nbsp; This often matches the<br/></li>
<li></span><span class="Comment"> * database encoding, but it differs for SQL_ASCII databases, for processes<br/></li>
<li></span><span class="Comment"> * not attached to a database, and under a database encoding lacking iconv<br/></li>
<li></span><span class="Comment"> * support (MULE_INTERNAL).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1308">&#x200c;</a></span><span class="linkable">GetMessageEncoding</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L82" title="utils/mb/mbutils.c:82">MessageEncoding</a>-&gt;encoding;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generic character incrementer function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Not knowing anything about the properties of the encoding in use, we just<br/></li>
<li></span><span class="Comment"> * keep incrementing the last byte until we get a validly-encoded result,<br/></li>
<li></span><span class="Comment"> * or we run out of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to try.&nbsp; We don't bother to try incrementing<br/></li>
<li></span><span class="Comment"> * higher-order bytes, so there's no growth in runtime for wider characters.<br/></li>
<li></span><span class="Comment"> * (If we did try to do that, we'd need to consider the likelihood that 255<br/></li>
<li></span><span class="Comment"> * is not a valid final byte in the encoding.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1325">&#x200c;</a></span><span class="linkable">pg_generic_charinc</span>(<span class="Type">unsigned</span> <span class="Type">char</span> *charptr, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *lastbyte = charptr + len - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; mbchar_verifier mbverify;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can just invoke the character verifier directly. */<br/></li>
<li></span>&nbsp; &nbsp; mbverify = pg_wchar_table[<a href="#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>()].mbverifychar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (*lastbyte &lt; (<span class="Type">unsigned</span> <span class="Type">char</span>) <span class="Constant">255</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*lastbyte)++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((*mbverify) (charptr, len) == len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * UTF-8 character incrementer function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For a one-byte character less than 0x7F, we just increment the byte.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For a multibyte character, every byte but the first must fall between 0x80<br/></li>
<li></span><span class="Comment"> * and 0xBF; and the first byte must be between 0xC0 and 0xF4.&nbsp; We increment<br/></li>
<li></span><span class="Comment"> * the last byte that's not already at its maximum value.&nbsp; If we can't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a<br/></li>
<li></span><span class="Comment"> * byte that's less than the maximum allowable value, we simply fail.&nbsp; We also<br/></li>
<li></span><span class="Comment"> * need some special-case logic to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> regions used for surrogate pair<br/></li>
<li></span><span class="Comment"> * handling, as those should not occur in valid UTF-8.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we don't reset <a href="../adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-order bytes back to their minimums, since<br/></li>
<li></span><span class="Comment"> * we can't afford to make an exhaustive search (see <a href="../adt/like_support.c.html#L1573" title="utils/adt/like_support.c:1573">make_greater_string</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1359">&#x200c;</a></span><span class="linkable">pg_utf8_increment</span>(<span class="Type">unsigned</span> <span class="Type">char</span> *charptr, <span class="Type">int</span> length)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> limit;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (length)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reject lengths 5 and 6 for <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">4</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = charptr[<span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a &lt; <span class="Constant">0xBF</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; charptr[<span class="Constant">3</span>]++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">3</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = charptr[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a &lt; <span class="Constant">0xBF</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; charptr[<span class="Constant">2</span>]++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">2</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = charptr[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (*charptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0xED</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limit = <span class="Constant">0x9F</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0xF4</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limit = <span class="Constant">0x8F</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; limit = <span class="Constant">0xBF</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a &lt; limit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; charptr[<span class="Constant">1</span>]++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = *charptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a == <span class="Constant">0x7F</span> || a == <span class="Constant">0xDF</span> || a == <span class="Constant">0xEF</span> || a == <span class="Constant">0xF4</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; charptr[<span class="Constant">0</span>]++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * EUC-JP character incrementer function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the sequence starts with SS2 (0x8e), it must be a two-byte sequence<br/></li>
<li></span><span class="Comment"> * representing JIS X 0201 characters with the second byte ranging between<br/></li>
<li></span><span class="Comment"> * 0xa1 and 0xdf.&nbsp; We just increment the last byte if it's less than 0xdf,<br/></li>
<li></span><span class="Comment"> * and otherwise rewrite the whole sequence to 0xa1 0xa1.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the sequence starts with SS3 (0x8f), it must be a three-byte sequence<br/></li>
<li></span><span class="Comment"> * in which the last two bytes <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> between 0xa1 and 0xfe.&nbsp; The last byte<br/></li>
<li></span><span class="Comment"> * is incremented if possible, otherwise the second-to-last byte.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the sequence starts with a value other than the above and its MSB<br/></li>
<li></span><span class="Comment"> * is set, it must be a two-byte sequence representing JIS X 0208 characters<br/></li>
<li></span><span class="Comment"> * with both bytes ranging between 0xa1 and 0xfe.&nbsp; The last byte is<br/></li>
<li></span><span class="Comment"> * incremented if possible, otherwise the second-to-last byte.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Otherwise, the sequence is a single-byte ASCII character. It is<br/></li>
<li></span><span class="Comment"> * incremented up to 0x7f.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1437">&#x200c;</a></span><span class="linkable">pg_eucjp_increment</span>(<span class="Type">unsigned</span> <span class="Type">char</span> *charptr, <span class="Type">int</span> length)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> c1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; c1 = *charptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (c1)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SS2:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* JIS X 0201 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (length != <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c2 = charptr[<span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (c2 &gt;= <span class="Constant">0xdf</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; charptr[<span class="Constant">0</span>] = charptr[<span class="Constant">1</span>] = <span class="Constant">0xa1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (c2 &lt; <span class="Constant">0xa1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; charptr[<span class="Constant">1</span>] = <span class="Constant">0xa1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; charptr[<span class="Constant">1</span>]++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SS3:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* JIS X 0212 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (length != <span class="Constant">3</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">2</span>; i &gt; <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c2 = charptr[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (c2 &lt; <span class="Constant">0xa1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; charptr[i] = <span class="Constant">0xa1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (c2 &lt; <span class="Constant">0xfe</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; charptr[i]++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Out of 3-byte code region */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IS_HIGHBIT_SET(c1)) <span class="Comment">/* JIS X 0208? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (length != <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c2 = charptr[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (c2 &lt; <span class="Constant">0xa1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; charptr[i] = <span class="Constant">0xa1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (c2 &lt; <span class="Constant">0xfe</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; charptr[i]++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Out of 2 byte code region */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ASCII, single byte */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (c1 &gt; <span class="Constant">0x7e</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*charptr)++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * get the character incrementer for the encoding for the current database<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>mbcharacter_incrementer<br/></li>
<li><a id="L1523">&#x200c;</a><span class="linkable">pg_database_encoding_character_incrementer</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Eventually it might be best to add a field to pg_wchar_table[], but for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we just use a switch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PG_UTF8:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1359" title="utils/mb/mbutils.c:1359">pg_utf8_increment</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PG_EUC_JP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1437" title="utils/mb/mbutils.c:1437">pg_eucjp_increment</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1325" title="utils/mb/mbutils.c:1325">pg_generic_charinc</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * fetch maximum length of the encoding for the current database<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1546">&#x200c;</a></span><span class="linkable">pg_database_encoding_max_length</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_wchar_table[<a href="#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>()].maxmblen;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Verify mbstr to make sure that it is validly encoded in the current<br/></li>
<li></span><span class="Comment"> * database encoding.&nbsp; Otherwise same as <a href="#L1566" title="utils/mb/mbutils.c:1566">pg_verify_mbstr</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1556">&#x200c;</a></span><span class="linkable">pg_verifymbstr</span>(<span class="Type">const</span> <span class="Type">char</span> *mbstr, <span class="Type">int</span> len, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> noError)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1566" title="utils/mb/mbutils.c:1566">pg_verify_mbstr</a>(<a href="#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>(), mbstr, len, noError);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Verify mbstr to make sure that it is validly encoded in the specified<br/></li>
<li></span><span class="Comment"> * encoding.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1566">&#x200c;</a></span><span class="linkable">pg_verify_mbstr</span>(<span class="Type">int</span> encoding, <span class="Type">const</span> <span class="Type">char</span> *mbstr, <span class="Type">int</span> len, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> noError)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oklen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(PG_VALID_ENCODING(encoding));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oklen = pg_wchar_table[encoding].mbverifystr((<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span> *) mbstr, len);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (oklen != len)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (noError)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1698" title="utils/mb/mbutils.c:1698">report_invalid_encoding</a>(encoding, mbstr + oklen, len - oklen);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Verify mbstr to make sure that it is validly encoded in the specified<br/></li>
<li></span><span class="Comment"> * encoding.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * mbstr is not necessarily zero terminated; length of mbstr is<br/></li>
<li></span><span class="Comment"> * specified by len.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If OK, return length of string in the encoding.<br/></li>
<li></span><span class="Comment"> * If a problem is found, return -1 when noError is<br/></li>
<li></span><span class="Comment"> * true; when noError is false, ereport() a descriptive message.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: We cannot use the faster encoding-specific mbverifystr() function<br/></li>
<li></span><span class="Comment"> * here, because we need to count the number of characters in the string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1597">&#x200c;</a></span><span class="linkable">pg_verify_mbstr_len</span>(<span class="Type">int</span> encoding, <span class="Type">const</span> <span class="Type">char</span> *mbstr, <span class="Type">int</span> len, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> noError)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; mbchar_verifier mbverifychar;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mb_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(PG_VALID_ENCODING(encoding));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In single-byte encodings, we need only reject nulls (\0).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pg_encoding_max_length(encoding) &lt;= <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *nullpos = memchr(mbstr, <span class="Constant">0</span>, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nullpos == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (noError)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1698" title="utils/mb/mbutils.c:1698">report_invalid_encoding</a>(encoding, nullpos, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fetch function pointer just once */<br/></li>
<li></span>&nbsp; &nbsp; mbverifychar = pg_wchar_table[encoding].mbverifychar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mb_len = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fast path for ASCII-<a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> characters */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IS_HIGHBIT_SET(*mbstr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*mbstr != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mb_len++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mbstr++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (noError)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1698" title="utils/mb/mbutils.c:1698">report_invalid_encoding</a>(encoding, mbstr, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; l = (*mbverifychar) ((<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span> *) mbstr, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (l &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (noError)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1698" title="utils/mb/mbutils.c:1698">report_invalid_encoding</a>(encoding, mbstr, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mbstr += l;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len -= l;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mb_len++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> mb_len;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1669" title="utils/mb/mbutils.c:1669">check_encoding_conversion_args</a>: check arguments of a conversion function<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;expected&quot; arguments can be either an encoding ID or -1 to indicate that<br/></li>
<li></span><span class="Comment"> * the caller will check whether it accepts the ID.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the errors here are not really user-facing, so elog instead of<br/></li>
<li></span><span class="Comment"> * ereport seems sufficient.&nbsp; Also, we trust that the &quot;expected&quot; encoding<br/></li>
<li></span><span class="Comment"> * arguments are valid encoding IDs, but we don't trust the actuals.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1669">&#x200c;</a></span><span class="linkable">check_encoding_conversion_args</span>(<span class="Type">int</span> src_encoding,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> dest_encoding,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> expected_src_encoding,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> expected_dest_encoding)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_VALID_ENCODING(src_encoding))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid source encoding ID: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, src_encoding);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (src_encoding != expected_src_encoding &amp;&amp; expected_src_encoding &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;expected source encoding </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, but got </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_enc2name_tbl[expected_src_encoding].name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_enc2name_tbl[src_encoding].name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_VALID_ENCODING(dest_encoding))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid destination encoding ID: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, dest_encoding);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dest_encoding != expected_dest_encoding &amp;&amp; expected_dest_encoding &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;expected destination encoding </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, but got </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_enc2name_tbl[expected_dest_encoding].name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_enc2name_tbl[dest_encoding].name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;encoding conversion length must not be negative&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1698" title="utils/mb/mbutils.c:1698">report_invalid_encoding</a>: complain about invalid multibyte character<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * note: len is remaining length of string, not length of character;<br/></li>
<li></span><span class="Comment"> * len must be greater than zero, as we always examine the first byte.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1698">&#x200c;</a></span><span class="linkable">report_invalid_encoding</span>(<span class="Type">int</span> encoding, <span class="Type">const</span> <span class="Type">char</span> *mbstr, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l = pg_encoding_mblen(encoding, mbstr);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[<span class="Constant">8</span> * <span class="Constant">5</span> + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p = buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jlimit;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; jlimit = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(l, len);<br/></li>
<li>&nbsp; &nbsp; jlimit = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(jlimit, <span class="Constant">8</span>);&nbsp; &nbsp; <span class="Comment">/* prevent buffer overrun */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; jlimit; j++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p += sprintf(p, <span class="Constant">&quot;0x</span><span class="Special">%02x</span><span class="Constant">&quot;</span>, (<span class="Type">unsigned</span> <span class="Type">char</span>) mbstr[j]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j &lt; jlimit - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p += sprintf(p, <span class="Constant">&quot; &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid byte sequence for encoding </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_enc2name_tbl[encoding].name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1730" title="utils/mb/mbutils.c:1730">report_untranslatable_char</a>: complain about untranslatable character<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * note: len is remaining length of string, not length of character;<br/></li>
<li></span><span class="Comment"> * len must be greater than zero, as we always examine the first byte.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1730">&#x200c;</a></span><span class="linkable">report_untranslatable_char</span>(<span class="Type">int</span> src_encoding, <span class="Type">int</span> dest_encoding,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *mbstr, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l = pg_encoding_mblen(src_encoding, mbstr);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[<span class="Constant">8</span> * <span class="Constant">5</span> + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p = buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jlimit;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; jlimit = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(l, len);<br/></li>
<li>&nbsp; &nbsp; jlimit = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(jlimit, <span class="Constant">8</span>);&nbsp; &nbsp; <span class="Comment">/* prevent buffer overrun */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; jlimit; j++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p += sprintf(p, <span class="Constant">&quot;0x</span><span class="Special">%02x</span><span class="Constant">&quot;</span>, (<span class="Type">unsigned</span> <span class="Type">char</span>) mbstr[j]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j &lt; jlimit - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p += sprintf(p, <span class="Constant">&quot; &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNTRANSLATABLE_CHARACTER),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;character with byte sequence </span><span class="Special">%s</span><span class="Constant"> in encoding </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has no equivalent in encoding </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_enc2name_tbl[src_encoding].name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_enc2name_tbl[dest_encoding].name)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert from <a href="#L82" title="utils/mb/mbutils.c:82">MessageEncoding</a> to a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'ed, null-terminated utf16<br/></li>
<li></span><span class="Comment"> * string. The character length is also passed to utf16len if not<br/></li>
<li></span><span class="Comment"> * null. Returns NULL iff failed. Before <a href="#L82" title="utils/mb/mbutils.c:82">MessageEncoding</a> initialization, &quot;str&quot;<br/></li>
<li></span><span class="Comment"> * should be ASCII-only; this will function as though <a href="#L82" title="utils/mb/mbutils.c:82">MessageEncoding</a> is UTF8.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>WCHAR *<br/></li>
<li><a id="L1766">&#x200c;</a><span class="linkable">pgwin32_message_to_UTF16</span>(<span class="Type">const</span> <span class="Type">char</span> *str, <span class="Type">int</span> len, <span class="Type">int</span> *utf16len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msgenc = <a href="#L1308" title="utils/mb/mbutils.c:1308">GetMessageEncoding</a>();<br/></li>
<li>&nbsp; &nbsp; WCHAR&nbsp; &nbsp; &nbsp;&nbsp; *utf16;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dstlen;<br/></li>
<li>&nbsp; &nbsp; UINT&nbsp; &nbsp; &nbsp; &nbsp; codepage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (msgenc == PG_SQL_ASCII)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No conversion is possible, and SQL_ASCII is never utf16. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; codepage = pg_enc2name_tbl[msgenc].codepage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use MultiByteToWideChar directly if there is a corresponding codepage,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or double conversion through UTF8 if not.&nbsp; Double conversion is needed,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for example, in an ENCODING=LATIN8, LC_CTYPE=C database.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (codepage != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; utf16 = (WCHAR *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(WCHAR) * (len + <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dstlen = MultiByteToWideChar(codepage, <span class="Constant">0</span>, str, len, utf16, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; utf16[dstlen] = (WCHAR) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *utf8;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> <a href="#L356" title="utils/mb/mbutils.c:356">pg_do_encoding_conversion</a>() requires a transaction.&nbsp; In the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * absence of one, hope for the input to be valid UTF8.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; utf8 = (<span class="Type">char</span> *) <a href="#L356" title="utils/mb/mbutils.c:356">pg_do_encoding_conversion</a>((<span class="Type">unsigned</span> <span class="Type">char</span> *) str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msgenc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_UTF8);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (utf8 != str)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = strlen(utf8);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; utf8 = (<span class="Type">char</span> *) str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; utf16 = (WCHAR *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(WCHAR) * (len + <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dstlen = MultiByteToWideChar(CP_UTF8, <span class="Constant">0</span>, utf8, len, utf16, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; utf16[dstlen] = (WCHAR) <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (utf8 != str)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(utf8);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dstlen == <span class="Constant">0</span> &amp;&amp; len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(utf16);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* error */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (utf16len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *utf16len = dstlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> utf16;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
