<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/mmgr/portalmem.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/mmgr/portalmem.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L54">PortalHashTable</a></li>
<li><a href="#L91">TopPortalContext</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L52">PortalHashEnt</a></li>
<li><a href="#L48">portalhashent</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L781">AtAbort_Portals</a></li>
<li><a href="#L858">AtCleanup_Portals</a></li>
<li><a href="#L979">AtSubAbort_Portals</a></li>
<li><a href="#L1092">AtSubCleanup_Portals</a></li>
<li><a href="#L943">AtSubCommit_Portals</a></li>
<li><a href="#L235">CreateNewPortal</a></li>
<li><a href="#L175">CreatePortal</a></li>
<li><a href="#L104">EnablePortalManager</a></li>
<li><a href="#L1253">ForgetPortalSnapshots</a></li>
<li><a href="#L130">GetPortalByName</a></li>
<li><a href="#L1204">HoldPinnedPortals</a></li>
<li><a href="#L636">HoldPortal</a></li>
<li><a href="#L395">MarkPortalActive</a></li>
<li><a href="#L414">MarkPortalDone</a></li>
<li><a href="#L442">MarkPortalFailed</a></li>
<li><a href="#L371">PinPortal</a></li>
<li><a href="#L331">PortalCreateHoldStore</a></li>
<li><a href="#L282">PortalDefineQuery</a></li>
<li><a href="#L468">PortalDrop</a></li>
<li><a href="#L917">PortalErrorCleanup</a></li>
<li><a href="#L151">PortalGetPrimaryStmt</a></li>
<li><a href="#L607">PortalHashTableDeleteAll</a></li>
<li><a href="#L310">PortalReleaseCachedPlan</a></li>
<li><a href="#L677">PreCommit_Portals</a></li>
<li><a href="#L1168">ThereAreNoReadyPortals</a></li>
<li><a href="#L380">UnpinPortal</a></li>
<li><a href="#L1131">pg_cursor</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L46">MAX_PORTALNAME_LEN</a></li>
<li><a href="#L38">PORTALS_PER_USER</a></li>
<li><a href="#L81">PortalHashTableDelete</a></li>
<li><a href="#L68">PortalHashTableInsert</a></li>
<li><a href="#L56">PortalHashTableLookup</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * portalmem.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; backend portal memory management<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portals are objects representing the execution state of a query.<br/></li>
<li></span><span class="Comment"> * This module provides memory management services for portals, but it<br/></li>
<li></span><span class="Comment"> * doesn't actually run the executor for them.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/mmgr/portalmem.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/portalcmds.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Estimate of the maximum number of open portals a user would have,<br/></li>
<li></span><span class="Comment"> * used in initially sizing the <a href="#L54" title="utils/mmgr/portalmem.c:54">PortalHashTable</a> in <a href="#L104" title="utils/mmgr/portalmem.c:104">EnablePortalManager</a>().<br/></li>
<li></span><span class="Comment"> * Since the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table can expand, there's no need to make this overly<br/></li>
<li></span><span class="Comment"> * generous, and keeping it small avoids unnecessary overhead in the<br/></li>
<li></span><span class="Comment"> * <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>() calls executed during transaction end.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L38">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PORTALS_PER_USER</span>&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Constant">16<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Global state<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L46">&#x200c;</a><span class="PreProc">#define <span class="linkable">MAX_PORTALNAME_LEN</span>&nbsp; &nbsp; &nbsp; &nbsp; NAMEDATALEN<br/></li>
<li></span><br/></li>
<li><a id="L48">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">portalhashent</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; portalname[<a href="#L46" title="utils/mmgr/portalmem.c:46">MAX_PORTALNAME_LEN</a>];<br/></li>
<li>&nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal;<br/></li>
<li><a id="L52">&#x200c;</a>} <span class="linkable">PortalHashEnt</span>;<br/></li>
<li><br/></li>
<li><a id="L54">&#x200c;</a><span class="Type">static</span> <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">PortalHashTable</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><a id="L56">&#x200c;</a><span class="PreProc">#define <span class="linkable">PortalHashTableLookup</span>(NAME, PORTAL) \<br/></li>
<li></span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *hentry; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; hentry = (<a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *) <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L54" title="utils/mmgr/portalmem.c:54">PortalHashTable</a>, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (NAME), HASH_FIND, </span><span class="Constant">NULL</span><span class="PreProc">); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (hentry) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; PORTAL = hentry-&gt;portal; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">else</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; PORTAL = </span><span class="Constant">NULL</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">} </span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L68">&#x200c;</a><span class="PreProc">#define <span class="linkable">PortalHashTableInsert</span>(PORTAL, NAME) \<br/></li>
<li></span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *hentry; </span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span><span class="PreProc"> found; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; hentry = (<a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *) <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L54" title="utils/mmgr/portalmem.c:54">PortalHashTable</a>, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (NAME), HASH_ENTER, &amp;found); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (found) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, </span><span class="Constant">&quot;duplicate portal name&quot;</span><span class="PreProc">); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; hentry-&gt;portal = PORTAL; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* To avoid duplicate storage, make PORTAL-&gt;name point to htab entry */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; PORTAL-&gt;name = hentry-&gt;portalname; \<br/></li>
<li></span><span class="PreProc">} </span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L81">&#x200c;</a><span class="PreProc">#define <span class="linkable">PortalHashTableDelete</span>(PORTAL) \<br/></li>
<li></span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *hentry; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; hentry = (<a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *) <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L54" title="utils/mmgr/portalmem.c:54">PortalHashTable</a>, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PORTAL-&gt;name, HASH_REMOVE, </span><span class="Constant">NULL</span><span class="PreProc">); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (hentry == </span><span class="Constant">NULL</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, </span><span class="Constant">&quot;trying to delete portal name that does not exist&quot;</span><span class="PreProc">); \<br/></li>
<li></span><span class="PreProc">} </span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L91">&#x200c;</a><span class="Type">static</span> MemoryContext <span class="linkable">TopPortalContext</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; public portal interface <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L104" title="utils/mmgr/portalmem.c:104">EnablePortalManager</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Enables the portal management module at backend startup.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L104">&#x200c;</a></span><span class="linkable">EnablePortalManager</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L91" title="utils/mmgr/portalmem.c:91">TopPortalContext</a> == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L91" title="utils/mmgr/portalmem.c:91">TopPortalContext</a> = AllocSetContextCreate(<a href="mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="#L91" title="utils/mmgr/portalmem.c:91">TopPortalContext</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctl.keysize = <a href="#L46" title="utils/mmgr/portalmem.c:46">MAX_PORTALNAME_LEN</a>;<br/></li>
<li>&nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use <a href="#L38" title="utils/mmgr/portalmem.c:38">PORTALS_PER_USER</a> as a guess of how many <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table entries to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create, initially<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L54" title="utils/mmgr/portalmem.c:54">PortalHashTable</a> = <a href="../hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;Portal <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>&quot;</span>, <a href="#L38" title="utils/mmgr/portalmem.c:38">PORTALS_PER_USER</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;ctl, HASH_ELEM | HASH_STRINGS);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L130" title="utils/mmgr/portalmem.c:130">GetPortalByName</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns a portal given a portal name, or NULL if name not found.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Portal<br/></li>
<li><a id="L130">&#x200c;</a><span class="linkable">GetPortalByName</span>(<span class="Type">const</span> <span class="Type">char</span> *name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PointerIsValid(name))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L56" title="utils/mmgr/portalmem.c:56">PortalHashTableLookup</a>(name, portal);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; portal = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> portal;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L151" title="utils/mmgr/portalmem.c:151">PortalGetPrimaryStmt</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get the &quot;primary&quot; stmt within a portal, ie, the one marked canSetTag.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns NULL if no such stmt.&nbsp; If multiple PlannedStmt structs within the<br/></li>
<li></span><span class="Comment"> * portal are marked canSetTag, returns the first one.&nbsp; Neither of these<br/></li>
<li></span><span class="Comment"> * cases should occur in present usages of this function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PlannedStmt *<br/></li>
<li><a id="L151">&#x200c;</a><span class="linkable">PortalGetPrimaryStmt</span>(Portal portal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, portal-&gt;stmts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlannedStmt *stmt = lfirst_node(PlannedStmt, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;canSetTag)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> stmt;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L175" title="utils/mmgr/portalmem.c:175">CreatePortal</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns a new portal given a name.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * allowDup: if true, automatically drop <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pre-existing portal of the<br/></li>
<li></span><span class="Comment"> * same name (if false, an error is raised).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * dupSilent: if true, don't even emit a WARNING.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Portal<br/></li>
<li><a id="L175">&#x200c;</a><span class="linkable">CreatePortal</span>(<span class="Type">const</span> <span class="Type">char</span> *name, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allowDup, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> dupSilent)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(PointerIsValid(name));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; portal = <a href="#L130" title="utils/mmgr/portalmem.c:130">GetPortalByName</a>(name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PortalIsValid(portal))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!allowDup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_CURSOR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cursor </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> already exists&quot;</span>, name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!dupSilent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_CURSOR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;closing existing cursor </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L468" title="utils/mmgr/portalmem.c:468">PortalDrop</a>(portal, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make new portal structure */<br/></li>
<li></span>&nbsp; &nbsp; portal = (Portal) <a href="mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(<a href="#L91" title="utils/mmgr/portalmem.c:91">TopPortalContext</a>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span> *portal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> portal context; typically it won't store much */<br/></li>
<li></span>&nbsp; &nbsp; portal-&gt;portalContext = AllocSetContextCreate(<a href="#L91" title="utils/mmgr/portalmem.c:91">TopPortalContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_SMALL_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* create a resource owner for the portal */<br/></li>
<li></span>&nbsp; &nbsp; portal-&gt;resowner = <a href="../resowner/resowner.c.html#L413" title="utils/resowner/resowner.c:413">ResourceOwnerCreate</a>(<a href="../resowner/resowner.c.html#L166" title="utils/resowner/resowner.c:166">CurTransactionResourceOwner</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Portal&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> portal fields that don't start off zero */<br/></li>
<li></span>&nbsp; &nbsp; portal-&gt;status = PORTAL_NEW;<br/></li>
<li>&nbsp; &nbsp; portal-&gt;<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> = <a href="../../commands/portalcmds.c.html#L263" title="commands/portalcmds.c:263">PortalCleanup</a>;<br/></li>
<li>&nbsp; &nbsp; portal-&gt;createSubid = <a href="../../access/transam/xact.c.html#L788" title="access/transam/xact.c:788">GetCurrentSubTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; portal-&gt;activeSubid = portal-&gt;createSubid;<br/></li>
<li>&nbsp; &nbsp; portal-&gt;createLevel = <a href="../../access/transam/xact.c.html#L926" title="access/transam/xact.c:926">GetCurrentTransactionNestLevel</a>();<br/></li>
<li>&nbsp; &nbsp; portal-&gt;strategy = PORTAL_MULTI_QUERY;<br/></li>
<li>&nbsp; &nbsp; portal-&gt;cursorOptions = CURSOR_OPT_NO_SCROLL;<br/></li>
<li>&nbsp; &nbsp; portal-&gt;atStart = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; portal-&gt;atEnd = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* disallow fetches until query is set */<br/></li>
<li></span>&nbsp; &nbsp; portal-&gt;visible = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; portal-&gt;creation_time = <a href="../../access/transam/xact.c.html#L876" title="access/transam/xact.c:876">GetCurrentStatementStartTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* put portal in table (sets portal-&gt;name) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L68" title="utils/mmgr/portalmem.c:68">PortalHashTableInsert</a>(portal, name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* for named portals reuse portal-&gt;name copy */<br/></li>
<li></span>&nbsp; &nbsp; <a href="mcxt.c.html#L612" title="utils/mmgr/mcxt.c:612">MemoryContextSetIdentifier</a>(portal-&gt;portalContext, portal-&gt;name[<span class="Constant">0</span>] ? portal-&gt;name : <span class="Constant">&quot;&lt;unnamed&gt;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> portal;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L235" title="utils/mmgr/portalmem.c:235">CreateNewPortal</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Create a new portal, assigning it a random nonconflicting name.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Portal<br/></li>
<li><a id="L235">&#x200c;</a><span class="linkable">CreateNewPortal</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">unsigned</span> <span class="Type">int</span> unnamed_portal_count = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; portalname[<a href="#L46" title="utils/mmgr/portalmem.c:46">MAX_PORTALNAME_LEN</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Select a nonconflicting name */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unnamed_portal_count++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sprintf(portalname, <span class="Constant">&quot;&lt;unnamed portal </span><span class="Special">%u</span><span class="Constant">&gt;&quot;</span>, unnamed_portal_count);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L130" title="utils/mmgr/portalmem.c:130">GetPortalByName</a>(portalname) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L175" title="utils/mmgr/portalmem.c:175">CreatePortal</a>(portalname, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L282" title="utils/mmgr/portalmem.c:282">PortalDefineQuery</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; A simple subroutine to establish a portal's query.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Notes: as of PG 8.4, caller MUST supply a sourceText string; it is not<br/></li>
<li></span><span class="Comment"> * allowed anymore to pass NULL.&nbsp; (If you really don't have source text,<br/></li>
<li></span><span class="Comment"> * you can pass a constant string, perhaps &quot;(query not available)&quot;.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * commandTag shall be NULL if and only if the original query string<br/></li>
<li></span><span class="Comment"> * (<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> rewriting) was an empty string.&nbsp; Also, the passed commandTag must<br/></li>
<li></span><span class="Comment"> * be a pointer to a constant string, since it is not copied.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If cplan is provided, then it is a cached plan containing the stmts, and<br/></li>
<li></span><span class="Comment"> * the caller must have done <a href="../cache/plancache.c.html#L1168" title="utils/cache/plancache.c:1168">GetCachedPlan</a>(), causing a refcount increment.<br/></li>
<li></span><span class="Comment"> * The refcount will be released when the portal is destroyed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If cplan is NULL, then it is the caller's responsibility to ensure that<br/></li>
<li></span><span class="Comment"> * the passed plan trees have adequate lifetime.&nbsp; Typically this is done by<br/></li>
<li></span><span class="Comment"> * copying them into the portal's context.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller is also responsible for ensuring that the passed prepStmtName<br/></li>
<li></span><span class="Comment"> * (if not NULL) and sourceText have adequate lifetime.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: this function mustn't do much beyond storing the passed <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>; in<br/></li>
<li></span><span class="Comment"> * particular don't do anything that risks elog(ERROR).&nbsp; If that were to<br/></li>
<li></span><span class="Comment"> * happen here <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> storing the cplan reference, we'd leak the plancache<br/></li>
<li></span><span class="Comment"> * refcount that the caller is trying to hand off to us.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L282">&#x200c;</a></span><span class="linkable">PortalDefineQuery</span>(Portal portal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *prepStmtName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *sourceText,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CommandTag commandTag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *stmts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CachedPlan *cplan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(PortalIsValid(portal));<br/></li>
<li>&nbsp; &nbsp; Assert(portal-&gt;status == PORTAL_NEW);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(sourceText != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(commandTag != CMDTAG_UNKNOWN || stmts == NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; portal-&gt;prepStmtName = prepStmtName;<br/></li>
<li>&nbsp; &nbsp; portal-&gt;sourceText = sourceText;<br/></li>
<li>&nbsp; &nbsp; portal-&gt;qc.commandTag = commandTag;<br/></li>
<li>&nbsp; &nbsp; portal-&gt;qc.nprocessed = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; portal-&gt;commandTag = commandTag;<br/></li>
<li>&nbsp; &nbsp; portal-&gt;stmts = stmts;<br/></li>
<li>&nbsp; &nbsp; portal-&gt;cplan = cplan;<br/></li>
<li>&nbsp; &nbsp; portal-&gt;status = PORTAL_DEFINED;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L310" title="utils/mmgr/portalmem.c:310">PortalReleaseCachedPlan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Release a portal's reference to its cached plan, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L310">&#x200c;</a></span><span class="linkable">PortalReleaseCachedPlan</span>(Portal portal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;cplan)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/plancache.c.html#L1291" title="utils/cache/plancache.c:1291">ReleaseCachedPlan</a>(portal-&gt;cplan, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;cplan = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must also clear portal-&gt;stmts which is <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> a dangling reference<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the cached plan's plan list.&nbsp; This protects <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> code that might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * try to examine the Portal later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;stmts = NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L331" title="utils/mmgr/portalmem.c:331">PortalCreateHoldStore</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Create the tuplestore for a portal.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L331">&#x200c;</a></span><span class="linkable">PortalCreateHoldStore</span>(Portal portal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(portal-&gt;holdContext == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(portal-&gt;holdStore == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(portal-&gt;holdSnapshot == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the memory context that is used for storage of the tuple set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note this is NOT a child of the portal's portalContext.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; portal-&gt;holdContext =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AllocSetContextCreate(<a href="#L91" title="utils/mmgr/portalmem.c:91">TopPortalContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;PortalHoldContext&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the tuple store, selecting cross-transaction temp files, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enabling random access only if cursor requires scrolling.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: Should <a href="../init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> be used for the portal size?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(portal-&gt;holdContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; portal-&gt;holdStore =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../sort/tuplestore.c.html#L318" title="utils/sort/tuplestore.c:318">tuplestore_begin_heap</a>(portal-&gt;cursorOptions &amp; CURSOR_OPT_SCROLL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <a href="../init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L371" title="utils/mmgr/portalmem.c:371">PinPortal</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Protect a portal from dropping.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A pinned portal is still unpinned and dropped at transaction or<br/></li>
<li></span><span class="Comment"> * subtransaction abort.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L371">&#x200c;</a></span><span class="linkable">PinPortal</span>(Portal portal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;portalPinned)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;portal already pinned&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; portal-&gt;portalPinned = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L380">&#x200c;</a></span><span class="linkable">UnpinPortal</span>(Portal portal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!portal-&gt;portalPinned)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;portal not pinned&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; portal-&gt;portalPinned = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L395" title="utils/mmgr/portalmem.c:395">MarkPortalActive</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Transition a portal from READY to ACTIVE state.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: never set portal-&gt;status = PORTAL_ACTIVE directly; call this instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L395">&#x200c;</a></span><span class="linkable">MarkPortalActive</span>(Portal portal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For safety, this is a runtime test not just an Assert */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;status != PORTAL_READY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;portal </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> cannot be run&quot;</span>, portal-&gt;name)));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Perform the state transition */<br/></li>
<li></span>&nbsp; &nbsp; portal-&gt;status = PORTAL_ACTIVE;<br/></li>
<li>&nbsp; &nbsp; portal-&gt;activeSubid = <a href="../../access/transam/xact.c.html#L788" title="access/transam/xact.c:788">GetCurrentSubTransactionId</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L414" title="utils/mmgr/portalmem.c:414">MarkPortalDone</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Transition a portal from ACTIVE to DONE state.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: never set portal-&gt;status = PORTAL_DONE directly; call this instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L414">&#x200c;</a></span><span class="linkable">MarkPortalDone</span>(Portal portal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Perform the state transition */<br/></li>
<li></span>&nbsp; &nbsp; Assert(portal-&gt;status == PORTAL_ACTIVE);<br/></li>
<li>&nbsp; &nbsp; portal-&gt;status = PORTAL_DONE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allow portalcmds.c to clean up the state it knows about.&nbsp; We might as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * well do that <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, since the portal can't be executed <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In some cases involving execution of a ROLLBACK command in an already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aborted transaction, this is necessary, or we'd reach <a href="#L858" title="utils/mmgr/portalmem.c:858">AtCleanup_Portals</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with the <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> hook still unexecuted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PointerIsValid(portal-&gt;<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>(portal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L442" title="utils/mmgr/portalmem.c:442">MarkPortalFailed</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Transition a portal into FAILED state.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: never set portal-&gt;status = PORTAL_FAILED directly; call this instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L442">&#x200c;</a></span><span class="linkable">MarkPortalFailed</span>(Portal portal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Perform the state transition */<br/></li>
<li></span>&nbsp; &nbsp; Assert(portal-&gt;status != PORTAL_DONE);<br/></li>
<li>&nbsp; &nbsp; portal-&gt;status = PORTAL_FAILED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allow portalcmds.c to clean up the state it knows about.&nbsp; We might as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * well do that <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, since the portal can't be executed <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In some cases involving <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> of an already aborted transaction, this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is necessary, or we'd reach <a href="#L858" title="utils/mmgr/portalmem.c:858">AtCleanup_Portals</a> with the <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> hook<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * still unexecuted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PointerIsValid(portal-&gt;<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>(portal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L468" title="utils/mmgr/portalmem.c:468">PortalDrop</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Destroy the portal.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L468">&#x200c;</a></span><span class="linkable">PortalDrop</span>(Portal portal, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isTopCommit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(PortalIsValid(portal));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't allow dropping a pinned portal, it's still needed by whoever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pinned it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;portalPinned)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_CURSOR_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot drop pinned portal </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, portal-&gt;name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Not sure if the PORTAL_ACTIVE case can validly happen or not...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;status == PORTAL_ACTIVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_CURSOR_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot drop active portal </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, portal-&gt;name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allow portalcmds.c to clean up the state it knows about, in particular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shutting down the executor if still active.&nbsp; This step potentially runs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * user-defined code so failure has to be expected.&nbsp; It's the <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hook's responsibility to not try to do that more than once, in the case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that failure occurs and then we come back to drop the portal again<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during transaction abort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: in most paths of control, this will have been done already in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L414" title="utils/mmgr/portalmem.c:414">MarkPortalDone</a> or <a href="#L442" title="utils/mmgr/portalmem.c:442">MarkPortalFailed</a>.&nbsp; We're just making sure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PointerIsValid(portal-&gt;<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>(portal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* There shouldn't be an active snapshot anymore, except after error */<br/></li>
<li></span>&nbsp; &nbsp; Assert(portal-&gt;portalSnapshot == <span class="Constant">NULL</span> || !isTopCommit);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove portal from <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.&nbsp; Because we do this here, we will not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * come back to try to remove the portal again if there's <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subsequent steps.&nbsp; Better to leak a little memory than to get into an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * infinite error-recovery loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L81" title="utils/mmgr/portalmem.c:81">PortalHashTableDelete</a>(portal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* drop cached plan reference, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L310" title="utils/mmgr/portalmem.c:310">PortalReleaseCachedPlan</a>(portal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If portal has a snapshot protecting its data, release that.&nbsp; This needs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a little care since the registration will be attached to the portal's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * resowner; if the portal failed, we will already have released the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * resowner (and the snapshot) during transaction abort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;holdSnapshot)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;resowner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../time/snapmgr.c.html#L849" title="utils/time/snapmgr.c:849">UnregisterSnapshotFromOwner</a>(portal-&gt;holdSnapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;resowner);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;holdSnapshot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> resources still attached to the portal.&nbsp; There are several<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases being covered here:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Top transaction commit (indicated by isTopCommit): normally we should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do nothing here and let the regular end-of-transaction resource<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * releasing mechanism handle these resources too.&nbsp; However, if we have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * FAILED portal (eg, a cursor that got an error), we'd better clean up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its resources to avoid resource-leakage warning messages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sub transaction commit: never comes here at all, since we don't kill<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> portals in <a href="#L943" title="utils/mmgr/portalmem.c:943">AtSubCommit_Portals</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Main or sub transaction abort: we will do nothing here because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * portal-&gt;resowner was already set NULL; the resources were already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cleaned up in transaction abort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ordinary portal drop: must release resources.&nbsp; However, if the portal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is not FAILED then we do not release its locks.&nbsp; The locks become the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * responsibility of the transaction's ResourceOwner (since it is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent of the portal's owner) and will be released when the transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * eventually ends.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;resowner &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (!isTopCommit || portal-&gt;status == PORTAL_FAILED))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isCommit = (portal-&gt;status != PORTAL_FAILED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../resowner/resowner.c.html#L648" title="utils/resowner/resowner.c:648">ResourceOwnerRelease</a>(portal-&gt;resowner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RESOURCE_RELEASE_BEFORE_LOCKS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isCommit, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../resowner/resowner.c.html#L648" title="utils/resowner/resowner.c:648">ResourceOwnerRelease</a>(portal-&gt;resowner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RESOURCE_RELEASE_LOCKS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isCommit, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../resowner/resowner.c.html#L648" title="utils/resowner/resowner.c:648">ResourceOwnerRelease</a>(portal-&gt;resowner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RESOURCE_RELEASE_AFTER_LOCKS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isCommit, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../resowner/resowner.c.html#L854" title="utils/resowner/resowner.c:854">ResourceOwnerDelete</a>(portal-&gt;resowner);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; portal-&gt;resowner = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> tuplestore if present.&nbsp; We should do this even under error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conditions; since the tuplestore would have been using cross-<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction storage, its temp files need to be explicitly deleted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;holdStore)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(portal-&gt;holdContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../sort/tuplestore.c.html#L453" title="utils/sort/tuplestore.c:453">tuplestore_end</a>(portal-&gt;holdStore);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;holdStore = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* delete tuplestore storage, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;holdContext)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(portal-&gt;holdContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* release subsidiary storage */<br/></li>
<li></span>&nbsp; &nbsp; <a href="mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(portal-&gt;portalContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* release portal struct (it's in <a href="#L91" title="utils/mmgr/portalmem.c:91">TopPortalContext</a>) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(portal);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> all declared cursors.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Used by commands: CLOSE ALL, DISCARD ALL<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L607">&#x200c;</a></span><span class="linkable">PortalHashTableDeleteAll</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *hentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L54" title="utils/mmgr/portalmem.c:54">PortalHashTable</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L54" title="utils/mmgr/portalmem.c:54">PortalHashTable</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((hentry = <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal = hentry-&gt;portal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can't close the active portal (the one running the command) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;status == PORTAL_ACTIVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L468" title="utils/mmgr/portalmem.c:468">PortalDrop</a>(portal, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Restart the iteration in case that led to other drops */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1471" title="utils/hash/dynahash.c:1471">hash_seq_term</a>(&amp;status);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L54" title="utils/mmgr/portalmem.c:54">PortalHashTable</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * &quot;Hold&quot; a portal.&nbsp; Prepare it for access by later transactions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L636">&#x200c;</a></span><span class="linkable">HoldPortal</span>(Portal portal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that <a href="../../commands/portalcmds.c.html#L316" title="commands/portalcmds.c:316">PersistHoldablePortal</a>() must release all resources used by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the portal that are local to the creating transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L331" title="utils/mmgr/portalmem.c:331">PortalCreateHoldStore</a>(portal);<br/></li>
<li>&nbsp; &nbsp; <a href="../../commands/portalcmds.c.html#L316" title="commands/portalcmds.c:316">PersistHoldablePortal</a>(portal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* drop cached plan reference, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L310" title="utils/mmgr/portalmem.c:310">PortalReleaseCachedPlan</a>(portal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Any resources belonging to the portal will be released in the upcoming<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction-wide <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>; the portal will no longer have its own<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * resources.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; portal-&gt;resowner = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Having successfully exported the holdable cursor, mark it as not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * belonging to this transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; portal-&gt;createSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; portal-&gt;activeSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; portal-&gt;createLevel = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Pre-commit processing for portals.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Holdable cursors created in this transaction need to be converted to<br/></li>
<li></span><span class="Comment"> * materialized form, since we are going to close down the executor and<br/></li>
<li></span><span class="Comment"> * release locks.&nbsp; Non-holdable portals created in this transaction are<br/></li>
<li></span><span class="Comment"> * simply removed.&nbsp; Portals remaining from prior transactions should be<br/></li>
<li></span><span class="Comment"> * left untouched.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> portals changed state (possibly causing user-defined<br/></li>
<li></span><span class="Comment"> * code to be run), false if not.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L677">&#x200c;</a></span><span class="linkable">PreCommit_Portals</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isPrepare)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *hentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L54" title="utils/mmgr/portalmem.c:54">PortalHashTable</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((hentry = (<a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *) <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal = hentry-&gt;portal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There should be no pinned portals anymore. Complain if someone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leaked one. Auto-held portals are allowed; we assume that whoever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pinned them is managing them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;portalPinned &amp;&amp; !portal-&gt;autoHeld)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot commit while a portal is pinned&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do not touch active portals --- this can only happen in the case of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a multi-transaction utility command, such as VACUUM, or a commit in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a procedure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note however that <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> resource owner attached to such a portal is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still going to go away, so don't leave a dangling pointer.&nbsp; Also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unregister <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> snapshots held by the portal, mainly to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * snapshot leak warnings from <a href="../resowner/resowner.c.html#L648" title="utils/resowner/resowner.c:648">ResourceOwnerRelease</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;status == PORTAL_ACTIVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;holdSnapshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;resowner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../time/snapmgr.c.html#L849" title="utils/time/snapmgr.c:849">UnregisterSnapshotFromOwner</a>(portal-&gt;holdSnapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;resowner);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;holdSnapshot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;resowner = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Clear portalSnapshot too, for cleanliness */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;portalSnapshot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Is it a holdable portal created in the current xact? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((portal-&gt;cursorOptions &amp; CURSOR_OPT_HOLD) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;createSubid != InvalidSubTransactionId &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;status == PORTAL_READY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are exiting the transaction that created a holdable cursor.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Instead of dropping the portal, prepare it for access by later<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, if this is PREPARE TRANSACTION rather than COMMIT,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * refuse PREPARE, because the semantics seem pretty unclear.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isPrepare)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot PREPARE a transaction that has created a cursor WITH HOLD&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L636" title="utils/mmgr/portalmem.c:636">HoldPortal</a>(portal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report we changed state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (portal-&gt;createSubid == InvalidSubTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do nothing to cursors held over from a previous transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (including ones we just froze in a previous cycle of this loop)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Zap all non-holdable portals */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L468" title="utils/mmgr/portalmem.c:468">PortalDrop</a>(portal, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report we changed state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * After either freezing or dropping a portal, we have to restart the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * iteration, because we could have invoked user-defined code that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caused a drop of the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> portal in the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1471" title="utils/hash/dynahash.c:1471">hash_seq_term</a>(&amp;status);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L54" title="utils/mmgr/portalmem.c:54">PortalHashTable</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Abort processing for portals.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At this point we run the <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> hook if present, but we can't release the<br/></li>
<li></span><span class="Comment"> * portal's memory until the <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> call.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L781">&#x200c;</a></span><span class="linkable">AtAbort_Portals</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *hentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L54" title="utils/mmgr/portalmem.c:54">PortalHashTable</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((hentry = (<a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *) <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal = hentry-&gt;portal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When elog(FATAL) is progress, we need to set the active portal to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * failed, so that <a href="../../commands/portalcmds.c.html#L263" title="commands/portalcmds.c:263">PortalCleanup</a>() doesn't run the executor shutdown.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;status == PORTAL_ACTIVE &amp;&amp; <a href="../../storage/ipc/ipc.c.html#L45" title="storage/ipc/ipc.c:45">shmem_exit_inprogress</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L442" title="utils/mmgr/portalmem.c:442">MarkPortalFailed</a>(portal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do nothing else to cursors held over from a previous transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;createSubid == InvalidSubTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do nothing to auto-held cursors.&nbsp; This is similar to the case of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cursor from a previous transaction, but it could also be that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cursor was auto-held in this transaction, so it wants to live on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;autoHeld)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it was created in the current transaction, we can't do normal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shutdown on a READY portal either; it might refer to objects<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * created in the failed transaction.&nbsp; See comments in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L979" title="utils/mmgr/portalmem.c:979">AtSubAbort_Portals</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;status == PORTAL_READY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L442" title="utils/mmgr/portalmem.c:442">MarkPortalFailed</a>(portal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Allow portalcmds.c to clean up the state it knows about, if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * haven't already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PointerIsValid(portal-&gt;<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>(portal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* drop cached plan reference, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L310" title="utils/mmgr/portalmem.c:310">PortalReleaseCachedPlan</a>(portal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Any resources belonging to the portal will be released in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * upcoming transaction-wide <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>; they will be gone <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we run<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L468" title="utils/mmgr/portalmem.c:468">PortalDrop</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;resowner = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Although we can't delete the portal data structure proper, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * release <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> memory in subsidiary contexts, such as executor state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> hook was the last thing that might have needed data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there.&nbsp; But leave active portals alone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;status != PORTAL_ACTIVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="mcxt.c.html#L539" title="utils/mmgr/mcxt.c:539">MemoryContextDeleteChildren</a>(portal-&gt;portalContext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Post-abort <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> for portals.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> all portals not held over from prior transactions.&nbsp; */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L858">&#x200c;</a></span><span class="linkable">AtCleanup_Portals</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *hentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L54" title="utils/mmgr/portalmem.c:54">PortalHashTable</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((hentry = (<a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *) <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal = hentry-&gt;portal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do not touch active portals --- this can only happen in the case of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a multi-transaction command.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;status == PORTAL_ACTIVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do nothing to cursors held over from a previous transaction or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * auto-held ones.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;createSubid == InvalidSubTransactionId || portal-&gt;autoHeld)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(portal-&gt;status != PORTAL_ACTIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(portal-&gt;resowner == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If a portal is still pinned, forcibly unpin it. <a href="#L468" title="utils/mmgr/portalmem.c:468">PortalDrop</a> will not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * let us drop the portal otherwise. Whoever pinned the portal was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interrupted by the abort too and won't try to use it anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;portalPinned)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;portalPinned = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We had better not call <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> user-defined code during <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>, so if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> hook hasn't been run yet, too bad; we'll just <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PointerIsValid(portal-&gt;<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;skipping <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> for portal </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, portal-&gt;name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Zap it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L468" title="utils/mmgr/portalmem.c:468">PortalDrop</a>(portal, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Portal-related <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> when we return to the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop on error.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is different from the <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> at transaction abort.&nbsp; Auto-held portals<br/></li>
<li></span><span class="Comment"> * are cleaned up on error but not on transaction abort.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L917">&#x200c;</a></span><span class="linkable">PortalErrorCleanup</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *hentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L54" title="utils/mmgr/portalmem.c:54">PortalHashTable</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((hentry = (<a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *) <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal = hentry-&gt;portal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;autoHeld)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;portalPinned = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L468" title="utils/mmgr/portalmem.c:468">PortalDrop</a>(portal, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Pre-subcommit processing for portals.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Reassign portals created or used in the current subtransaction to the<br/></li>
<li></span><span class="Comment"> * parent subtransaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L943">&#x200c;</a></span><span class="linkable">AtSubCommit_Portals</span>(SubTransactionId mySubid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SubTransactionId parentSubid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> parentLevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResourceOwner parentXactOwner)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *hentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L54" title="utils/mmgr/portalmem.c:54">PortalHashTable</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((hentry = (<a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *) <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal = hentry-&gt;portal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;createSubid == mySubid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;createSubid = parentSubid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;createLevel = parentLevel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;resowner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../resowner/resowner.c.html#L897" title="utils/resowner/resowner.c:897">ResourceOwnerNewParent</a>(portal-&gt;resowner, parentXactOwner);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;activeSubid == mySubid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;activeSubid = parentSubid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subtransaction abort handling for portals.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Deactivate portals created or used during the failed subtransaction.<br/></li>
<li></span><span class="Comment"> * Note that per <a href="#L943" title="utils/mmgr/portalmem.c:943">AtSubCommit_Portals</a>, this will catch portals created/used<br/></li>
<li></span><span class="Comment"> * in descendants of the subtransaction too.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We don't destroy <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> portals here; that's done in <a href="#L1092" title="utils/mmgr/portalmem.c:1092">AtSubCleanup_Portals</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L979">&#x200c;</a></span><span class="linkable">AtSubAbort_Portals</span>(SubTransactionId mySubid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SubTransactionId parentSubid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ResourceOwner myXactOwner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ResourceOwner parentXactOwner)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *hentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L54" title="utils/mmgr/portalmem.c:54">PortalHashTable</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((hentry = (<a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *) <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal = hentry-&gt;portal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Was it created in this subtransaction? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;createSubid != mySubid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No, but maybe it was used in this subtransaction? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;activeSubid == mySubid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Maintain activeSubid until the portal is removed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;activeSubid = parentSubid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A <a href="#L395" title="utils/mmgr/portalmem.c:395">MarkPortalActive</a>() caller ran an <a href="../adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level portal in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this subtransaction and left the portal ACTIVE.&nbsp; This can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * happen, but force the portal into FAILED state for the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reasons discussed below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We assume we can get away without forcing <a href="../adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level READY<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * portals to fail, even if they were run and then suspended.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In theory a suspended <a href="../adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level portal could have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * acquired some references to objects that are about to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * destroyed, but there should be sufficient defenses against<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * such cases: the portal's original query cannot contain such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * references, and <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> references within, say, cached plans of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PL/pgSQL <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are not from active queries and should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be protected by revalidation logic.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;status == PORTAL_ACTIVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L442" title="utils/mmgr/portalmem.c:442">MarkPortalFailed</a>(portal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also, if we failed it during the current subtransaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (either just above, or earlier), reattach its resource<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * owner to the current subtransaction's resource owner, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> resources it still holds will be released while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cleaning up this subtransaction.&nbsp; This prevents some corner<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cases wherein we might get Asserts or worse while cleaning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * up objects created during the current subtransaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (because they're still referenced within this portal).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;status == PORTAL_FAILED &amp;&amp; portal-&gt;resowner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../resowner/resowner.c.html#L897" title="utils/resowner/resowner.c:897">ResourceOwnerNewParent</a>(portal-&gt;resowner, myXactOwner);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;resowner = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Done if it wasn't created in this subtransaction */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Force <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> live portals of my own subtransaction into FAILED state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to do this because they might refer to objects created or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changed in the failed subtransaction, leading to crashes within<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../executor/execMain.c.html#L467" title="executor/execMain.c:467">ExecutorEnd</a> when portalcmds.c tries to close down the portal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Currently, every <a href="#L395" title="utils/mmgr/portalmem.c:395">MarkPortalActive</a>() caller ensures it updates the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * portal status again <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> relinquishing control, so ACTIVE can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * happen here.&nbsp; If it does happen, dispose the portal like existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L395" title="utils/mmgr/portalmem.c:395">MarkPortalActive</a>() callers would.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;status == PORTAL_READY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;status == PORTAL_ACTIVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L442" title="utils/mmgr/portalmem.c:442">MarkPortalFailed</a>(portal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Allow portalcmds.c to clean up the state it knows about, if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * haven't already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PointerIsValid(portal-&gt;<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>(portal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* drop cached plan reference, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L310" title="utils/mmgr/portalmem.c:310">PortalReleaseCachedPlan</a>(portal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Any resources belonging to the portal will be released in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * upcoming transaction-wide <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>; they will be gone <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we run<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L468" title="utils/mmgr/portalmem.c:468">PortalDrop</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;resowner = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Although we can't delete the portal data structure proper, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * release <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> memory in subsidiary contexts, such as executor state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> hook was the last thing that might have needed data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="mcxt.c.html#L539" title="utils/mmgr/mcxt.c:539">MemoryContextDeleteChildren</a>(portal-&gt;portalContext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Post-subabort <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> for portals.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Drop all portals created in the failed subtransaction (but note that<br/></li>
<li></span><span class="Comment"> * we will not drop <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> that were reassigned to the parent above).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1092">&#x200c;</a></span><span class="linkable">AtSubCleanup_Portals</span>(SubTransactionId mySubid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *hentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L54" title="utils/mmgr/portalmem.c:54">PortalHashTable</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((hentry = (<a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *) <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal = hentry-&gt;portal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;createSubid != mySubid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If a portal is still pinned, forcibly unpin it. <a href="#L468" title="utils/mmgr/portalmem.c:468">PortalDrop</a> will not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * let us drop the portal otherwise. Whoever pinned the portal was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interrupted by the abort too and won't try to use it anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;portalPinned)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;portalPinned = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We had better not call <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> user-defined code during <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>, so if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> hook hasn't been run yet, too bad; we'll just <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PointerIsValid(portal-&gt;<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;skipping <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> for portal </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, portal-&gt;name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Zap it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L468" title="utils/mmgr/portalmem.c:468">PortalDrop</a>(portal, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Find all available cursors */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1131">&#x200c;</a><span class="linkable">pg_cursor</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReturnSetInfo *rsinfo = (ReturnSetInfo *) fcinfo-&gt;resultinfo;<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS hash_seq;<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *hentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We put all the tuples into a tuplestore in one scan of the hashtable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This avoids <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> issue of the hashtable possibly changing between calls.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../fmgr/funcapi.c.html#L76" title="utils/fmgr/funcapi.c:76">InitMaterializedSRF</a>(fcinfo, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;hash_seq, <a href="#L54" title="utils/mmgr/portalmem.c:54">PortalHashTable</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((hentry = <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;hash_seq)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal = hentry-&gt;portal;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">6</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">6</span>] = {<span class="Constant">0</span>};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* report only &quot;visible&quot; entries */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!portal-&gt;visible)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = CStringGetTextDatum(portal-&gt;name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = CStringGetTextDatum(portal-&gt;sourceText);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>] = BoolGetDatum(portal-&gt;cursorOptions &amp; CURSOR_OPT_HOLD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">3</span>] = BoolGetDatum(portal-&gt;cursorOptions &amp; CURSOR_OPT_BINARY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">4</span>] = BoolGetDatum(portal-&gt;cursorOptions &amp; CURSOR_OPT_SCROLL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">5</span>] = TimestampTzGetDatum(portal-&gt;creation_time);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../sort/tuplestore.c.html#L750" title="utils/sort/tuplestore.c:750">tuplestore_putvalues</a>(rsinfo-&gt;setResult, rsinfo-&gt;setDesc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1168">&#x200c;</a></span><span class="linkable">ThereAreNoReadyPortals</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *hentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L54" title="utils/mmgr/portalmem.c:54">PortalHashTable</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((hentry = (<a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *) <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal = hentry-&gt;portal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;status == PORTAL_READY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Hold all pinned portals.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When initiating a COMMIT or ROLLBACK inside a procedure, this must be<br/></li>
<li></span><span class="Comment"> * called to protect internally-generated cursors from being dropped during<br/></li>
<li></span><span class="Comment"> * the transaction shutdown.&nbsp; Currently, SPI calls this automatically; PLs<br/></li>
<li></span><span class="Comment"> * that initiate COMMIT or ROLLBACK some other way are on the hook to do it<br/></li>
<li></span><span class="Comment"> * themselves.&nbsp; (Note that we couldn't do this in, say, <a href="#L781" title="utils/mmgr/portalmem.c:781">AtAbort_Portals</a><br/></li>
<li></span><span class="Comment"> * because we need to run user-defined code while persisting a portal.<br/></li>
<li></span><span class="Comment"> * It's too late to do that once transaction abort has started.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We protect such portals by converting them to held cursors.&nbsp; We mark them<br/></li>
<li></span><span class="Comment"> * as &quot;auto-held&quot; so that exception exit knows to clean them up.&nbsp; (In normal,<br/></li>
<li></span><span class="Comment"> * non-exception code paths, the PL needs to clean such portals itself, since<br/></li>
<li></span><span class="Comment"> * transaction end won't do it anymore; but that should be normal practice<br/></li>
<li></span><span class="Comment"> * anyway.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1204">&#x200c;</a></span><span class="linkable">HoldPinnedPortals</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *hentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L54" title="utils/mmgr/portalmem.c:54">PortalHashTable</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((hentry = (<a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *) <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal = hentry-&gt;portal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;portalPinned &amp;&amp; !portal-&gt;autoHeld)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Doing transaction control, especially abort, inside a cursor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * loop that is not read-only, for example using UPDATE ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * RETURNING, has weird semantics issues.&nbsp; Also, this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * implementation wouldn't work, because such portals cannot be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * held.&nbsp; (The core grammar enforces that only SELECT statements<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can drive a cursor, but for example PL/pgSQL does not restrict<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;strategy != PORTAL_ONE_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot perform transaction commands inside a cursor loop that is not read-only&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Verify it's in a suitable state to be held */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;status != PORTAL_READY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;pinned portal is not ready to be auto-held&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L636" title="utils/mmgr/portalmem.c:636">HoldPortal</a>(portal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;autoHeld = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Drop the outer active snapshots for all portals, so that no snapshots<br/></li>
<li></span><span class="Comment"> * remain active.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Like <a href="#L1204" title="utils/mmgr/portalmem.c:1204">HoldPinnedPortals</a>, this must be called when initiating a COMMIT or<br/></li>
<li></span><span class="Comment"> * ROLLBACK inside a procedure.&nbsp; This has to be separate from that since it<br/></li>
<li></span><span class="Comment"> * should not be run until we're done with steps that are likely to fail.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It's tempting to fold this into <a href="#L677" title="utils/mmgr/portalmem.c:677">PreCommit_Portals</a>, but to do so, we'd<br/></li>
<li></span><span class="Comment"> * need to clean up snapshot management in VACUUM and perhaps other places.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1253">&#x200c;</a></span><span class="linkable">ForgetPortalSnapshots</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *hentry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numPortalSnaps = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numActiveSnaps = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First, scan <a href="#L54" title="utils/mmgr/portalmem.c:54">PortalHashTable</a> and clear portalSnapshot fields */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L54" title="utils/mmgr/portalmem.c:54">PortalHashTable</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((hentry = (<a href="#L52" title="utils/mmgr/portalmem.c:52">PortalHashEnt</a> *) <a href="../hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal = hentry-&gt;portal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;portalSnapshot != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;portalSnapshot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numPortalSnaps++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* portal-&gt;holdSnapshot will be cleaned up in <a href="#L677" title="utils/mmgr/portalmem.c:677">PreCommit_Portals</a> */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now, pop all the active snapshots, which should be just those that were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * portal snapshots.&nbsp; Ideally we'd drive this directly off the portal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan, but there's no good way to visit the portals in the correct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * order.&nbsp; So just cross-check after the fact.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="../time/snapmgr.c.html#L782" title="utils/time/snapmgr.c:782">ActiveSnapshotSet</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numActiveSnaps++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numPortalSnaps != numActiveSnaps)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;portal snapshots (</span><span class="Special">%d</span><span class="Constant">) did not account for all active snapshots (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numPortalSnaps, numActiveSnaps);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
