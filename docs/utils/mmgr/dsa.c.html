<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/mmgr/dsa.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/mmgr/dsa.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L248">dsa_size_class_map</a></li>
<li><a href="#L225">dsa_size_classes</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L347">dsa_area</a></li>
<li><a href="#L319">dsa_area_control</a></li>
<li><a href="#L281">dsa_area_pool</a></li>
<li><a href="#L196">dsa_area_span</a></li>
<li><a href="#L168">dsa_segment_header</a></li>
<li><a href="#L102">dsa_segment_index</a></li>
<li><a href="#L339">dsa_segment_map</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1929">add_span_to_fullness_class</a></li>
<li><a href="#L1472">alloc_object</a></li>
<li><a href="#L1326">attach_internal</a></li>
<li><a href="#L2252">check_for_freed_segments</a></li>
<li><a href="#L2288">check_for_freed_segments_locked</a></li>
<li><a href="#L119">contiguous_pages_to_segment_bin</a></li>
<li><a href="#L1218">create_internal</a></li>
<li><a href="#L1837">destroy_superblock</a></li>
<li><a href="#L671">dsa_allocate_extended</a></li>
<li><a href="#L510">dsa_attach</a></li>
<li><a href="#L545">dsa_attach_in_place</a></li>
<li><a href="#L421">dsa_create_ext</a></li>
<li><a href="#L471">dsa_create_in_place_ext</a></li>
<li><a href="#L1952">dsa_detach</a></li>
<li><a href="#L1088">dsa_dump</a></li>
<li><a href="#L826">dsa_free</a></li>
<li><a href="#L942">dsa_get_address</a></li>
<li><a href="#L498">dsa_get_handle</a></li>
<li><a href="#L1027">dsa_get_total_size</a></li>
<li><a href="#L1196">dsa_minimum_size</a></li>
<li><a href="#L576">dsa_on_dsm_detach_release_in_place</a></li>
<li><a href="#L590">dsa_on_shmem_exit_release_in_place</a></li>
<li><a href="#L975">dsa_pin</a></li>
<li><a href="#L635">dsa_pin_mapping</a></li>
<li><a href="#L605">dsa_release_in_place</a></li>
<li><a href="#L1018">dsa_set_size_limit</a></li>
<li><a href="#L1043">dsa_trim</a></li>
<li><a href="#L994">dsa_unpin</a></li>
<li><a href="#L1560">ensure_active_superblock</a></li>
<li><a href="#L2010">get_best_segment</a></li>
<li><a href="#L1757">get_segment_by_index</a></li>
<li><a href="#L1377">init_span</a></li>
<li><a href="#L2081">make_new_segment</a></li>
<li><a href="#L2316">rebin_segment</a></li>
<li><a href="#L1432">transfer_first_span</a></li>
<li><a href="#L1978">unlink_segment</a></li>
<li><a href="#L1906">unlink_span</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L132">DSA_AREA_LOCK</a></li>
<li><a href="#L99">DSA_EXTRACT_OFFSET</a></li>
<li><a href="#L96">DSA_EXTRACT_SEGMENT_NUMBER</a></li>
<li><a href="#L266">DSA_FULLNESS_CLASSES</a></li>
<li><a href="#L92">DSA_MAKE_POINTER</a></li>
<li><a href="#L75">DSA_MAX_SEGMENTS</a></li>
<li><a href="#L69">DSA_NUM_SEGMENTS_AT_EACH_SIZE</a></li>
<li><a href="#L111">DSA_NUM_SEGMENT_BINS</a></li>
<li><a href="#L236">DSA_NUM_SIZE_CLASSES</a></li>
<li><a href="#L79">DSA_OFFSET_BITMASK</a></li>
<li><a href="#L82">DSA_PAGES_PER_SUPERBLOCK</a></li>
<li><a href="#L239">DSA_SCLASS_BLOCK_OF_SPANS</a></li>
<li><a href="#L133">DSA_SCLASS_LOCK</a></li>
<li><a href="#L240">DSA_SCLASS_SPAN_LARGE</a></li>
<li><a href="#L89">DSA_SEGMENT_HEADER_MAGIC</a></li>
<li><a href="#L105">DSA_SEGMENT_INDEX_NONE</a></li>
<li><a href="#L258">DSA_SIZE_CLASS_MAP_QUANTUM</a></li>
<li><a href="#L375">DSA_SPAN_NOTHING_FREE</a></li>
<li><a href="#L376">DSA_SUPERBLOCK_SIZE</a></li>
<li><a href="#L322">DsaAreaPoolToDsaPointer</a></li>
<li><a href="#L202">NextFreeObjectIndex</a></li>
<li><a href="#L379">get_segment_index</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * dsa.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Dynamic shared memory areas.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This module provides dynamic shared memory areas which are built on top of<br/></li>
<li></span><span class="Comment"> * DSM segments.&nbsp; While dsm.c allows segments of memory of shared memory to be<br/></li>
<li></span><span class="Comment"> * created and shared between backends, it isn't designed to deal with small<br/></li>
<li></span><span class="Comment"> * objects.&nbsp; A DSA area is a shared memory heap usually backed by one or more<br/></li>
<li></span><span class="Comment"> * DSM segments which can allocate memory using dsa_allocate() and <a href="#L826" title="utils/mmgr/dsa.c:826">dsa_free</a>().<br/></li>
<li></span><span class="Comment"> * Alternatively, it can be created in pre-existing shared memory, including a<br/></li>
<li></span><span class="Comment"> * DSM segment, and then create extra DSM segments as required.&nbsp; Unlike the<br/></li>
<li></span><span class="Comment"> * regular system heap, it deals in pseudo-pointers which must be converted to<br/></li>
<li></span><span class="Comment"> * backend-local pointers <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> they are dereferenced.&nbsp; These pseudo-pointers<br/></li>
<li></span><span class="Comment"> * can however be shared with other backends, and can be used to construct<br/></li>
<li></span><span class="Comment"> * shared data structures.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Each DSA area manages a set of DSM segments, adding new segments as<br/></li>
<li></span><span class="Comment"> * required and detaching them when they are no longer needed.&nbsp; Each segment<br/></li>
<li></span><span class="Comment"> * contains a number of 4KB pages, a free page manager for tracking<br/></li>
<li></span><span class="Comment"> * consecutive runs of free pages, and a page map for tracking the source of<br/></li>
<li></span><span class="Comment"> * objects allocated on each page.&nbsp; Allocation requests above 8KB are handled<br/></li>
<li></span><span class="Comment"> * by choosing a segment and finding consecutive free pages in its free page<br/></li>
<li></span><span class="Comment"> * manager.&nbsp; Allocation requests for smaller sizes are handled using pools of<br/></li>
<li></span><span class="Comment"> * objects of a selection of sizes.&nbsp; Each pool consists of a number of 16 page<br/></li>
<li></span><span class="Comment"> * (64KB) superblocks allocated in the same way as large objects.&nbsp; Allocation<br/></li>
<li></span><span class="Comment"> * of large objects and new superblocks is serialized by a single LWLock, but<br/></li>
<li></span><span class="Comment"> * allocation of small objects from pre-existing superblocks uses one LWLock<br/></li>
<li></span><span class="Comment"> * per pool.&nbsp; Currently there is one pool, and therefore one lock, per size<br/></li>
<li></span><span class="Comment"> * class.&nbsp; Per-core pools to increase concurrency and strategies for reducing<br/></li>
<li></span><span class="Comment"> * the resulting fragmentation are areas for future research.&nbsp; Each superblock<br/></li>
<li></span><span class="Comment"> * is managed with a 'span', which tracks the superblock's freelist.&nbsp; Free<br/></li>
<li></span><span class="Comment"> * requests are handled by looking in the page map to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> which span an<br/></li>
<li></span><span class="Comment"> * address was allocated from, so that small objects can be returned to the<br/></li>
<li></span><span class="Comment"> * appropriate free list, and large object pages can be returned directly to<br/></li>
<li></span><span class="Comment"> * the free page map.&nbsp; When allocating, simple heuristics for selecting<br/></li>
<li></span><span class="Comment"> * segments and superblocks try to encourage occupied memory to be<br/></li>
<li></span><span class="Comment"> * concentrated, increasing the likelihood that whole superblocks can become<br/></li>
<li></span><span class="Comment"> * empty and be returned to the free page manager, and whole segments can<br/></li>
<li></span><span class="Comment"> * become empty and be returned to the operating system.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/mmgr/dsa.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;port/atomics.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/dsm.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lwlock.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/dsa.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/freepage.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/resowner.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * How many segments to create <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we double the segment size.&nbsp; If this is<br/></li>
<li></span><span class="Comment"> * low, then there is likely to be a lot of wasted space in the largest<br/></li>
<li></span><span class="Comment"> * segment.&nbsp; If it is high, then we risk running out of segment slots (see<br/></li>
<li></span><span class="Comment"> * dsm.c's limits on total number of segments), or limiting the total size<br/></li>
<li></span><span class="Comment"> * an area can manage when using small pointers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L69">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DSA_NUM_SEGMENTS_AT_EACH_SIZE</span> </span><span class="Constant">2<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The maximum number of DSM segments that an area can own, determined by<br/></li>
<li></span><span class="Comment"> * the number of bits remaining (but capped at 1024).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L75">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DSA_MAX_SEGMENTS</span> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(</span><span class="Constant">1024</span><span class="PreProc">, (</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; ((SIZEOF_DSA_POINTER * </span><span class="Constant">8</span><span class="PreProc">) - DSA_OFFSET_WIDTH)))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* The bitmask for extracting the offset from a dsa_pointer. */<br/></li>
<li><a id="L79">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DSA_OFFSET_BITMASK</span> (((dsa_pointer) </span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; DSA_OFFSET_WIDTH) - </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Number of pages (see FPM_PAGE_SIZE) per regular superblock. */<br/></li>
<li><a id="L82">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DSA_PAGES_PER_SUPERBLOCK</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">16<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A magic number used as a sanity check for following DSM segments belonging<br/></li>
<li></span><span class="Comment"> * to a DSA area (this number will be XORed with the area handle and<br/></li>
<li></span><span class="Comment"> * the segment index).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L89">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DSA_SEGMENT_HEADER_MAGIC</span> </span><span class="Constant">0x0ce26608<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Build a dsa_pointer given a segment number and offset. */<br/></li>
<li><a id="L92">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DSA_MAKE_POINTER</span>(segment_number, offset) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (((dsa_pointer) (segment_number) &lt;&lt; DSA_OFFSET_WIDTH) | (offset))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Extract the segment number from a dsa_pointer. */<br/></li>
<li><a id="L96">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DSA_EXTRACT_SEGMENT_NUMBER</span>(dp) ((dp) &gt;&gt; DSA_OFFSET_WIDTH)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Extract the offset from a dsa_pointer. */<br/></li>
<li><a id="L99">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DSA_EXTRACT_OFFSET</span>(dp) ((dp) &amp; <a href="#L79" title="utils/mmgr/dsa.c:79">DSA_OFFSET_BITMASK</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* The type used for index segment indexes (zero based). */<br/></li>
<li><a id="L102">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">size_t</span> <span class="linkable">dsa_segment_index</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Sentinel value for <a href="#L102" title="utils/mmgr/dsa.c:102">dsa_segment_index</a> indicating '<a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>' or 'end'. */<br/></li>
<li><a id="L105">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DSA_SEGMENT_INDEX_NONE</span> (~(<a href="#L102" title="utils/mmgr/dsa.c:102">dsa_segment_index</a>)</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * How many bins of segments do we have?&nbsp; The bins are used to categorize<br/></li>
<li></span><span class="Comment"> * segments by their largest contiguous run of free pages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L111">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DSA_NUM_SEGMENT_BINS</span> </span><span class="Constant">16<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * What is the lowest bin that holds segments that *might* have n contiguous<br/></li>
<li></span><span class="Comment"> * free pages?&nbsp; &nbsp; There is no point in looking in segments in <a href="../adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bins; they<br/></li>
<li></span><span class="Comment"> * definitely can't service a request for n free pages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">size_t<br/></li>
<li><a id="L119">&#x200c;</a></span><span class="linkable">contiguous_pages_to_segment_bin</span>(<span class="Type">size_t</span> n)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; bin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bin = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; bin = pg_leftmost_one_pos_size_t(n) + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(bin, <a href="#L111" title="utils/mmgr/dsa.c:111">DSA_NUM_SEGMENT_BINS</a> - <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Macros for access to locks. */<br/></li>
<li><a id="L132">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DSA_AREA_LOCK</span>(area) (&amp;area-&gt;control-&gt;lock)<br/></li>
<li><a id="L133">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DSA_SCLASS_LOCK</span>(area, sclass) (&amp;area-&gt;control-&gt;pools[sclass].lock)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The header for an individual segment.&nbsp; This lives at the start of each DSM<br/></li>
<li></span><span class="Comment"> * segment owned by a DSA area including the first segment (where it appears<br/></li>
<li></span><span class="Comment"> * as part of the <a href="#L319" title="utils/mmgr/dsa.c:319">dsa_area_control</a> struct).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sanity check magic value. */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; magic;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Total number of pages in this segment (excluding metadata area). */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; usable_pages;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Total size of this segment in bytes. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Index of the segment that precedes this one in the same segment bin, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L105" title="utils/mmgr/dsa.c:105">DSA_SEGMENT_INDEX_NONE</a> if this is the first one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L102" title="utils/mmgr/dsa.c:102">dsa_segment_index</a> prev;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Index of the segment that follows this one in the same segment bin, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L105" title="utils/mmgr/dsa.c:105">DSA_SEGMENT_INDEX_NONE</a> if this is the last one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L102" title="utils/mmgr/dsa.c:102">dsa_segment_index</a> <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The index of the bin that contains this segment. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; bin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A flag raised to indicate that this segment is being returned to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operating system and has been unpinned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; freed;<br/></li>
<li><a id="L168">&#x200c;</a>} <span class="linkable">dsa_segment_header</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Metadata for one superblock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For most blocks, span objects are stored out-of-line; that is, the span<br/></li>
<li></span><span class="Comment"> * object is not stored within the block itself.&nbsp; But, as an exception, for a<br/></li>
<li></span><span class="Comment"> * &quot;span of spans&quot;, the span object is stored &quot;inline&quot;.&nbsp; The allocation is<br/></li>
<li></span><span class="Comment"> * always exactly one page, and the <a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> object is located at<br/></li>
<li></span><span class="Comment"> * the beginning of that page.&nbsp; The size class is <a href="#L239" title="utils/mmgr/dsa.c:239">DSA_SCLASS_BLOCK_OF_SPANS</a>,<br/></li>
<li></span><span class="Comment"> * and the remaining fields are used just as they would be in an ordinary<br/></li>
<li></span><span class="Comment"> * block.&nbsp; We can't allocate spans out of ordinary superblocks because<br/></li>
<li></span><span class="Comment"> * creating an ordinary superblock requires us to be able to allocate a span<br/></li>
<li></span><span class="Comment"> * *first*.&nbsp; Doing it this way avoids that circularity.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; dsa_pointer pool;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Containing pool. */<br/></li>
<li></span>&nbsp; &nbsp; dsa_pointer prevspan;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Previous span. */<br/></li>
<li></span>&nbsp; &nbsp; dsa_pointer nextspan;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Next span. */<br/></li>
<li></span>&nbsp; &nbsp; dsa_pointer start;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Starting address. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; npages;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Length of span in pages. */<br/></li>
<li></span>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; size_class;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Size class. */<br/></li>
<li></span>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; ninitialized;&nbsp; &nbsp; <span class="Comment">/* Maximum number of objects ever allocated. */<br/></li>
<li></span>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; nallocatable;&nbsp; &nbsp; <span class="Comment">/* Number of objects currently allocatable. */<br/></li>
<li></span>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; firstfree;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First object on free list. */<br/></li>
<li></span>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; nmax;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Maximum number of objects ever possible. */<br/></li>
<li></span>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; fclass;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Current fullness class. */<br/></li>
<li><a id="L196">&#x200c;</a></span>} <span class="linkable">dsa_area_span</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a pointer to an object in a span, access the index of the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> free<br/></li>
<li></span><span class="Comment"> * object in the same span (ie in the span's freelist) as an L-value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L202">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NextFreeObjectIndex</span>(object) (* (uint16 *) (object))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Small allocations are handled by dividing a single block of memory into<br/></li>
<li></span><span class="Comment"> * many small objects of <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> size.&nbsp; The possible allocation sizes are<br/></li>
<li></span><span class="Comment"> * defined by the following array.&nbsp; Larger size classes are spaced more widely<br/></li>
<li></span><span class="Comment"> * than smaller size classes.&nbsp; We fudge the spacing for size classes &gt;1kB to<br/></li>
<li></span><span class="Comment"> * avoid space wastage: based on the knowledge that we plan to allocate 64kB<br/></li>
<li></span><span class="Comment"> * blocks, we bump the maximum object size up to the largest multiple of<br/></li>
<li></span><span class="Comment"> * 8 bytes that still lets us fit the same number of objects into one block.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: Because of this fudging, if we were ever to use differently-sized blocks<br/></li>
<li></span><span class="Comment"> * for small allocations, these size classes would need to be reworked to be<br/></li>
<li></span><span class="Comment"> * optimal for the new size.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: The optimal spacing for size classes, as well as the size of the blocks<br/></li>
<li></span><span class="Comment"> * out of which small objects are allocated, is not a question that has one<br/></li>
<li></span><span class="Comment"> * right answer.&nbsp; Some allocators (such as tcmalloc) use more closely-spaced<br/></li>
<li></span><span class="Comment"> * size classes than we do here, while others (like aset.c) use more<br/></li>
<li></span><span class="Comment"> * widely-spaced classes.&nbsp; Spacing the classes more closely avoids wasting<br/></li>
<li></span><span class="Comment"> * memory within individual chunks, but also means a larger number of<br/></li>
<li></span><span class="Comment"> * potentially-unfilled blocks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L225">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> uint16 <span class="linkable">dsa_size_classes</span>[] = {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a>), <span class="Constant">0</span>,&nbsp; &nbsp; <span class="Comment">/* special size classes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Constant">8</span>, <span class="Constant">16</span>, <span class="Constant">24</span>, <span class="Constant">32</span>, <span class="Constant">40</span>, <span class="Constant">48</span>, <span class="Constant">56</span>, <span class="Constant">64</span>,&nbsp; &nbsp; <span class="Comment">/* 8 classes separated by 8 bytes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Constant">80</span>, <span class="Constant">96</span>, <span class="Constant">112</span>, <span class="Constant">128</span>,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* 4 classes separated by 16 bytes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Constant">160</span>, <span class="Constant">192</span>, <span class="Constant">224</span>, <span class="Constant">256</span>,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* 4 classes separated by 32 bytes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Constant">320</span>, <span class="Constant">384</span>, <span class="Constant">448</span>, <span class="Constant">512</span>,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* 4 classes separated by 64 bytes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Constant">640</span>, <span class="Constant">768</span>, <span class="Constant">896</span>, <span class="Constant">1024</span>,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* 4 classes separated by 128 bytes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Constant">1280</span>, <span class="Constant">1560</span>, <span class="Constant">1816</span>, <span class="Constant">2048</span>,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* 4 classes separated by ~256 bytes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Constant">2616</span>, <span class="Constant">3120</span>, <span class="Constant">3640</span>, <span class="Constant">4096</span>,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* 4 classes separated by ~512 bytes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Constant">5456</span>, <span class="Constant">6552</span>, <span class="Constant">7280</span>, <span class="Constant">8192</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* 4 classes separated by ~1024 bytes */<br/></li>
<li></span>};<br/></li>
<li><a id="L236">&#x200c;</a><span class="PreProc">#define <span class="linkable">DSA_NUM_SIZE_CLASSES</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lengthof(<a href="#L225" title="utils/mmgr/dsa.c:225">dsa_size_classes</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Special size classes. */<br/></li>
<li><a id="L239">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DSA_SCLASS_BLOCK_OF_SPANS</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0<br/></li>
<li><a id="L240">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DSA_SCLASS_SPAN_LARGE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">1<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The following lookup table is used to map the size of small objects<br/></li>
<li></span><span class="Comment"> * (less than 1kB) onto the corresponding size class.&nbsp; To use this table,<br/></li>
<li></span><span class="Comment"> * round the size of the object up to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> multiple of 8 bytes, and then<br/></li>
<li></span><span class="Comment"> * index into this array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L248">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> uint8 <span class="linkable">dsa_size_class_map</span>[] = {<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">2</span>, <span class="Constant">3</span>, <span class="Constant">4</span>, <span class="Constant">5</span>, <span class="Constant">6</span>, <span class="Constant">7</span>, <span class="Constant">8</span>, <span class="Constant">9</span>, <span class="Constant">10</span>, <span class="Constant">10</span>, <span class="Constant">11</span>, <span class="Constant">11</span>, <span class="Constant">12</span>, <span class="Constant">12</span>, <span class="Constant">13</span>, <span class="Constant">13</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">14</span>, <span class="Constant">14</span>, <span class="Constant">14</span>, <span class="Constant">14</span>, <span class="Constant">15</span>, <span class="Constant">15</span>, <span class="Constant">15</span>, <span class="Constant">15</span>, <span class="Constant">16</span>, <span class="Constant">16</span>, <span class="Constant">16</span>, <span class="Constant">16</span>, <span class="Constant">17</span>, <span class="Constant">17</span>, <span class="Constant">17</span>, <span class="Constant">17</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">18</span>, <span class="Constant">18</span>, <span class="Constant">18</span>, <span class="Constant">18</span>, <span class="Constant">18</span>, <span class="Constant">18</span>, <span class="Constant">18</span>, <span class="Constant">18</span>, <span class="Constant">19</span>, <span class="Constant">19</span>, <span class="Constant">19</span>, <span class="Constant">19</span>, <span class="Constant">19</span>, <span class="Constant">19</span>, <span class="Constant">19</span>, <span class="Constant">19</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">20</span>, <span class="Constant">20</span>, <span class="Constant">20</span>, <span class="Constant">20</span>, <span class="Constant">20</span>, <span class="Constant">20</span>, <span class="Constant">20</span>, <span class="Constant">20</span>, <span class="Constant">21</span>, <span class="Constant">21</span>, <span class="Constant">21</span>, <span class="Constant">21</span>, <span class="Constant">21</span>, <span class="Constant">21</span>, <span class="Constant">21</span>, <span class="Constant">21</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">22</span>, <span class="Constant">22</span>, <span class="Constant">22</span>, <span class="Constant">22</span>, <span class="Constant">22</span>, <span class="Constant">22</span>, <span class="Constant">22</span>, <span class="Constant">22</span>, <span class="Constant">22</span>, <span class="Constant">22</span>, <span class="Constant">22</span>, <span class="Constant">22</span>, <span class="Constant">22</span>, <span class="Constant">22</span>, <span class="Constant">22</span>, <span class="Constant">22</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">23</span>, <span class="Constant">23</span>, <span class="Constant">23</span>, <span class="Constant">23</span>, <span class="Constant">23</span>, <span class="Constant">23</span>, <span class="Constant">23</span>, <span class="Constant">23</span>, <span class="Constant">23</span>, <span class="Constant">23</span>, <span class="Constant">23</span>, <span class="Constant">23</span>, <span class="Constant">23</span>, <span class="Constant">23</span>, <span class="Constant">23</span>, <span class="Constant">23</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">24</span>, <span class="Constant">24</span>, <span class="Constant">24</span>, <span class="Constant">24</span>, <span class="Constant">24</span>, <span class="Constant">24</span>, <span class="Constant">24</span>, <span class="Constant">24</span>, <span class="Constant">24</span>, <span class="Constant">24</span>, <span class="Constant">24</span>, <span class="Constant">24</span>, <span class="Constant">24</span>, <span class="Constant">24</span>, <span class="Constant">24</span>, <span class="Constant">24</span>,<br/></li>
<li>&nbsp; &nbsp; <span class="Constant">25</span>, <span class="Constant">25</span>, <span class="Constant">25</span>, <span class="Constant">25</span>, <span class="Constant">25</span>, <span class="Constant">25</span>, <span class="Constant">25</span>, <span class="Constant">25</span>, <span class="Constant">25</span>, <span class="Constant">25</span>, <span class="Constant">25</span>, <span class="Constant">25</span>, <span class="Constant">25</span>, <span class="Constant">25</span>, <span class="Constant">25</span>, <span class="Constant">25<br/></li>
<li></span>};<br/></li>
<li><a id="L258">&#x200c;</a><span class="PreProc">#define <span class="linkable">DSA_SIZE_CLASS_MAP_QUANTUM</span>&nbsp; &nbsp; </span><span class="Constant">8<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Superblocks are binned by how full they are.&nbsp; Generally, each fullness<br/></li>
<li></span><span class="Comment"> * class corresponds to one quartile, but the block being used for<br/></li>
<li></span><span class="Comment"> * allocations is always at the head of the list for fullness class 1,<br/></li>
<li></span><span class="Comment"> * regardless of how full it really is.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L266">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DSA_FULLNESS_CLASSES</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">4<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A <a href="#L281" title="utils/mmgr/dsa.c:281">dsa_area_pool</a> represents a set of objects of a given size class.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Perhaps there should be multiple pools for the same size class for<br/></li>
<li></span><span class="Comment"> * contention avoidance, but for <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> there is just one!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* A lock protecting access to this pool. */<br/></li>
<li></span>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp; &nbsp; lock;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* A set of linked lists of spans, arranged by fullness. */<br/></li>
<li></span>&nbsp; &nbsp; dsa_pointer spans[<a href="#L266" title="utils/mmgr/dsa.c:266">DSA_FULLNESS_CLASSES</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should we pad this out to a cacheline boundary? */<br/></li>
<li><a id="L281">&#x200c;</a></span>} <span class="linkable">dsa_area_pool</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The control block for an area.&nbsp; This lives in shared memory, at the start of<br/></li>
<li></span><span class="Comment"> * the first DSM segment controlled by this area.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The segment header for the first segment. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L168" title="utils/mmgr/dsa.c:168">dsa_segment_header</a> segment_header;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The handle for this area. */<br/></li>
<li></span>&nbsp; &nbsp; dsa_handle&nbsp; &nbsp; handle;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The handles of the segments owned by this area. */<br/></li>
<li></span>&nbsp; &nbsp; dsm_handle&nbsp; &nbsp; segment_handles[<a href="#L75" title="utils/mmgr/dsa.c:75">DSA_MAX_SEGMENTS</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Lists of segments, binned by maximum contiguous run of free pages. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L102" title="utils/mmgr/dsa.c:102">dsa_segment_index</a> segment_bins[<a href="#L111" title="utils/mmgr/dsa.c:111">DSA_NUM_SEGMENT_BINS</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The object pools for each size class. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L281" title="utils/mmgr/dsa.c:281">dsa_area_pool</a> pools[<a href="#L236" title="utils/mmgr/dsa.c:236">DSA_NUM_SIZE_CLASSES</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* initial allocation segment size */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; init_segment_size;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* maximum allocation segment size */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; max_segment_size;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The total size of all active segments. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; total_segment_size;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The maximum total size of backing storage we are allowed. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; max_total_segment_size;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Highest used segment index in the history of this area. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L102" title="utils/mmgr/dsa.c:102">dsa_segment_index</a> high_segment_index;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The reference count for this area. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; refcnt;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* A flag indicating that this area has been pinned. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; pinned;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The number of times that segments have been freed. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; freed_segment_counter;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The LWLock tranche ID. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lwlock_tranche_id;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The general lock (protects everything except object pools). */<br/></li>
<li></span>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp; &nbsp; lock;<br/></li>
<li><a id="L319">&#x200c;</a>} <span class="linkable">dsa_area_control</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Given a pointer to a pool, <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a dsa_pointer. */<br/></li>
<li><a id="L322">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DsaAreaPoolToDsaPointer</span>(area, p)&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="#L92" title="utils/mmgr/dsa.c:92">DSA_MAKE_POINTER</a>(</span><span class="Constant">0</span><span class="PreProc">, (</span><span class="Type">char</span><span class="PreProc"> *) p - (</span><span class="Type">char</span><span class="PreProc"> *) area-&gt;control)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> is stored within the backend-private memory of each<br/></li>
<li></span><span class="Comment"> * individual backend.&nbsp; It holds the base address of the segment within that<br/></li>
<li></span><span class="Comment"> * backend, plus the addresses of key objects within the segment.&nbsp; Those<br/></li>
<li></span><span class="Comment"> * could instead be derived from the base address but it's handy to have them<br/></li>
<li></span><span class="Comment"> * around.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *segment;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* DSM segment */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *mapped_address; <span class="Comment">/* Address at which segment is mapped */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L168" title="utils/mmgr/dsa.c:168">dsa_segment_header</a> *header; <span class="Comment">/* Header (same as mapped_address) */<br/></li>
<li></span>&nbsp; &nbsp; FreePageManager *fpm;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Free page manager within segment. */<br/></li>
<li></span>&nbsp; &nbsp; dsa_pointer *pagemap;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Page map within segment. */<br/></li>
<li><a id="L339">&#x200c;</a></span>} <span class="linkable">dsa_segment_map</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Per-backend state for a storage area.&nbsp; Backends obtain one of these by<br/></li>
<li></span><span class="Comment"> * creating an area or attaching to an existing one using a handle.&nbsp; Each<br/></li>
<li></span><span class="Comment"> * process that needs to use an area uses its own object to track where the<br/></li>
<li></span><span class="Comment"> * segments are mapped.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L347">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">dsa_area</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pointer to the control object in shared memory. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L319" title="utils/mmgr/dsa.c:319">dsa_area_control</a> *control;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All the mappings are owned by this.&nbsp; The <a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> itself is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * directly tracked by the ResourceOwner, but the effect is the same. NULL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the attachment has session lifespan, i.e if <a href="#L635" title="utils/mmgr/dsa.c:635">dsa_pin_mapping</a>() has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * been called.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ResourceOwner resowner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This backend's array of segment <a href="../mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a>, ordered by segment index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corresponding to control-&gt;segment_handles.&nbsp; Some of the area's segments<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * may not be mapped in this backend yet, and some slots may have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * freed and need to be detached; these operations happen on demand.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> segment_maps[<a href="#L75" title="utils/mmgr/dsa.c:75">DSA_MAX_SEGMENTS</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The highest segment index this backend has ever mapped. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L102" title="utils/mmgr/dsa.c:102">dsa_segment_index</a> high_segment_index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The last observed freed_segment_counter. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; freed_segment_counter;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L375">&#x200c;</a><span class="PreProc">#define <span class="linkable">DSA_SPAN_NOTHING_FREE</span>&nbsp; &nbsp; ((uint16) -</span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li><a id="L376">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DSA_SUPERBLOCK_SIZE</span> (<a href="#L82" title="utils/mmgr/dsa.c:82">DSA_PAGES_PER_SUPERBLOCK</a> * FPM_PAGE_SIZE)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Given a pointer to a segment_map, obtain a segment index number. */<br/></li>
<li><a id="L379">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">get_segment_index</span>(area, segment_map_ptr) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (segment_map_ptr - &amp;area-&gt;segment_maps[</span><span class="Constant">0</span><span class="PreProc">])<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1377" title="utils/mmgr/dsa.c:1377">init_span</a>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, dsa_pointer span_pointer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L281" title="utils/mmgr/dsa.c:281">dsa_area_pool</a> *pool, dsa_pointer start, <span class="Type">size_t</span> npages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16 size_class);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1432" title="utils/mmgr/dsa.c:1432">transfer_first_span</a>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, <a href="#L281" title="utils/mmgr/dsa.c:281">dsa_area_pool</a> *pool,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> fromclass, <span class="Type">int</span> toclass);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> dsa_pointer <a href="#L1472" title="utils/mmgr/dsa.c:1472">alloc_object</a>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, <span class="Type">int</span> size_class);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1560" title="utils/mmgr/dsa.c:1560">ensure_active_superblock</a>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, <a href="#L281" title="utils/mmgr/dsa.c:281">dsa_area_pool</a> *pool,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> size_class);<br/></li>
<li><span class="Type">static</span> <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> *<a href="#L1757" title="utils/mmgr/dsa.c:1757">get_segment_by_index</a>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L102" title="utils/mmgr/dsa.c:102">dsa_segment_index</a> index);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1837" title="utils/mmgr/dsa.c:1837">destroy_superblock</a>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, dsa_pointer span_pointer);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1906" title="utils/mmgr/dsa.c:1906">unlink_span</a>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, <a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *span);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1929" title="utils/mmgr/dsa.c:1929">add_span_to_fullness_class</a>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, <a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *span,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dsa_pointer span_pointer, <span class="Type">int</span> fclass);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1978" title="utils/mmgr/dsa.c:1978">unlink_segment</a>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> *segment_map);<br/></li>
<li><span class="Type">static</span> <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> *<a href="#L2010" title="utils/mmgr/dsa.c:2010">get_best_segment</a>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, <span class="Type">size_t</span> npages);<br/></li>
<li><span class="Type">static</span> <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> *<a href="#L2081" title="utils/mmgr/dsa.c:2081">make_new_segment</a>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, <span class="Type">size_t</span> requested_pages);<br/></li>
<li><span class="Type">static</span> <a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *<a href="#L1218" title="utils/mmgr/dsa.c:1218">create_internal</a>(<span class="Type">void</span> *place, <span class="Type">size_t</span> size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> tranche_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dsm_handle control_handle,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *control_segment,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">size_t</span> init_segment_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">size_t</span> max_segment_size);<br/></li>
<li><span class="Type">static</span> <a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *<a href="#L1326" title="utils/mmgr/dsa.c:1326">attach_internal</a>(<span class="Type">void</span> *place, <a href="../../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *segment,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dsa_handle handle);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2252" title="utils/mmgr/dsa.c:2252">check_for_freed_segments</a>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2288" title="utils/mmgr/dsa.c:2288">check_for_freed_segments_locked</a>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2316" title="utils/mmgr/dsa.c:2316">rebin_segment</a>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> *segment_map);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a new shared area in a new DSM segment.&nbsp; Further DSM segments will<br/></li>
<li></span><span class="Comment"> * be allocated as required to extend the available space.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We can't allocate a LWLock tranche_id within this function, because tranche<br/></li>
<li></span><span class="Comment"> * IDs are a scarce resource; there are only 64k available, using low numbers<br/></li>
<li></span><span class="Comment"> * when possible matters, and we have no provision for recycling them.&nbsp; So,<br/></li>
<li></span><span class="Comment"> * we require the caller to provide one.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *<br/></li>
<li><a id="L421">&#x200c;</a><span class="linkable">dsa_create_ext</span>(<span class="Type">int</span> tranche_id, <span class="Type">size_t</span> init_segment_size, <span class="Type">size_t</span> max_segment_size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *segment;<br/></li>
<li>&nbsp; &nbsp; <a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a>&nbsp;&nbsp; *area;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the DSM segment that will hold the shared control object and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first segment of usable space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; segment = <a href="../../storage/ipc/dsm.c.html#L516" title="storage/ipc/dsm.c:516">dsm_create</a>(init_segment_size, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All segments backing this area are pinned, so that DSA can explicitly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * control their lifetime (otherwise a newly created segment belonging to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this area might be freed when the only backend that happens to have it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mapped in ends, corrupting the area).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L955" title="storage/ipc/dsm.c:955">dsm_pin_segment</a>(segment);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create a new DSA area with the control object in this segment. */<br/></li>
<li></span>&nbsp; &nbsp; area = <a href="#L1218" title="utils/mmgr/dsa.c:1218">create_internal</a>(<a href="../../storage/ipc/dsm.c.html#L1095" title="storage/ipc/dsm.c:1095">dsm_segment_address</a>(segment),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; init_segment_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tranche_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/ipc/dsm.c.html#L1123" title="storage/ipc/dsm.c:1123">dsm_segment_handle</a>(segment), segment,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; init_segment_size, max_segment_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up when the control segment detaches. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L1132" title="storage/ipc/dsm.c:1132">on_dsm_detach</a>(segment, &amp;<a href="#L576" title="utils/mmgr/dsa.c:576">dsa_on_dsm_detach_release_in_place</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(<a href="../../storage/ipc/dsm.c.html#L1095" title="storage/ipc/dsm.c:1095">dsm_segment_address</a>(segment)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> area;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a new shared area in an existing shared memory space, which may be<br/></li>
<li></span><span class="Comment"> * either DSM or Postmaster-initialized memory.&nbsp; DSM segments will be<br/></li>
<li></span><span class="Comment"> * allocated as required to extend the available space, though that can be<br/></li>
<li></span><span class="Comment"> * prevented with <a href="#L1018" title="utils/mmgr/dsa.c:1018">dsa_set_size_limit</a>(area, size) using the same size provided<br/></li>
<li></span><span class="Comment"> * to dsa_create_in_place.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Areas created in-place must eventually be released by the backend that<br/></li>
<li></span><span class="Comment"> * created them and all backends that attach to them.&nbsp; This can be done<br/></li>
<li></span><span class="Comment"> * explicitly with <a href="#L605" title="utils/mmgr/dsa.c:605">dsa_release_in_place</a>, or, in the special case that 'place'<br/></li>
<li></span><span class="Comment"> * happens to be in a pre-existing DSM segment, by passing in a pointer to the<br/></li>
<li></span><span class="Comment"> * segment so that a detach hook can be registered with the containing DSM<br/></li>
<li></span><span class="Comment"> * segment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See dsa_create() for a note about the tranche arguments.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *<br/></li>
<li><a id="L471">&#x200c;</a><span class="linkable">dsa_create_in_place_ext</span>(<span class="Type">void</span> *place, <span class="Type">size_t</span> size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> tranche_id, <a href="../../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *segment,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span> init_segment_size, <span class="Type">size_t</span> max_segment_size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a>&nbsp;&nbsp; *area;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; area = <a href="#L1218" title="utils/mmgr/dsa.c:1218">create_internal</a>(place, size, tranche_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DSM_HANDLE_INVALID, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; init_segment_size, max_segment_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clean up when the control segment detaches, if a containing DSM segment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * was provided.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (segment != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L1132" title="storage/ipc/dsm.c:1132">on_dsm_detach</a>(segment, &amp;<a href="#L576" title="utils/mmgr/dsa.c:576">dsa_on_dsm_detach_release_in_place</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(place));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> area;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Obtain a handle that can be passed to other processes so that they can<br/></li>
<li></span><span class="Comment"> * attach to the given area.&nbsp; Cannot be called for areas created with<br/></li>
<li></span><span class="Comment"> * dsa_create_in_place.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>dsa_handle<br/></li>
<li><a id="L498">&#x200c;</a><span class="linkable">dsa_get_handle</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(area-&gt;control-&gt;handle != DSA_HANDLE_INVALID);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> area-&gt;control-&gt;handle;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attach to an area given a handle generated (possibly in another process) by<br/></li>
<li></span><span class="Comment"> * <a href="#L498" title="utils/mmgr/dsa.c:498">dsa_get_handle</a>.&nbsp; The area must have been created with dsa_create (not<br/></li>
<li></span><span class="Comment"> * dsa_create_in_place).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *<br/></li>
<li><a id="L510">&#x200c;</a><span class="linkable">dsa_attach</span>(dsa_handle handle)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *segment;<br/></li>
<li>&nbsp; &nbsp; <a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a>&nbsp;&nbsp; *area;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * An area handle is really a DSM segment handle for the first segment, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we go ahead and attach to that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; segment = <a href="../../storage/ipc/dsm.c.html#L665" title="storage/ipc/dsm.c:665">dsm_attach</a>(handle);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (segment == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not attach to dynamic shared area&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; area = <a href="#L1326" title="utils/mmgr/dsa.c:1326">attach_internal</a>(<a href="../../storage/ipc/dsm.c.html#L1095" title="storage/ipc/dsm.c:1095">dsm_segment_address</a>(segment), segment, handle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up when the control segment detaches. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L1132" title="storage/ipc/dsm.c:1132">on_dsm_detach</a>(segment, &amp;<a href="#L576" title="utils/mmgr/dsa.c:576">dsa_on_dsm_detach_release_in_place</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(<a href="../../storage/ipc/dsm.c.html#L1095" title="storage/ipc/dsm.c:1095">dsm_segment_address</a>(segment)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> area;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attach to an area that was created with dsa_create_in_place.&nbsp; The caller<br/></li>
<li></span><span class="Comment"> * must somehow know the location in memory that was used when the area was<br/></li>
<li></span><span class="Comment"> * created, though it may be mapped at a different virtual address in this<br/></li>
<li></span><span class="Comment"> * process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See dsa_create_in_place for note about releasing in-place areas, and the<br/></li>
<li></span><span class="Comment"> * optional 'segment' argument which can be provided to allow automatic<br/></li>
<li></span><span class="Comment"> * release if the containing memory happens to be a DSM segment.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *<br/></li>
<li><a id="L545">&#x200c;</a><span class="linkable">dsa_attach_in_place</span>(<span class="Type">void</span> *place, <a href="../../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *segment)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a>&nbsp;&nbsp; *area;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; area = <a href="#L1326" title="utils/mmgr/dsa.c:1326">attach_internal</a>(place, <span class="Constant">NULL</span>, DSA_HANDLE_INVALID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clean up when the control segment detaches, if a containing DSM segment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * was provided.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (segment != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L1132" title="storage/ipc/dsm.c:1132">on_dsm_detach</a>(segment, &amp;<a href="#L576" title="utils/mmgr/dsa.c:576">dsa_on_dsm_detach_release_in_place</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(place));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> area;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Release a DSA area that was produced by dsa_create_in_place or<br/></li>
<li></span><span class="Comment"> * <a href="#L545" title="utils/mmgr/dsa.c:545">dsa_attach_in_place</a>.&nbsp; The 'segment' argument is ignored but provides an<br/></li>
<li></span><span class="Comment"> * interface suitable for <a href="../../storage/ipc/dsm.c.html#L1132" title="storage/ipc/dsm.c:1132">on_dsm_detach</a>, for the convenience of users who want<br/></li>
<li></span><span class="Comment"> * to create a DSA segment inside an existing DSM segment and have it<br/></li>
<li></span><span class="Comment"> * automatically released when the containing DSM segment is detached.<br/></li>
<li></span><span class="Comment"> * 'place' should be the address of the place where the area was created.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This callback is automatically registered for the DSM segment containing<br/></li>
<li></span><span class="Comment"> * the control object of in-place areas when a segment is provided to<br/></li>
<li></span><span class="Comment"> * dsa_create_in_place or <a href="#L545" title="utils/mmgr/dsa.c:545">dsa_attach_in_place</a>, and also for all areas created<br/></li>
<li></span><span class="Comment"> * with dsa_create.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L576">&#x200c;</a></span><span class="linkable">dsa_on_dsm_detach_release_in_place</span>(<a href="../../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *segment, Datum place)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L605" title="utils/mmgr/dsa.c:605">dsa_release_in_place</a>(DatumGetPointer(place));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Release a DSA area that was produced by dsa_create_in_place or<br/></li>
<li></span><span class="Comment"> * <a href="#L545" title="utils/mmgr/dsa.c:545">dsa_attach_in_place</a>.&nbsp; The 'code' argument is ignored but provides an<br/></li>
<li></span><span class="Comment"> * interface suitable for <a href="../../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a> or <a href="../../storage/ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a>, for the<br/></li>
<li></span><span class="Comment"> * convenience of users who want to create a DSA segment inside shared memory<br/></li>
<li></span><span class="Comment"> * other than a DSM segment and have it automatically release at backend exit.<br/></li>
<li></span><span class="Comment"> * 'place' should be the address of the place where the area was created.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L590">&#x200c;</a></span><span class="linkable">dsa_on_shmem_exit_release_in_place</span>(<span class="Type">int</span> code, Datum place)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L605" title="utils/mmgr/dsa.c:605">dsa_release_in_place</a>(DatumGetPointer(place));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Release a DSA area that was produced by dsa_create_in_place or<br/></li>
<li></span><span class="Comment"> * <a href="#L545" title="utils/mmgr/dsa.c:545">dsa_attach_in_place</a>.&nbsp; It is preferable to use one of the 'dsa_on_XXX'<br/></li>
<li></span><span class="Comment"> * callbacks so that this is managed automatically, because failure to release<br/></li>
<li></span><span class="Comment"> * an area created in-place leaks its segments permanently.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is also called automatically for areas produced by dsa_create or<br/></li>
<li></span><span class="Comment"> * <a href="#L510" title="utils/mmgr/dsa.c:510">dsa_attach</a> as an implementation detail.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L605">&#x200c;</a></span><span class="linkable">dsa_release_in_place</span>(<span class="Type">void</span> *place)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L319" title="utils/mmgr/dsa.c:319">dsa_area_control</a> *control = (<a href="#L319" title="utils/mmgr/dsa.c:319">dsa_area_control</a> *) place;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;control-&gt;lock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; Assert(control-&gt;segment_header.magic ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="#L89" title="utils/mmgr/dsa.c:89">DSA_SEGMENT_HEADER_MAGIC</a> ^ control-&gt;handle ^ <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; Assert(control-&gt;refcnt &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (--control-&gt;refcnt == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt;= control-&gt;high_segment_index; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dsm_handle&nbsp; &nbsp; handle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; handle = control-&gt;segment_handles[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (handle != DSM_HANDLE_INVALID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L988" title="storage/ipc/dsm.c:988">dsm_unpin_segment</a>(handle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;control-&gt;lock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Keep a DSA area attached until end of session or explicit detach.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * By default, areas are owned by the current resource owner, which means they<br/></li>
<li></span><span class="Comment"> * are detached automatically when that scope ends.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L635">&#x200c;</a></span><span class="linkable">dsa_pin_mapping</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (area-&gt;resowner != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; area-&gt;resowner = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt;= area-&gt;high_segment_index; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (area-&gt;segment_maps[i].segment != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L915" title="storage/ipc/dsm.c:915">dsm_pin_mapping</a>(area-&gt;segment_maps[i].segment);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate memory in this storage area.&nbsp; The return value is a dsa_pointer<br/></li>
<li></span><span class="Comment"> * that can be passed to other processes, and converted to a local pointer<br/></li>
<li></span><span class="Comment"> * with <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>.&nbsp; 'flags' is a bitmap which should be constructed<br/></li>
<li></span><span class="Comment"> * from the following <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * DSA_ALLOC_HUGE allows allocations &gt;= 1GB.&nbsp; Otherwise, such allocations<br/></li>
<li></span><span class="Comment"> * will result in an ERROR.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * DSA_ALLOC_NO_OOM causes this function to return InvalidDsaPointer when<br/></li>
<li></span><span class="Comment"> * no memory is available or a size limit established by <a href="#L1018" title="utils/mmgr/dsa.c:1018">dsa_set_size_limit</a><br/></li>
<li></span><span class="Comment"> * would be exceeded.&nbsp; Otherwise, such allocations will result in an ERROR.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * DSA_ALLOC_ZERO causes the allocated memory to be zeroed.&nbsp; Otherwise, the<br/></li>
<li></span><span class="Comment"> * contents of newly-allocated memory are indeterminate.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These flags correspond to similarly named flags used by<br/></li>
<li></span><span class="Comment"> * <a href="mcxt.c.html#L1237" title="utils/mmgr/mcxt.c:1237">MemoryContextAllocExtended</a>().&nbsp; See also the macros dsa_allocate and<br/></li>
<li></span><span class="Comment"> * dsa_allocate0 which expand to a call to this function with commonly used<br/></li>
<li></span><span class="Comment"> * flags.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>dsa_pointer<br/></li>
<li><a id="L671">&#x200c;</a><span class="linkable">dsa_allocate_extended</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, <span class="Type">size_t</span> size, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; size_class;<br/></li>
<li>&nbsp; &nbsp; dsa_pointer start_pointer;<br/></li>
<li>&nbsp; &nbsp; <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> *segment_map;<br/></li>
<li>&nbsp; &nbsp; dsa_pointer result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(size &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sanity check on huge individual allocation size. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (((flags &amp; DSA_ALLOC_HUGE) != <span class="Constant">0</span> &amp;&amp; !AllocHugeSizeIsValid(size)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((flags &amp; DSA_ALLOC_HUGE) == <span class="Constant">0</span> &amp;&amp; !AllocSizeIsValid(size)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid DSA memory alloc request size </span><span class="Special">%zu</span><span class="Constant">&quot;</span>, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If bigger than the largest size class, just grab a run of pages from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the free page manager, instead of allocating an object from a pool.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There will still be a span, but it's a special class of span that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * manages this whole allocation and simply gives all pages back to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * free page manager when <a href="#L826" title="utils/mmgr/dsa.c:826">dsa_free</a> is called.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (size &gt; <a href="#L225" title="utils/mmgr/dsa.c:225">dsa_size_classes</a>[lengthof(<a href="#L225" title="utils/mmgr/dsa.c:225">dsa_size_classes</a>) - <span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; npages = fpm_size_to_pages(size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; first_page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dsa_pointer span_pointer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L281" title="utils/mmgr/dsa.c:281">dsa_area_pool</a> *pool = &amp;area-&gt;control-&gt;pools[<a href="#L240" title="utils/mmgr/dsa.c:240">DSA_SCLASS_SPAN_LARGE</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Obtain a span object. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; span_pointer = <a href="#L1472" title="utils/mmgr/dsa.c:1472">alloc_object</a>(area, <a href="#L239" title="utils/mmgr/dsa.c:239">DSA_SCLASS_BLOCK_OF_SPANS</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!DsaPointerIsValid(span_pointer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Raise error unless asked not to. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; DSA_ALLOC_NO_OOM) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failed on DSA request of size </span><span class="Special">%zu</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; size)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidDsaPointer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area), LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find a segment from which to allocate. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; segment_map = <a href="#L2010" title="utils/mmgr/dsa.c:2010">get_best_segment</a>(area, npages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (segment_map == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment_map = <a href="#L2081" title="utils/mmgr/dsa.c:2081">make_new_segment</a>(area, npages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (segment_map == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can't make <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more segments: game over. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L826" title="utils/mmgr/dsa.c:826">dsa_free</a>(area, span_pointer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Raise error unless asked not to. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; DSA_ALLOC_NO_OOM) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failed on DSA request of size </span><span class="Special">%zu</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; size)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidDsaPointer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ask the free page manager for a run of pages.&nbsp; This should always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * succeed, since both <a href="#L2010" title="utils/mmgr/dsa.c:2010">get_best_segment</a> and <a href="#L2081" title="utils/mmgr/dsa.c:2081">make_new_segment</a> should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only return a non-NULL pointer if it actually contains enough<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contiguous freespace.&nbsp; If it does fail, something in our backend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * private state is out of whack, so use FATAL to kill the process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="freepage.c.html#L210" title="utils/mmgr/freepage.c:210">FreePageManagerGet</a>(segment_map-&gt;fpm, npages, &amp;first_page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;dsa_allocate could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> </span><span class="Special">%zu</span><span class="Constant"> free pages&quot;</span>, npages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; start_pointer = <a href="#L92" title="utils/mmgr/dsa.c:92">DSA_MAKE_POINTER</a>(<a href="#L379" title="utils/mmgr/dsa.c:379">get_segment_index</a>(area, segment_map),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; first_page * FPM_PAGE_SIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize span and pagemap. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L133" title="utils/mmgr/dsa.c:133">DSA_SCLASS_LOCK</a>(area, <a href="#L240" title="utils/mmgr/dsa.c:240">DSA_SCLASS_SPAN_LARGE</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1377" title="utils/mmgr/dsa.c:1377">init_span</a>(area, span_pointer, pool, start_pointer, npages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L240" title="utils/mmgr/dsa.c:240">DSA_SCLASS_SPAN_LARGE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; segment_map-&gt;pagemap[first_page] = span_pointer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L133" title="utils/mmgr/dsa.c:133">DSA_SCLASS_LOCK</a>(area, <a href="#L240" title="utils/mmgr/dsa.c:240">DSA_SCLASS_SPAN_LARGE</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Zero-<a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the memory if requested. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; DSA_ALLOC_ZERO) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(<a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, start_pointer), <span class="Constant">0</span>, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> start_pointer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Map allocation to a size class. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (size &lt; lengthof(<a href="#L248" title="utils/mmgr/dsa.c:248">dsa_size_class_map</a>) * <a href="#L258" title="utils/mmgr/dsa.c:258">DSA_SIZE_CLASS_MAP_QUANTUM</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapidx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* For smaller sizes we have a lookup table... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mapidx = ((size + <a href="#L258" title="utils/mmgr/dsa.c:258">DSA_SIZE_CLASS_MAP_QUANTUM</a> - <span class="Constant">1</span>) /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L258" title="utils/mmgr/dsa.c:258">DSA_SIZE_CLASS_MAP_QUANTUM</a>) - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size_class = <a href="#L248" title="utils/mmgr/dsa.c:248">dsa_size_class_map</a>[mapidx];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; min;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; max;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and for the rest we search by binary chop. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; min = <a href="#L248" title="utils/mmgr/dsa.c:248">dsa_size_class_map</a>[lengthof(<a href="#L248" title="utils/mmgr/dsa.c:248">dsa_size_class_map</a>) - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; max = lengthof(<a href="#L225" title="utils/mmgr/dsa.c:225">dsa_size_classes</a>) - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (min &lt; max)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; mid = (min + max) / <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; class_size = <a href="#L225" title="utils/mmgr/dsa.c:225">dsa_size_classes</a>[mid];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (class_size &lt; size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min = mid + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max = mid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size_class = min;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(size &lt;= <a href="#L225" title="utils/mmgr/dsa.c:225">dsa_size_classes</a>[size_class]);<br/></li>
<li>&nbsp; &nbsp; Assert(size_class == <span class="Constant">0</span> || size &gt; <a href="#L225" title="utils/mmgr/dsa.c:225">dsa_size_classes</a>[size_class - <span class="Constant">1</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Attempt to allocate an object from the appropriate pool. */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="#L1472" title="utils/mmgr/dsa.c:1472">alloc_object</a>(area, size_class);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for failure to allocate. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!DsaPointerIsValid(result))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Raise error unless asked not to. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; DSA_ALLOC_NO_OOM) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failed on DSA request of size </span><span class="Special">%zu</span><span class="Constant">.&quot;</span>, size)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidDsaPointer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Zero-<a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the memory if requested. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; DSA_ALLOC_ZERO) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(<a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, result), <span class="Constant">0</span>, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free memory obtained with dsa_allocate.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L826">&#x200c;</a></span><span class="linkable">dsa_free</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, dsa_pointer dp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> *segment_map;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageno;<br/></li>
<li>&nbsp; &nbsp; dsa_pointer span_pointer;<br/></li>
<li>&nbsp; &nbsp; <a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *span;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *superblock;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *object;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size_class;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we don't have a stale segment in the slot 'dp' refers to. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2252" title="utils/mmgr/dsa.c:2252">check_for_freed_segments</a>(area);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Locate the object, span and pool. */<br/></li>
<li></span>&nbsp; &nbsp; segment_map = <a href="#L1757" title="utils/mmgr/dsa.c:1757">get_segment_by_index</a>(area, <a href="#L96" title="utils/mmgr/dsa.c:96">DSA_EXTRACT_SEGMENT_NUMBER</a>(dp));<br/></li>
<li>&nbsp; &nbsp; pageno = <a href="#L99" title="utils/mmgr/dsa.c:99">DSA_EXTRACT_OFFSET</a>(dp) / FPM_PAGE_SIZE;<br/></li>
<li>&nbsp; &nbsp; span_pointer = segment_map-&gt;pagemap[pageno];<br/></li>
<li>&nbsp; &nbsp; span = <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, span_pointer);<br/></li>
<li>&nbsp; &nbsp; superblock = <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, span-&gt;start);<br/></li>
<li>&nbsp; &nbsp; object = <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, dp);<br/></li>
<li>&nbsp; &nbsp; size_class = span-&gt;size_class;<br/></li>
<li>&nbsp; &nbsp; size = <a href="#L225" title="utils/mmgr/dsa.c:225">dsa_size_classes</a>[size_class];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Special case for large objects that live in a special span: we return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those pages directly to the free page manager and free the span.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (span-&gt;size_class == <a href="#L240" title="utils/mmgr/dsa.c:240">DSA_SCLASS_SPAN_LARGE</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef CLOBBER_FREED_MEMORY<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memset(object, <span class="Constant">0x7f</span>, span-&gt;npages * FPM_PAGE_SIZE);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Give pages back to free page manager. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area), LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="freepage.c.html#L379" title="utils/mmgr/freepage.c:379">FreePageManagerPut</a>(segment_map-&gt;fpm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L99" title="utils/mmgr/dsa.c:99">DSA_EXTRACT_OFFSET</a>(span-&gt;start) / FPM_PAGE_SIZE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; span-&gt;npages);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Move segment to appropriate bin if necessary. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2316" title="utils/mmgr/dsa.c:2316">rebin_segment</a>(area, segment_map);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unlink span. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L133" title="utils/mmgr/dsa.c:133">DSA_SCLASS_LOCK</a>(area, <a href="#L240" title="utils/mmgr/dsa.c:240">DSA_SCLASS_SPAN_LARGE</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1906" title="utils/mmgr/dsa.c:1906">unlink_span</a>(area, span);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L133" title="utils/mmgr/dsa.c:133">DSA_SCLASS_LOCK</a>(area, <a href="#L240" title="utils/mmgr/dsa.c:240">DSA_SCLASS_SPAN_LARGE</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Free the span object so it can be reused. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L826" title="utils/mmgr/dsa.c:826">dsa_free</a>(area, span_pointer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef CLOBBER_FREED_MEMORY<br/></li>
<li></span>&nbsp; &nbsp; memset(object, <span class="Constant">0x7f</span>, size);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L133" title="utils/mmgr/dsa.c:133">DSA_SCLASS_LOCK</a>(area, size_class), LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Put the object on the span's freelist. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(object &gt;= superblock);<br/></li>
<li>&nbsp; &nbsp; Assert(object &lt; superblock + <a href="#L376" title="utils/mmgr/dsa.c:376">DSA_SUPERBLOCK_SIZE</a>);<br/></li>
<li>&nbsp; &nbsp; Assert((object - superblock) % size == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L202" title="utils/mmgr/dsa.c:202">NextFreeObjectIndex</a>(object) = span-&gt;firstfree;<br/></li>
<li>&nbsp; &nbsp; span-&gt;firstfree = (object - superblock) / size;<br/></li>
<li>&nbsp; &nbsp; ++span-&gt;nallocatable;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See if the span needs to moved to a different fullness class, or be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * freed so its pages can be given back to the segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (span-&gt;nallocatable == <span class="Constant">1</span> &amp;&amp; span-&gt;fclass == <a href="#L266" title="utils/mmgr/dsa.c:266">DSA_FULLNESS_CLASSES</a> - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The block was completely full and is located in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * highest-numbered fullness class, which is never scanned for free<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * chunks.&nbsp; We must move it to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-<a href="../adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> fullness class.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1906" title="utils/mmgr/dsa.c:1906">unlink_span</a>(area, span);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1929" title="utils/mmgr/dsa.c:1929">add_span_to_fullness_class</a>(area, span, span_pointer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L266" title="utils/mmgr/dsa.c:266">DSA_FULLNESS_CLASSES</a> - <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is the only span, and there is no active span, then we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should probably move this span to fullness class 1.&nbsp; (Otherwise if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * you allocate exactly all the objects in the only span, it moves to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * class 3, then you free them all, it moves to 2, and then is given<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * back, leaving no active span).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (span-&gt;nallocatable == span-&gt;nmax &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (span-&gt;fclass != <span class="Constant">1</span> || span-&gt;prevspan != InvalidDsaPointer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This entire block is free, and it's not the active block for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * size class.&nbsp; Return the memory to the free page manager. We don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do this for the active block to prevent hysteresis: if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * repeatedly allocate and free the only chunk in the active block, it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will be very inefficient if we deallocate and reallocate the block<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * every time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1837" title="utils/mmgr/dsa.c:1837">destroy_superblock</a>(area, span_pointer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L133" title="utils/mmgr/dsa.c:133">DSA_SCLASS_LOCK</a>(area, size_class));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Obtain a backend-local address for a dsa_pointer.&nbsp; 'dp' must point to<br/></li>
<li></span><span class="Comment"> * memory allocated by the given area (possibly in another process) that<br/></li>
<li></span><span class="Comment"> * hasn't yet been freed.&nbsp; This may cause a segment to be mapped into the<br/></li>
<li></span><span class="Comment"> * current process if required, and may cause freed segments to be unmapped.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L942">&#x200c;</a><span class="linkable">dsa_get_address</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, dsa_pointer dp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L102" title="utils/mmgr/dsa.c:102">dsa_segment_index</a> index;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert InvalidDsaPointer to NULL. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!DsaPointerIsValid(dp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> requests to detach from freed segments. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2252" title="utils/mmgr/dsa.c:2252">check_for_freed_segments</a>(area);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Break the dsa_pointer into its components. */<br/></li>
<li></span>&nbsp; &nbsp; index = <a href="#L96" title="utils/mmgr/dsa.c:96">DSA_EXTRACT_SEGMENT_NUMBER</a>(dp);<br/></li>
<li>&nbsp; &nbsp; offset = <a href="#L99" title="utils/mmgr/dsa.c:99">DSA_EXTRACT_OFFSET</a>(dp);<br/></li>
<li>&nbsp; &nbsp; Assert(index &lt; <a href="#L75" title="utils/mmgr/dsa.c:75">DSA_MAX_SEGMENTS</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if we need to cause this segment to be mapped in. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(area-&gt;segment_maps[index].mapped_address == <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Call for effect (we don't need the result). */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1757" title="utils/mmgr/dsa.c:1757">get_segment_by_index</a>(area, index);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> area-&gt;segment_maps[index].mapped_address + offset;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Pin this area, so that it will continue to exist even if all backends<br/></li>
<li></span><span class="Comment"> * detach from it.&nbsp; In that case, the area can still be reattached to if a<br/></li>
<li></span><span class="Comment"> * handle has been recorded somewhere.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L975">&#x200c;</a></span><span class="linkable">dsa_pin</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area), LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (area-&gt;control-&gt;pinned)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> already pinned&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; area-&gt;control-&gt;pinned = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; ++area-&gt;control-&gt;refcnt;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Undo the effects of <a href="#L975" title="utils/mmgr/dsa.c:975">dsa_pin</a>, so that the given area can be freed when no<br/></li>
<li></span><span class="Comment"> * backends are attached to it.&nbsp; May be called only if <a href="#L975" title="utils/mmgr/dsa.c:975">dsa_pin</a> has been<br/></li>
<li></span><span class="Comment"> * called.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L994">&#x200c;</a></span><span class="linkable">dsa_unpin</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area), LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; Assert(area-&gt;control-&gt;refcnt &gt; <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!area-&gt;control-&gt;pinned)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> not pinned&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; area-&gt;control-&gt;pinned = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; --area-&gt;control-&gt;refcnt;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set the total size limit for this area.&nbsp; This limit is checked whenever new<br/></li>
<li></span><span class="Comment"> * segments need to be allocated from the operating system.&nbsp; If the new size<br/></li>
<li></span><span class="Comment"> * limit is already exceeded, this has no immediate effect.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the total virtual memory usage may be temporarily larger than<br/></li>
<li></span><span class="Comment"> * this limit when segments have been freed, but not yet detached by all<br/></li>
<li></span><span class="Comment"> * backends that have attached to them.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1018">&#x200c;</a></span><span class="linkable">dsa_set_size_limit</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, <span class="Type">size_t</span> limit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area), LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; area-&gt;control-&gt;max_total_segment_size = limit;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Return the total size of all active segments */<br/></li>
<li></span><span class="Type">size_t<br/></li>
<li><a id="L1027">&#x200c;</a></span><span class="linkable">dsa_get_total_size</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area), LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; size = area-&gt;control-&gt;total_segment_size;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Aggressively free all spare memory in the hope of returning DSM segments to<br/></li>
<li></span><span class="Comment"> * the operating system.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1043">&#x200c;</a></span><span class="linkable">dsa_trim</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size_class;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Trim in reverse pool order so we get to the spans-of-spans last, just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in case <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> become entirely free while processing all the other pools.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (size_class = <a href="#L236" title="utils/mmgr/dsa.c:236">DSA_NUM_SIZE_CLASSES</a> - <span class="Constant">1</span>; size_class &gt;= <span class="Constant">0</span>; --size_class)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L281" title="utils/mmgr/dsa.c:281">dsa_area_pool</a> *pool = &amp;area-&gt;control-&gt;pools[size_class];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dsa_pointer span_pointer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (size_class == <a href="#L240" title="utils/mmgr/dsa.c:240">DSA_SCLASS_SPAN_LARGE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Large object frees give back segments aggressively already. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Search fullness class 1 only.&nbsp; That is where we expect to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entirely empty superblock (entirely empty superblocks in other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fullness classes are returned to the free page map by <a href="#L826" title="utils/mmgr/dsa.c:826">dsa_free</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L133" title="utils/mmgr/dsa.c:133">DSA_SCLASS_LOCK</a>(area, size_class), LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; span_pointer = pool-&gt;spans[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (DsaPointerIsValid(span_pointer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *span = <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, span_pointer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dsa_pointer <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = span-&gt;nextspan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (span-&gt;nallocatable == span-&gt;nmax)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1837" title="utils/mmgr/dsa.c:1837">destroy_superblock</a>(area, span_pointer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; span_pointer = <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L133" title="utils/mmgr/dsa.c:133">DSA_SCLASS_LOCK</a>(area, size_class));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Print out debugging information about the <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> state of the shared<br/></li>
<li></span><span class="Comment"> * memory area.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1088">&#x200c;</a></span><span class="linkable">dsa_dump</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: This gives an inconsistent snapshot as it acquires and releases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * individual locks as it goes...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area), LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L2288" title="utils/mmgr/dsa.c:2288">check_for_freed_segments_locked</a>(area);<br/></li>
<li>&nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> handle </span><span class="Special">%x</span><span class="Constant">:</span><span class="Special">\n</span><span class="Constant">&quot;</span>, area-&gt;control-&gt;handle);<br/></li>
<li>&nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;&nbsp; max_total_segment_size: </span><span class="Special">%zu\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; area-&gt;control-&gt;max_total_segment_size);<br/></li>
<li>&nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;&nbsp; total_segment_size: </span><span class="Special">%zu\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; area-&gt;control-&gt;total_segment_size);<br/></li>
<li>&nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;&nbsp; refcnt: </span><span class="Special">%d\n</span><span class="Constant">&quot;</span>, area-&gt;control-&gt;refcnt);<br/></li>
<li>&nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;&nbsp; pinned: </span><span class="Special">%c\n</span><span class="Constant">&quot;</span>, area-&gt;control-&gt;pinned ? <span class="Constant">'t'</span> : <span class="Constant">'f'</span>);<br/></li>
<li>&nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;&nbsp; segment bins:</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L111" title="utils/mmgr/dsa.c:111">DSA_NUM_SEGMENT_BINS</a>; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (area-&gt;control-&gt;segment_bins[i] != <a href="#L105" title="utils/mmgr/dsa.c:105">DSA_SEGMENT_INDEX_NONE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L102" title="utils/mmgr/dsa.c:102">dsa_segment_index</a> segment_index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;&nbsp; &nbsp; segment bin </span><span class="Special">%zu</span><span class="Constant"> (no contiguous free pages):</span><span class="Special">\n</span><span class="Constant">&quot;</span>, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;&nbsp; &nbsp; segment bin </span><span class="Special">%zu</span><span class="Constant"> (at least </span><span class="Special">%d</span><span class="Constant"> contiguous pages free):</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i, <span class="Constant">1</span> &lt;&lt; (i - <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment_index = area-&gt;control-&gt;segment_bins[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (segment_index != <a href="#L105" title="utils/mmgr/dsa.c:105">DSA_SEGMENT_INDEX_NONE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> *segment_map;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment_map =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1757" title="utils/mmgr/dsa.c:1757">get_segment_by_index</a>(area, segment_index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;&nbsp; &nbsp; &nbsp; segment index </span><span class="Special">%zu</span><span class="Constant">, usable_pages = </span><span class="Special">%zu</span><span class="Constant">, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;contiguous_pages = </span><span class="Special">%zu</span><span class="Constant">, mapped at </span><span class="Special">%p\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment_map-&gt;header-&gt;usable_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fpm_largest(segment_map-&gt;fpm),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment_map-&gt;mapped_address);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment_index = segment_map-&gt;header-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;&nbsp; pools:</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L236" title="utils/mmgr/dsa.c:236">DSA_NUM_SIZE_CLASSES</a>; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L133" title="utils/mmgr/dsa.c:133">DSA_SCLASS_LOCK</a>(area, i), LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; <a href="#L266" title="utils/mmgr/dsa.c:266">DSA_FULLNESS_CLASSES</a>; ++j)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DsaPointerIsValid(area-&gt;control-&gt;pools[i].spans[j]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == <a href="#L239" title="utils/mmgr/dsa.c:239">DSA_SCLASS_BLOCK_OF_SPANS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;&nbsp; &nbsp; pool for blocks of span objects:</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (i == <a href="#L240" title="utils/mmgr/dsa.c:240">DSA_SCLASS_SPAN_LARGE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;&nbsp; &nbsp; pool for large object spans:</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;&nbsp; &nbsp; pool for size class </span><span class="Special">%zu</span><span class="Constant"> (object size </span><span class="Special">%hu</span><span class="Constant"> bytes):</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i, <a href="#L225" title="utils/mmgr/dsa.c:225">dsa_size_classes</a>[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; <a href="#L266" title="utils/mmgr/dsa.c:266">DSA_FULLNESS_CLASSES</a>; ++j)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!DsaPointerIsValid(area-&gt;control-&gt;pools[i].spans[j]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;&nbsp; &nbsp; &nbsp; fullness class </span><span class="Special">%zu</span><span class="Constant"> is empty</span><span class="Special">\n</span><span class="Constant">&quot;</span>, j);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dsa_pointer span_pointer = area-&gt;control-&gt;pools[i].spans[j];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;&nbsp; &nbsp; &nbsp; fullness class </span><span class="Special">%zu</span><span class="Constant">:</span><span class="Special">\n</span><span class="Constant">&quot;</span>, j);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (DsaPointerIsValid(span_pointer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *span;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; span = <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, span_pointer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;&nbsp; &nbsp; &nbsp; &nbsp; span descriptor at &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DSA_POINTER_FORMAT <span class="Constant">&quot;, superblock at &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DSA_POINTER_FORMAT<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;, pages = </span><span class="Special">%zu</span><span class="Constant">, objects free = </span><span class="Special">%hu</span><span class="Constant">/</span><span class="Special">%hu\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; span_pointer, span-&gt;start, span-&gt;npages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; span-&gt;nallocatable, span-&gt;nmax);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; span_pointer = span-&gt;nextspan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L133" title="utils/mmgr/dsa.c:133">DSA_SCLASS_LOCK</a>(area, i));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the smallest size that you can successfully provide to<br/></li>
<li></span><span class="Comment"> * dsa_create_in_place.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">size_t<br/></li>
<li><a id="L1196">&#x200c;</a></span><span class="linkable">dsa_minimum_size</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pages = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L319" title="utils/mmgr/dsa.c:319">dsa_area_control</a>)) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FreePageManager));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Figure out how many pages we need, including the page map... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (((size + FPM_PAGE_SIZE - <span class="Constant">1</span>) / FPM_PAGE_SIZE) &gt; pages)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ++pages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(dsa_pointer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pages * FPM_PAGE_SIZE;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Workhorse function for dsa_create and dsa_create_in_place.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *<br/></li>
<li><a id="L1218">&#x200c;</a><span class="linkable">create_internal</span>(<span class="Type">void</span> *place, <span class="Type">size_t</span> size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> tranche_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dsm_handle control_handle,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *control_segment,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span> init_segment_size, <span class="Type">size_t</span> max_segment_size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L319" title="utils/mmgr/dsa.c:319">dsa_area_control</a> *control;<br/></li>
<li>&nbsp; &nbsp; <a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a>&nbsp;&nbsp; *area;<br/></li>
<li>&nbsp; &nbsp; <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> *segment_map;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; usable_pages;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; total_pages;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; metadata_bytes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check the initial and maximum block sizes */<br/></li>
<li></span>&nbsp; &nbsp; Assert(init_segment_size &gt;= DSA_MIN_SEGMENT_SIZE);<br/></li>
<li>&nbsp; &nbsp; Assert(max_segment_size &gt;= init_segment_size);<br/></li>
<li>&nbsp; &nbsp; Assert(max_segment_size &lt;= DSA_MAX_SEGMENT_SIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sanity check on the space we have to work in. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (size &lt; <a href="#L1196" title="utils/mmgr/dsa.c:1196">dsa_minimum_size</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> space must be at least </span><span class="Special">%zu</span><span class="Constant">, but </span><span class="Special">%zu</span><span class="Constant"> provided&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1196" title="utils/mmgr/dsa.c:1196">dsa_minimum_size</a>(), size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now figure out how much space is usable */<br/></li>
<li></span>&nbsp; &nbsp; total_pages = size / FPM_PAGE_SIZE;<br/></li>
<li>&nbsp; &nbsp; metadata_bytes =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L319" title="utils/mmgr/dsa.c:319">dsa_area_control</a>)) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FreePageManager)) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; total_pages * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(dsa_pointer);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add padding up to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page boundary. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (metadata_bytes % FPM_PAGE_SIZE != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metadata_bytes += FPM_PAGE_SIZE - (metadata_bytes % FPM_PAGE_SIZE);<br/></li>
<li>&nbsp; &nbsp; Assert(metadata_bytes &lt;= size);<br/></li>
<li>&nbsp; &nbsp; usable_pages = (size - metadata_bytes) / FPM_PAGE_SIZE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the <a href="#L319" title="utils/mmgr/dsa.c:319">dsa_area_control</a> object located at the start of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; control = (<a href="#L319" title="utils/mmgr/dsa.c:319">dsa_area_control</a> *) place;<br/></li>
<li>&nbsp; &nbsp; memset(place, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*control));<br/></li>
<li>&nbsp; &nbsp; control-&gt;segment_header.magic =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L89" title="utils/mmgr/dsa.c:89">DSA_SEGMENT_HEADER_MAGIC</a> ^ control_handle ^ <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; control-&gt;segment_header.<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <a href="#L105" title="utils/mmgr/dsa.c:105">DSA_SEGMENT_INDEX_NONE</a>;<br/></li>
<li>&nbsp; &nbsp; control-&gt;segment_header.prev = <a href="#L105" title="utils/mmgr/dsa.c:105">DSA_SEGMENT_INDEX_NONE</a>;<br/></li>
<li>&nbsp; &nbsp; control-&gt;segment_header.usable_pages = usable_pages;<br/></li>
<li>&nbsp; &nbsp; control-&gt;segment_header.freed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; control-&gt;segment_header.size = size;<br/></li>
<li>&nbsp; &nbsp; control-&gt;handle = control_handle;<br/></li>
<li>&nbsp; &nbsp; control-&gt;init_segment_size = init_segment_size;<br/></li>
<li>&nbsp; &nbsp; control-&gt;max_segment_size = max_segment_size;<br/></li>
<li>&nbsp; &nbsp; control-&gt;max_total_segment_size = (<span class="Type">size_t</span>) -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; control-&gt;total_segment_size = size;<br/></li>
<li>&nbsp; &nbsp; control-&gt;segment_handles[<span class="Constant">0</span>] = control_handle;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L111" title="utils/mmgr/dsa.c:111">DSA_NUM_SEGMENT_BINS</a>; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; control-&gt;segment_bins[i] = <a href="#L105" title="utils/mmgr/dsa.c:105">DSA_SEGMENT_INDEX_NONE</a>;<br/></li>
<li>&nbsp; &nbsp; control-&gt;refcnt = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; control-&gt;lwlock_tranche_id = tranche_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the <a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> object that this backend will use to access the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * area.&nbsp; Other backends will need to obtain their own <a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> object by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attaching.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; area = <a href="mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a>));<br/></li>
<li>&nbsp; &nbsp; area-&gt;control = control;<br/></li>
<li>&nbsp; &nbsp; area-&gt;resowner = <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li>&nbsp; &nbsp; memset(area-&gt;segment_maps, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a>) * <a href="#L75" title="utils/mmgr/dsa.c:75">DSA_MAX_SEGMENTS</a>);<br/></li>
<li>&nbsp; &nbsp; area-&gt;high_segment_index = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; area-&gt;freed_segment_counter = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L709" title="storage/lmgr/lwlock.c:709">LWLockInitialize</a>(&amp;control-&gt;lock, control-&gt;lwlock_tranche_id);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L236" title="utils/mmgr/dsa.c:236">DSA_NUM_SIZE_CLASSES</a>; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L709" title="storage/lmgr/lwlock.c:709">LWLockInitialize</a>(<a href="#L133" title="utils/mmgr/dsa.c:133">DSA_SCLASS_LOCK</a>(area, i),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; control-&gt;lwlock_tranche_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up the segment map for this process's mapping. */<br/></li>
<li></span>&nbsp; &nbsp; segment_map = &amp;area-&gt;segment_maps[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; segment_map-&gt;segment = control_segment;<br/></li>
<li>&nbsp; &nbsp; segment_map-&gt;mapped_address = place;<br/></li>
<li>&nbsp; &nbsp; segment_map-&gt;header = (<a href="#L168" title="utils/mmgr/dsa.c:168">dsa_segment_header</a> *) place;<br/></li>
<li>&nbsp; &nbsp; segment_map-&gt;fpm = (FreePageManager *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (segment_map-&gt;mapped_address +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L319" title="utils/mmgr/dsa.c:319">dsa_area_control</a>)));<br/></li>
<li>&nbsp; &nbsp; segment_map-&gt;pagemap = (dsa_pointer *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (segment_map-&gt;mapped_address +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L319" title="utils/mmgr/dsa.c:319">dsa_area_control</a>)) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FreePageManager)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up the free page map. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="freepage.c.html#L183" title="utils/mmgr/freepage.c:183">FreePageManagerInitialize</a>(segment_map-&gt;fpm, segment_map-&gt;mapped_address);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* There can be 0 usable pages if size is <a href="#L1196" title="utils/mmgr/dsa.c:1196">dsa_minimum_size</a>(). */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (usable_pages &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="freepage.c.html#L379" title="utils/mmgr/freepage.c:379">FreePageManagerPut</a>(segment_map-&gt;fpm, metadata_bytes / FPM_PAGE_SIZE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; usable_pages);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Put this segment into the appropriate bin. */<br/></li>
<li></span>&nbsp; &nbsp; control-&gt;segment_bins[<a href="#L119" title="utils/mmgr/dsa.c:119">contiguous_pages_to_segment_bin</a>(usable_pages)] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; segment_map-&gt;header-&gt;bin = <a href="#L119" title="utils/mmgr/dsa.c:119">contiguous_pages_to_segment_bin</a>(usable_pages);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> area;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Workhorse function for <a href="#L510" title="utils/mmgr/dsa.c:510">dsa_attach</a> and <a href="#L545" title="utils/mmgr/dsa.c:545">dsa_attach_in_place</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *<br/></li>
<li><a id="L1326">&#x200c;</a><span class="linkable">attach_internal</span>(<span class="Type">void</span> *place, <a href="../../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *segment, dsa_handle handle)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L319" title="utils/mmgr/dsa.c:319">dsa_area_control</a> *control;<br/></li>
<li>&nbsp; &nbsp; <a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a>&nbsp;&nbsp; *area;<br/></li>
<li>&nbsp; &nbsp; <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> *segment_map;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; control = (<a href="#L319" title="utils/mmgr/dsa.c:319">dsa_area_control</a> *) place;<br/></li>
<li>&nbsp; &nbsp; Assert(control-&gt;handle == handle);<br/></li>
<li>&nbsp; &nbsp; Assert(control-&gt;segment_handles[<span class="Constant">0</span>] == handle);<br/></li>
<li>&nbsp; &nbsp; Assert(control-&gt;segment_header.magic ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="#L89" title="utils/mmgr/dsa.c:89">DSA_SEGMENT_HEADER_MAGIC</a> ^ handle ^ <span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build the backend-local area object. */<br/></li>
<li></span>&nbsp; &nbsp; area = <a href="mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a>));<br/></li>
<li>&nbsp; &nbsp; area-&gt;control = control;<br/></li>
<li>&nbsp; &nbsp; area-&gt;resowner = <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li>&nbsp; &nbsp; memset(&amp;area-&gt;segment_maps[<span class="Constant">0</span>], <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a>) * <a href="#L75" title="utils/mmgr/dsa.c:75">DSA_MAX_SEGMENTS</a>);<br/></li>
<li>&nbsp; &nbsp; area-&gt;high_segment_index = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up the segment map for this process's mapping. */<br/></li>
<li></span>&nbsp; &nbsp; segment_map = &amp;area-&gt;segment_maps[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; segment_map-&gt;segment = segment; <span class="Comment">/* NULL for in-place */<br/></li>
<li></span>&nbsp; &nbsp; segment_map-&gt;mapped_address = place;<br/></li>
<li>&nbsp; &nbsp; segment_map-&gt;header = (<a href="#L168" title="utils/mmgr/dsa.c:168">dsa_segment_header</a> *) segment_map-&gt;mapped_address;<br/></li>
<li>&nbsp; &nbsp; segment_map-&gt;fpm = (FreePageManager *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (segment_map-&gt;mapped_address + MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L319" title="utils/mmgr/dsa.c:319">dsa_area_control</a>)));<br/></li>
<li>&nbsp; &nbsp; segment_map-&gt;pagemap = (dsa_pointer *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (segment_map-&gt;mapped_address + MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L319" title="utils/mmgr/dsa.c:319">dsa_area_control</a>)) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FreePageManager)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Bump the reference count. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area), LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (control-&gt;refcnt == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can't attach to a DSA area that has already been destroyed. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not attach to dynamic shared area&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; ++control-&gt;refcnt;<br/></li>
<li>&nbsp; &nbsp; area-&gt;freed_segment_counter = area-&gt;control-&gt;freed_segment_counter;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> area;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add a new span to fullness class 1 of the indicated pool.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1377">&#x200c;</a></span><span class="linkable">init_span</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dsa_pointer span_pointer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L281" title="utils/mmgr/dsa.c:281">dsa_area_pool</a> *pool, dsa_pointer start, <span class="Type">size_t</span> npages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16 size_class)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *span = <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, span_pointer);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; obsize = <a href="#L225" title="utils/mmgr/dsa.c:225">dsa_size_classes</a>[size_class];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The per-pool lock must be held because we manipulate the span list for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this pool.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(<a href="#L133" title="utils/mmgr/dsa.c:133">DSA_SCLASS_LOCK</a>(area, size_class)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push this span onto the front of the span list for fullness class 1. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (DsaPointerIsValid(pool-&gt;spans[<span class="Constant">1</span>]))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *head = (<a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, pool-&gt;spans[<span class="Constant">1</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; head-&gt;prevspan = span_pointer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; span-&gt;pool = <a href="#L322" title="utils/mmgr/dsa.c:322">DsaAreaPoolToDsaPointer</a>(area, pool);<br/></li>
<li>&nbsp; &nbsp; span-&gt;nextspan = pool-&gt;spans[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; span-&gt;prevspan = InvalidDsaPointer;<br/></li>
<li>&nbsp; &nbsp; pool-&gt;spans[<span class="Constant">1</span>] = span_pointer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; span-&gt;start = start;<br/></li>
<li>&nbsp; &nbsp; span-&gt;npages = npages;<br/></li>
<li>&nbsp; &nbsp; span-&gt;size_class = size_class;<br/></li>
<li>&nbsp; &nbsp; span-&gt;ninitialized = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (size_class == <a href="#L239" title="utils/mmgr/dsa.c:239">DSA_SCLASS_BLOCK_OF_SPANS</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A block-of-spans contains its own descriptor, so mark one object as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * initialized and reduce the count of allocatable objects by one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Doing this here has the side effect of also reducing nmax by one,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which is important to make sure we free this object at the correct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; span-&gt;ninitialized = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; span-&gt;nallocatable = FPM_PAGE_SIZE / obsize - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (size_class != <a href="#L240" title="utils/mmgr/dsa.c:240">DSA_SCLASS_SPAN_LARGE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; span-&gt;nallocatable = <a href="#L376" title="utils/mmgr/dsa.c:376">DSA_SUPERBLOCK_SIZE</a> / obsize;<br/></li>
<li>&nbsp; &nbsp; span-&gt;firstfree = <a href="#L375" title="utils/mmgr/dsa.c:375">DSA_SPAN_NOTHING_FREE</a>;<br/></li>
<li>&nbsp; &nbsp; span-&gt;nmax = span-&gt;nallocatable;<br/></li>
<li>&nbsp; &nbsp; span-&gt;fclass = <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Transfer the first span in one fullness class to the head of another<br/></li>
<li></span><span class="Comment"> * fullness class.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1432">&#x200c;</a></span><span class="linkable">transfer_first_span</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L281" title="utils/mmgr/dsa.c:281">dsa_area_pool</a> *pool, <span class="Type">int</span> fromclass, <span class="Type">int</span> toclass)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dsa_pointer span_pointer;<br/></li>
<li>&nbsp; &nbsp; <a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *span;<br/></li>
<li>&nbsp; &nbsp; <a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *nextspan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't do it if source list is empty. */<br/></li>
<li></span>&nbsp; &nbsp; span_pointer = pool-&gt;spans[fromclass];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!DsaPointerIsValid(span_pointer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove span from head of source list. */<br/></li>
<li></span>&nbsp; &nbsp; span = <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, span_pointer);<br/></li>
<li>&nbsp; &nbsp; pool-&gt;spans[fromclass] = span-&gt;nextspan;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DsaPointerIsValid(span-&gt;nextspan))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nextspan = (<a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, span-&gt;nextspan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nextspan-&gt;prevspan = InvalidDsaPointer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add span to head of target list. */<br/></li>
<li></span>&nbsp; &nbsp; span-&gt;nextspan = pool-&gt;spans[toclass];<br/></li>
<li>&nbsp; &nbsp; pool-&gt;spans[toclass] = span_pointer;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DsaPointerIsValid(span-&gt;nextspan))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nextspan = (<a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, span-&gt;nextspan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nextspan-&gt;prevspan = span_pointer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; span-&gt;fclass = toclass;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate one object of the requested size class from the given area.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> dsa_pointer<br/></li>
<li><a id="L1472">&#x200c;</a><span class="linkable">alloc_object</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, <span class="Type">int</span> size_class)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L281" title="utils/mmgr/dsa.c:281">dsa_area_pool</a> *pool = &amp;area-&gt;control-&gt;pools[size_class];<br/></li>
<li>&nbsp; &nbsp; <a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *span;<br/></li>
<li>&nbsp; &nbsp; dsa_pointer block;<br/></li>
<li>&nbsp; &nbsp; dsa_pointer result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *object;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Even though <a href="#L1560" title="utils/mmgr/dsa.c:1560">ensure_active_superblock</a> can in turn call <a href="#L1472" title="utils/mmgr/dsa.c:1472">alloc_object</a> if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it needs to allocate a new span, that's always from a different pool,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and the order of lock acquisition is always the same, so it's OK that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we hold this lock for the duration of this function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!<a href="../../storage/lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(<a href="#L133" title="utils/mmgr/dsa.c:133">DSA_SCLASS_LOCK</a>(area, size_class)));<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L133" title="utils/mmgr/dsa.c:133">DSA_SCLASS_LOCK</a>(area, size_class), LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there's no active superblock, we must successfully obtain one or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fail the request.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!DsaPointerIsValid(pool-&gt;spans[<span class="Constant">1</span>]) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L1560" title="utils/mmgr/dsa.c:1560">ensure_active_superblock</a>(area, pool, size_class))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = InvalidDsaPointer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There should be a block in fullness class 1 at this point, and it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should never be completely full.&nbsp; Thus we can either pop an object<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from the free list or, failing that, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> a new object.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(DsaPointerIsValid(pool-&gt;spans[<span class="Constant">1</span>]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; span = (<a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, pool-&gt;spans[<span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(span-&gt;nallocatable &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; block = span-&gt;start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(size_class &lt; <a href="#L236" title="utils/mmgr/dsa.c:236">DSA_NUM_SIZE_CLASSES</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size = <a href="#L225" title="utils/mmgr/dsa.c:225">dsa_size_classes</a>[size_class];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (span-&gt;firstfree != <a href="#L375" title="utils/mmgr/dsa.c:375">DSA_SPAN_NOTHING_FREE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = block + span-&gt;firstfree * size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; object = <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; span-&gt;firstfree = <a href="#L202" title="utils/mmgr/dsa.c:202">NextFreeObjectIndex</a>(object);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = block + span-&gt;ninitialized * size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++span-&gt;ninitialized;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; --span-&gt;nallocatable;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> full, move it to the highest-numbered fullness class. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (span-&gt;nallocatable == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1432" title="utils/mmgr/dsa.c:1432">transfer_first_span</a>(area, pool, <span class="Constant">1</span>, <a href="#L266" title="utils/mmgr/dsa.c:266">DSA_FULLNESS_CLASSES</a> - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(<a href="#L133" title="utils/mmgr/dsa.c:133">DSA_SCLASS_LOCK</a>(area, size_class)));<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L133" title="utils/mmgr/dsa.c:133">DSA_SCLASS_LOCK</a>(area, size_class));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Ensure an active (i.e. fullness class 1) superblock, unless all existing<br/></li>
<li></span><span class="Comment"> * superblocks are completely full and no more can be allocated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Fullness classes K of 0..N are loosely intended to represent blocks whose<br/></li>
<li></span><span class="Comment"> * utilization percentage is at least K/N, but we only enforce this rigorously<br/></li>
<li></span><span class="Comment"> * for the highest-numbered fullness class, which always contains exactly<br/></li>
<li></span><span class="Comment"> * those blocks that are completely full.&nbsp; It's otherwise acceptable for a<br/></li>
<li></span><span class="Comment"> * block to be in a higher-numbered fullness class than the one to which it<br/></li>
<li></span><span class="Comment"> * logically belongs.&nbsp; In addition, the active block, which is always the<br/></li>
<li></span><span class="Comment"> * first block in fullness class 1, is permitted to have a higher allocation<br/></li>
<li></span><span class="Comment"> * percentage than would normally be allowable for that fullness class; we<br/></li>
<li></span><span class="Comment"> * don't move it until it's completely full, and then it goes to the<br/></li>
<li></span><span class="Comment"> * highest-numbered fullness class.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It might seem odd that the active block is the head of fullness class 1<br/></li>
<li></span><span class="Comment"> * rather than fullness class 0, but experience with other allocators has<br/></li>
<li></span><span class="Comment"> * shown that it's usually better to allocate from a block that's moderately<br/></li>
<li></span><span class="Comment"> * full rather than one that's nearly empty.&nbsp; Insofar as is reasonably<br/></li>
<li></span><span class="Comment"> * possible, we want to avoid performing new allocations in a block that would<br/></li>
<li></span><span class="Comment"> * otherwise become empty soon.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1560">&#x200c;</a></span><span class="linkable">ensure_active_superblock</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, <a href="#L281" title="utils/mmgr/dsa.c:281">dsa_area_pool</a> *pool,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> size_class)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dsa_pointer span_pointer;<br/></li>
<li>&nbsp; &nbsp; dsa_pointer start_pointer;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; obsize = <a href="#L225" title="utils/mmgr/dsa.c:225">dsa_size_classes</a>[size_class];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; nmax;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fclass;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; npages = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; first_page;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> *segment_map;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(<a href="#L133" title="utils/mmgr/dsa.c:133">DSA_SCLASS_LOCK</a>(area, size_class)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute the number of objects that will fit in a block of this size<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * class.&nbsp; Span-of-spans blocks are just a single page, and the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * object isn't available for use because it describes the block-of-spans<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (size_class == <a href="#L239" title="utils/mmgr/dsa.c:239">DSA_SCLASS_BLOCK_OF_SPANS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nmax = FPM_PAGE_SIZE / obsize - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nmax = <a href="#L376" title="utils/mmgr/dsa.c:376">DSA_SUPERBLOCK_SIZE</a> / obsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If fullness class 1 is empty, try to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a span to put in it by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scanning higher-numbered fullness classes (excluding the last one,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whose blocks are certain to all be completely full).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (fclass = <span class="Constant">2</span>; fclass &lt; <a href="#L266" title="utils/mmgr/dsa.c:266">DSA_FULLNESS_CLASSES</a> - <span class="Constant">1</span>; ++fclass)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; span_pointer = pool-&gt;spans[fclass];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (DsaPointerIsValid(span_pointer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tfclass;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *span;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *nextspan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *prevspan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dsa_pointer next_span_pointer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; span = (<a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, span_pointer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_span_pointer = span-&gt;nextspan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Figure out what fullness class should contain this span. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tfclass = (nmax - span-&gt;nallocatable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * (<a href="#L266" title="utils/mmgr/dsa.c:266">DSA_FULLNESS_CLASSES</a> - <span class="Constant">1</span>) / nmax;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Look up <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> span. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DsaPointerIsValid(span-&gt;nextspan))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextspan = (<a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, span-&gt;nextspan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextspan = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If utilization has dropped enough that this <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> belongs in some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other fullness class, move it there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tfclass &lt; fclass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remove from the current fullness class list. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pool-&gt;spans[fclass] == span_pointer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It was the head; remove it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!DsaPointerIsValid(span-&gt;prevspan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool-&gt;spans[fclass] = span-&gt;nextspan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nextspan != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextspan-&gt;prevspan = InvalidDsaPointer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It was not the head. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(DsaPointerIsValid(span-&gt;prevspan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevspan = (<a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, span-&gt;prevspan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevspan-&gt;nextspan = span-&gt;nextspan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nextspan != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextspan-&gt;prevspan = span-&gt;prevspan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Push onto the head of the new fullness class list. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; span-&gt;nextspan = pool-&gt;spans[tfclass];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool-&gt;spans[tfclass] = span_pointer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; span-&gt;prevspan = InvalidDsaPointer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DsaPointerIsValid(span-&gt;nextspan))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextspan = (<a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, span-&gt;nextspan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextspan-&gt;prevspan = span_pointer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; span-&gt;fclass = tfclass;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> span on list. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; span_pointer = next_span_pointer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Stop <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> if we found a suitable block. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DsaPointerIsValid(pool-&gt;spans[<span class="Constant">1</span>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are no blocks that properly belong in fullness class 1, pick<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one from some other fullness class and move it there anyway, so that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have an allocation target.&nbsp; Our last choice is to transfer a block<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that's almost empty (and might become completely empty soon if left<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * alone), but even that is better than failing, which is what we must do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if there are no blocks at all with freespace.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!DsaPointerIsValid(pool-&gt;spans[<span class="Constant">1</span>]));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (fclass = <span class="Constant">2</span>; fclass &lt; <a href="#L266" title="utils/mmgr/dsa.c:266">DSA_FULLNESS_CLASSES</a> - <span class="Constant">1</span>; ++fclass)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1432" title="utils/mmgr/dsa.c:1432">transfer_first_span</a>(area, pool, fclass, <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!DsaPointerIsValid(pool-&gt;spans[<span class="Constant">1</span>]) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1432" title="utils/mmgr/dsa.c:1432">transfer_first_span</a>(area, pool, <span class="Constant">0</span>, <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We failed to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an existing span with free objects, so we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocate a new superblock and construct a new span to manage it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, get a <a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> object to describe the new superblock block<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ... unless this allocation is for a <a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> object, in which case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that's surely not going to work.&nbsp; We handle that case by storing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * span describing a block-of-spans inline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (size_class != <a href="#L239" title="utils/mmgr/dsa.c:239">DSA_SCLASS_BLOCK_OF_SPANS</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; span_pointer = <a href="#L1472" title="utils/mmgr/dsa.c:1472">alloc_object</a>(area, <a href="#L239" title="utils/mmgr/dsa.c:239">DSA_SCLASS_BLOCK_OF_SPANS</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!DsaPointerIsValid(span_pointer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; npages = <a href="#L82" title="utils/mmgr/dsa.c:82">DSA_PAGES_PER_SUPERBLOCK</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find or create a segment and allocate the superblock. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area), LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; segment_map = <a href="#L2010" title="utils/mmgr/dsa.c:2010">get_best_segment</a>(area, npages);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (segment_map == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; segment_map = <a href="#L2081" title="utils/mmgr/dsa.c:2081">make_new_segment</a>(area, npages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (segment_map == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This shouldn't happen: <a href="#L2010" title="utils/mmgr/dsa.c:2010">get_best_segment</a>() or <a href="#L2081" title="utils/mmgr/dsa.c:2081">make_new_segment</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * promised that we can successfully allocate npages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="freepage.c.html#L210" title="utils/mmgr/freepage.c:210">FreePageManagerGet</a>(segment_map-&gt;fpm, npages, &amp;first_page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;dsa_allocate could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> </span><span class="Special">%zu</span><span class="Constant"> free pages for superblock&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; npages);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute the start of the superblock. */<br/></li>
<li></span>&nbsp; &nbsp; start_pointer =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L92" title="utils/mmgr/dsa.c:92">DSA_MAKE_POINTER</a>(<a href="#L379" title="utils/mmgr/dsa.c:379">get_segment_index</a>(area, segment_map),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; first_page * FPM_PAGE_SIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is a block-of-spans, carve the descriptor right out of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocated space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (size_class == <a href="#L239" title="utils/mmgr/dsa.c:239">DSA_SCLASS_BLOCK_OF_SPANS</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have a pointer into the segment.&nbsp; We need to build a dsa_pointer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from the segment index and offset into the segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; span_pointer = start_pointer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize span and pagemap. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1377" title="utils/mmgr/dsa.c:1377">init_span</a>(area, span_pointer, pool, start_pointer, npages, size_class);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; npages; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; segment_map-&gt;pagemap[first_page + i] = span_pointer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the segment map corresponding to a given segment index, mapping the<br/></li>
<li></span><span class="Comment"> * segment in if necessary.&nbsp; For <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> segment book-keeping, this is called<br/></li>
<li></span><span class="Comment"> * with the area lock held.&nbsp; It is also called by <a href="#L826" title="utils/mmgr/dsa.c:826">dsa_free</a> and <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a><br/></li>
<li></span><span class="Comment"> * without <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> locking, relying on the fact they have a known live segment<br/></li>
<li></span><span class="Comment"> * index and they always call <a href="#L2252" title="utils/mmgr/dsa.c:2252">check_for_freed_segments</a> to ensures that <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * freed segment occupying the same slot is detached first.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> *<br/></li>
<li><a id="L1757">&#x200c;</a><span class="linkable">get_segment_by_index</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, <a href="#L102" title="utils/mmgr/dsa.c:102">dsa_segment_index</a> index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(area-&gt;segment_maps[index].mapped_address == <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dsm_handle&nbsp; &nbsp; handle;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *segment;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> *segment_map;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ResourceOwner oldowner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are reached by <a href="#L826" title="utils/mmgr/dsa.c:826">dsa_free</a> or <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>, there must be at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * least one object allocated in the referenced segment.&nbsp; Otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * their caller has a double-free or access-after-free bug, which we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have no hope of detecting.&nbsp; So we know it's safe to access this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * array slot without holding a lock; it won't change underneath us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Furthermore, we know that we can see the latest contents of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * slot, as explained in <a href="#L2252" title="utils/mmgr/dsa.c:2252">check_for_freed_segments</a>, which those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> call <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> arriving here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; handle = area-&gt;control-&gt;segment_handles[index];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It's an error to try to access an unused slot. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (handle == DSM_HANDLE_INVALID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> could not attach to a segment that has been freed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldowner = <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = area-&gt;resowner;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; segment = <a href="../../storage/ipc/dsm.c.html#L665" title="storage/ipc/dsm.c:665">dsm_attach</a>(handle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = oldowner;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (segment == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> could not attach to segment&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; segment_map = &amp;area-&gt;segment_maps[index];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; segment_map-&gt;segment = segment;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; segment_map-&gt;mapped_address = <a href="../../storage/ipc/dsm.c.html#L1095" title="storage/ipc/dsm.c:1095">dsm_segment_address</a>(segment);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; segment_map-&gt;header =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L168" title="utils/mmgr/dsa.c:168">dsa_segment_header</a> *) segment_map-&gt;mapped_address;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; segment_map-&gt;fpm = (FreePageManager *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (segment_map-&gt;mapped_address +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L168" title="utils/mmgr/dsa.c:168">dsa_segment_header</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; segment_map-&gt;pagemap = (dsa_pointer *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (segment_map-&gt;mapped_address +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L168" title="utils/mmgr/dsa.c:168">dsa_segment_header</a>)) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FreePageManager)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remember the highest index this backend has ever mapped. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (area-&gt;high_segment_index &lt; index)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; area-&gt;high_segment_index = index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(segment_map-&gt;header-&gt;magic ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="#L89" title="utils/mmgr/dsa.c:89">DSA_SEGMENT_HEADER_MAGIC</a> ^ area-&gt;control-&gt;handle ^ index));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Callers of <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>() and <a href="#L826" title="utils/mmgr/dsa.c:826">dsa_free</a>() don't hold the area lock,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but it's a bug in the calling code and undefined behavior if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * address is not live (ie if the segment might possibly have been freed,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they're trying to use a dangling pointer).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For dsa.c code that holds the area lock to manipulate segment_bins<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lists, it would be a bug if we ever reach a freed segment here.&nbsp; After<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's marked as freed, the only thing <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> backend should do with it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unmap it, and it should always have done that in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2288" title="utils/mmgr/dsa.c:2288">check_for_freed_segments_locked</a>() <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> arriving here to resolve an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index to a segment_map.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Either way we can assert that we aren't returning a freed segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!area-&gt;segment_maps[index].header-&gt;freed);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> &amp;area-&gt;segment_maps[index];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return a superblock to the free page manager.&nbsp; If the underlying segment<br/></li>
<li></span><span class="Comment"> * has become entirely free, then return it to the operating system.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The appropriate pool lock must be held.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1837">&#x200c;</a></span><span class="linkable">destroy_superblock</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, dsa_pointer span_pointer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *span = <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, span_pointer);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size_class = span-&gt;size_class;<br/></li>
<li>&nbsp; &nbsp; <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> *segment_map;<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove it from its fullness class list. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1906" title="utils/mmgr/dsa.c:1906">unlink_span</a>(area, span);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: Here we acquire the area lock while we already hold a per-pool<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock.&nbsp; We never hold the area lock and then take a pool lock, or we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could deadlock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area), LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L2288" title="utils/mmgr/dsa.c:2288">check_for_freed_segments_locked</a>(area);<br/></li>
<li>&nbsp; &nbsp; segment_map =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1757" title="utils/mmgr/dsa.c:1757">get_segment_by_index</a>(area, <a href="#L96" title="utils/mmgr/dsa.c:96">DSA_EXTRACT_SEGMENT_NUMBER</a>(span-&gt;start));<br/></li>
<li>&nbsp; &nbsp; <a href="freepage.c.html#L379" title="utils/mmgr/freepage.c:379">FreePageManagerPut</a>(segment_map-&gt;fpm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L99" title="utils/mmgr/dsa.c:99">DSA_EXTRACT_OFFSET</a>(span-&gt;start) / FPM_PAGE_SIZE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; span-&gt;npages);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if the segment is <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> entirely free. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fpm_largest(segment_map-&gt;fpm) == segment_map-&gt;header-&gt;usable_pages)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L102" title="utils/mmgr/dsa.c:102">dsa_segment_index</a> index = <a href="#L379" title="utils/mmgr/dsa.c:379">get_segment_index</a>(area, segment_map);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's not the segment with extra control data, free it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Give it back to the OS, and allow other backends to detect that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * they need to detach.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1978" title="utils/mmgr/dsa.c:1978">unlink_segment</a>(area, segment_map);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment_map-&gt;header-&gt;freed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(area-&gt;control-&gt;total_segment_size &gt;=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; segment_map-&gt;header-&gt;size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; area-&gt;control-&gt;total_segment_size -=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment_map-&gt;header-&gt;size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L988" title="storage/ipc/dsm.c:988">dsm_unpin_segment</a>(<a href="../../storage/ipc/dsm.c.html#L1123" title="storage/ipc/dsm.c:1123">dsm_segment_handle</a>(segment_map-&gt;segment));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L803" title="storage/ipc/dsm.c:803">dsm_detach</a>(segment_map-&gt;segment);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; area-&gt;control-&gt;segment_handles[index] = DSM_HANDLE_INVALID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++area-&gt;control-&gt;freed_segment_counter;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment_map-&gt;segment = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment_map-&gt;header = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment_map-&gt;mapped_address = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Move segment to appropriate bin if necessary. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (segment_map-&gt;header != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2316" title="utils/mmgr/dsa.c:2316">rebin_segment</a>(area, segment_map);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Span-of-spans blocks store the span which describes them within the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * block itself, so freeing the storage implicitly frees the descriptor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * also.&nbsp; If this is a block of <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other type, we need to separately free<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the span object also.&nbsp; This recursive call to <a href="#L826" title="utils/mmgr/dsa.c:826">dsa_free</a> will acquire the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * span pool's lock.&nbsp; We can't deadlock because the acquisition order is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * always some other pool and then the span pool.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (size_class != <a href="#L239" title="utils/mmgr/dsa.c:239">DSA_SCLASS_BLOCK_OF_SPANS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L826" title="utils/mmgr/dsa.c:826">dsa_free</a>(area, span_pointer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1906">&#x200c;</a></span><span class="linkable">unlink_span</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, <a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *span)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DsaPointerIsValid(span-&gt;nextspan))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, span-&gt;nextspan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-&gt;prevspan = span-&gt;prevspan;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DsaPointerIsValid(span-&gt;prevspan))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *prev = <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, span-&gt;prevspan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prev-&gt;nextspan = span-&gt;nextspan;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L281" title="utils/mmgr/dsa.c:281">dsa_area_pool</a> *pool = <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, span-&gt;pool);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pool-&gt;spans[span-&gt;fclass] = span-&gt;nextspan;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1929">&#x200c;</a></span><span class="linkable">add_span_to_fullness_class</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, <a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *span,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dsa_pointer span_pointer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> fclass)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L281" title="utils/mmgr/dsa.c:281">dsa_area_pool</a> *pool = <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, span-&gt;pool);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DsaPointerIsValid(pool-&gt;spans[fclass]))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L196" title="utils/mmgr/dsa.c:196">dsa_area_span</a> *head = <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pool-&gt;spans[fclass]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; head-&gt;prevspan = span_pointer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; span-&gt;prevspan = InvalidDsaPointer;<br/></li>
<li>&nbsp; &nbsp; span-&gt;nextspan = pool-&gt;spans[fclass];<br/></li>
<li>&nbsp; &nbsp; pool-&gt;spans[fclass] = span_pointer;<br/></li>
<li>&nbsp; &nbsp; span-&gt;fclass = fclass;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Detach from an area that was either created or attached to by this process.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1952">&#x200c;</a></span><span class="linkable">dsa_detach</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Detach from all segments. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt;= area-&gt;high_segment_index; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (area-&gt;segment_maps[i].segment != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L803" title="storage/ipc/dsm.c:803">dsm_detach</a>(area-&gt;segment_maps[i].segment);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that 'detaching' (= detaching from DSM segments) doesn't include<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'releasing' (= adjusting the reference count).&nbsp; It would be nice to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> these operations, but client code might never get around to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calling <a href="#L1952" title="utils/mmgr/dsa.c:1952">dsa_detach</a> because of an error path, and a detach hook on <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * particular segment is too late to detach other segments in the area<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * without risking a 'leak' warning in the non-error path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Free the backend-local area object. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(area);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Unlink a segment from the bin that contains it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1978">&#x200c;</a></span><span class="linkable">unlink_segment</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> *segment_map)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (segment_map-&gt;header-&gt;prev != <a href="#L105" title="utils/mmgr/dsa.c:105">DSA_SEGMENT_INDEX_NONE</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> *prev;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prev = <a href="#L1757" title="utils/mmgr/dsa.c:1757">get_segment_by_index</a>(area, segment_map-&gt;header-&gt;prev);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prev-&gt;header-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = segment_map-&gt;header-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(area-&gt;control-&gt;segment_bins[segment_map-&gt;header-&gt;bin] ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L379" title="utils/mmgr/dsa.c:379">get_segment_index</a>(area, segment_map));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; area-&gt;control-&gt;segment_bins[segment_map-&gt;header-&gt;bin] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment_map-&gt;header-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (segment_map-&gt;header-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> != <a href="#L105" title="utils/mmgr/dsa.c:105">DSA_SEGMENT_INDEX_NONE</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> *<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <a href="#L1757" title="utils/mmgr/dsa.c:1757">get_segment_by_index</a>(area, segment_map-&gt;header-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-&gt;header-&gt;prev = segment_map-&gt;header-&gt;prev;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find a segment that could satisfy a request for 'npages' of contiguous<br/></li>
<li></span><span class="Comment"> * memory, or return NULL if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> can be found.&nbsp; This may involve attaching to<br/></li>
<li></span><span class="Comment"> * segments that weren't previously attached so that we can query their free<br/></li>
<li></span><span class="Comment"> * pages map.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> *<br/></li>
<li><a id="L2010">&#x200c;</a><span class="linkable">get_best_segment</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, <span class="Type">size_t</span> npages)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; bin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area)));<br/></li>
<li>&nbsp; &nbsp; <a href="#L2288" title="utils/mmgr/dsa.c:2288">check_for_freed_segments_locked</a>(area);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start searching from the first bin that *might* have enough contiguous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (bin = <a href="#L119" title="utils/mmgr/dsa.c:119">contiguous_pages_to_segment_bin</a>(npages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bin &lt; <a href="#L111" title="utils/mmgr/dsa.c:111">DSA_NUM_SEGMENT_BINS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ++bin)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The minimum contiguous size that <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> segment in this bin should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have.&nbsp; We'll re-bin if we see segments with fewer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; threshold = (<span class="Type">size_t</span>) <span class="Constant">1</span> &lt;&lt; (bin - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L102" title="utils/mmgr/dsa.c:102">dsa_segment_index</a> segment_index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Search this bin for a segment with enough contiguous space. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; segment_index = area-&gt;control-&gt;segment_bins[bin];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (segment_index != <a href="#L105" title="utils/mmgr/dsa.c:105">DSA_SEGMENT_INDEX_NONE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> *segment_map;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L102" title="utils/mmgr/dsa.c:102">dsa_segment_index</a> next_segment_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; contiguous_pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment_map = <a href="#L1757" title="utils/mmgr/dsa.c:1757">get_segment_by_index</a>(area, segment_index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_segment_index = segment_map-&gt;header-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; contiguous_pages = fpm_largest(segment_map-&gt;fpm);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not enough for the request, still enough for this bin. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (contiguous_pages &gt;= threshold &amp;&amp; contiguous_pages &lt; npages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment_index = next_segment_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Re-bin it if it's no longer in the appropriate bin. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (contiguous_pages &lt; threshold)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2316" title="utils/mmgr/dsa.c:2316">rebin_segment</a>(area, segment_map);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * But fall through to see if it's enough to satisfy this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * request anyway....<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check if we are done. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (contiguous_pages &gt;= npages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> segment_map;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Continue searching the same bin. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment_index = next_segment_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Not found. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a new segment that can handle at least requested_pages.&nbsp; Returns<br/></li>
<li></span><span class="Comment"> * NULL if the requested total size limit or maximum allowed number of<br/></li>
<li></span><span class="Comment"> * segments would be exceeded.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> *<br/></li>
<li><a id="L2081">&#x200c;</a><span class="linkable">make_new_segment</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, <span class="Type">size_t</span> requested_pages)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L102" title="utils/mmgr/dsa.c:102">dsa_segment_index</a> new_index;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; metadata_bytes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; total_size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; total_pages;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; usable_pages;<br/></li>
<li>&nbsp; &nbsp; <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> *segment_map;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *segment;<br/></li>
<li>&nbsp; &nbsp; ResourceOwner oldowner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find a segment slot that is not in use (linearly for <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>). */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (new_index = <span class="Constant">1</span>; new_index &lt; <a href="#L75" title="utils/mmgr/dsa.c:75">DSA_MAX_SEGMENTS</a>; ++new_index)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (area-&gt;control-&gt;segment_handles[new_index] == DSM_HANDLE_INVALID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (new_index == <a href="#L75" title="utils/mmgr/dsa.c:75">DSA_MAX_SEGMENTS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the total size limit is already exceeded, then we exit early and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoid arithmetic wraparound in the unsigned expressions below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (area-&gt;control-&gt;total_segment_size &gt;=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; area-&gt;control-&gt;max_total_segment_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The size should be at least as big as requested, and at least big<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enough to follow a geometric series that approximately doubles the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * total storage each time we create a new segment.&nbsp; We use geometric<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * growth because the underlying DSM system isn't designed for large<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * numbers of segments (otherwise we might even consider just using one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * DSM segment for each large allocation and for each superblock, and then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we wouldn't need to use FreePageManager).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We decide on a total segment size first, so that we produce tidy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * power-of-two sized segments.&nbsp; This is a good property to have if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * move to huge pages in the future.&nbsp; Then we work back to the number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pages we can fit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; total_size = area-&gt;control-&gt;init_segment_size *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">size_t</span>) <span class="Constant">1</span> &lt;&lt; (new_index / <a href="#L69" title="utils/mmgr/dsa.c:69">DSA_NUM_SEGMENTS_AT_EACH_SIZE</a>));<br/></li>
<li>&nbsp; &nbsp; total_size = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(total_size, area-&gt;control-&gt;max_segment_size);<br/></li>
<li>&nbsp; &nbsp; total_size = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(total_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; area-&gt;control-&gt;max_total_segment_size -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; area-&gt;control-&gt;total_segment_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; total_pages = total_size / FPM_PAGE_SIZE;<br/></li>
<li>&nbsp; &nbsp; metadata_bytes =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L168" title="utils/mmgr/dsa.c:168">dsa_segment_header</a>)) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FreePageManager)) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(dsa_pointer) * total_pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add padding up to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page boundary. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (metadata_bytes % FPM_PAGE_SIZE != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metadata_bytes += FPM_PAGE_SIZE - (metadata_bytes % FPM_PAGE_SIZE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (total_size &lt;= metadata_bytes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; usable_pages = (total_size - metadata_bytes) / FPM_PAGE_SIZE;<br/></li>
<li>&nbsp; &nbsp; Assert(metadata_bytes + usable_pages * FPM_PAGE_SIZE &lt;= total_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See if that is enough... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (requested_pages &gt; usable_pages)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'll make an odd-sized segment, working forward from the requested<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * number of pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; usable_pages = requested_pages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metadata_bytes =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L168" title="utils/mmgr/dsa.c:168">dsa_segment_header</a>)) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FreePageManager)) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usable_pages * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(dsa_pointer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add padding up to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page boundary. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (metadata_bytes % FPM_PAGE_SIZE != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metadata_bytes += FPM_PAGE_SIZE - (metadata_bytes % FPM_PAGE_SIZE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; total_size = metadata_bytes + usable_pages * FPM_PAGE_SIZE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Is that too large for dsa_pointer's addressing scheme? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (total_size &gt; DSA_MAX_SEGMENT_SIZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Would that exceed the limit? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (total_size &gt; area-&gt;control-&gt;max_total_segment_size -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; area-&gt;control-&gt;total_segment_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the segment. */<br/></li>
<li></span>&nbsp; &nbsp; oldowner = <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = area-&gt;resowner;<br/></li>
<li>&nbsp; &nbsp; segment = <a href="../../storage/ipc/dsm.c.html#L516" title="storage/ipc/dsm.c:516">dsm_create</a>(total_size, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = oldowner;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (segment == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L955" title="storage/ipc/dsm.c:955">dsm_pin_segment</a>(segment);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store the handle in shared memory to be found by index. */<br/></li>
<li></span>&nbsp; &nbsp; area-&gt;control-&gt;segment_handles[new_index] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L1123" title="storage/ipc/dsm.c:1123">dsm_segment_handle</a>(segment);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Track the highest segment index in the history of the area. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (area-&gt;control-&gt;high_segment_index &lt; new_index)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; area-&gt;control-&gt;high_segment_index = new_index;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Track the highest segment index this backend has ever mapped. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (area-&gt;high_segment_index &lt; new_index)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; area-&gt;high_segment_index = new_index;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Track total size of all segments. */<br/></li>
<li></span>&nbsp; &nbsp; area-&gt;control-&gt;total_segment_size += total_size;<br/></li>
<li>&nbsp; &nbsp; Assert(area-&gt;control-&gt;total_segment_size &lt;=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; area-&gt;control-&gt;max_total_segment_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build a segment map for this segment in this backend. */<br/></li>
<li></span>&nbsp; &nbsp; segment_map = &amp;area-&gt;segment_maps[new_index];<br/></li>
<li>&nbsp; &nbsp; segment_map-&gt;segment = segment;<br/></li>
<li>&nbsp; &nbsp; segment_map-&gt;mapped_address = <a href="../../storage/ipc/dsm.c.html#L1095" title="storage/ipc/dsm.c:1095">dsm_segment_address</a>(segment);<br/></li>
<li>&nbsp; &nbsp; segment_map-&gt;header = (<a href="#L168" title="utils/mmgr/dsa.c:168">dsa_segment_header</a> *) segment_map-&gt;mapped_address;<br/></li>
<li>&nbsp; &nbsp; segment_map-&gt;fpm = (FreePageManager *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (segment_map-&gt;mapped_address +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L168" title="utils/mmgr/dsa.c:168">dsa_segment_header</a>)));<br/></li>
<li>&nbsp; &nbsp; segment_map-&gt;pagemap = (dsa_pointer *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (segment_map-&gt;mapped_address +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L168" title="utils/mmgr/dsa.c:168">dsa_segment_header</a>)) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FreePageManager)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up the free page map. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="freepage.c.html#L183" title="utils/mmgr/freepage.c:183">FreePageManagerInitialize</a>(segment_map-&gt;fpm, segment_map-&gt;mapped_address);<br/></li>
<li>&nbsp; &nbsp; <a href="freepage.c.html#L379" title="utils/mmgr/freepage.c:379">FreePageManagerPut</a>(segment_map-&gt;fpm, metadata_bytes / FPM_PAGE_SIZE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; usable_pages);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up the segment header and put it in the appropriate bin. */<br/></li>
<li></span>&nbsp; &nbsp; segment_map-&gt;header-&gt;magic =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L89" title="utils/mmgr/dsa.c:89">DSA_SEGMENT_HEADER_MAGIC</a> ^ area-&gt;control-&gt;handle ^ new_index;<br/></li>
<li>&nbsp; &nbsp; segment_map-&gt;header-&gt;usable_pages = usable_pages;<br/></li>
<li>&nbsp; &nbsp; segment_map-&gt;header-&gt;size = total_size;<br/></li>
<li>&nbsp; &nbsp; segment_map-&gt;header-&gt;bin = <a href="#L119" title="utils/mmgr/dsa.c:119">contiguous_pages_to_segment_bin</a>(usable_pages);<br/></li>
<li>&nbsp; &nbsp; segment_map-&gt;header-&gt;prev = <a href="#L105" title="utils/mmgr/dsa.c:105">DSA_SEGMENT_INDEX_NONE</a>;<br/></li>
<li>&nbsp; &nbsp; segment_map-&gt;header-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; area-&gt;control-&gt;segment_bins[segment_map-&gt;header-&gt;bin];<br/></li>
<li>&nbsp; &nbsp; segment_map-&gt;header-&gt;freed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; area-&gt;control-&gt;segment_bins[segment_map-&gt;header-&gt;bin] = new_index;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (segment_map-&gt;header-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> != <a href="#L105" title="utils/mmgr/dsa.c:105">DSA_SEGMENT_INDEX_NONE</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> *<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1757" title="utils/mmgr/dsa.c:1757">get_segment_by_index</a>(area, segment_map-&gt;header-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-&gt;header-&gt;bin == segment_map-&gt;header-&gt;bin);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-&gt;header-&gt;prev = new_index;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> segment_map;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> segments have been freed by <a href="#L1837" title="utils/mmgr/dsa.c:1837">destroy_superblock</a>, so we can<br/></li>
<li></span><span class="Comment"> * detach from them in this backend.&nbsp; This function is called by<br/></li>
<li></span><span class="Comment"> * <a href="#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a> and <a href="#L826" title="utils/mmgr/dsa.c:826">dsa_free</a> to make sure that a dsa_pointer they have<br/></li>
<li></span><span class="Comment"> * received can be resolved to the correct segment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The danger we want to defend against is that there could be an old segment<br/></li>
<li></span><span class="Comment"> * mapped into a given slot in this backend, and the dsa_pointer they have<br/></li>
<li></span><span class="Comment"> * might refer to some new segment in the same slot.&nbsp; So those <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> must<br/></li>
<li></span><span class="Comment"> * be sure to process all instructions to detach from a freed segment that had<br/></li>
<li></span><span class="Comment"> * been generated by the time this process received the dsa_pointer, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * they call <a href="#L1757" title="utils/mmgr/dsa.c:1757">get_segment_by_index</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2252">&#x200c;</a></span><span class="linkable">check_for_freed_segments</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; freed_segment_counter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Any other process that has freed a segment has incremented<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * freed_segment_counter while holding an LWLock, and that must precede<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> backend creating a new segment in the same slot while holding an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LWLock, and that must precede the creation of <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> dsa_pointer pointing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into the new segment which might reach us here, and the caller must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have sent the dsa_pointer to this process using appropriate memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * synchronization (some kind of locking or atomic primitive or system<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * call).&nbsp; So all we need to do on the reading side is ask for the load of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * freed_segment_counter to follow the caller's load of the dsa_pointer it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has, and we can be sure to detect <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> segments that had been freed as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the time that the dsa_pointer reached this process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_read_barrier();<br/></li>
<li>&nbsp; &nbsp; freed_segment_counter = area-&gt;control-&gt;freed_segment_counter;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(area-&gt;freed_segment_counter != freed_segment_counter))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check all currently mapped segments to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> what's been freed. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area), LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2288" title="utils/mmgr/dsa.c:2288">check_for_freed_segments_locked</a>(area);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Workhorse for <a href="#L2252" title="utils/mmgr/dsa.c:2252">check_for_freed_segments</a>(), and also used directly in path<br/></li>
<li></span><span class="Comment"> * where the area lock is already held.&nbsp; This should be called after acquiring<br/></li>
<li></span><span class="Comment"> * the lock but <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> looking up <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> segment by index number, to make sure we<br/></li>
<li></span><span class="Comment"> * unmap <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> stale segments that might have previously had the same index as a<br/></li>
<li></span><span class="Comment"> * current segment.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2288">&#x200c;</a></span><span class="linkable">check_for_freed_segments_locked</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; freed_segment_counter;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(<a href="#L132" title="utils/mmgr/dsa.c:132">DSA_AREA_LOCK</a>(area)));<br/></li>
<li>&nbsp; &nbsp; freed_segment_counter = area-&gt;control-&gt;freed_segment_counter;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(area-&gt;freed_segment_counter != freed_segment_counter))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt;= area-&gt;high_segment_index; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (area-&gt;segment_maps[i].header != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; area-&gt;segment_maps[i].header-&gt;freed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L803" title="storage/ipc/dsm.c:803">dsm_detach</a>(area-&gt;segment_maps[i].segment);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; area-&gt;segment_maps[i].segment = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; area-&gt;segment_maps[i].header = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; area-&gt;segment_maps[i].mapped_address = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; area-&gt;freed_segment_counter = freed_segment_counter;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Re-bin segment if it's no longer in the appropriate bin.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2316">&#x200c;</a></span><span class="linkable">rebin_segment</span>(<a href="#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> *segment_map)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; new_bin;<br/></li>
<li>&nbsp; &nbsp; <a href="#L102" title="utils/mmgr/dsa.c:102">dsa_segment_index</a> segment_index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; new_bin = <a href="#L119" title="utils/mmgr/dsa.c:119">contiguous_pages_to_segment_bin</a>(fpm_largest(segment_map-&gt;fpm));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (segment_map-&gt;header-&gt;bin == new_bin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove it from its current bin. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1978" title="utils/mmgr/dsa.c:1978">unlink_segment</a>(area, segment_map);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push it onto the front of its new bin. */<br/></li>
<li></span>&nbsp; &nbsp; segment_index = <a href="#L379" title="utils/mmgr/dsa.c:379">get_segment_index</a>(area, segment_map);<br/></li>
<li>&nbsp; &nbsp; segment_map-&gt;header-&gt;prev = <a href="#L105" title="utils/mmgr/dsa.c:105">DSA_SEGMENT_INDEX_NONE</a>;<br/></li>
<li>&nbsp; &nbsp; segment_map-&gt;header-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = area-&gt;control-&gt;segment_bins[new_bin];<br/></li>
<li>&nbsp; &nbsp; segment_map-&gt;header-&gt;bin = new_bin;<br/></li>
<li>&nbsp; &nbsp; area-&gt;control-&gt;segment_bins[new_bin] = segment_index;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (segment_map-&gt;header-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> != <a href="#L105" title="utils/mmgr/dsa.c:105">DSA_SEGMENT_INDEX_NONE</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L339" title="utils/mmgr/dsa.c:339">dsa_segment_map</a> *<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <a href="#L1757" title="utils/mmgr/dsa.c:1757">get_segment_by_index</a>(area, segment_map-&gt;header-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-&gt;header-&gt;bin == new_bin);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-&gt;header-&gt;prev = segment_index;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
