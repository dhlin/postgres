<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/mmgr/aset.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/mmgr/aset.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L257">context_freelists</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L107">AllocBlock</a></li>
<li><a href="#L181">AllocBlockData</a></li>
<li><a href="#L188">AllocBlockData</a></li>
<li><a href="#L122">AllocFreeListLink</a></li>
<li><a href="#L125">AllocFreeListLink</a></li>
<li><a href="#L113">AllocPointer</a></li>
<li><a href="#L167">AllocSet</a></li>
<li><a href="#L152">AllocSetContext</a></li>
<li><a href="#L165">AllocSetContext</a></li>
<li><a href="#L250">AllocSetFreeList</a></li>
<li><a href="#L254">AllocSetFreeList</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L967">AllocSetAlloc</a></li>
<li><a href="#L774">AllocSetAllocChunkFromBlock</a></li>
<li><a href="#L819">AllocSetAllocFromNewBlock</a></li>
<li><a href="#L696">AllocSetAllocLarge</a></li>
<li><a href="#L1599">AllocSetCheck</a></li>
<li><a href="#L347">AllocSetContextCreateInternal</a></li>
<li><a href="#L607">AllocSetDelete</a></li>
<li><a href="#L1062">AllocSetFree</a></li>
<li><a href="#L277">AllocSetFreeIndex</a></li>
<li><a href="#L1433">AllocSetGetChunkContext</a></li>
<li><a href="#L1462">AllocSetGetChunkSpace</a></li>
<li><a href="#L1496">AllocSetIsEmpty</a></li>
<li><a href="#L1169">AllocSetRealloc</a></li>
<li><a href="#L537">AllocSetReset</a></li>
<li><a href="#L1521">AllocSetStats</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L84">ALLOCSET_NUM_FREELISTS</a></li>
<li><a href="#L104">ALLOC_BLOCKHDRSZ</a></li>
<li><a href="#L105">ALLOC_CHUNKHDRSZ</a></li>
<li><a href="#L87">ALLOC_CHUNK_FRACTION</a></li>
<li><a href="#L85">ALLOC_CHUNK_LIMIT</a></li>
<li><a href="#L83">ALLOC_MINBITS</a></li>
<li><a href="#L207">AllocBlockIsValid</a></li>
<li><a href="#L194">AllocPointerIsValid</a></li>
<li><a href="#L200">AllocSetIsValid</a></li>
<li><a href="#L215">ExternalChunkGetBlock</a></li>
<li><a href="#L136">FreeListIdxIsValid</a></li>
<li><a href="#L140">GetChunkSizeFromFreeListIdx</a></li>
<li><a href="#L132">GetFreeListLink</a></li>
<li><a href="#L248">IsKeeperBlock</a></li>
<li><a href="#L244">KeeperBlock</a></li>
<li><a href="#L241">MAX_FREE_CONTEXTS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * aset.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Allocation set definitions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L167" title="utils/mmgr/aset.c:167">AllocSet</a> is our standard implementation of the abstract MemoryContext<br/></li>
<li></span><span class="Comment"> * type.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/mmgr/aset.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This is a new (Feb. 05, 1999) implementation of the allocation set<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; routines. <a href="#L167" title="utils/mmgr/aset.c:167">AllocSet</a>...() does not use OrderedSet...() <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Instead it manages allocations in a block pool by itself, combining<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; many small allocations in a few bigger blocks. <a href="#L1062" title="utils/mmgr/aset.c:1062">AllocSetFree</a>() normally<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; doesn't free() memory really. It just add's the free'd area to some<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; list for later reuse by <a href="#L967" title="utils/mmgr/aset.c:967">AllocSetAlloc</a>(). All memory blocks are free()'d<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; at once on <a href="#L537" title="utils/mmgr/aset.c:537">AllocSetReset</a>(), which happens when the memory context gets<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; destroyed.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Jan Wieck<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Performance improvement from Tom Lane, 8/99: for extremely large request<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; sizes, we do want to be able to give the memory back to free() as soon<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; as it is <a href="mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>()'d.&nbsp; Otherwise we risk tying up a lot of memory in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; freelist entries that might never be usable.&nbsp; This is specially needed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; when the caller is repeatedly <a href="mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>()'ing a block bigger and bigger;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the previous instances of the block were guaranteed to be wasted until<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L537" title="utils/mmgr/aset.c:537">AllocSetReset</a>() under the old way.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Further improvement 12/00: as the code stood, request sizes in the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; midrange between &quot;small&quot; and &quot;large&quot; were handled very inefficiently,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; because <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sufficiently large free chunk would be used to satisfy a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; request, even if it was much larger than necessary.&nbsp; This led to more<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; and more wasted space in allocated chunks over time.&nbsp; To fix, get rid<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; of the midrange behavior: we <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> handle only &quot;small&quot; power-of-2-size<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; chunks as chunks.&nbsp; Anything &quot;large&quot; is passed off to malloc().&nbsp; Change<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the number of freelists to change the small/large boundary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memdebug.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils_memorychunk.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*--------------------<br/></li>
<li></span><span class="Comment"> * Chunk freelist k holds chunks of size 1 &lt;&lt; (k + <a href="#L83" title="utils/mmgr/aset.c:83">ALLOC_MINBITS</a>),<br/></li>
<li></span><span class="Comment"> * for k = 0 .. <a href="#L84" title="utils/mmgr/aset.c:84">ALLOCSET_NUM_FREELISTS</a>-1.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that all chunks in the freelists have power-of-2 sizes.&nbsp; This<br/></li>
<li></span><span class="Comment"> * improves recyclability: we may waste some space, but the wasted space<br/></li>
<li></span><span class="Comment"> * should stay pretty constant as requests are made and released.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A request too large for the last freelist is handled by allocating a<br/></li>
<li></span><span class="Comment"> * dedicated block from malloc().&nbsp; The block still has a block header and<br/></li>
<li></span><span class="Comment"> * chunk header, but when the chunk is freed we'll return the whole block<br/></li>
<li></span><span class="Comment"> * to malloc(), not put it on our freelists.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * CAUTION: <a href="#L83" title="utils/mmgr/aset.c:83">ALLOC_MINBITS</a> must be large enough so that<br/></li>
<li></span><span class="Comment"> * 1&lt;&lt;<a href="#L83" title="utils/mmgr/aset.c:83">ALLOC_MINBITS</a> is at least MAXALIGN,<br/></li>
<li></span><span class="Comment"> * or we may fail to align the smallest chunks adequately.<br/></li>
<li></span><span class="Comment"> * 8-byte alignment is enough on all currently known machines.&nbsp; This 8-byte<br/></li>
<li></span><span class="Comment"> * minimum also allows us to store a pointer to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> freelist item within<br/></li>
<li></span><span class="Comment"> * the chunk of memory itself.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * With the current parameters, request sizes up to 8K are treated as chunks,<br/></li>
<li></span><span class="Comment"> * larger requests go into dedicated blocks.&nbsp; Change <a href="#L84" title="utils/mmgr/aset.c:84">ALLOCSET_NUM_FREELISTS</a><br/></li>
<li></span><span class="Comment"> * to adjust the boundary point; and adjust ALLOCSET_SEPARATE_THRESHOLD in<br/></li>
<li></span><span class="Comment"> * memutils.h to agree.&nbsp; (Note: in contexts with small maxBlockSize, we may<br/></li>
<li></span><span class="Comment"> * set the allocChunkLimit to less than 8K, so as to avoid space wastage.)<br/></li>
<li></span><span class="Comment"> *--------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L83">&#x200c;</a><span class="PreProc">#define <span class="linkable">ALLOC_MINBITS</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">3</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* smallest chunk size is 8 bytes */<br/></li>
<li><a id="L84">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ALLOCSET_NUM_FREELISTS</span>&nbsp; &nbsp; </span><span class="Constant">11<br/></li>
<li><a id="L85">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ALLOC_CHUNK_LIMIT</span>&nbsp; &nbsp; (</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; (<a href="#L84" title="utils/mmgr/aset.c:84">ALLOCSET_NUM_FREELISTS</a>-</span><span class="Constant">1</span><span class="PreProc">+<a href="#L83" title="utils/mmgr/aset.c:83">ALLOC_MINBITS</a>))<br/></li>
<li></span><span class="Comment">/* Size of largest chunk that we use a fixed size for */<br/></li>
<li><a id="L87">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ALLOC_CHUNK_FRACTION</span>&nbsp; &nbsp; </span><span class="Constant">4<br/></li>
<li></span><span class="Comment">/* We allow chunks to be at most 1/4 of maxBlockSize (less overhead) */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*--------------------<br/></li>
<li></span><span class="Comment"> * The first block allocated for an allocset has size initBlockSize.<br/></li>
<li></span><span class="Comment"> * Each time we have to allocate another block, we double the block size<br/></li>
<li></span><span class="Comment"> * (if possible, and without exceeding maxBlockSize), so as to reduce<br/></li>
<li></span><span class="Comment"> * the bookkeeping load on malloc().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Blocks allocated to hold oversize chunks do not follow this rule, however;<br/></li>
<li></span><span class="Comment"> * they are just however big they need to be to hold that single chunk.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also, if a minContextSize is specified, the first block has that size,<br/></li>
<li></span><span class="Comment"> * and then initBlockSize is used for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one.<br/></li>
<li></span><span class="Comment"> *--------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L104">&#x200c;</a><span class="PreProc">#define <span class="linkable">ALLOC_BLOCKHDRSZ</span>&nbsp; &nbsp; MAXALIGN(</span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(<a href="#L181" title="utils/mmgr/aset.c:181">AllocBlockData</a>))<br/></li>
<li><a id="L105">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ALLOC_CHUNKHDRSZ</span>&nbsp; &nbsp; </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(MemoryChunk)<br/></li>
<li></span><br/></li>
<li><a id="L107">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <a href="#L181" title="utils/mmgr/aset.c:181">AllocBlockData</a> *<span class="linkable">AllocBlock</span>;&nbsp; &nbsp; <span class="Comment">/* forward reference */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L113" title="utils/mmgr/aset.c:113">AllocPointer</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Aligned pointer which may be a member of an allocation set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L113">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">void</span> *<span class="linkable">AllocPointer</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L122" title="utils/mmgr/aset.c:122">AllocFreeListLink</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; When pfreeing memory, if we maintain a freelist for the given chunk's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; size then we use a <a href="#L122" title="utils/mmgr/aset.c:122">AllocFreeListLink</a> to point to the current item in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the <a href="#L152" title="utils/mmgr/aset.c:152">AllocSetContext</a>'s freelist and then set the given freelist <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; to point to the chunk being freed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L122">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">AllocFreeListLink</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryChunk *<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><a id="L125">&#x200c;</a>} <span class="linkable">AllocFreeListLink</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Obtain a <a href="#L122" title="utils/mmgr/aset.c:122">AllocFreeListLink</a> for the given chunk.&nbsp; Allocation sizes are<br/></li>
<li></span><span class="Comment"> * always at least <a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(<a href="#L122" title="utils/mmgr/aset.c:122">AllocFreeListLink</a>), so we reuse the pointer's memory<br/></li>
<li></span><span class="Comment"> * itself to store the freelist link.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L132">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">GetFreeListLink</span>(chkptr) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (<a href="#L122" title="utils/mmgr/aset.c:122">AllocFreeListLink</a> *) ((</span><span class="Type">char</span><span class="PreProc"> *) (chkptr) + <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Validate a freelist index retrieved from a chunk header */<br/></li>
<li><a id="L136">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FreeListIdxIsValid</span>(fidx) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((fidx) &gt;= </span><span class="Constant">0</span><span class="PreProc"> &amp;&amp; (fidx) &lt; <a href="#L84" title="utils/mmgr/aset.c:84">ALLOCSET_NUM_FREELISTS</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Determine the size of the chunk based on the freelist index */<br/></li>
<li><a id="L140">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">GetChunkSizeFromFreeListIdx</span>(fidx) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((((Size) </span><span class="Constant">1</span><span class="PreProc">) &lt;&lt; <a href="#L83" title="utils/mmgr/aset.c:83">ALLOC_MINBITS</a>) &lt;&lt; (fidx))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L152" title="utils/mmgr/aset.c:152">AllocSetContext</a> is our standard implementation of MemoryContext.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: header.isReset means there is nothing for <a href="#L537" title="utils/mmgr/aset.c:537">AllocSetReset</a> to do.<br/></li>
<li></span><span class="Comment"> * This is different from the aset being physically empty (empty blocks list)<br/></li>
<li></span><span class="Comment"> * because we will still have a keeper block.&nbsp; It's also different from the set<br/></li>
<li></span><span class="Comment"> * being logically empty, because we don't attempt to detect <a href="mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>'ing the<br/></li>
<li></span><span class="Comment"> * last active chunk.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L152">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">AllocSetContext</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContextData header;&nbsp; &nbsp; <span class="Comment">/* Standard memory-context fields */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Info about storage allocated in this context: */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>&nbsp; &nbsp; blocks;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* head of list of blocks in this set */<br/></li>
<li></span>&nbsp; &nbsp; MemoryChunk *freelist[<a href="#L84" title="utils/mmgr/aset.c:84">ALLOCSET_NUM_FREELISTS</a>];&nbsp; &nbsp; <span class="Comment">/* free chunk lists */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Allocation parameters for this context: */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; initBlockSize;&nbsp; &nbsp; <span class="Comment">/* initial block size */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; maxBlockSize;&nbsp; &nbsp; <span class="Comment">/* maximum block size */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nextBlockSize;&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block size to allocate */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; allocChunkLimit;&nbsp; &nbsp; <span class="Comment">/* effective chunk size limit */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* freelist this context could be put in, or -1 if not a candidate: */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freeListIndex;&nbsp; &nbsp; <span class="Comment">/* index in <a href="#L257" title="utils/mmgr/aset.c:257">context_freelists</a>[], or -1 */<br/></li>
<li><a id="L165">&#x200c;</a></span>} <span class="linkable">AllocSetContext</span>;<br/></li>
<li><br/></li>
<li><a id="L167">&#x200c;</a><span class="Type">typedef</span> <a href="#L152" title="utils/mmgr/aset.c:152">AllocSetContext</a> *<span class="linkable">AllocSet</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; An <a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a> is the unit of memory that is obtained by aset.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; from malloc().&nbsp; It contains one or more MemoryChunks, which are<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the units requested by <a href="mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>() and freed by <a href="mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(). MemoryChunks<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; cannot be returned to malloc() individually, instead they are put<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; on freelists by <a href="mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>() and re-used by the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>() that has<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a matching request size.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L181" title="utils/mmgr/aset.c:181">AllocBlockData</a> is the header data for a block --- the usable space<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; within the block begins at the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> alignment boundary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L181">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">AllocBlockData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="utils/mmgr/aset.c:167">AllocSet</a>&nbsp; &nbsp; aset;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* aset that owns this block */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>&nbsp; &nbsp; prev;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* prev block in aset's blocks list, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>&nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block in aset's blocks list, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *freeptr;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* start of free space in this block */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endptr;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of space in this block */<br/></li>
<li><a id="L188">&#x200c;</a></span>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">AllocBlockData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L194" title="utils/mmgr/aset.c:194">AllocPointerIsValid</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; True iff pointer is valid allocation pointer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L194">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">AllocPointerIsValid</span>(pointer) PointerIsValid(pointer)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L200" title="utils/mmgr/aset.c:200">AllocSetIsValid</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; True iff set is valid allocation set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L200">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">AllocSetIsValid</span>(set) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (PointerIsValid(set) &amp;&amp; IsA(set, <a href="#L152" title="utils/mmgr/aset.c:152">AllocSetContext</a>))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L207" title="utils/mmgr/aset.c:207">AllocBlockIsValid</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; True iff block is valid block of allocation set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L207">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">AllocBlockIsValid</span>(block) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (PointerIsValid(block) &amp;&amp; <a href="#L200" title="utils/mmgr/aset.c:200">AllocSetIsValid</a>((block)-&gt;aset))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We always store external chunks on a dedicated block.&nbsp; This makes fetching<br/></li>
<li></span><span class="Comment"> * the block from an external chunk easy since it's always the first and only<br/></li>
<li></span><span class="Comment"> * chunk on the block.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L215">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ExternalChunkGetBlock</span>(chunk) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (<a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>) ((</span><span class="Type">char</span><span class="PreProc"> *) chunk - <a href="#L104" title="utils/mmgr/aset.c:104">ALLOC_BLOCKHDRSZ</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Rather than repeatedly creating and deleting memory contexts, we keep some<br/></li>
<li></span><span class="Comment"> * freed contexts in freelists so that we can hand them out again with little<br/></li>
<li></span><span class="Comment"> * work.&nbsp; Before putting a context in a freelist, we reset it so that it has<br/></li>
<li></span><span class="Comment"> * only its initial malloc chunk and no others.&nbsp; To be a candidate for a<br/></li>
<li></span><span class="Comment"> * freelist, a context must have the same minContextSize/initBlockSize as<br/></li>
<li></span><span class="Comment"> * other contexts in the list; but its maxBlockSize is irrelevant since that<br/></li>
<li></span><span class="Comment"> * doesn't affect the size of the initial chunk.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We currently provide one freelist for ALLOCSET_DEFAULT_SIZES contexts<br/></li>
<li></span><span class="Comment"> * and one for ALLOCSET_SMALL_SIZES contexts; the latter works for<br/></li>
<li></span><span class="Comment"> * ALLOCSET_START_SMALL_SIZES too, since only the maxBlockSize differs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Ordinarily, we re-use freelist contexts in last-in-first-out order, in<br/></li>
<li></span><span class="Comment"> * hopes of improving locality of reference.&nbsp; But if there get to be too<br/></li>
<li></span><span class="Comment"> * many contexts in the list, we'd prefer to drop the most-recently-created<br/></li>
<li></span><span class="Comment"> * contexts in hopes of keeping the process memory map <a href="../../regex/regc_nfa.c.html#L3479" title="regex/regc_nfa.c:3479">compact</a>.<br/></li>
<li></span><span class="Comment"> * We approximate that by simply deleting all existing entries when the list<br/></li>
<li></span><span class="Comment"> * overflows, on the assumption that queries that allocate a lot of contexts<br/></li>
<li></span><span class="Comment"> * will probably free them in more or less reverse order of allocation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Contexts in a freelist are chained via their nextchild pointers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L241">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_FREE_CONTEXTS</span> </span><span class="Constant">100</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* arbitrary limit on freelist length */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Obtain the keeper block for an allocation set */<br/></li>
<li><a id="L244">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">KeeperBlock</span>(set) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((<a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>) (((</span><span class="Type">char</span><span class="PreProc"> *) set) + MAXALIGN(</span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(<a href="#L152" title="utils/mmgr/aset.c:152">AllocSetContext</a>))))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Check if the block is the keeper block of the given allocation set */<br/></li>
<li><a id="L248">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">IsKeeperBlock</span>(set, block) ((block) == (<a href="#L244" title="utils/mmgr/aset.c:244">KeeperBlock</a>(set)))<br/></li>
<li></span><br/></li>
<li><a id="L250">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">AllocSetFreeList</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_free;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* current list length */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L152" title="utils/mmgr/aset.c:152">AllocSetContext</a> *first_free;&nbsp; &nbsp; <span class="Comment">/* list header */<br/></li>
<li><a id="L254">&#x200c;</a></span>} <span class="linkable">AllocSetFreeList</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L257" title="utils/mmgr/aset.c:257">context_freelists</a>[0] is for default params, [1] for small params */<br/></li>
<li><a id="L257">&#x200c;</a></span><span class="Type">static</span> <a href="#L250" title="utils/mmgr/aset.c:250">AllocSetFreeList</a> <span class="linkable">context_freelists</span>[<span class="Constant">2</span>] =<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>, <span class="Constant">NULL<br/></li>
<li></span>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>, <span class="Constant">NULL<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L277" title="utils/mmgr/aset.c:277">AllocSetFreeIndex</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Depending on the size of an allocation compute which freechunk<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; list of the alloc set it belongs to.&nbsp; Caller must have verified<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; that size &lt;= <a href="#L85" title="utils/mmgr/aset.c:85">ALLOC_CHUNK_LIMIT</a>.<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int<br/></li>
<li><a id="L277">&#x200c;</a></span><span class="linkable">AllocSetFreeIndex</span>(Size size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (size &gt; (<span class="Constant">1</span> &lt;&lt; <a href="#L83" title="utils/mmgr/aset.c:83">ALLOC_MINBITS</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At this point we must compute ceil(log2(size &gt;&gt; <a href="#L83" title="utils/mmgr/aset.c:83">ALLOC_MINBITS</a>)).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is the same as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; pg_leftmost_one_pos32((size - 1) &gt;&gt; <a href="#L83" title="utils/mmgr/aset.c:83">ALLOC_MINBITS</a>) + 1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or equivalently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; pg_leftmost_one_pos32(size - 1) - <a href="#L83" title="utils/mmgr/aset.c:83">ALLOC_MINBITS</a> + 1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, for platforms without intrinsic support, we duplicate the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * logic here, allowing an additional optimization.&nbsp; It's reasonable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to assume that <a href="#L85" title="utils/mmgr/aset.c:85">ALLOC_CHUNK_LIMIT</a> fits in 16 bits, so we can unroll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the byte-at-a-time loop in pg_leftmost_one_pos32 and just handle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the last two bytes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Yes, this function is enough of a hot-spot to make it worth this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * much trouble.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef HAVE_BITSCAN_REVERSE<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; idx = pg_leftmost_one_pos32((uint32) size - <span class="Constant">1</span>) - <a href="#L83" title="utils/mmgr/aset.c:83">ALLOC_MINBITS</a> + <span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; t,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Statically assert that we only have a 16-<a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> input value. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; StaticAssertDecl(<a href="#L85" title="utils/mmgr/aset.c:85">ALLOC_CHUNK_LIMIT</a> &lt; (<span class="Constant">1</span> &lt;&lt; <span class="Constant">16</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="#L85" title="utils/mmgr/aset.c:85">ALLOC_CHUNK_LIMIT</a> must be less than 64kB&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tsize = size - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; t = tsize &gt;&gt; <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idx = t ? pg_leftmost_one_pos[t] + <span class="Constant">8</span> : pg_leftmost_one_pos[tsize];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idx -= <a href="#L83" title="utils/mmgr/aset.c:83">ALLOC_MINBITS</a> - <span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(idx &lt; <a href="#L84" title="utils/mmgr/aset.c:84">ALLOCSET_NUM_FREELISTS</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; idx = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> idx;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Public routines<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L347" title="utils/mmgr/aset.c:347">AllocSetContextCreateInternal</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Create a new <a href="#L167" title="utils/mmgr/aset.c:167">AllocSet</a> context.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * parent: parent context, or NULL if top-level context<br/></li>
<li></span><span class="Comment"> * name: name of context (must be statically allocated)<br/></li>
<li></span><span class="Comment"> * minContextSize: minimum context size<br/></li>
<li></span><span class="Comment"> * initBlockSize: initial allocation block size<br/></li>
<li></span><span class="Comment"> * maxBlockSize: maximum allocation block size<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Most callers should abstract the context size parameters using a macro<br/></li>
<li></span><span class="Comment"> * such as ALLOCSET_DEFAULT_SIZES.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: don't call this directly; go through the wrapper macro<br/></li>
<li></span><span class="Comment"> * AllocSetContextCreate.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MemoryContext<br/></li>
<li><a id="L347">&#x200c;</a><span class="linkable">AllocSetContextCreateInternal</span>(MemoryContext parent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size minContextSize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size initBlockSize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size maxBlockSize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freeListIndex;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; firstBlockSize;<br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="utils/mmgr/aset.c:167">AllocSet</a>&nbsp; &nbsp; set;<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>&nbsp; &nbsp; block;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ensure MemoryChunk's size is properly maxaligned */<br/></li>
<li></span>&nbsp; &nbsp; StaticAssertDecl(<a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a> == MAXALIGN(<a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(MemoryChunk) is not maxaligned&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check we have enough space to store the freelist link */<br/></li>
<li></span>&nbsp; &nbsp; StaticAssertDecl(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L122" title="utils/mmgr/aset.c:122">AllocFreeListLink</a>) &lt;= (<span class="Constant">1</span> &lt;&lt; <a href="#L83" title="utils/mmgr/aset.c:83">ALLOC_MINBITS</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(<a href="#L122" title="utils/mmgr/aset.c:122">AllocFreeListLink</a>) larger than minimum allocation size&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, validate allocation parameters.&nbsp; Once these were regular runtime<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tests and elog's, but in practice Asserts seem sufficient because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nobody varies their parameters at runtime.&nbsp; We somewhat arbitrarily<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enforce a minimum 1K block size.&nbsp; We restrict the maximum block size to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MEMORYCHUNK_MAX_BLOCKOFFSET as MemoryChunks are limited to this in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * regards to addressing the offset between the chunk and the block that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the chunk is stored on.&nbsp; We would be unable to store the offset between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the chunk and block for <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> chunks that were beyond<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MEMORYCHUNK_MAX_BLOCKOFFSET bytes into the block if the block was to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * larger than this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(initBlockSize == MAXALIGN(initBlockSize) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; initBlockSize &gt;= <span class="Constant">1024</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(maxBlockSize == MAXALIGN(maxBlockSize) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; maxBlockSize &gt;= initBlockSize &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AllocHugeSizeIsValid(maxBlockSize)); <span class="Comment">/* must be safe to double */<br/></li>
<li></span>&nbsp; &nbsp; Assert(minContextSize == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (minContextSize == MAXALIGN(minContextSize) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minContextSize &gt;= <span class="Constant">1024</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minContextSize &lt;= maxBlockSize));<br/></li>
<li>&nbsp; &nbsp; Assert(maxBlockSize &lt;= MEMORYCHUNK_MAX_BLOCKOFFSET);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check whether the parameters match either available freelist.&nbsp; We do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not need to demand a match of maxBlockSize.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (minContextSize == ALLOCSET_DEFAULT_MINSIZE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initBlockSize == ALLOCSET_DEFAULT_INITSIZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freeListIndex = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (minContextSize == ALLOCSET_SMALL_MINSIZE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; initBlockSize == ALLOCSET_SMALL_INITSIZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freeListIndex = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; freeListIndex = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If a suitable freelist entry exists, just recycle that context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (freeListIndex &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L250" title="utils/mmgr/aset.c:250">AllocSetFreeList</a> *freelist = &amp;<a href="#L257" title="utils/mmgr/aset.c:257">context_freelists</a>[freeListIndex];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (freelist-&gt;first_free != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remove entry from freelist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set = freelist-&gt;first_free;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freelist-&gt;first_free = (<a href="#L167" title="utils/mmgr/aset.c:167">AllocSet</a>) set-&gt;header.nextchild;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freelist-&gt;num_free--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update its maxBlockSize; everything else should be OK */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set-&gt;maxBlockSize = maxBlockSize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reinitialize its header, installing correct name and parent */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="mcxt.c.html#L1100" title="utils/mmgr/mcxt.c:1100">MemoryContextCreate</a>((MemoryContext) set,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; T_AllocSetContext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MCTX_ASET_ID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((MemoryContext) set)-&gt;mem_allocated =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L244" title="utils/mmgr/aset.c:244">KeeperBlock</a>(set)-&gt;endptr - ((<span class="Type">char</span> *) set);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (MemoryContext) set;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine size of initial block */<br/></li>
<li></span>&nbsp; &nbsp; firstBlockSize = MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L152" title="utils/mmgr/aset.c:152">AllocSetContext</a>)) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L104" title="utils/mmgr/aset.c:104">ALLOC_BLOCKHDRSZ</a> + <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (minContextSize != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; firstBlockSize = Max(firstBlockSize, minContextSize);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; firstBlockSize = Max(firstBlockSize, initBlockSize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate the initial block.&nbsp; Unlike other aset.c blocks, it starts with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the context header and its block header follows that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; set = (<a href="#L167" title="utils/mmgr/aset.c:167">AllocSet</a>) malloc(firstBlockSize);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (set == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="mcxt.c.html#L814" title="utils/mmgr/mcxt.c:814">MemoryContextStats</a>(<a href="mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failed while creating memory context </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Avoid writing code that can fail between here and <a href="mcxt.c.html#L1100" title="utils/mmgr/mcxt.c:1100">MemoryContextCreate</a>;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we'd leak the header/initial block if we ereport in this stretch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fill in the initial block's block header */<br/></li>
<li></span>&nbsp; &nbsp; block = <a href="#L244" title="utils/mmgr/aset.c:244">KeeperBlock</a>(set);<br/></li>
<li>&nbsp; &nbsp; block-&gt;aset = set;<br/></li>
<li>&nbsp; &nbsp; block-&gt;freeptr = ((<span class="Type">char</span> *) block) + <a href="#L104" title="utils/mmgr/aset.c:104">ALLOC_BLOCKHDRSZ</a>;<br/></li>
<li>&nbsp; &nbsp; block-&gt;endptr = ((<span class="Type">char</span> *) set) + firstBlockSize;<br/></li>
<li>&nbsp; &nbsp; block-&gt;prev = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; block-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark unallocated space NOACCESS; leave the block header alone. */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(block-&gt;freeptr, block-&gt;endptr - block-&gt;freeptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remember block as part of block list */<br/></li>
<li></span>&nbsp; &nbsp; set-&gt;blocks = block;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finish filling in aset-specific parts of the context header */<br/></li>
<li></span>&nbsp; &nbsp; MemSetAligned(set-&gt;freelist, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(set-&gt;freelist));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; set-&gt;initBlockSize = (uint32) initBlockSize;<br/></li>
<li>&nbsp; &nbsp; set-&gt;maxBlockSize = (uint32) maxBlockSize;<br/></li>
<li>&nbsp; &nbsp; set-&gt;nextBlockSize = (uint32) initBlockSize;<br/></li>
<li>&nbsp; &nbsp; set-&gt;freeListIndex = freeListIndex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute the allocation chunk size limit for this context.&nbsp; It can't be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more than <a href="#L85" title="utils/mmgr/aset.c:85">ALLOC_CHUNK_LIMIT</a> because of the fixed number of freelists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If maxBlockSize is small then requests exceeding the maxBlockSize, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * even a significant fraction of it, should be treated as large chunks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * too.&nbsp; For the typical case of maxBlockSize a power of 2, the chunk size<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * limit will be at most 1/8th maxBlockSize, so that given a stream of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requests that are all the maximum chunk size we will waste at most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 1/8th of the allocated space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, allocChunkLimit must not exceed ALLOCSET_SEPARATE_THRESHOLD.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; StaticAssertStmt(<a href="#L85" title="utils/mmgr/aset.c:85">ALLOC_CHUNK_LIMIT</a> == ALLOCSET_SEPARATE_THRESHOLD,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="#L85" title="utils/mmgr/aset.c:85">ALLOC_CHUNK_LIMIT</a> != ALLOCSET_SEPARATE_THRESHOLD&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the maximum size that a chunk can be <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we allocate an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entire <a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a> dedicated for that chunk.&nbsp; We set the absolute limit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of that size as <a href="#L85" title="utils/mmgr/aset.c:85">ALLOC_CHUNK_LIMIT</a> but we reduce it further so that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can fit about <a href="#L87" title="utils/mmgr/aset.c:87">ALLOC_CHUNK_FRACTION</a> chunks this size on a maximally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sized block.&nbsp; (We opt to keep allocChunkLimit a power-of-2 value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * primarily for legacy reasons rather than calculating it so that exactly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L87" title="utils/mmgr/aset.c:87">ALLOC_CHUNK_FRACTION</a> chunks fit on a maximally sized block.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; set-&gt;allocChunkLimit = <a href="#L85" title="utils/mmgr/aset.c:85">ALLOC_CHUNK_LIMIT</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((Size) (set-&gt;allocChunkLimit + <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>) &gt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Size) ((maxBlockSize - <a href="#L104" title="utils/mmgr/aset.c:104">ALLOC_BLOCKHDRSZ</a>) / <a href="#L87" title="utils/mmgr/aset.c:87">ALLOC_CHUNK_FRACTION</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set-&gt;allocChunkLimit &gt;&gt;= <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finally, do the type-independent part of context creation */<br/></li>
<li></span>&nbsp; &nbsp; <a href="mcxt.c.html#L1100" title="utils/mmgr/mcxt.c:1100">MemoryContextCreate</a>((MemoryContext) set,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; T_AllocSetContext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MCTX_ASET_ID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ((MemoryContext) set)-&gt;mem_allocated = firstBlockSize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (MemoryContext) set;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L537" title="utils/mmgr/aset.c:537">AllocSetReset</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Frees all memory which is allocated in the given set.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Actually, this routine has some discretion about what to do.<br/></li>
<li></span><span class="Comment"> * It should mark all allocated chunks freed, but it need not necessarily<br/></li>
<li></span><span class="Comment"> * give back all the resources the set owns.&nbsp; Our actual implementation is<br/></li>
<li></span><span class="Comment"> * that we give back all but the &quot;keeper&quot; block (which we must keep, since<br/></li>
<li></span><span class="Comment"> * it shares a malloc chunk with the context header).&nbsp; In this way, we don't<br/></li>
<li></span><span class="Comment"> * thrash malloc() when a context is repeatedly reset after small allocations,<br/></li>
<li></span><span class="Comment"> * which is typical behavior for per-tuple contexts.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L537">&#x200c;</a></span><span class="linkable">AllocSetReset</span>(MemoryContext context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="utils/mmgr/aset.c:167">AllocSet</a>&nbsp; &nbsp; set = (<a href="#L167" title="utils/mmgr/aset.c:167">AllocSet</a>) context;<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>&nbsp; &nbsp; block;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; keepersize <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L200" title="utils/mmgr/aset.c:200">AllocSetIsValid</a>(set));<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Check for corruption and leaks <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> freeing */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1599" title="utils/mmgr/aset.c:1599">AllocSetCheck</a>(context);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remember keeper block size for Assert below */<br/></li>
<li></span>&nbsp; &nbsp; keepersize = <a href="#L244" title="utils/mmgr/aset.c:244">KeeperBlock</a>(set)-&gt;endptr - ((<span class="Type">char</span> *) set);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clear chunk freelists */<br/></li>
<li></span>&nbsp; &nbsp; MemSetAligned(set-&gt;freelist, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(set-&gt;freelist));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; block = set-&gt;blocks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* New blocks list will be just the keeper block */<br/></li>
<li></span>&nbsp; &nbsp; set-&gt;blocks = <a href="#L244" title="utils/mmgr/aset.c:244">KeeperBlock</a>(set);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (block != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>&nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = block-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L248" title="utils/mmgr/aset.c:248">IsKeeperBlock</a>(set, block))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset the block, but don't return it to malloc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *datastart = ((<span class="Type">char</span> *) block) + <a href="#L104" title="utils/mmgr/aset.c:104">ALLOC_BLOCKHDRSZ</a>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef CLOBBER_FREED_MEMORY<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wipe_mem(datastart, block-&gt;freeptr - datastart);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wipe_mem() would have done this */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(datastart, block-&gt;freeptr - datastart);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block-&gt;freeptr = datastart;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block-&gt;prev = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Normal case, release the block */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;mem_allocated -= block-&gt;endptr - ((<span class="Type">char</span> *) block);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef CLOBBER_FREED_MEMORY<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wipe_mem(block, block-&gt;freeptr - ((<span class="Type">char</span> *) block));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free(block);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; block = <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(context-&gt;mem_allocated == keepersize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset block size allocation sequence, too */<br/></li>
<li></span>&nbsp; &nbsp; set-&gt;nextBlockSize = set-&gt;initBlockSize;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L607" title="utils/mmgr/aset.c:607">AllocSetDelete</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Frees all memory which is allocated in the given set,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; in preparation for deletion of the set.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike <a href="#L537" title="utils/mmgr/aset.c:537">AllocSetReset</a>, this *must* free all resources of the set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L607">&#x200c;</a></span><span class="linkable">AllocSetDelete</span>(MemoryContext context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="utils/mmgr/aset.c:167">AllocSet</a>&nbsp; &nbsp; set = (<a href="#L167" title="utils/mmgr/aset.c:167">AllocSet</a>) context;<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>&nbsp; &nbsp; block = set-&gt;blocks;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; keepersize <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L200" title="utils/mmgr/aset.c:200">AllocSetIsValid</a>(set));<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Check for corruption and leaks <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> freeing */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1599" title="utils/mmgr/aset.c:1599">AllocSetCheck</a>(context);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remember keeper block size for Assert below */<br/></li>
<li></span>&nbsp; &nbsp; keepersize = <a href="#L244" title="utils/mmgr/aset.c:244">KeeperBlock</a>(set)-&gt;endptr - ((<span class="Type">char</span> *) set);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the context is a candidate for a freelist, put it into that freelist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * instead of destroying it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (set-&gt;freeListIndex &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L250" title="utils/mmgr/aset.c:250">AllocSetFreeList</a> *freelist = &amp;<a href="#L257" title="utils/mmgr/aset.c:257">context_freelists</a>[set-&gt;freeListIndex];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset the context, if it needs it, so that we aren't hanging on to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more than the initial malloc chunk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!context-&gt;isReset)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="mcxt.c.html#L402" title="utils/mmgr/mcxt.c:402">MemoryContextResetOnly</a>(context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the freelist is full, just discard what's already in it.&nbsp; See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comments with <a href="#L257" title="utils/mmgr/aset.c:257">context_freelists</a>[].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (freelist-&gt;num_free &gt;= <a href="#L241" title="utils/mmgr/aset.c:241">MAX_FREE_CONTEXTS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (freelist-&gt;first_free != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L152" title="utils/mmgr/aset.c:152">AllocSetContext</a> *oldset = freelist-&gt;first_free;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freelist-&gt;first_free = (<a href="#L152" title="utils/mmgr/aset.c:152">AllocSetContext</a> *) oldset-&gt;header.nextchild;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freelist-&gt;num_free--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* All that remains is to free the header/initial block */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free(oldset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(freelist-&gt;num_free == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now add the just-deleted context to the freelist. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; set-&gt;header.nextchild = (MemoryContext) freelist-&gt;first_free;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freelist-&gt;first_free = set;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freelist-&gt;num_free++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Free all blocks, except the keeper which is part of context header */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (block != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>&nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = block-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L248" title="utils/mmgr/aset.c:248">IsKeeperBlock</a>(set, block))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;mem_allocated -= block-&gt;endptr - ((<span class="Type">char</span> *) block);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef CLOBBER_FREED_MEMORY<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; wipe_mem(block, block-&gt;freeptr - ((<span class="Type">char</span> *) block));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L248" title="utils/mmgr/aset.c:248">IsKeeperBlock</a>(set, block))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free(block);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; block = <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(context-&gt;mem_allocated == keepersize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finally, free the context header, including the keeper block */<br/></li>
<li></span>&nbsp; &nbsp; free(set);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper for <a href="#L967" title="utils/mmgr/aset.c:967">AllocSetAlloc</a>() that allocates an entire block for the chunk.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L967" title="utils/mmgr/aset.c:967">AllocSetAlloc</a>()'s comment explains why this is separate.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>pg_noinline<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> *<br/></li>
<li><a id="L696">&#x200c;</a><span class="linkable">AllocSetAllocLarge</span>(MemoryContext context, Size size, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="utils/mmgr/aset.c:167">AllocSet</a>&nbsp; &nbsp; set = (<a href="#L167" title="utils/mmgr/aset.c:167">AllocSet</a>) context;<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>&nbsp; &nbsp; block;<br/></li>
<li>&nbsp; &nbsp; MemoryChunk *chunk;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; chunk_size;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; blksize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* validate 'size' is within the limits for the given 'flags' */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextCheckSize(context, size, flags);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* ensure there's always space for the <a href="../../lib/rbtree.c.html#L63" title="lib/rbtree.c:63">sentinel</a> byte */<br/></li>
<li></span>&nbsp; &nbsp; chunk_size = MAXALIGN(size + <span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; chunk_size = MAXALIGN(size);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; blksize = chunk_size + <a href="#L104" title="utils/mmgr/aset.c:104">ALLOC_BLOCKHDRSZ</a> + <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>;<br/></li>
<li>&nbsp; &nbsp; block = (<a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>) malloc(blksize);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (block == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="mcxt.c.html#L1147" title="utils/mmgr/mcxt.c:1147">MemoryContextAllocationFailure</a>(context, size, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context-&gt;mem_allocated += blksize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; block-&gt;aset = set;<br/></li>
<li>&nbsp; &nbsp; block-&gt;freeptr = block-&gt;endptr = ((<span class="Type">char</span> *) block) + blksize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; chunk = (MemoryChunk *) (((<span class="Type">char</span> *) block) + <a href="#L104" title="utils/mmgr/aset.c:104">ALLOC_BLOCKHDRSZ</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* mark the MemoryChunk as externally managed */<br/></li>
<li></span>&nbsp; &nbsp; MemoryChunkSetHdrMaskExternal(chunk, MCTX_ASET_ID);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; chunk-&gt;requested_size = size;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set mark to catch clobber of &quot;unused&quot; space */<br/></li>
<li></span>&nbsp; &nbsp; Assert(size &lt; chunk_size);<br/></li>
<li>&nbsp; &nbsp; set_sentinel(MemoryChunkGetPointer(chunk), size);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef RANDOMIZE_ALLOCATED_MEMORY<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* fill the allocated space with junk */<br/></li>
<li></span>&nbsp; &nbsp; <a href="memdebug.c.html#L75" title="utils/mmgr/memdebug.c:75">randomize_mem</a>((<span class="Type">char</span> *) MemoryChunkGetPointer(chunk), size);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Stick the new block underneath the active allocation block, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we don't lose the use of the space remaining therein.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (set-&gt;blocks != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; block-&gt;prev = set-&gt;blocks;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; block-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = set-&gt;blocks-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (block-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-&gt;prev = block;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set-&gt;blocks-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = block;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; block-&gt;prev = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; block-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set-&gt;blocks = block;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> padding bytes are marked NOACCESS. */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS((<span class="Type">char</span> *) MemoryChunkGetPointer(chunk) + size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; chunk_size - size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Disallow access to the chunk header. */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(chunk, <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> MemoryChunkGetPointer(chunk);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Small helper for allocating a new chunk from a chunk, to avoid duplicating<br/></li>
<li></span><span class="Comment"> * the code between <a href="#L967" title="utils/mmgr/aset.c:967">AllocSetAlloc</a>() and <a href="#L819" title="utils/mmgr/aset.c:819">AllocSetAllocFromNewBlock</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> *<br/></li>
<li><a id="L774">&#x200c;</a><span class="linkable">AllocSetAllocChunkFromBlock</span>(MemoryContext context, <a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a> block,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size size, Size chunk_size, <span class="Type">int</span> fidx)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryChunk *chunk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; chunk = (MemoryChunk *) (block-&gt;freeptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the chunk header. */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_UNDEFINED(chunk, <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; block-&gt;freeptr += (chunk_size + <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(block-&gt;freeptr &lt;= block-&gt;endptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* store the free list index in the value field */<br/></li>
<li></span>&nbsp; &nbsp; MemoryChunkSetHdrMask(chunk, block, fidx, MCTX_ASET_ID);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; chunk-&gt;requested_size = size;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set mark to catch clobber of &quot;unused&quot; space */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (size &lt; chunk_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set_sentinel(MemoryChunkGetPointer(chunk), size);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef RANDOMIZE_ALLOCATED_MEMORY<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* fill the allocated space with junk */<br/></li>
<li></span>&nbsp; &nbsp; <a href="memdebug.c.html#L75" title="utils/mmgr/memdebug.c:75">randomize_mem</a>((<span class="Type">char</span> *) MemoryChunkGetPointer(chunk), size);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> padding bytes are marked NOACCESS. */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS((<span class="Type">char</span> *) MemoryChunkGetPointer(chunk) + size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; chunk_size - size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Disallow access to the chunk header. */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(chunk, <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> MemoryChunkGetPointer(chunk);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper for <a href="#L967" title="utils/mmgr/aset.c:967">AllocSetAlloc</a>() that allocates a new block and returns a chunk<br/></li>
<li></span><span class="Comment"> * allocated from it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L967" title="utils/mmgr/aset.c:967">AllocSetAlloc</a>()'s comment explains why this is separate.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>pg_noinline<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> *<br/></li>
<li><a id="L819">&#x200c;</a><span class="linkable">AllocSetAllocFromNewBlock</span>(MemoryContext context, Size size, <span class="Type">int</span> flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> fidx)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="utils/mmgr/aset.c:167">AllocSet</a>&nbsp; &nbsp; set = (<a href="#L167" title="utils/mmgr/aset.c:167">AllocSet</a>) context;<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>&nbsp; &nbsp; block;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; availspace;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; blksize;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; required_size;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; chunk_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* due to the keeper block set-&gt;blocks should always be valid */<br/></li>
<li></span>&nbsp; &nbsp; Assert(set-&gt;blocks != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; block = set-&gt;blocks;<br/></li>
<li>&nbsp; &nbsp; availspace = block-&gt;endptr - block-&gt;freeptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The existing active (top) block does not have enough room for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requested allocation, but it might still have a useful amount of space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in it.&nbsp; Once we <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> it down in the block list, we'll never try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocate more space from it. So, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we do that, carve up its free<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * space into chunks that we can put on the set's freelists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because we can only get here when there's less than <a href="#L85" title="utils/mmgr/aset.c:85">ALLOC_CHUNK_LIMIT</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * left in the block, this loop cannot iterate more than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L84" title="utils/mmgr/aset.c:84">ALLOCSET_NUM_FREELISTS</a>-1 times.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (availspace &gt;= ((<span class="Constant">1</span> &lt;&lt; <a href="#L83" title="utils/mmgr/aset.c:83">ALLOC_MINBITS</a>) + <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L122" title="utils/mmgr/aset.c:122">AllocFreeListLink</a> *link;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryChunk *chunk;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; availchunk = availspace - <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a_fidx = <a href="#L277" title="utils/mmgr/aset.c:277">AllocSetFreeIndex</a>(availchunk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In most cases, we'll get back the index of the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> larger freelist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than the one we need to put this chunk on.&nbsp; The exception is when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * availchunk is exactly a power of 2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (availchunk != <a href="#L140" title="utils/mmgr/aset.c:140">GetChunkSizeFromFreeListIdx</a>(a_fidx))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a_fidx--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(a_fidx &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; availchunk = <a href="#L140" title="utils/mmgr/aset.c:140">GetChunkSizeFromFreeListIdx</a>(a_fidx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; chunk = (MemoryChunk *) (block-&gt;freeptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prepare to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the chunk header. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_UNDEFINED(chunk, <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; block-&gt;freeptr += (availchunk + <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; availspace -= (availchunk + <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* store the freelist index in the value field */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryChunkSetHdrMask(chunk, block, a_fidx, MCTX_ASET_ID);<br/></li>
<li><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; chunk-&gt;requested_size = InvalidAllocSize;&nbsp; &nbsp; <span class="Comment">/* mark it free */<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> this chunk onto the free list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; link = <a href="#L132" title="utils/mmgr/aset.c:132">GetFreeListLink</a>(chunk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(link, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L122" title="utils/mmgr/aset.c:122">AllocFreeListLink</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; link-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = set-&gt;freelist[a_fidx];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(link, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L122" title="utils/mmgr/aset.c:122">AllocFreeListLink</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set-&gt;freelist[a_fidx] = chunk;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The first such block has size initBlockSize, and we double the space in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * each succeeding block, but not more than maxBlockSize.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; blksize = set-&gt;nextBlockSize;<br/></li>
<li>&nbsp; &nbsp; set-&gt;nextBlockSize &lt;&lt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (set-&gt;nextBlockSize &gt; set-&gt;maxBlockSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set-&gt;nextBlockSize = set-&gt;maxBlockSize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Choose the actual chunk size to allocate */<br/></li>
<li></span>&nbsp; &nbsp; chunk_size = <a href="#L140" title="utils/mmgr/aset.c:140">GetChunkSizeFromFreeListIdx</a>(fidx);<br/></li>
<li>&nbsp; &nbsp; Assert(chunk_size &gt;= size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If initBlockSize is less than <a href="#L85" title="utils/mmgr/aset.c:85">ALLOC_CHUNK_LIMIT</a>, we could need more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * space... but try to keep it a power of 2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; required_size = chunk_size + <a href="#L104" title="utils/mmgr/aset.c:104">ALLOC_BLOCKHDRSZ</a> + <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (blksize &lt; required_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blksize &lt;&lt;= <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to allocate it */<br/></li>
<li></span>&nbsp; &nbsp; block = (<a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>) malloc(blksize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We could be asking for pretty big blocks here, so cope if malloc fails.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * But give up if there's less than 1 MB or so available...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (block == <span class="Constant">NULL</span> &amp;&amp; blksize &gt; <span class="Constant">1024</span> * <span class="Constant">1024</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blksize &gt;&gt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blksize &lt; required_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; block = (<a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>) malloc(blksize);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (block == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="mcxt.c.html#L1147" title="utils/mmgr/mcxt.c:1147">MemoryContextAllocationFailure</a>(context, size, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context-&gt;mem_allocated += blksize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; block-&gt;aset = set;<br/></li>
<li>&nbsp; &nbsp; block-&gt;freeptr = ((<span class="Type">char</span> *) block) + <a href="#L104" title="utils/mmgr/aset.c:104">ALLOC_BLOCKHDRSZ</a>;<br/></li>
<li>&nbsp; &nbsp; block-&gt;endptr = ((<span class="Type">char</span> *) block) + blksize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark unallocated space NOACCESS. */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(block-&gt;freeptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blksize - <a href="#L104" title="utils/mmgr/aset.c:104">ALLOC_BLOCKHDRSZ</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; block-&gt;prev = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; block-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = set-&gt;blocks;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (block-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; block-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-&gt;prev = block;<br/></li>
<li>&nbsp; &nbsp; set-&gt;blocks = block;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L774" title="utils/mmgr/aset.c:774">AllocSetAllocChunkFromBlock</a>(context, block, size, chunk_size, fidx);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L967" title="utils/mmgr/aset.c:967">AllocSetAlloc</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns a pointer to allocated memory of given size or raises an ERROR<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; on allocation failure, or returns NULL when flags contains<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; MCXT_ALLOC_NO_OOM.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * No request may exceed:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN_DOWN(SIZE_MAX) - <a href="#L104" title="utils/mmgr/aset.c:104">ALLOC_BLOCKHDRSZ</a> - <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a><br/></li>
<li></span><span class="Comment"> * All callers use a much-<a href="../adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> limit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: when using valgrind, it doesn't matter how the returned allocation<br/></li>
<li></span><span class="Comment"> * is marked, as mcxt.c will set it to UNDEFINED.&nbsp; In some paths we will<br/></li>
<li></span><span class="Comment"> * return space that is marked NOACCESS - <a href="#L1169" title="utils/mmgr/aset.c:1169">AllocSetRealloc</a> has to beware!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function should only contain the most common code paths.&nbsp; Everything<br/></li>
<li></span><span class="Comment"> * else should be in pg_noinline helper <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, thus avoiding the overhead<br/></li>
<li></span><span class="Comment"> * of creating a stack frame for the common cases.&nbsp; Allocating memory is often<br/></li>
<li></span><span class="Comment"> * a bottleneck in many workloads, so avoiding stack frame setup is<br/></li>
<li></span><span class="Comment"> * worthwhile.&nbsp; Helper <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> should always directly return the newly<br/></li>
<li></span><span class="Comment"> * allocated memory so that we can just return that address directly as a tail<br/></li>
<li></span><span class="Comment"> * call.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L967">&#x200c;</a><span class="linkable">AllocSetAlloc</span>(MemoryContext context, Size size, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="utils/mmgr/aset.c:167">AllocSet</a>&nbsp; &nbsp; set = (<a href="#L167" title="utils/mmgr/aset.c:167">AllocSet</a>) context;<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>&nbsp; &nbsp; block;<br/></li>
<li>&nbsp; &nbsp; MemoryChunk *chunk;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fidx;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; chunk_size;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; availspace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L200" title="utils/mmgr/aset.c:200">AllocSetIsValid</a>(set));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* due to the keeper block set-&gt;blocks should never be NULL */<br/></li>
<li></span>&nbsp; &nbsp; Assert(set-&gt;blocks != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If requested size exceeds maximum for chunks we hand the request off to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L696" title="utils/mmgr/aset.c:696">AllocSetAllocLarge</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (size &gt; set-&gt;allocChunkLimit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L696" title="utils/mmgr/aset.c:696">AllocSetAllocLarge</a>(context, size, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Request is small enough to be treated as a chunk.&nbsp; Look in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corresponding free list to see if there is a free chunk we could reuse.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If one is found, remove it from the free list, make it again a member<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the alloc set and return its data address.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we don't attempt to ensure there's space for the <a href="../../lib/rbtree.c.html#L63" title="lib/rbtree.c:63">sentinel</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * byte here.&nbsp; We expect a large proportion of allocations to be for sizes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which are already a power of 2.&nbsp; If we were to always make space for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../lib/rbtree.c.html#L63" title="lib/rbtree.c:63">sentinel</a> byte in MEMORY_CONTEXT_CHECKING builds, then we'd end up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doubling the memory requirements for such allocations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fidx = <a href="#L277" title="utils/mmgr/aset.c:277">AllocSetFreeIndex</a>(size);<br/></li>
<li>&nbsp; &nbsp; chunk = set-&gt;freelist[fidx];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (chunk != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L122" title="utils/mmgr/aset.c:122">AllocFreeListLink</a> *link = <a href="#L132" title="utils/mmgr/aset.c:132">GetFreeListLink</a>(chunk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allow access to the chunk header. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(chunk, <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(fidx == MemoryChunkGetValue(chunk));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pop this chunk off the freelist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(link, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L122" title="utils/mmgr/aset.c:122">AllocFreeListLink</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set-&gt;freelist[fidx] = link-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(link, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L122" title="utils/mmgr/aset.c:122">AllocFreeListLink</a>));<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; chunk-&gt;requested_size = size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set mark to catch clobber of &quot;unused&quot; space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (size &lt; <a href="#L140" title="utils/mmgr/aset.c:140">GetChunkSizeFromFreeListIdx</a>(fidx))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_sentinel(MemoryChunkGetPointer(chunk), size);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef RANDOMIZE_ALLOCATED_MEMORY<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fill the allocated space with junk */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="memdebug.c.html#L75" title="utils/mmgr/memdebug.c:75">randomize_mem</a>((<span class="Type">char</span> *) MemoryChunkGetPointer(chunk), size);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ensure <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> padding bytes are marked NOACCESS. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS((<span class="Type">char</span> *) MemoryChunkGetPointer(chunk) + size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L140" title="utils/mmgr/aset.c:140">GetChunkSizeFromFreeListIdx</a>(fidx) - size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Disallow access to the chunk header. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(chunk, <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> MemoryChunkGetPointer(chunk);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Choose the actual chunk size to allocate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; chunk_size = <a href="#L140" title="utils/mmgr/aset.c:140">GetChunkSizeFromFreeListIdx</a>(fidx);<br/></li>
<li>&nbsp; &nbsp; Assert(chunk_size &gt;= size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; block = set-&gt;blocks;<br/></li>
<li>&nbsp; &nbsp; availspace = block-&gt;endptr - block-&gt;freeptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is enough room in the active allocation block, we will put the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * chunk into that block.&nbsp; Else must start a new one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(availspace &lt; (chunk_size + <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L819" title="utils/mmgr/aset.c:819">AllocSetAllocFromNewBlock</a>(context, size, flags, fidx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* There's enough space on the current block, so allocate from that */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L774" title="utils/mmgr/aset.c:774">AllocSetAllocChunkFromBlock</a>(context, block, size, chunk_size, fidx);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1062" title="utils/mmgr/aset.c:1062">AllocSetFree</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Frees allocated memory; memory is removed from the set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1062">&#x200c;</a></span><span class="linkable">AllocSetFree</span>(<span class="Type">void</span> *pointer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="utils/mmgr/aset.c:167">AllocSet</a>&nbsp; &nbsp; set;<br/></li>
<li>&nbsp; &nbsp; MemoryChunk *chunk = PointerGetMemoryChunk(pointer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allow access to the chunk header. */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(chunk, <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MemoryChunkIsExternal(chunk))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release single-chunk block. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>&nbsp; &nbsp; block = <a href="#L215" title="utils/mmgr/aset.c:215">ExternalChunkGetBlock</a>(chunk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to verify that we have a sane block pointer: the block header<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should reference an aset and the freeptr should match the endptr.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L207" title="utils/mmgr/aset.c:207">AllocBlockIsValid</a>(block) || block-&gt;freeptr != block-&gt;endptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> block containing chunk </span><span class="Special">%p</span><span class="Constant">&quot;</span>, chunk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set = block-&gt;aset;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Test for someone scribbling on unused space in chunk */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(chunk-&gt;requested_size &lt; (block-&gt;endptr - (<span class="Type">char</span> *) pointer));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!sentinel_ok(pointer, chunk-&gt;requested_size))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;detected write past chunk end in </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; set-&gt;header.name, chunk);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, remove block from aset's list and free it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (block-&gt;prev)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block-&gt;prev-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = block-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set-&gt;blocks = block-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (block-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-&gt;prev = block-&gt;prev;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set-&gt;header.mem_allocated -= block-&gt;endptr - ((<span class="Type">char</span> *) block);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef CLOBBER_FREED_MEMORY<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; wipe_mem(block, block-&gt;freeptr - ((<span class="Type">char</span> *) block));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; free(block);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>&nbsp; &nbsp; block = MemoryChunkGetBlock(chunk);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fidx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L122" title="utils/mmgr/aset.c:122">AllocFreeListLink</a> *link;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In this path, for speed reasons we just Assert that the referenced<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * block is good.&nbsp; We can also Assert that the value field is sane.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Future field experience may show that these Asserts had better<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * become regular runtime test-and-elog checks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L207" title="utils/mmgr/aset.c:207">AllocBlockIsValid</a>(block));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set = block-&gt;aset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fidx = MemoryChunkGetValue(chunk);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L136" title="utils/mmgr/aset.c:136">FreeListIdxIsValid</a>(fidx));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; link = <a href="#L132" title="utils/mmgr/aset.c:132">GetFreeListLink</a>(chunk);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Test for someone scribbling on unused space in chunk */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (chunk-&gt;requested_size &lt; <a href="#L140" title="utils/mmgr/aset.c:140">GetChunkSizeFromFreeListIdx</a>(fidx))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!sentinel_ok(pointer, chunk-&gt;requested_size))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;detected write past chunk end in </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; set-&gt;header.name, chunk);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef CLOBBER_FREED_MEMORY<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; wipe_mem(pointer, <a href="#L140" title="utils/mmgr/aset.c:140">GetChunkSizeFromFreeListIdx</a>(fidx));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> this chunk onto the top of the free list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(link, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L122" title="utils/mmgr/aset.c:122">AllocFreeListLink</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; link-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = set-&gt;freelist[fidx];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(link, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L122" title="utils/mmgr/aset.c:122">AllocFreeListLink</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set-&gt;freelist[fidx] = chunk;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset requested_size to InvalidAllocSize in chunks that are on free<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; chunk-&gt;requested_size = InvalidAllocSize;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1169" title="utils/mmgr/aset.c:1169">AllocSetRealloc</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns new pointer to allocated memory of given size or NULL if<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; request could not be completed; this memory is added to the set.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Memory associated with given pointer is copied into the new memory,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and the old memory is freed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Without MEMORY_CONTEXT_CHECKING, we don't know the old request size.&nbsp; This<br/></li>
<li></span><span class="Comment"> * makes our Valgrind client requests less-precise, hazarding false negatives.<br/></li>
<li></span><span class="Comment"> * (In principle, we could use VALGRIND_GET_VBITS() to rediscover the old<br/></li>
<li></span><span class="Comment"> * request size.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L1169">&#x200c;</a><span class="linkable">AllocSetRealloc</span>(<span class="Type">void</span> *pointer, Size size, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>&nbsp; &nbsp; block;<br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="utils/mmgr/aset.c:167">AllocSet</a>&nbsp; &nbsp; set;<br/></li>
<li>&nbsp; &nbsp; MemoryChunk *chunk = PointerGetMemoryChunk(pointer);<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; oldchksize;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fidx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allow access to the chunk header. */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(chunk, <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MemoryChunkIsExternal(chunk))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The chunk must have been allocated as a single-chunk block.&nbsp; Use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * realloc() to make the containing block bigger, or smaller, with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * minimum space wastage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; chksize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; blksize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; oldblksize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; block = <a href="#L215" title="utils/mmgr/aset.c:215">ExternalChunkGetBlock</a>(chunk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to verify that we have a sane block pointer: the block header<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should reference an aset and the freeptr should match the endptr.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L207" title="utils/mmgr/aset.c:207">AllocBlockIsValid</a>(block) || block-&gt;freeptr != block-&gt;endptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> block containing chunk </span><span class="Special">%p</span><span class="Constant">&quot;</span>, chunk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set = block-&gt;aset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* only check size in paths where the limits could be hit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextCheckSize((MemoryContext) set, size, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldchksize = block-&gt;endptr - (<span class="Type">char</span> *) pointer;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Test for someone scribbling on unused space in chunk */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(chunk-&gt;requested_size &lt; oldchksize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!sentinel_ok(pointer, chunk-&gt;requested_size))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;detected write past chunk end in </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; set-&gt;header.name, chunk);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ensure there's always space for the <a href="../../lib/rbtree.c.html#L63" title="lib/rbtree.c:63">sentinel</a> byte */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; chksize = MAXALIGN(size + <span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; chksize = MAXALIGN(size);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do the realloc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; blksize = chksize + <a href="#L104" title="utils/mmgr/aset.c:104">ALLOC_BLOCKHDRSZ</a> + <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldblksize = block-&gt;endptr - ((<span class="Type">char</span> *) block);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; block = (<a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>) realloc(block, blksize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (block == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Disallow access to the chunk header. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(chunk, <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="mcxt.c.html#L1147" title="utils/mmgr/mcxt.c:1147">MemoryContextAllocationFailure</a>(&amp;set-&gt;header, size, flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* updated separately, not to underflow when (oldblksize &gt; blksize) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; set-&gt;header.mem_allocated -= oldblksize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set-&gt;header.mem_allocated += blksize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; block-&gt;freeptr = block-&gt;endptr = ((<span class="Type">char</span> *) block) + blksize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update pointers since block has likely been moved */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; chunk = (MemoryChunk *) (((<span class="Type">char</span> *) block) + <a href="#L104" title="utils/mmgr/aset.c:104">ALLOC_BLOCKHDRSZ</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pointer = MemoryChunkGetPointer(chunk);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (block-&gt;prev)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block-&gt;prev-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = block;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set-&gt;blocks = block;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (block-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-&gt;prev = block;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span><span class="PreProc">#ifdef RANDOMIZE_ALLOCATED_MEMORY<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can only randomize the extra space if we know the prior request.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When using Valgrind, <a href="memdebug.c.html#L75" title="utils/mmgr/memdebug.c:75">randomize_mem</a>() also marks memory UNDEFINED.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (size &gt; chunk-&gt;requested_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="memdebug.c.html#L75" title="utils/mmgr/memdebug.c:75">randomize_mem</a>((<span class="Type">char</span> *) pointer + chunk-&gt;requested_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size - chunk-&gt;requested_size);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is an increase, realloc() will have marked <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * newly-allocated part (from oldchksize to chksize) UNDEFINED, but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * also need to adjust trailing bytes from the old allocation (from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * chunk-&gt;requested_size to oldchksize) as they are marked NOACCESS.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure not to mark too many bytes in case chunk-&gt;requested_size<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &lt; size &lt; oldchksize.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef USE_VALGRIND<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(size, oldchksize) &gt; chunk-&gt;requested_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_UNDEFINED((<span class="Type">char</span> *) pointer + chunk-&gt;requested_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(size, oldchksize) - chunk-&gt;requested_size);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; chunk-&gt;requested_size = size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set mark to catch clobber of &quot;unused&quot; space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(size &lt; chksize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set_sentinel(pointer, size);<br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* !MEMORY_CONTEXT_CHECKING */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We may need to adjust marking of bytes from the old allocation as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * some of them may be marked NOACCESS.&nbsp; We don't know how much of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * old chunk size was the requested size; it could have been as small<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as one byte.&nbsp; We have to be conservative and just mark the entire<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * old portion DEFINED.&nbsp; Make sure not to mark memory beyond the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allocation in case it's smaller than the old one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(pointer, <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(size, oldchksize));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ensure <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> padding bytes are marked NOACCESS. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS((<span class="Type">char</span> *) pointer + size, chksize - size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Disallow access to the chunk header . */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(chunk, <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> pointer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; block = MemoryChunkGetBlock(chunk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In this path, for speed reasons we just Assert that the referenced<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * block is good. We can also Assert that the value field is sane. Future<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * field experience may show that these Asserts had better become regular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * runtime test-and-elog checks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L207" title="utils/mmgr/aset.c:207">AllocBlockIsValid</a>(block));<br/></li>
<li>&nbsp; &nbsp; set = block-&gt;aset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fidx = MemoryChunkGetValue(chunk);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L136" title="utils/mmgr/aset.c:136">FreeListIdxIsValid</a>(fidx));<br/></li>
<li>&nbsp; &nbsp; oldchksize = <a href="#L140" title="utils/mmgr/aset.c:140">GetChunkSizeFromFreeListIdx</a>(fidx);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Test for someone scribbling on unused space in chunk */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (chunk-&gt;requested_size &lt; oldchksize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!sentinel_ok(pointer, chunk-&gt;requested_size))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;detected write past chunk end in </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; set-&gt;header.name, chunk);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Chunk sizes are aligned to power of 2 in <a href="#L967" title="utils/mmgr/aset.c:967">AllocSetAlloc</a>().&nbsp; Maybe the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocated area already is &gt;= the new size.&nbsp; (In particular, we will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fall out here if the requested size is a decrease.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (oldchksize &gt;= size)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; oldrequest = chunk-&gt;requested_size;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef RANDOMIZE_ALLOCATED_MEMORY<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can only fill the extra space if we know the prior request */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (size &gt; oldrequest)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="memdebug.c.html#L75" title="utils/mmgr/memdebug.c:75">randomize_mem</a>((<span class="Type">char</span> *) pointer + oldrequest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size - oldrequest);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; chunk-&gt;requested_size = size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is an increase, mark <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> newly-available part UNDEFINED.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, mark the obsolete part NOACCESS.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (size &gt; oldrequest)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_UNDEFINED((<span class="Type">char</span> *) pointer + oldrequest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size - oldrequest);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS((<span class="Type">char</span> *) pointer + size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldchksize - size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set mark to catch clobber of &quot;unused&quot; space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (size &lt; oldchksize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_sentinel(pointer, size);<br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* !MEMORY_CONTEXT_CHECKING */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't have the information to determine whether we're growing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the old request or shrinking it, so we conservatively mark the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entire new allocation DEFINED.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(pointer, oldchksize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(pointer, size);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Disallow access to the chunk header. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(chunk, <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> pointer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Enlarge-a-small-chunk case.&nbsp; We just do this by brute force, ie,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allocate a new chunk and copy the data.&nbsp; Since we know the existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * data isn't huge, this won't involve <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> great memcpy expense, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's not worth being smarter.&nbsp; (At one time we tried to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memcpy when it was possible to enlarge the chunk in-place, but that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * turns out to misbehave unpleasantly for repeated cycles of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>/<a href="mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>/<a href="mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>: the eventually freed chunks go into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wrong freelist for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> initial <a href="mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> request, and so we leak<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memory indefinitely.&nbsp; See pgsql-hackers archives for 2007-08-11.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L113" title="utils/mmgr/aset.c:113">AllocPointer</a> newPointer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; oldsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocate new chunk (this also checks size is valid) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newPointer = <a href="#L967" title="utils/mmgr/aset.c:967">AllocSetAlloc</a>((MemoryContext) set, size, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* leave immediately if request was not completed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newPointer == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Disallow access to the chunk header. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(chunk, <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="mcxt.c.html#L1147" title="utils/mmgr/mcxt.c:1147">MemoryContextAllocationFailure</a>((MemoryContext) set, size, flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L967" title="utils/mmgr/aset.c:967">AllocSetAlloc</a>() may have returned a region that is still NOACCESS.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Change it to UNDEFINED for the moment; memcpy() will then transfer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * definedness from the old allocation to the new.&nbsp; If we know the old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allocation, copy just that much.&nbsp; Otherwise, make the entire old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * chunk defined to avoid errors as we copy the currently-NOACCESS<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * trailing bytes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_UNDEFINED(newPointer, size);<br/></li>
<li><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldsize = chunk-&gt;requested_size;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldsize = oldchksize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(pointer, oldsize);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* transfer existing data (certain to fit) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(newPointer, pointer, oldsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* free old chunk */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1062" title="utils/mmgr/aset.c:1062">AllocSetFree</a>(pointer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> newPointer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1433" title="utils/mmgr/aset.c:1433">AllocSetGetChunkContext</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return the MemoryContext that 'pointer' belongs to.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MemoryContext<br/></li>
<li><a id="L1433">&#x200c;</a><span class="linkable">AllocSetGetChunkContext</span>(<span class="Type">void</span> *pointer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryChunk *chunk = PointerGetMemoryChunk(pointer);<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>&nbsp; &nbsp; block;<br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="utils/mmgr/aset.c:167">AllocSet</a>&nbsp; &nbsp; set;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allow access to the chunk header. */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(chunk, <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MemoryChunkIsExternal(chunk))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; block = <a href="#L215" title="utils/mmgr/aset.c:215">ExternalChunkGetBlock</a>(chunk);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; block = (<a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>) MemoryChunkGetBlock(chunk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Disallow access to the chunk header. */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(chunk, <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L207" title="utils/mmgr/aset.c:207">AllocBlockIsValid</a>(block));<br/></li>
<li>&nbsp; &nbsp; set = block-&gt;aset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> &amp;set-&gt;header;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1462" title="utils/mmgr/aset.c:1462">AllocSetGetChunkSpace</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given a currently-allocated chunk, determine the total space<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; it occupies (including all memory-allocation overhead).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L1462">&#x200c;</a><span class="linkable">AllocSetGetChunkSpace</span>(<span class="Type">void</span> *pointer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryChunk *chunk = PointerGetMemoryChunk(pointer);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fidx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allow access to the chunk header. */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(chunk, <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MemoryChunkIsExternal(chunk))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>&nbsp; &nbsp; block = <a href="#L215" title="utils/mmgr/aset.c:215">ExternalChunkGetBlock</a>(chunk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Disallow access to the chunk header. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(chunk, <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L207" title="utils/mmgr/aset.c:207">AllocBlockIsValid</a>(block));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> block-&gt;endptr - (<span class="Type">char</span> *) chunk;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fidx = MemoryChunkGetValue(chunk);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L136" title="utils/mmgr/aset.c:136">FreeListIdxIsValid</a>(fidx));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Disallow access to the chunk header. */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(chunk, <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L140" title="utils/mmgr/aset.c:140">GetChunkSizeFromFreeListIdx</a>(fidx) + <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1496" title="utils/mmgr/aset.c:1496">AllocSetIsEmpty</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Is an allocset empty of <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> allocated space?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1496">&#x200c;</a></span><span class="linkable">AllocSetIsEmpty</span>(MemoryContext context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L200" title="utils/mmgr/aset.c:200">AllocSetIsValid</a>(context));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we say &quot;empty&quot; only if the context is new or just reset. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could examine the freelists to determine if all space has been freed,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but it's not really worth the trouble for present uses of this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * functionality.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;isReset)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1521" title="utils/mmgr/aset.c:1521">AllocSetStats</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Compute stats about memory consumption of an allocset.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * printfunc: if not NULL, pass a human-readable stats string to this.<br/></li>
<li></span><span class="Comment"> * passthru: pass this pointer through to printfunc.<br/></li>
<li></span><span class="Comment"> * totals: if not NULL, add stats about this context into *totals.<br/></li>
<li></span><span class="Comment"> * print_to_stderr: <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> stats to stderr if true, elog otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1521">&#x200c;</a></span><span class="linkable">AllocSetStats</span>(MemoryContext context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryStatsPrintFunc printfunc, <span class="Type">void</span> *passthru,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextCounters *totals, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> print_to_stderr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="utils/mmgr/aset.c:167">AllocSet</a>&nbsp; &nbsp; set = (<a href="#L167" title="utils/mmgr/aset.c:167">AllocSet</a>) context;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; nblocks = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; freechunks = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; totalspace;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; freespace = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>&nbsp; &nbsp; block;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fidx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L200" title="utils/mmgr/aset.c:200">AllocSetIsValid</a>(set));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Include context header in totalspace */<br/></li>
<li></span>&nbsp; &nbsp; totalspace = MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L152" title="utils/mmgr/aset.c:152">AllocSetContext</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (block = set-&gt;blocks; block != <span class="Constant">NULL</span>; block = block-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nblocks++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; totalspace += block-&gt;endptr - ((<span class="Type">char</span> *) block);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freespace += block-&gt;endptr - block-&gt;freeptr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (fidx = <span class="Constant">0</span>; fidx &lt; <a href="#L84" title="utils/mmgr/aset.c:84">ALLOCSET_NUM_FREELISTS</a>; fidx++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; chksz = <a href="#L140" title="utils/mmgr/aset.c:140">GetChunkSizeFromFreeListIdx</a>(fidx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryChunk *chunk = set-&gt;freelist[fidx];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (chunk != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L122" title="utils/mmgr/aset.c:122">AllocFreeListLink</a> *link = <a href="#L132" title="utils/mmgr/aset.c:132">GetFreeListLink</a>(chunk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allow access to the chunk header. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(chunk, <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(MemoryChunkGetValue(chunk) == fidx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(chunk, <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freechunks++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freespace += chksz + <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(link, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L122" title="utils/mmgr/aset.c:122">AllocFreeListLink</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunk = link-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(link, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L122" title="utils/mmgr/aset.c:122">AllocFreeListLink</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (printfunc)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; stats_string[<span class="Constant">200</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(stats_string, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(stats_string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;</span><span class="Special">%zu</span><span class="Constant"> total in </span><span class="Special">%zu</span><span class="Constant"> blocks; </span><span class="Special">%zu</span><span class="Constant"> free (</span><span class="Special">%zu</span><span class="Constant"> chunks); </span><span class="Special">%zu</span><span class="Constant"> used&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; totalspace, nblocks, freespace, freechunks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; totalspace - freespace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; printfunc(context, passthru, stats_string, print_to_stderr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (totals)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; totals-&gt;nblocks += nblocks;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; totals-&gt;freechunks += freechunks;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; totals-&gt;totalspace += totalspace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; totals-&gt;freespace += freespace;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1599" title="utils/mmgr/aset.c:1599">AllocSetCheck</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Walk through chunks and check consistency of memory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: report errors as WARNING, *not* ERROR or FATAL.&nbsp; Otherwise you'll<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> yourself in an infinite loop when trouble occurs, because this<br/></li>
<li></span><span class="Comment"> * routine will be entered again when elog <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> tries to release memory!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1599">&#x200c;</a></span><span class="linkable">AllocSetCheck</span>(MemoryContext context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="utils/mmgr/aset.c:167">AllocSet</a>&nbsp; &nbsp; set = (<a href="#L167" title="utils/mmgr/aset.c:167">AllocSet</a>) context;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *name = set-&gt;header.name;<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>&nbsp; &nbsp; prevblock;<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="utils/mmgr/aset.c:107">AllocBlock</a>&nbsp; &nbsp; block;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; total_allocated = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (prevblock = <span class="Constant">NULL</span>, block = set-&gt;blocks;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; block != <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prevblock = block, block = block-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *bpoz = ((<span class="Type">char</span> *) block) + <a href="#L104" title="utils/mmgr/aset.c:104">ALLOC_BLOCKHDRSZ</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; blk_used = block-&gt;freeptr - bpoz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; blk_data = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; nchunks = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_external_chunk = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L248" title="utils/mmgr/aset.c:248">IsKeeperBlock</a>(set, block))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_allocated += block-&gt;endptr - ((<span class="Type">char</span> *) set);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_allocated += block-&gt;endptr - ((<span class="Type">char</span> *) block);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Empty block - empty can be keeper-block only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!blk_used)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L248" title="utils/mmgr/aset.c:248">IsKeeperBlock</a>(set, block))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;problem in alloc set </span><span class="Special">%s</span><span class="Constant">: empty block </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; name, block);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check block header fields<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (block-&gt;aset != set ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block-&gt;prev != prevblock ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block-&gt;freeptr &lt; bpoz ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block-&gt;freeptr &gt; block-&gt;endptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;problem in alloc set </span><span class="Special">%s</span><span class="Constant">: corrupt header in block </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; name, block);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Chunk walker<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (bpoz &lt; block-&gt;freeptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryChunk *chunk = (MemoryChunk *) bpoz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; chsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allow access to the chunk header. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(chunk, <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (MemoryChunkIsExternal(chunk))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chsize = block-&gt;endptr - (<span class="Type">char</span> *) MemoryChunkGetPointer(chunk); <span class="Comment">/* aligned chunk size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has_external_chunk = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure this chunk consumes the entire block */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (chsize + <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a> != blk_used)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;problem in alloc set </span><span class="Special">%s</span><span class="Constant">: bad single-chunk </span><span class="Special">%p</span><span class="Constant"> in block </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; name, chunk, block);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fidx = MemoryChunkGetValue(chunk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L136" title="utils/mmgr/aset.c:136">FreeListIdxIsValid</a>(fidx))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;problem in alloc set </span><span class="Special">%s</span><span class="Constant">: bad chunk size for chunk </span><span class="Special">%p</span><span class="Constant"> in block </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; name, chunk, block);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chsize = <a href="#L140" title="utils/mmgr/aset.c:140">GetChunkSizeFromFreeListIdx</a>(fidx); <span class="Comment">/* aligned chunk size */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check the stored block offset correctly references this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * block.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (block != MemoryChunkGetBlock(chunk))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;problem in alloc set </span><span class="Special">%s</span><span class="Constant">: bad block offset for chunk </span><span class="Special">%p</span><span class="Constant"> in block </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; name, chunk, block);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dsize = chunk-&gt;requested_size;&nbsp; &nbsp; <span class="Comment">/* real data */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* an allocated chunk's requested size must be &lt;= the chsize */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dsize != InvalidAllocSize &amp;&amp; dsize &gt; chsize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;problem in alloc set </span><span class="Special">%s</span><span class="Constant">: req size &gt; alloc size for chunk </span><span class="Special">%p</span><span class="Constant"> in block </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; name, chunk, block);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* chsize must not be smaller than the first freelist's size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (chsize &lt; (<span class="Constant">1</span> &lt;&lt; <a href="#L83" title="utils/mmgr/aset.c:83">ALLOC_MINBITS</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;problem in alloc set </span><span class="Special">%s</span><span class="Constant">: bad size </span><span class="Special">%zu</span><span class="Constant"> for chunk </span><span class="Special">%p</span><span class="Constant"> in block </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; name, chsize, chunk, block);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for overwrite of padding space in an allocated chunk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dsize != InvalidAllocSize &amp;&amp; dsize &lt; chsize &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !sentinel_ok(chunk, <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a> + dsize))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;problem in alloc set </span><span class="Special">%s</span><span class="Constant">: detected write past chunk end in block </span><span class="Special">%p</span><span class="Constant">, chunk </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; name, block, chunk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if chunk is allocated, disallow access to the chunk header */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dsize != InvalidAllocSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(chunk, <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blk_data += chsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nchunks++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bpoz += <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a> + chsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((blk_data + (nchunks * <a href="#L105" title="utils/mmgr/aset.c:105">ALLOC_CHUNKHDRSZ</a>)) != blk_used)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;problem in alloc set </span><span class="Special">%s</span><span class="Constant">: found inconsistent memory block </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; name, block);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (has_external_chunk &amp;&amp; nchunks &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;problem in alloc set </span><span class="Special">%s</span><span class="Constant">: external chunk on non-dedicated block </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; name, block);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(total_allocated == context-&gt;mem_allocated);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* MEMORY_CONTEXT_CHECKING */<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
