<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/mmgr/freepage.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/mmgr/freepage.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L108">FreePageBtree</a></li>
<li><a href="#L77">FreePageBtreeHeader</a></li>
<li><a href="#L83">FreePageBtreeHeader</a></li>
<li><a href="#L86">FreePageBtreeInternalKey</a></li>
<li><a href="#L90">FreePageBtreeInternalKey</a></li>
<li><a href="#L93">FreePageBtreeLeafKey</a></li>
<li><a href="#L97">FreePageBtreeLeafKey</a></li>
<li><a href="#L119">FreePageBtreeSearchResult</a></li>
<li><a href="#L125">FreePageBtreeSearchResult</a></li>
<li><a href="#L68">FreePageSpanLeader</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L501">FreePageBtreeAdjustAncestorKeys</a></li>
<li><a href="#L580">FreePageBtreeCleanup</a></li>
<li><a href="#L695">FreePageBtreeConsolidate</a></li>
<li><a href="#L774">FreePageBtreeFindLeftSibling</a></li>
<li><a href="#L819">FreePageBtreeFindRightSibling</a></li>
<li><a href="#L863">FreePageBtreeFirstKey</a></li>
<li><a href="#L880">FreePageBtreeGetRecycled</a></li>
<li><a href="#L900">FreePageBtreeInsertInternal</a></li>
<li><a href="#L917">FreePageBtreeInsertLeaf</a></li>
<li><a href="#L934">FreePageBtreeRecycle</a></li>
<li><a href="#L955">FreePageBtreeRemove</a></li>
<li><a href="#L987">FreePageBtreeRemovePage</a></li>
<li><a href="#L1064">FreePageBtreeSearch</a></li>
<li><a href="#L1140">FreePageBtreeSearchInternal</a></li>
<li><a href="#L1170">FreePageBtreeSearchLeaf</a></li>
<li><a href="#L1201">FreePageBtreeSplitPage</a></li>
<li><a href="#L1232">FreePageBtreeUpdateParentPointers</a></li>
<li><a href="#L424">FreePageManagerDump</a></li>
<li><a href="#L1250">FreePageManagerDumpBtree</a></li>
<li><a href="#L1296">FreePageManagerDumpSpans</a></li>
<li><a href="#L210">FreePageManagerGet</a></li>
<li><a href="#L1319">FreePageManagerGetInternal</a></li>
<li><a href="#L183">FreePageManagerInitialize</a></li>
<li><a href="#L324">FreePageManagerLargestContiguous</a></li>
<li><a href="#L379">FreePageManagerPut</a></li>
<li><a href="#L1476">FreePageManagerPutInternal</a></li>
<li><a href="#L366">FreePageManagerUpdateLargest</a></li>
<li><a href="#L1843">FreePagePopSpanLeader</a></li>
<li><a href="#L1871">FreePagePushSpanLeader</a></li>
<li><a href="#L274">sum_free_pages</a></li>
<li><a href="#L252">sum_free_pages_recurse</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L100">FPM_ITEMS_PER_INTERNAL_PAGE</a></li>
<li><a href="#L103">FPM_ITEMS_PER_LEAF_PAGE</a></li>
<li><a href="#L65">FREE_PAGE_INTERNAL_MAGIC</a></li>
<li><a href="#L64">FREE_PAGE_LEAF_MAGIC</a></li>
<li><a href="#L63">FREE_PAGE_SPAN_LEADER_MAGIC</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * freepage.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Management of free memory pages.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The intention of this code is to provide infrastructure for memory<br/></li>
<li></span><span class="Comment"> * allocators written specifically for PostgreSQL.&nbsp; At least in the case<br/></li>
<li></span><span class="Comment"> * of dynamic shared memory, we can't simply use malloc() or even<br/></li>
<li></span><span class="Comment"> * relatively thin wrappers like <a href="mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>() which sit on top of it, because<br/></li>
<li></span><span class="Comment"> * no allocator built into the operating system will deal with relative<br/></li>
<li></span><span class="Comment"> * pointers.&nbsp; In the future, we may <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> other cases in which greater<br/></li>
<li></span><span class="Comment"> * control over our own memory management seems desirable.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A FreePageManager keeps track of which 4kB pages of memory are currently<br/></li>
<li></span><span class="Comment"> * unused from the point of view of some higher-level memory allocator.<br/></li>
<li></span><span class="Comment"> * Unlike a user-facing allocator such as <a href="mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(), a FreePageManager can<br/></li>
<li></span><span class="Comment"> * only allocate and free in units of whole pages, and freeing an<br/></li>
<li></span><span class="Comment"> * allocation can only be done given knowledge of its length in pages.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since a free page manager has only a fixed amount of dedicated memory,<br/></li>
<li></span><span class="Comment"> * and since there is no underlying allocator, it uses the free pages<br/></li>
<li></span><span class="Comment"> * it is given to manage to store its bookkeeping data.&nbsp; It keeps multiple<br/></li>
<li></span><span class="Comment"> * freelists of runs of pages, sorted by the size of the run; the head of<br/></li>
<li></span><span class="Comment"> * each freelist is stored in the FreePageManager itself, and the first<br/></li>
<li></span><span class="Comment"> * page of each run contains a relative pointer to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> run. See<br/></li>
<li></span><span class="Comment"> * <a href="#L1319" title="utils/mmgr/freepage.c:1319">FreePageManagerGetInternal</a> for more details on how the freelists are<br/></li>
<li></span><span class="Comment"> * managed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To avoid memory fragmentation, it's important to consolidate adjacent<br/></li>
<li></span><span class="Comment"> * spans of pages whenever possible; otherwise, large allocation requests<br/></li>
<li></span><span class="Comment"> * might not be satisfied even when sufficient contiguous space is<br/></li>
<li></span><span class="Comment"> * available.&nbsp; Therefore, in addition to the freelists, we maintain an<br/></li>
<li></span><span class="Comment"> * in-memory btree of free page ranges ordered by page number.&nbsp; If a<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> being freed precedes or follows a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> that is already free,<br/></li>
<li></span><span class="Comment"> * the existing <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is extended; if it exactly bridges the gap between<br/></li>
<li></span><span class="Comment"> * free ranges, then the two existing ranges are consolidated with the<br/></li>
<li></span><span class="Comment"> * newly-freed <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> to form one great big <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of free pages.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When there is only one <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of free pages, the btree is trivial and<br/></li>
<li></span><span class="Comment"> * is stored within the FreePageManager proper; otherwise, pages are<br/></li>
<li></span><span class="Comment"> * allocated from the area under management as needed.&nbsp; Even in cases<br/></li>
<li></span><span class="Comment"> * where memory fragmentation is very severe, only a tiny fraction of<br/></li>
<li></span><span class="Comment"> * the pages under management are consumed by this btree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/mmgr/freepage.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/stringinfo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;utils/freepage.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/relptr.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* Magic numbers to identify various page types */<br/></li>
<li><a id="L63">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FREE_PAGE_SPAN_LEADER_MAGIC</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0xea4020f0<br/></li>
<li><a id="L64">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FREE_PAGE_LEAF_MAGIC</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x98eae728<br/></li>
<li><a id="L65">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FREE_PAGE_INTERNAL_MAGIC</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x19aa32c9<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Doubly linked list of spans of free pages; stored in first page of span. */<br/></li>
<li><a id="L68">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">FreePageSpanLeader</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; magic;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* always <a href="#L63" title="utils/mmgr/freepage.c:63">FREE_PAGE_SPAN_LEADER_MAGIC</a> */<br/></li>
<li></span>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; npages;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of pages in span */<br/></li>
<li></span>&nbsp; &nbsp; RelptrFreePageSpanLeader prev;<br/></li>
<li>&nbsp; &nbsp; RelptrFreePageSpanLeader <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Common header for btree leaf and <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> pages. */<br/></li>
<li><a id="L77">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">FreePageBtreeHeader</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; magic;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L64" title="utils/mmgr/freepage.c:64">FREE_PAGE_LEAF_MAGIC</a> or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L65" title="utils/mmgr/freepage.c:65">FREE_PAGE_INTERNAL_MAGIC</a> */<br/></li>
<li></span>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; nused;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of items used */<br/></li>
<li></span>&nbsp; &nbsp; RelptrFreePageBtree parent; <span class="Comment">/* uplink */<br/></li>
<li><a id="L83">&#x200c;</a></span>} <span class="linkable">FreePageBtreeHeader</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Internal key; points to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> level of btree. */<br/></li>
<li><a id="L86">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">FreePageBtreeInternalKey</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; first_page;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* low bound for keys on child page */<br/></li>
<li></span>&nbsp; &nbsp; RelptrFreePageBtree child;&nbsp; &nbsp; <span class="Comment">/* downlink */<br/></li>
<li><a id="L90">&#x200c;</a></span>} <span class="linkable">FreePageBtreeInternalKey</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Leaf key; no payload data. */<br/></li>
<li><a id="L93">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">FreePageBtreeLeafKey</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; first_page;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first page in span */<br/></li>
<li></span>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; npages;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of pages in span */<br/></li>
<li><a id="L97">&#x200c;</a></span>} <span class="linkable">FreePageBtreeLeafKey</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Work out how many keys will fit on a page. */<br/></li>
<li><a id="L100">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FPM_ITEMS_PER_INTERNAL_PAGE</span> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((FPM_PAGE_SIZE - </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(<a href="#L77" title="utils/mmgr/freepage.c:77">FreePageBtreeHeader</a>)) / \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(<a href="#L86" title="utils/mmgr/freepage.c:86">FreePageBtreeInternalKey</a>))<br/></li>
<li><a id="L103">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FPM_ITEMS_PER_LEAF_PAGE</span> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((FPM_PAGE_SIZE - </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(<a href="#L77" title="utils/mmgr/freepage.c:77">FreePageBtreeHeader</a>)) / \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(<a href="#L93" title="utils/mmgr/freepage.c:93">FreePageBtreeLeafKey</a>))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* A btree page of either sort */<br/></li>
<li><a id="L108">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">FreePageBtree</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L77" title="utils/mmgr/freepage.c:77">FreePageBtreeHeader</a> hdr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">union<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L86" title="utils/mmgr/freepage.c:86">FreePageBtreeInternalKey</a> internal_key[<a href="#L100" title="utils/mmgr/freepage.c:100">FPM_ITEMS_PER_INTERNAL_PAGE</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L93" title="utils/mmgr/freepage.c:93">FreePageBtreeLeafKey</a> leaf_key[<a href="#L103" title="utils/mmgr/freepage.c:103">FPM_ITEMS_PER_LEAF_PAGE</a>];<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Results of a btree search */<br/></li>
<li><a id="L119">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">FreePageBtreeSearchResult</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *page;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span>&nbsp; &nbsp; split_pages;<br/></li>
<li><a id="L125">&#x200c;</a>} <span class="linkable">FreePageBtreeSearchResult</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Helper <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L501" title="utils/mmgr/freepage.c:501">FreePageBtreeAdjustAncestorKeys</a>(FreePageManager *fpm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp);<br/></li>
<li><span class="Type">static</span> Size <a href="#L580" title="utils/mmgr/freepage.c:580">FreePageBtreeCleanup</a>(FreePageManager *fpm);<br/></li>
<li><span class="Type">static</span> <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *<a href="#L774" title="utils/mmgr/freepage.c:774">FreePageBtreeFindLeftSibling</a>(<span class="Type">char</span> *base,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp);<br/></li>
<li><span class="Type">static</span> <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *<a href="#L819" title="utils/mmgr/freepage.c:819">FreePageBtreeFindRightSibling</a>(<span class="Type">char</span> *base,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp);<br/></li>
<li><span class="Type">static</span> Size <a href="#L863" title="utils/mmgr/freepage.c:863">FreePageBtreeFirstKey</a>(<a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp);<br/></li>
<li><span class="Type">static</span> <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *<a href="#L880" title="utils/mmgr/freepage.c:880">FreePageBtreeGetRecycled</a>(FreePageManager *fpm);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L900" title="utils/mmgr/freepage.c:900">FreePageBtreeInsertInternal</a>(<span class="Type">char</span> *base, <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size index, Size first_page, <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *child);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L917" title="utils/mmgr/freepage.c:917">FreePageBtreeInsertLeaf</a>(<a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp, Size index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size first_page, Size npages);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L934" title="utils/mmgr/freepage.c:934">FreePageBtreeRecycle</a>(FreePageManager *fpm, Size pageno);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L955" title="utils/mmgr/freepage.c:955">FreePageBtreeRemove</a>(FreePageManager *fpm, <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size index);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L987" title="utils/mmgr/freepage.c:987">FreePageBtreeRemovePage</a>(FreePageManager *fpm, <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1064" title="utils/mmgr/freepage.c:1064">FreePageBtreeSearch</a>(FreePageManager *fpm, Size first_page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L119" title="utils/mmgr/freepage.c:119">FreePageBtreeSearchResult</a> *result);<br/></li>
<li><span class="Type">static</span> Size <a href="#L1140" title="utils/mmgr/freepage.c:1140">FreePageBtreeSearchInternal</a>(<a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp, Size first_page);<br/></li>
<li><span class="Type">static</span> Size <a href="#L1170" title="utils/mmgr/freepage.c:1170">FreePageBtreeSearchLeaf</a>(<a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp, Size first_page);<br/></li>
<li><span class="Type">static</span> <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *<a href="#L1201" title="utils/mmgr/freepage.c:1201">FreePageBtreeSplitPage</a>(FreePageManager *fpm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1232" title="utils/mmgr/freepage.c:1232">FreePageBtreeUpdateParentPointers</a>(<span class="Type">char</span> *base, <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1250" title="utils/mmgr/freepage.c:1250">FreePageManagerDumpBtree</a>(FreePageManager *fpm, <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *parent, <span class="Type">int</span> level, StringInfo buf);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1296" title="utils/mmgr/freepage.c:1296">FreePageManagerDumpSpans</a>(FreePageManager *fpm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *span, Size expected_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; StringInfo buf);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1319" title="utils/mmgr/freepage.c:1319">FreePageManagerGetInternal</a>(FreePageManager *fpm, Size npages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Size *first_page);<br/></li>
<li><span class="Type">static</span> Size <a href="#L1476" title="utils/mmgr/freepage.c:1476">FreePageManagerPutInternal</a>(FreePageManager *fpm, Size first_page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Size npages, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> soft);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1843" title="utils/mmgr/freepage.c:1843">FreePagePopSpanLeader</a>(FreePageManager *fpm, Size pageno);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1871" title="utils/mmgr/freepage.c:1871">FreePagePushSpanLeader</a>(FreePageManager *fpm, Size first_page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Size npages);<br/></li>
<li><span class="Type">static</span> Size <a href="#L324" title="utils/mmgr/freepage.c:324">FreePageManagerLargestContiguous</a>(FreePageManager *fpm);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L366" title="utils/mmgr/freepage.c:366">FreePageManagerUpdateLargest</a>(FreePageManager *fpm);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef FPM_EXTRA_ASSERTS<br/></li>
<li></span><span class="Type">static</span> Size <a href="#L274" title="utils/mmgr/freepage.c:274">sum_free_pages</a>(FreePageManager *fpm);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize a new, empty free page manager.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'fpm' should reference caller-provided memory large enough to contain a<br/></li>
<li></span><span class="Comment"> * FreePageManager.&nbsp; We'll <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> it here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'base' is the address to which all pointers are relative.&nbsp; When managing<br/></li>
<li></span><span class="Comment"> * a dynamic shared memory segment, it should normally be the base of the<br/></li>
<li></span><span class="Comment"> * segment.&nbsp; When managing backend-private memory, it can be either NULL or,<br/></li>
<li></span><span class="Comment"> * if managing a single contiguous extent of memory, the start of that extent.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L183">&#x200c;</a></span><span class="linkable">FreePageManagerInitialize</span>(FreePageManager *fpm, <span class="Type">char</span> *base)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; f;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relptr_store(base, fpm-&gt;self, fpm);<br/></li>
<li>&nbsp; &nbsp; relptr_store(base, fpm-&gt;btree_root, (<a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *) <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; relptr_store(base, fpm-&gt;btree_recycle, (<a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *) <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; fpm-&gt;btree_depth = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; fpm-&gt;btree_recycle_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; fpm-&gt;singleton_first_page = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; fpm-&gt;singleton_npages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; fpm-&gt;contiguous_pages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; fpm-&gt;contiguous_pages_dirty = <span class="Constant">true</span>;<br/></li>
<li><span class="PreProc">#ifdef FPM_EXTRA_ASSERTS<br/></li>
<li></span>&nbsp; &nbsp; fpm-&gt;free_pages = <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (f = <span class="Constant">0</span>; f &lt; FPM_NUM_FREELISTS; f++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relptr_store(base, fpm-&gt;freelist[f], (<a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *) <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate a run of pages of the given length from the free page manager.<br/></li>
<li></span><span class="Comment"> * The return value indicates whether we were able to satisfy the request;<br/></li>
<li></span><span class="Comment"> * if true, the first page of the allocation is stored in *first_page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L210">&#x200c;</a></span><span class="linkable">FreePageManagerGet</span>(FreePageManager *fpm, Size npages, Size *first_page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; contiguous_pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1319" title="utils/mmgr/freepage.c:1319">FreePageManagerGetInternal</a>(fpm, npages, first_page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's a <a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> counterintuitive, but allocating pages can actually create<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * opportunities for <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> that create larger ranges.&nbsp; We might <a href="../../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * key out of the btree that enables the item at the head of the btree<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recycle list to be inserted; and then if there are more items behind it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one of those might cause two currently-separated ranges to <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * creating a single <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of contiguous pages larger than <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * existed previously.&nbsp; It might be worth trying to improve the <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * algorithm to avoid such corner cases, but for <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we just notice the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * condition and do the appropriate reporting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; contiguous_pages = <a href="#L580" title="utils/mmgr/freepage.c:580">FreePageBtreeCleanup</a>(fpm);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fpm-&gt;contiguous_pages &lt; contiguous_pages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fpm-&gt;contiguous_pages = contiguous_pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1319" title="utils/mmgr/freepage.c:1319">FreePageManagerGetInternal</a> may have set contiguous_pages_dirty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Recompute contiguous_pages if so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L366" title="utils/mmgr/freepage.c:366">FreePageManagerUpdateLargest</a>(fpm);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef FPM_EXTRA_ASSERTS<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(fpm-&gt;free_pages &gt;= npages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fpm-&gt;free_pages -= npages;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(fpm-&gt;free_pages == <a href="#L274" title="utils/mmgr/freepage.c:274">sum_free_pages</a>(fpm));<br/></li>
<li>&nbsp; &nbsp; Assert(fpm-&gt;contiguous_pages == <a href="#L324" title="utils/mmgr/freepage.c:324">FreePageManagerLargestContiguous</a>(fpm));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef FPM_EXTRA_ASSERTS<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L252">&#x200c;</a></span><span class="linkable">sum_free_pages_recurse</span>(FreePageManager *fpm, <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp, Size *sum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *base = fpm_segment_base(fpm);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(btp-&gt;hdr.magic == <a href="#L65" title="utils/mmgr/freepage.c:65">FREE_PAGE_INTERNAL_MAGIC</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; btp-&gt;hdr.magic == <a href="#L64" title="utils/mmgr/freepage.c:64">FREE_PAGE_LEAF_MAGIC</a>);<br/></li>
<li>&nbsp; &nbsp; ++*sum;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (btp-&gt;hdr.magic == <a href="#L65" title="utils/mmgr/freepage.c:65">FREE_PAGE_INTERNAL_MAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (index = <span class="Constant">0</span>; index &lt; btp-&gt;hdr.nused; ++index)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *child;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child = relptr_access(base, btp-&gt;u.internal_key[index].child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L252" title="utils/mmgr/freepage.c:252">sum_free_pages_recurse</a>(fpm, child, sum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><span class="Type">static</span> Size<br/></li>
<li><a id="L274">&#x200c;</a><span class="linkable">sum_free_pages</span>(FreePageManager *fpm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *recycle;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *base = fpm_segment_base(fpm);<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; sum = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Count the spans by scanning the freelists. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (list = <span class="Constant">0</span>; list &lt; FPM_NUM_FREELISTS; ++list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!relptr_is_null(fpm-&gt;freelist[list]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *candidate =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relptr_access(base, fpm-&gt;freelist[list]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sum += candidate-&gt;npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; candidate = relptr_access(base, candidate-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (candidate != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Count btree <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> pages. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fpm-&gt;btree_depth &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *root = relptr_access(base, fpm-&gt;btree_root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L252" title="utils/mmgr/freepage.c:252">sum_free_pages_recurse</a>(fpm, root, &amp;sum);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Count the recycle list. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (recycle = relptr_access(base, fpm-&gt;btree_recycle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; recycle != <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; recycle = relptr_access(base, recycle-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(recycle-&gt;npages == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ++sum;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> sum;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the size of the largest run of pages that the user could<br/></li>
<li></span><span class="Comment"> * successfully get.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Size<br/></li>
<li><a id="L324">&#x200c;</a><span class="linkable">FreePageManagerLargestContiguous</span>(FreePageManager *fpm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *base;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; largest;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; base = fpm_segment_base(fpm);<br/></li>
<li>&nbsp; &nbsp; largest = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!relptr_is_null(fpm-&gt;freelist[FPM_NUM_FREELISTS - <span class="Constant">1</span>]))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *candidate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; candidate = relptr_access(base, fpm-&gt;freelist[FPM_NUM_FREELISTS - <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (candidate-&gt;npages &gt; largest)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; largest = candidate-&gt;npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; candidate = relptr_access(base, candidate-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (candidate != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; f = FPM_NUM_FREELISTS - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --f;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!relptr_is_null(fpm-&gt;freelist[f]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; largest = f + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (f &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> largest;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Recompute the size of the largest run of pages that the user could<br/></li>
<li></span><span class="Comment"> * successfully get, if it has been marked dirty.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L366">&#x200c;</a></span><span class="linkable">FreePageManagerUpdateLargest</span>(FreePageManager *fpm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!fpm-&gt;contiguous_pages_dirty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fpm-&gt;contiguous_pages = <a href="#L324" title="utils/mmgr/freepage.c:324">FreePageManagerLargestContiguous</a>(fpm);<br/></li>
<li>&nbsp; &nbsp; fpm-&gt;contiguous_pages_dirty = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Transfer a run of pages to the free page manager.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L379">&#x200c;</a></span><span class="linkable">FreePageManagerPut</span>(FreePageManager *fpm, Size first_page, Size npages)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; contiguous_pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(npages &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Record the new pages. */<br/></li>
<li></span>&nbsp; &nbsp; contiguous_pages =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1476" title="utils/mmgr/freepage.c:1476">FreePageManagerPutInternal</a>(fpm, first_page, npages, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the new <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> we inserted into the page manager was contiguous with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an existing <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, it may have opened up <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> opportunities.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (contiguous_pages &gt; npages)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; cleanup_contiguous_pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cleanup_contiguous_pages = <a href="#L580" title="utils/mmgr/freepage.c:580">FreePageBtreeCleanup</a>(fpm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cleanup_contiguous_pages &gt; contiguous_pages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; contiguous_pages = cleanup_contiguous_pages;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See if we <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have a new largest chunk. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fpm-&gt;contiguous_pages &lt; contiguous_pages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fpm-&gt;contiguous_pages = contiguous_pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The earlier call to <a href="#L1476" title="utils/mmgr/freepage.c:1476">FreePageManagerPutInternal</a> may have set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contiguous_pages_dirty if it needed to allocate <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> pages, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recompute contiguous_pages if necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L366" title="utils/mmgr/freepage.c:366">FreePageManagerUpdateLargest</a>(fpm);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef FPM_EXTRA_ASSERTS<br/></li>
<li></span>&nbsp; &nbsp; fpm-&gt;free_pages += npages;<br/></li>
<li>&nbsp; &nbsp; Assert(fpm-&gt;free_pages == <a href="#L274" title="utils/mmgr/freepage.c:274">sum_free_pages</a>(fpm));<br/></li>
<li>&nbsp; &nbsp; Assert(fpm-&gt;contiguous_pages == <a href="#L324" title="utils/mmgr/freepage.c:324">FreePageManagerLargestContiguous</a>(fpm));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Produce a debugging <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> of the state of a free page manager.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L424">&#x200c;</a><span class="linkable">FreePageManagerDump</span>(FreePageManager *fpm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *base = fpm_segment_base(fpm);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *recycle;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dumped_any_freelist = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; f;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize output buffer. */<br/></li>
<li></span>&nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Dump general stuff. */<br/></li>
<li></span>&nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;metadata: self </span><span class="Special">%zu</span><span class="Constant"> max contiguous pages = </span><span class="Special">%zu\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relptr_offset(fpm-&gt;self), fpm-&gt;contiguous_pages);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Dump btree. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fpm-&gt;btree_depth &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *root;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;btree depth </span><span class="Special">%u</span><span class="Constant">:</span><span class="Special">\n</span><span class="Constant">&quot;</span>, fpm-&gt;btree_depth);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root = relptr_access(base, fpm-&gt;btree_root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1250" title="utils/mmgr/freepage.c:1250">FreePageManagerDumpBtree</a>(fpm, root, <span class="Constant">NULL</span>, <span class="Constant">0</span>, &amp;buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (fpm-&gt;singleton_npages &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;singleton: </span><span class="Special">%zu</span><span class="Constant">(</span><span class="Special">%zu</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fpm-&gt;singleton_first_page, fpm-&gt;singleton_npages);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Dump btree recycle list. */<br/></li>
<li></span>&nbsp; &nbsp; recycle = relptr_access(base, fpm-&gt;btree_recycle);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (recycle != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot;btree recycle:&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1296" title="utils/mmgr/freepage.c:1296">FreePageManagerDumpSpans</a>(fpm, recycle, <span class="Constant">1</span>, &amp;buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Dump free lists. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (f = <span class="Constant">0</span>; f &lt; FPM_NUM_FREELISTS; ++f)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *span;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relptr_is_null(fpm-&gt;freelist[f]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!dumped_any_freelist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot;freelists:</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dumped_any_freelist = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;&nbsp; </span><span class="Special">%zu</span><span class="Constant">:&quot;</span>, f + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; span = relptr_access(base, fpm-&gt;freelist[f]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1296" title="utils/mmgr/freepage.c:1296">FreePageManagerDumpSpans</a>(fpm, span, f + <span class="Constant">1</span>, &amp;buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And return result to caller. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> buf.data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The first_page value stored at index zero in <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-root page must match<br/></li>
<li></span><span class="Comment"> * the first_page value stored in its parent at the index which points to that<br/></li>
<li></span><span class="Comment"> * page.&nbsp; So when the value stored at index zero in a btree page changes, we've<br/></li>
<li></span><span class="Comment"> * got to walk up the tree adjusting ancestor keys until we reach an ancestor<br/></li>
<li></span><span class="Comment"> * where that key isn't index zero.&nbsp; This function should be called after<br/></li>
<li></span><span class="Comment"> * updating the first key on the target page; it will propagate the change<br/></li>
<li></span><span class="Comment"> * upward as far as needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume here that the first key on the page has not changed enough to<br/></li>
<li></span><span class="Comment"> * require changes in the ordering of keys on its ancestor pages.&nbsp; Thus,<br/></li>
<li></span><span class="Comment"> * if we search the parent page for the first key greater than or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to<br/></li>
<li></span><span class="Comment"> * the first key on the current page, the downlink to this page will be either<br/></li>
<li></span><span class="Comment"> * the exact index returned by the search (if the first key decreased)<br/></li>
<li></span><span class="Comment"> * or one less (if the first key increased).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L501">&#x200c;</a></span><span class="linkable">FreePageBtreeAdjustAncestorKeys</span>(FreePageManager *fpm, <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *base = fpm_segment_base(fpm);<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; first_page;<br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *parent;<br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *child;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This might be either a leaf or an <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(btp-&gt;hdr.nused &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (btp-&gt;hdr.magic == <a href="#L64" title="utils/mmgr/freepage.c:64">FREE_PAGE_LEAF_MAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(btp-&gt;hdr.nused &lt;= <a href="#L103" title="utils/mmgr/freepage.c:103">FPM_ITEMS_PER_LEAF_PAGE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; first_page = btp-&gt;u.leaf_key[<span class="Constant">0</span>].first_page;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(btp-&gt;hdr.magic == <a href="#L65" title="utils/mmgr/freepage.c:65">FREE_PAGE_INTERNAL_MAGIC</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(btp-&gt;hdr.nused &lt;= <a href="#L100" title="utils/mmgr/freepage.c:100">FPM_ITEMS_PER_INTERNAL_PAGE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; first_page = btp-&gt;u.internal_key[<span class="Constant">0</span>].first_page;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; child = btp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop until we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an ancestor that does not require adjustment. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent = relptr_access(base, child-&gt;hdr.parent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s = <a href="#L1140" title="utils/mmgr/freepage.c:1140">FreePageBtreeSearchInternal</a>(parent, first_page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Key is either at index s or index s-1; figure out which. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s &gt;= parent-&gt;hdr.nused)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(s == parent-&gt;hdr.nused);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --s;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *check;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; check = relptr_access(base, parent-&gt;u.internal_key[s].child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (check != child)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(s &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --s;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Debugging double-check. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *check;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; check = relptr_access(base, parent-&gt;u.internal_key[s].child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(s &lt; parent-&gt;hdr.nused);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(child == check);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update the parent key. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; parent-&gt;u.internal_key[s].first_page = first_page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is the first key in the parent, go up another level; else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; child = parent;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attempt to reclaim space from the free-page btree.&nbsp; The return value is<br/></li>
<li></span><span class="Comment"> * the largest <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of contiguous pages created by the <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> operation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Size<br/></li>
<li><a id="L580">&#x200c;</a><span class="linkable">FreePageBtreeCleanup</span>(FreePageManager *fpm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *base = fpm_segment_base(fpm);<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; max_contiguous_pages = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Attempt to shrink the depth of the btree. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (!relptr_is_null(fpm-&gt;btree_root))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *root = relptr_access(base, fpm-&gt;btree_root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If the root contains only one key, reduce depth by one. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;hdr.nused == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Shrink depth of tree by one. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(fpm-&gt;btree_depth &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --fpm-&gt;btree_depth;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;hdr.magic == <a href="#L64" title="utils/mmgr/freepage.c:64">FREE_PAGE_LEAF_MAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If root is a leaf, convert only entry to singleton <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relptr_store(base, fpm-&gt;btree_root, (<a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *) <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fpm-&gt;singleton_first_page = root-&gt;u.leaf_key[<span class="Constant">0</span>].first_page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fpm-&gt;singleton_npages = root-&gt;u.leaf_key[<span class="Constant">0</span>].npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *newroot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If root is an <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page, make only child the root. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(root-&gt;hdr.magic == <a href="#L65" title="utils/mmgr/freepage.c:65">FREE_PAGE_INTERNAL_MAGIC</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relptr_copy(fpm-&gt;btree_root, root-&gt;u.internal_key[<span class="Constant">0</span>].child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newroot = relptr_access(base, fpm-&gt;btree_root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relptr_store(base, newroot-&gt;hdr.parent, (<a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *) <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L934" title="utils/mmgr/freepage.c:934">FreePageBtreeRecycle</a>(fpm, fpm_pointer_to_page(base, root));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (root-&gt;hdr.nused == <span class="Constant">2</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root-&gt;hdr.magic == <a href="#L64" title="utils/mmgr/freepage.c:64">FREE_PAGE_LEAF_MAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; end_of_first;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; start_of_second;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_of_first = root-&gt;u.leaf_key[<span class="Constant">0</span>].first_page +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;u.leaf_key[<span class="Constant">0</span>].npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start_of_second = root-&gt;u.leaf_key[<span class="Constant">1</span>].first_page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (end_of_first + <span class="Constant">1</span> == start_of_second)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; root_page = fpm_pointer_to_page(base, root);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (end_of_first == root_page)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1843" title="utils/mmgr/freepage.c:1843">FreePagePopSpanLeader</a>(fpm, root-&gt;u.leaf_key[<span class="Constant">0</span>].first_page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1843" title="utils/mmgr/freepage.c:1843">FreePagePopSpanLeader</a>(fpm, root-&gt;u.leaf_key[<span class="Constant">1</span>].first_page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fpm-&gt;singleton_first_page = root-&gt;u.leaf_key[<span class="Constant">0</span>].first_page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fpm-&gt;singleton_npages = root-&gt;u.leaf_key[<span class="Constant">0</span>].npages +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;u.leaf_key[<span class="Constant">1</span>].npages + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fpm-&gt;btree_depth = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relptr_store(base, fpm-&gt;btree_root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *) <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1871" title="utils/mmgr/freepage.c:1871">FreePagePushSpanLeader</a>(fpm, fpm-&gt;singleton_first_page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fpm-&gt;singleton_npages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(max_contiguous_pages == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_contiguous_pages = fpm-&gt;singleton_npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Whether it worked or not, it's time to stop. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nothing more to do.&nbsp; Stop. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Attempt to free recycled btree pages.&nbsp; We <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this if releasing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recycled page would require a btree page split, because the page we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trying to recycle would be consumed by the split, which would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * counterproductive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We also currently only ever attempt to recycle the first page on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list; that could be made more aggressive, but it's not clear that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * complexity would be worthwhile.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (fpm-&gt;btree_recycle_count &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; first_page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; contiguous_pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; btp = <a href="#L880" title="utils/mmgr/freepage.c:880">FreePageBtreeGetRecycled</a>(fpm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; first_page = fpm_pointer_to_page(base, btp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; contiguous_pages = <a href="#L1476" title="utils/mmgr/freepage.c:1476">FreePageManagerPutInternal</a>(fpm, first_page, <span class="Constant">1</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (contiguous_pages == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L934" title="utils/mmgr/freepage.c:934">FreePageBtreeRecycle</a>(fpm, first_page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (contiguous_pages &gt; max_contiguous_pages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_contiguous_pages = contiguous_pages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> max_contiguous_pages;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Consider consolidating the given page with its left or right sibling,<br/></li>
<li></span><span class="Comment"> * if it's fairly empty.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L695">&#x200c;</a></span><span class="linkable">FreePageBtreeConsolidate</span>(FreePageManager *fpm, <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *base = fpm_segment_base(fpm);<br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *np;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; max;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We only try to consolidate pages that are less than a third full. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could be more aggressive about this, but that might risk performing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consolidation only to end up splitting again shortly thereafter.&nbsp; Since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the btree should be very small compared to the space under management,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * our goal isn't so much to ensure that it always occupies the absolutely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * smallest possible number of pages as to reclaim pages <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> things get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * too egregiously out of hand.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (btp-&gt;hdr.magic == <a href="#L64" title="utils/mmgr/freepage.c:64">FREE_PAGE_LEAF_MAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; max = <a href="#L103" title="utils/mmgr/freepage.c:103">FPM_ITEMS_PER_LEAF_PAGE</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(btp-&gt;hdr.magic == <a href="#L65" title="utils/mmgr/freepage.c:65">FREE_PAGE_INTERNAL_MAGIC</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; max = <a href="#L100" title="utils/mmgr/freepage.c:100">FPM_ITEMS_PER_INTERNAL_PAGE</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (btp-&gt;hdr.nused &gt;= max / <span class="Constant">3</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we can fit our right sibling's keys onto this page, consolidate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; np = <a href="#L819" title="utils/mmgr/freepage.c:819">FreePageBtreeFindRightSibling</a>(base, btp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (np != <span class="Constant">NULL</span> &amp;&amp; btp-&gt;hdr.nused + np-&gt;hdr.nused &lt;= max)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (btp-&gt;hdr.magic == <a href="#L64" title="utils/mmgr/freepage.c:64">FREE_PAGE_LEAF_MAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;btp-&gt;u.leaf_key[btp-&gt;hdr.nused], &amp;np-&gt;u.leaf_key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L93" title="utils/mmgr/freepage.c:93">FreePageBtreeLeafKey</a>) * np-&gt;hdr.nused);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; btp-&gt;hdr.nused += np-&gt;hdr.nused;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;btp-&gt;u.internal_key[btp-&gt;hdr.nused], &amp;np-&gt;u.internal_key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L86" title="utils/mmgr/freepage.c:86">FreePageBtreeInternalKey</a>) * np-&gt;hdr.nused);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; btp-&gt;hdr.nused += np-&gt;hdr.nused;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1232" title="utils/mmgr/freepage.c:1232">FreePageBtreeUpdateParentPointers</a>(base, btp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L987" title="utils/mmgr/freepage.c:987">FreePageBtreeRemovePage</a>(fpm, np);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we can fit our keys onto our left sibling's page, consolidate. In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this case, we move our keys onto the other page rather than vice versa,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to avoid having to adjust ancestor keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; np = <a href="#L774" title="utils/mmgr/freepage.c:774">FreePageBtreeFindLeftSibling</a>(base, btp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (np != <span class="Constant">NULL</span> &amp;&amp; btp-&gt;hdr.nused + np-&gt;hdr.nused &lt;= max)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (btp-&gt;hdr.magic == <a href="#L64" title="utils/mmgr/freepage.c:64">FREE_PAGE_LEAF_MAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;np-&gt;u.leaf_key[np-&gt;hdr.nused], &amp;btp-&gt;u.leaf_key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L93" title="utils/mmgr/freepage.c:93">FreePageBtreeLeafKey</a>) * btp-&gt;hdr.nused);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; np-&gt;hdr.nused += btp-&gt;hdr.nused;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;np-&gt;u.internal_key[np-&gt;hdr.nused], &amp;btp-&gt;u.internal_key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L86" title="utils/mmgr/freepage.c:86">FreePageBtreeInternalKey</a>) * btp-&gt;hdr.nused);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; np-&gt;hdr.nused += btp-&gt;hdr.nused;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1232" title="utils/mmgr/freepage.c:1232">FreePageBtreeUpdateParentPointers</a>(base, np);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L987" title="utils/mmgr/freepage.c:987">FreePageBtreeRemovePage</a>(fpm, btp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find the passed page's left sibling; that is, the page at the same level<br/></li>
<li></span><span class="Comment"> * of the tree whose keyspace immediately precedes ours.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *<br/></li>
<li><a id="L774">&#x200c;</a><span class="linkable">FreePageBtreeFindLeftSibling</span>(<span class="Type">char</span> *base, <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *p = btp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; levels = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Move up until we can move left. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; first_page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; first_page = <a href="#L863" title="utils/mmgr/freepage.c:863">FreePageBtreeFirstKey</a>(p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p = relptr_access(base, p-&gt;hdr.parent);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we were passed the rightmost page */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; index = <a href="#L1140" title="utils/mmgr/freepage.c:1140">FreePageBtreeSearchInternal</a>(p, first_page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(p-&gt;u.internal_key[index].first_page == first_page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = relptr_access(base, p-&gt;u.internal_key[index - <span class="Constant">1</span>].child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(index == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ++levels;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Descend left. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (levels &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(p-&gt;hdr.magic == <a href="#L65" title="utils/mmgr/freepage.c:65">FREE_PAGE_INTERNAL_MAGIC</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p = relptr_access(base, p-&gt;u.internal_key[p-&gt;hdr.nused - <span class="Constant">1</span>].child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; --levels;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(p-&gt;hdr.magic == btp-&gt;hdr.magic);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> p;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find the passed page's right sibling; that is, the page at the same level<br/></li>
<li></span><span class="Comment"> * of the tree whose keyspace immediately follows ours.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *<br/></li>
<li><a id="L819">&#x200c;</a><span class="linkable">FreePageBtreeFindRightSibling</span>(<span class="Type">char</span> *base, <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *p = btp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; levels = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Move up until we can move right. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; first_page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; first_page = <a href="#L863" title="utils/mmgr/freepage.c:863">FreePageBtreeFirstKey</a>(p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p = relptr_access(base, p-&gt;hdr.parent);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we were passed the rightmost page */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; index = <a href="#L1140" title="utils/mmgr/freepage.c:1140">FreePageBtreeSearchInternal</a>(p, first_page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index &lt; p-&gt;hdr.nused - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(p-&gt;u.internal_key[index].first_page == first_page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = relptr_access(base, p-&gt;u.internal_key[index + <span class="Constant">1</span>].child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(index == p-&gt;hdr.nused - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ++levels;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Descend left. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (levels &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(p-&gt;hdr.magic == <a href="#L65" title="utils/mmgr/freepage.c:65">FREE_PAGE_INTERNAL_MAGIC</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p = relptr_access(base, p-&gt;u.internal_key[<span class="Constant">0</span>].child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; --levels;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(p-&gt;hdr.magic == btp-&gt;hdr.magic);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> p;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the first key on a btree page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Size<br/></li>
<li><a id="L863">&#x200c;</a><span class="linkable">FreePageBtreeFirstKey</span>(<a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(btp-&gt;hdr.nused &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (btp-&gt;hdr.magic == <a href="#L64" title="utils/mmgr/freepage.c:64">FREE_PAGE_LEAF_MAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> btp-&gt;u.leaf_key[<span class="Constant">0</span>].first_page;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(btp-&gt;hdr.magic == <a href="#L65" title="utils/mmgr/freepage.c:65">FREE_PAGE_INTERNAL_MAGIC</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> btp-&gt;u.internal_key[<span class="Constant">0</span>].first_page;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get a page from the btree recycle list for use as a btree page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *<br/></li>
<li><a id="L880">&#x200c;</a><span class="linkable">FreePageBtreeGetRecycled</span>(FreePageManager *fpm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *base = fpm_segment_base(fpm);<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *victim = relptr_access(base, fpm-&gt;btree_recycle);<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *newhead;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(victim != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; newhead = relptr_access(base, victim-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newhead != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relptr_copy(newhead-&gt;prev, victim-&gt;prev);<br/></li>
<li>&nbsp; &nbsp; relptr_store(base, fpm-&gt;btree_recycle, newhead);<br/></li>
<li>&nbsp; &nbsp; Assert(fpm_pointer_is_page_aligned(base, victim));<br/></li>
<li>&nbsp; &nbsp; fpm-&gt;btree_recycle_count--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *) victim;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> an item into an <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L900">&#x200c;</a></span><span class="linkable">FreePageBtreeInsertInternal</span>(<span class="Type">char</span> *base, <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp, Size index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size first_page, <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *child)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(btp-&gt;hdr.magic == <a href="#L65" title="utils/mmgr/freepage.c:65">FREE_PAGE_INTERNAL_MAGIC</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(btp-&gt;hdr.nused &lt;= <a href="#L100" title="utils/mmgr/freepage.c:100">FPM_ITEMS_PER_INTERNAL_PAGE</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(index &lt;= btp-&gt;hdr.nused);<br/></li>
<li>&nbsp; &nbsp; memmove(&amp;btp-&gt;u.internal_key[index + <span class="Constant">1</span>], &amp;btp-&gt;u.internal_key[index],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L86" title="utils/mmgr/freepage.c:86">FreePageBtreeInternalKey</a>) * (btp-&gt;hdr.nused - index));<br/></li>
<li>&nbsp; &nbsp; btp-&gt;u.internal_key[index].first_page = first_page;<br/></li>
<li>&nbsp; &nbsp; relptr_store(base, btp-&gt;u.internal_key[index].child, child);<br/></li>
<li>&nbsp; &nbsp; ++btp-&gt;hdr.nused;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> an item into a leaf page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L917">&#x200c;</a></span><span class="linkable">FreePageBtreeInsertLeaf</span>(<a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp, Size index, Size first_page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size npages)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(btp-&gt;hdr.magic == <a href="#L64" title="utils/mmgr/freepage.c:64">FREE_PAGE_LEAF_MAGIC</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(btp-&gt;hdr.nused &lt;= <a href="#L103" title="utils/mmgr/freepage.c:103">FPM_ITEMS_PER_LEAF_PAGE</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(index &lt;= btp-&gt;hdr.nused);<br/></li>
<li>&nbsp; &nbsp; memmove(&amp;btp-&gt;u.leaf_key[index + <span class="Constant">1</span>], &amp;btp-&gt;u.leaf_key[index],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L93" title="utils/mmgr/freepage.c:93">FreePageBtreeLeafKey</a>) * (btp-&gt;hdr.nused - index));<br/></li>
<li>&nbsp; &nbsp; btp-&gt;u.leaf_key[index].first_page = first_page;<br/></li>
<li>&nbsp; &nbsp; btp-&gt;u.leaf_key[index].npages = npages;<br/></li>
<li>&nbsp; &nbsp; ++btp-&gt;hdr.nused;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Put a page on the btree recycle list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L934">&#x200c;</a></span><span class="linkable">FreePageBtreeRecycle</span>(FreePageManager *fpm, Size pageno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *base = fpm_segment_base(fpm);<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *head = relptr_access(base, fpm-&gt;btree_recycle);<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *span;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; span = (<a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *) fpm_page_to_pointer(base, pageno);<br/></li>
<li>&nbsp; &nbsp; span-&gt;magic = <a href="#L63" title="utils/mmgr/freepage.c:63">FREE_PAGE_SPAN_LEADER_MAGIC</a>;<br/></li>
<li>&nbsp; &nbsp; span-&gt;npages = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; relptr_store(base, span-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>, head);<br/></li>
<li>&nbsp; &nbsp; relptr_store(base, span-&gt;prev, (<a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *) <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (head != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relptr_store(base, head-&gt;prev, span);<br/></li>
<li>&nbsp; &nbsp; relptr_store(base, fpm-&gt;btree_recycle, span);<br/></li>
<li>&nbsp; &nbsp; fpm-&gt;btree_recycle_count++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove an item from the btree at the given position on the given page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L955">&#x200c;</a></span><span class="linkable">FreePageBtreeRemove</span>(FreePageManager *fpm, <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp, Size index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(btp-&gt;hdr.magic == <a href="#L64" title="utils/mmgr/freepage.c:64">FREE_PAGE_LEAF_MAGIC</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(index &lt; btp-&gt;hdr.nused);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* When last item is removed, extirpate entire page from btree. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (btp-&gt;hdr.nused == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L987" title="utils/mmgr/freepage.c:987">FreePageBtreeRemovePage</a>(fpm, btp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Physically remove the key from the page. */<br/></li>
<li></span>&nbsp; &nbsp; --btp-&gt;hdr.nused;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (index &lt; btp-&gt;hdr.nused)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memmove(&amp;btp-&gt;u.leaf_key[index], &amp;btp-&gt;u.leaf_key[index + <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L93" title="utils/mmgr/freepage.c:93">FreePageBtreeLeafKey</a>) * (btp-&gt;hdr.nused - index));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we just removed the first key, adjust ancestor keys. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (index == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L501" title="utils/mmgr/freepage.c:501">FreePageBtreeAdjustAncestorKeys</a>(fpm, btp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Consider whether to consolidate this page with a sibling. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L695" title="utils/mmgr/freepage.c:695">FreePageBtreeConsolidate</a>(fpm, btp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove a page from the btree.&nbsp; Caller is responsible for having relocated<br/></li>
<li></span><span class="Comment"> * <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> keys from this page that are still wanted.&nbsp; The page is placed on the<br/></li>
<li></span><span class="Comment"> * recycled list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L987">&#x200c;</a></span><span class="linkable">FreePageBtreeRemovePage</span>(FreePageManager *fpm, <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *base = fpm_segment_base(fpm);<br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *parent;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; first_page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find parent page. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; parent = relptr_access(base, btp-&gt;hdr.parent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We are removing the root page. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relptr_store(base, fpm-&gt;btree_root, (<a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *) <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fpm-&gt;btree_depth = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(fpm-&gt;singleton_first_page == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(fpm-&gt;singleton_npages == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the parent contains only one item, we need to remove it as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent-&gt;hdr.nused &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L934" title="utils/mmgr/freepage.c:934">FreePageBtreeRecycle</a>(fpm, fpm_pointer_to_page(base, btp));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; btp = parent;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find and remove the downlink. */<br/></li>
<li></span>&nbsp; &nbsp; first_page = <a href="#L863" title="utils/mmgr/freepage.c:863">FreePageBtreeFirstKey</a>(btp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parent-&gt;hdr.magic == <a href="#L64" title="utils/mmgr/freepage.c:64">FREE_PAGE_LEAF_MAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; index = <a href="#L1170" title="utils/mmgr/freepage.c:1170">FreePageBtreeSearchLeaf</a>(parent, first_page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(index &lt; parent-&gt;hdr.nused);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index &lt; parent-&gt;hdr.nused - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memmove(&amp;parent-&gt;u.leaf_key[index],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;parent-&gt;u.leaf_key[index + <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L93" title="utils/mmgr/freepage.c:93">FreePageBtreeLeafKey</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * (parent-&gt;hdr.nused - index - <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; index = <a href="#L1140" title="utils/mmgr/freepage.c:1140">FreePageBtreeSearchInternal</a>(parent, first_page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(index &lt; parent-&gt;hdr.nused);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index &lt; parent-&gt;hdr.nused - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memmove(&amp;parent-&gt;u.internal_key[index],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;parent-&gt;u.internal_key[index + <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L86" title="utils/mmgr/freepage.c:86">FreePageBtreeInternalKey</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * (parent-&gt;hdr.nused - index - <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; parent-&gt;hdr.nused--;<br/></li>
<li>&nbsp; &nbsp; Assert(parent-&gt;hdr.nused &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Recycle the page. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L934" title="utils/mmgr/freepage.c:934">FreePageBtreeRecycle</a>(fpm, fpm_pointer_to_page(base, btp));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Adjust ancestor keys if needed. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (index == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L501" title="utils/mmgr/freepage.c:501">FreePageBtreeAdjustAncestorKeys</a>(fpm, parent);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Consider whether to consolidate the parent with a sibling. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L695" title="utils/mmgr/freepage.c:695">FreePageBtreeConsolidate</a>(fpm, parent);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Search the btree for an entry for the given first page and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a><br/></li>
<li></span><span class="Comment"> * *result with the results of the search.&nbsp; result-&gt;page and result-&gt;index<br/></li>
<li></span><span class="Comment"> * indicate either the position of an exact match or the position at which<br/></li>
<li></span><span class="Comment"> * the new key should be inserted.&nbsp; result-&gt;found is true for an exact match,<br/></li>
<li></span><span class="Comment"> * otherwise false.&nbsp; result-&gt;split_pages will contain the number of additional<br/></li>
<li></span><span class="Comment"> * btree pages that will be needed when performing a split to insert a key.<br/></li>
<li></span><span class="Comment"> * Except as described above, the contents of fields in the result object are<br/></li>
<li></span><span class="Comment"> * undefined on return.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1064">&#x200c;</a></span><span class="linkable">FreePageBtreeSearch</span>(FreePageManager *fpm, Size first_page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L119" title="utils/mmgr/freepage.c:119">FreePageBtreeSearchResult</a> *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *base = fpm_segment_base(fpm);<br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp = relptr_access(base, fpm-&gt;btree_root);<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;split_pages = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If the btree is empty, there's nothing to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (btp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;page = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Descend until we hit a leaf. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (btp-&gt;hdr.magic == <a href="#L65" title="utils/mmgr/freepage.c:65">FREE_PAGE_INTERNAL_MAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *child;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found_exact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; index = <a href="#L1140" title="utils/mmgr/freepage.c:1140">FreePageBtreeSearchInternal</a>(btp, first_page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; found_exact = index &lt; btp-&gt;hdr.nused &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; btp-&gt;u.internal_key[index].first_page == first_page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we found an exact match we descend directly.&nbsp; Otherwise, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * descend into the child to the left if possible so that we can <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the insertion point at that child's high end.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found_exact &amp;&amp; index &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Track required split depth for leaf insert. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (btp-&gt;hdr.nused &gt;= <a href="#L100" title="utils/mmgr/freepage.c:100">FPM_ITEMS_PER_INTERNAL_PAGE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(btp-&gt;hdr.nused == <a href="#L100" title="utils/mmgr/freepage.c:100">FPM_ITEMS_PER_INTERNAL_PAGE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;split_pages++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;split_pages = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Descend to appropriate child page. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(index &lt; btp-&gt;hdr.nused);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; child = relptr_access(base, btp-&gt;u.internal_key[index].child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(relptr_access(base, child-&gt;hdr.parent) == btp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; btp = child;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Track required split depth for leaf insert. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (btp-&gt;hdr.nused &gt;= <a href="#L103" title="utils/mmgr/freepage.c:103">FPM_ITEMS_PER_LEAF_PAGE</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(btp-&gt;hdr.nused == <a href="#L100" title="utils/mmgr/freepage.c:100">FPM_ITEMS_PER_INTERNAL_PAGE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;split_pages++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;split_pages = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Search leaf page. */<br/></li>
<li></span>&nbsp; &nbsp; index = <a href="#L1170" title="utils/mmgr/freepage.c:1170">FreePageBtreeSearchLeaf</a>(btp, first_page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assemble results. */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;page = btp;<br/></li>
<li>&nbsp; &nbsp; result-&gt;index = index;<br/></li>
<li>&nbsp; &nbsp; result-&gt;found = index &lt; btp-&gt;hdr.nused &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; first_page == btp-&gt;u.leaf_key[index].first_page;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Search an <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page for the first key greater than or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to a given<br/></li>
<li></span><span class="Comment"> * page number.&nbsp; Returns the index of that key, or one greater than the number<br/></li>
<li></span><span class="Comment"> * of keys on the page if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Size<br/></li>
<li><a id="L1140">&#x200c;</a><span class="linkable">FreePageBtreeSearchInternal</span>(<a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp, Size first_page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; low = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; high = btp-&gt;hdr.nused;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(btp-&gt;hdr.magic == <a href="#L65" title="utils/mmgr/freepage.c:65">FREE_PAGE_INTERNAL_MAGIC</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(high &gt; <span class="Constant">0</span> &amp;&amp; high &lt;= <a href="#L100" title="utils/mmgr/freepage.c:100">FPM_ITEMS_PER_INTERNAL_PAGE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (low &lt; high)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; mid = (low + high) / <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; val = btp-&gt;u.internal_key[mid].first_page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (first_page == val)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> mid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (first_page &lt; val)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high = mid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low = mid + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> low;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Search a leaf page for the first key greater than or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to a given<br/></li>
<li></span><span class="Comment"> * page number.&nbsp; Returns the index of that key, or one greater than the number<br/></li>
<li></span><span class="Comment"> * of keys on the page if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Size<br/></li>
<li><a id="L1170">&#x200c;</a><span class="linkable">FreePageBtreeSearchLeaf</span>(<a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp, Size first_page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; low = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; high = btp-&gt;hdr.nused;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(btp-&gt;hdr.magic == <a href="#L64" title="utils/mmgr/freepage.c:64">FREE_PAGE_LEAF_MAGIC</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(high &gt; <span class="Constant">0</span> &amp;&amp; high &lt;= <a href="#L103" title="utils/mmgr/freepage.c:103">FPM_ITEMS_PER_LEAF_PAGE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (low &lt; high)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; mid = (low + high) / <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; val = btp-&gt;u.leaf_key[mid].first_page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (first_page == val)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> mid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (first_page &lt; val)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high = mid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low = mid + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> low;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate a new btree page and move half the keys from the provided page<br/></li>
<li></span><span class="Comment"> * to the new page.&nbsp; Caller is responsible for making sure that there's a<br/></li>
<li></span><span class="Comment"> * page available from fpm-&gt;btree_recycle.&nbsp; Returns a pointer to the new page,<br/></li>
<li></span><span class="Comment"> * to which caller must add a downlink.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *<br/></li>
<li><a id="L1201">&#x200c;</a><span class="linkable">FreePageBtreeSplitPage</span>(FreePageManager *fpm, <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *newsibling;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newsibling = <a href="#L880" title="utils/mmgr/freepage.c:880">FreePageBtreeGetRecycled</a>(fpm);<br/></li>
<li>&nbsp; &nbsp; newsibling-&gt;hdr.magic = btp-&gt;hdr.magic;<br/></li>
<li>&nbsp; &nbsp; newsibling-&gt;hdr.nused = btp-&gt;hdr.nused / <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; relptr_copy(newsibling-&gt;hdr.parent, btp-&gt;hdr.parent);<br/></li>
<li>&nbsp; &nbsp; btp-&gt;hdr.nused -= newsibling-&gt;hdr.nused;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (btp-&gt;hdr.magic == <a href="#L64" title="utils/mmgr/freepage.c:64">FREE_PAGE_LEAF_MAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;newsibling-&gt;u.leaf_key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;btp-&gt;u.leaf_key[btp-&gt;hdr.nused],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L93" title="utils/mmgr/freepage.c:93">FreePageBtreeLeafKey</a>) * newsibling-&gt;hdr.nused);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(btp-&gt;hdr.magic == <a href="#L65" title="utils/mmgr/freepage.c:65">FREE_PAGE_INTERNAL_MAGIC</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;newsibling-&gt;u.internal_key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;btp-&gt;u.internal_key[btp-&gt;hdr.nused],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L86" title="utils/mmgr/freepage.c:86">FreePageBtreeInternalKey</a>) * newsibling-&gt;hdr.nused);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1232" title="utils/mmgr/freepage.c:1232">FreePageBtreeUpdateParentPointers</a>(fpm_segment_base(fpm), newsibling);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newsibling;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> pages are split or merged, the parent pointers of their<br/></li>
<li></span><span class="Comment"> * children must be updated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1232">&#x200c;</a></span><span class="linkable">FreePageBtreeUpdateParentPointers</span>(<span class="Type">char</span> *base, <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(btp-&gt;hdr.magic == <a href="#L65" title="utils/mmgr/freepage.c:65">FREE_PAGE_INTERNAL_MAGIC</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; btp-&gt;hdr.nused; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *child;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; child = relptr_access(base, btp-&gt;u.internal_key[i].child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relptr_store(base, child-&gt;hdr.parent, btp);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Debugging <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> of btree data.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1250">&#x200c;</a></span><span class="linkable">FreePageManagerDumpBtree</span>(FreePageManager *fpm, <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *btp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *parent, <span class="Type">int</span> level, StringInfo buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *base = fpm_segment_base(fpm);<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; pageno = fpm_pointer_to_page(base, btp);<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *check_parent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li>&nbsp; &nbsp; check_parent = relptr_access(base, btp-&gt;hdr.parent);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;&nbsp; </span><span class="Special">%zu</span><span class="Constant">@</span><span class="Special">%d</span><span class="Constant"> </span><span class="Special">%c</span><span class="Constant">&quot;</span>, pageno, level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; btp-&gt;hdr.magic == <a href="#L65" title="utils/mmgr/freepage.c:65">FREE_PAGE_INTERNAL_MAGIC</a> ? <span class="Constant">'i'</span> : <span class="Constant">'l'</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parent != check_parent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot; [actual parent </span><span class="Special">%zu</span><span class="Constant">, expected </span><span class="Special">%zu</span><span class="Constant">]&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fpm_pointer_to_page(base, check_parent),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fpm_pointer_to_page(base, parent));<br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(buf, <span class="Constant">':'</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (index = <span class="Constant">0</span>; index &lt; btp-&gt;hdr.nused; ++index)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (btp-&gt;hdr.magic == <a href="#L65" title="utils/mmgr/freepage.c:65">FREE_PAGE_INTERNAL_MAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot; </span><span class="Special">%zu</span><span class="Constant">-&gt;</span><span class="Special">%zu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; btp-&gt;u.internal_key[index].first_page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relptr_offset(btp-&gt;u.internal_key[index].child) / FPM_PAGE_SIZE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot; </span><span class="Special">%zu</span><span class="Constant">(</span><span class="Special">%zu</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; btp-&gt;u.leaf_key[index].first_page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; btp-&gt;u.leaf_key[index].npages);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(buf, <span class="Special">'\n'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (btp-&gt;hdr.magic == <a href="#L65" title="utils/mmgr/freepage.c:65">FREE_PAGE_INTERNAL_MAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (index = <span class="Constant">0</span>; index &lt; btp-&gt;hdr.nused; ++index)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *child;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child = relptr_access(base, btp-&gt;u.internal_key[index].child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1250" title="utils/mmgr/freepage.c:1250">FreePageManagerDumpBtree</a>(fpm, child, btp, level + <span class="Constant">1</span>, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Debugging <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> of free-span data.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1296">&#x200c;</a></span><span class="linkable">FreePageManagerDumpSpans</span>(FreePageManager *fpm, <a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *span,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Size expected_pages, StringInfo buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *base = fpm_segment_base(fpm);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (span != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (span-&gt;npages != expected_pages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot; </span><span class="Special">%zu</span><span class="Constant">(</span><span class="Special">%zu</span><span class="Constant">)&quot;</span>, fpm_pointer_to_page(base, span),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; span-&gt;npages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot; </span><span class="Special">%zu</span><span class="Constant">&quot;</span>, fpm_pointer_to_page(base, span));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; span = relptr_access(base, span-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(buf, <span class="Special">'\n'</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This function allocates a run of pages of the given length from the free<br/></li>
<li></span><span class="Comment"> * page manager.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1319">&#x200c;</a></span><span class="linkable">FreePageManagerGetInternal</span>(FreePageManager *fpm, Size npages, Size *first_page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *base = fpm_segment_base(fpm);<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *victim = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *prev;<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L119" title="utils/mmgr/freepage.c:119">FreePageBtreeSearchResult</a> result;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; victim_page = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* placate compiler */<br/></li>
<li></span>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; f;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Search for a free span.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Right <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we use a simple best-fit policy here, but it's possible for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this to result in memory fragmentation if we're repeatedly asked to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocate chunks just a little smaller than what we have available.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Hopefully, this is unlikely, because we expect most requests to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * single pages or superblock-sized chunks -- but no policy can be optimal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * under all circumstances unless it has knowledge of future allocation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * patterns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (f = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(npages, FPM_NUM_FREELISTS) - <span class="Constant">1</span>; f &lt; FPM_NUM_FREELISTS; ++f)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip empty freelists. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relptr_is_null(fpm-&gt;freelist[f]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * All of the freelists except the last one contain only items of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * single size, so we just take the first one.&nbsp; But the final free<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list contains everything too big for <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the other lists, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to search the list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (f &lt; FPM_NUM_FREELISTS - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; victim = relptr_access(base, fpm-&gt;freelist[f]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *candidate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; candidate = relptr_access(base, fpm-&gt;freelist[f]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (candidate-&gt;npages &gt;= npages &amp;&amp; (victim == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; victim-&gt;npages &gt; candidate-&gt;npages))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; victim = candidate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (victim-&gt;npages == npages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; candidate = relptr_access(base, candidate-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (candidate != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an allocatable span, return failure. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (victim == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove span from free list. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(victim-&gt;magic == <a href="#L63" title="utils/mmgr/freepage.c:63">FREE_PAGE_SPAN_LEADER_MAGIC</a>);<br/></li>
<li>&nbsp; &nbsp; prev = relptr_access(base, victim-&gt;prev);<br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = relptr_access(base, victim-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (prev != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relptr_copy(prev-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>, victim-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relptr_copy(fpm-&gt;freelist[f], victim-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relptr_copy(<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-&gt;prev, victim-&gt;prev);<br/></li>
<li>&nbsp; &nbsp; victim_page = fpm_pointer_to_page(base, victim);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Decide whether we might be invalidating contiguous_pages. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (f == FPM_NUM_FREELISTS - <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; victim-&gt;npages == fpm-&gt;contiguous_pages)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The victim span came from the oversized freelist, and had the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * size as the <a href="../../regex/rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a> span.&nbsp; There may or may not be another one of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same size, so contiguous_pages must be recomputed just to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fpm-&gt;contiguous_pages_dirty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (f + <span class="Constant">1</span> == fpm-&gt;contiguous_pages &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relptr_is_null(fpm-&gt;freelist[f]))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The victim span came from a fixed sized freelist, and it was the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list for spans of the same size as the current <a href="../../regex/rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a> span, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the list is <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> empty after removing the victim.&nbsp; So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contiguous_pages must be recomputed without a doubt.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fpm-&gt;contiguous_pages_dirty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we haven't initialized the btree yet, the victim must be the single<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * span stored within the FreePageManager itself.&nbsp; Otherwise, we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * update the btree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relptr_is_null(fpm-&gt;btree_root))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(victim_page == fpm-&gt;singleton_first_page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(victim-&gt;npages == fpm-&gt;singleton_npages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(victim-&gt;npages &gt;= npages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fpm-&gt;singleton_first_page += npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fpm-&gt;singleton_npages -= npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fpm-&gt;singleton_npages &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1871" title="utils/mmgr/freepage.c:1871">FreePagePushSpanLeader</a>(fpm, fpm-&gt;singleton_first_page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fpm-&gt;singleton_npages);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the span we found is exactly the right size, remove it from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * btree completely.&nbsp; Otherwise, adjust the btree entry to reflect the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still-unallocated portion of the span, and put that portion on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * appropriate free list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1064" title="utils/mmgr/freepage.c:1064">FreePageBtreeSearch</a>(fpm, victim_page, &amp;result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(result.found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (victim-&gt;npages == npages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L955" title="utils/mmgr/freepage.c:955">FreePageBtreeRemove</a>(fpm, result.page, result.index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L93" title="utils/mmgr/freepage.c:93">FreePageBtreeLeafKey</a> *key;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust btree to reflect remaining pages. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(victim-&gt;npages &gt; npages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key = &amp;result.page-&gt;u.leaf_key[result.index];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(key-&gt;npages == victim-&gt;npages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;first_page += npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;npages -= npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result.index == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L501" title="utils/mmgr/freepage.c:501">FreePageBtreeAdjustAncestorKeys</a>(fpm, result.page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Put the unallocated pages back on the appropriate free list. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1871" title="utils/mmgr/freepage.c:1871">FreePagePushSpanLeader</a>(fpm, victim_page + npages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; victim-&gt;npages - npages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return results to caller. */<br/></li>
<li></span>&nbsp; &nbsp; *first_page = fpm_pointer_to_page(base, victim);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Put a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of pages into the btree and freelists, consolidating it with<br/></li>
<li></span><span class="Comment"> * existing free spans just <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> and/or after it.&nbsp; If 'soft' is true,<br/></li>
<li></span><span class="Comment"> * only perform the insertion if it can be done without allocating new btree<br/></li>
<li></span><span class="Comment"> * pages; if false, do it always.&nbsp; Returns 0 if the soft flag caused the<br/></li>
<li></span><span class="Comment"> * insertion to be skipped, or otherwise the size of the contiguous span<br/></li>
<li></span><span class="Comment"> * created by the insertion.&nbsp; This may be larger than npages if we're able<br/></li>
<li></span><span class="Comment"> * to consolidate with an adjacent <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Size<br/></li>
<li><a id="L1476">&#x200c;</a><span class="linkable">FreePageManagerPutInternal</span>(FreePageManager *fpm, Size first_page, Size npages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> soft)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *base = fpm_segment_base(fpm);<br/></li>
<li>&nbsp; &nbsp; <a href="#L119" title="utils/mmgr/freepage.c:119">FreePageBtreeSearchResult</a> result;<br/></li>
<li>&nbsp; &nbsp; <a href="#L93" title="utils/mmgr/freepage.c:93">FreePageBtreeLeafKey</a> *prevkey = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L93" title="utils/mmgr/freepage.c:93">FreePageBtreeLeafKey</a> *nextkey = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *np;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; nindex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(npages &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can store a single free span without initializing the btree. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fpm-&gt;btree_depth == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fpm-&gt;singleton_npages == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't have a span yet; store this one. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fpm-&gt;singleton_first_page = first_page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fpm-&gt;singleton_npages = npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1871" title="utils/mmgr/freepage.c:1871">FreePagePushSpanLeader</a>(fpm, first_page, npages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> fpm-&gt;singleton_npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (fpm-&gt;singleton_first_page + fpm-&gt;singleton_npages ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; first_page)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* New span immediately follows sole existing span. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fpm-&gt;singleton_npages += npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1843" title="utils/mmgr/freepage.c:1843">FreePagePopSpanLeader</a>(fpm, fpm-&gt;singleton_first_page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1871" title="utils/mmgr/freepage.c:1871">FreePagePushSpanLeader</a>(fpm, fpm-&gt;singleton_first_page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fpm-&gt;singleton_npages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> fpm-&gt;singleton_npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (first_page + npages == fpm-&gt;singleton_first_page)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* New span immediately precedes sole existing span. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1843" title="utils/mmgr/freepage.c:1843">FreePagePopSpanLeader</a>(fpm, fpm-&gt;singleton_first_page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fpm-&gt;singleton_first_page = first_page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fpm-&gt;singleton_npages += npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1871" title="utils/mmgr/freepage.c:1871">FreePagePushSpanLeader</a>(fpm, fpm-&gt;singleton_first_page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fpm-&gt;singleton_npages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> fpm-&gt;singleton_npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not contiguous; we need to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the btree. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; root_page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *root;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!relptr_is_null(fpm-&gt;btree_recycle))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root = <a href="#L880" title="utils/mmgr/freepage.c:880">FreePageBtreeGetRecycled</a>(fpm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (soft)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Should not allocate if soft. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L1319" title="utils/mmgr/freepage.c:1319">FreePageManagerGetInternal</a>(fpm, <span class="Constant">1</span>, &amp;root_page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root = (<a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *) fpm_page_to_pointer(base, root_page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We'd better be able to get a page from the existing <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;free page manager btree is corrupt&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create the btree and move the preexisting <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> into it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;hdr.magic = <a href="#L64" title="utils/mmgr/freepage.c:64">FREE_PAGE_LEAF_MAGIC</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;hdr.nused = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relptr_store(base, root-&gt;hdr.parent, (<a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *) <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;u.leaf_key[<span class="Constant">0</span>].first_page = fpm-&gt;singleton_first_page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;u.leaf_key[<span class="Constant">0</span>].npages = fpm-&gt;singleton_npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relptr_store(base, fpm-&gt;btree_root, root);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fpm-&gt;singleton_first_page = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fpm-&gt;singleton_npages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fpm-&gt;btree_depth = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Corner case: it may be that the btree root took the very last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * free page.&nbsp; In that case, the sole btree entry covers a zero<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page run, which is invalid.&nbsp; Overwrite it with the entry we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * trying to insert and get out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (root-&gt;u.leaf_key[<span class="Constant">0</span>].npages == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;u.leaf_key[<span class="Constant">0</span>].first_page = first_page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root-&gt;u.leaf_key[<span class="Constant">0</span>].npages = npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1871" title="utils/mmgr/freepage.c:1871">FreePagePushSpanLeader</a>(fpm, first_page, npages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fall through to insert the new key. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Search the btree. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1064" title="utils/mmgr/freepage.c:1064">FreePageBtreeSearch</a>(fpm, first_page, &amp;result);<br/></li>
<li>&nbsp; &nbsp; Assert(!result.found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result.index &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prevkey = &amp;result.page-&gt;u.leaf_key[result.index - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result.index &lt; result.page-&gt;hdr.nused)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; np = result.page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nindex = result.index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nextkey = &amp;result.page-&gt;u.leaf_key[result.index];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; np = <a href="#L819" title="utils/mmgr/freepage.c:819">FreePageBtreeFindRightSibling</a>(base, result.page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nindex = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (np != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextkey = &amp;np-&gt;u.leaf_key[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Consolidate with the previous entry if possible. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (prevkey != <span class="Constant">NULL</span> &amp;&amp; prevkey-&gt;first_page + prevkey-&gt;npages &gt;= first_page)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; remove_next = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(prevkey-&gt;first_page + prevkey-&gt;npages == first_page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prevkey-&gt;npages = (first_page - prevkey-&gt;first_page) + npages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check whether we can *also* consolidate with the following entry. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nextkey != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevkey-&gt;first_page + prevkey-&gt;npages &gt;= nextkey-&gt;first_page)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(prevkey-&gt;first_page + prevkey-&gt;npages ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nextkey-&gt;first_page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevkey-&gt;npages = (nextkey-&gt;first_page - prevkey-&gt;first_page)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + nextkey-&gt;npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1843" title="utils/mmgr/freepage.c:1843">FreePagePopSpanLeader</a>(fpm, nextkey-&gt;first_page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remove_next = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Put the span on the correct freelist and save size. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1843" title="utils/mmgr/freepage.c:1843">FreePagePopSpanLeader</a>(fpm, prevkey-&gt;first_page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1871" title="utils/mmgr/freepage.c:1871">FreePagePushSpanLeader</a>(fpm, prevkey-&gt;first_page, prevkey-&gt;npages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = prevkey-&gt;npages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we consolidated with both the preceding and following entries,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we must remove the following entry.&nbsp; We do this last, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * removing an <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> from the btree may invalidate pointers we hold<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * into the current data structure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NB: The btree is technically in an invalid state a this point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because we've already updated prevkey to cover the same key space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as nextkey.&nbsp; <a href="#L955" title="utils/mmgr/freepage.c:955">FreePageBtreeRemove</a>() shouldn't notice that, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (remove_next)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L955" title="utils/mmgr/freepage.c:955">FreePageBtreeRemove</a>(fpm, np, nindex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Consolidate with the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> entry if possible. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nextkey != <span class="Constant">NULL</span> &amp;&amp; first_page + npages &gt;= nextkey-&gt;first_page)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; newpages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute new size for span. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(first_page + npages == nextkey-&gt;first_page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newpages = (nextkey-&gt;first_page - first_page) + nextkey-&gt;npages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Put span on correct free list. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1843" title="utils/mmgr/freepage.c:1843">FreePagePopSpanLeader</a>(fpm, nextkey-&gt;first_page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1871" title="utils/mmgr/freepage.c:1871">FreePagePushSpanLeader</a>(fpm, first_page, newpages);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update key in place. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nextkey-&gt;first_page = first_page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nextkey-&gt;npages = newpages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If reducing first key on page, ancestors might need adjustment. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nindex == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L501" title="utils/mmgr/freepage.c:501">FreePageBtreeAdjustAncestorKeys</a>(fpm, np);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> nextkey-&gt;npages;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Split leaf page and as many of its ancestors as necessary. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result.split_pages &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NB: We could consider various coping strategies here to avoid a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * split; most obviously, if np != result.page, we could target that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page instead.&nbsp;&nbsp; More complicated shuffling strategies could be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible as well; basically, unless every single leaf page is 100%<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * full, we can jam this key in there if we try hard enough.&nbsp; It's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unlikely that trying that hard is worthwhile, but it's possible we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might need to make more than no effort.&nbsp; For <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we just do the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * easy thing, which is nothing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If this is a soft insert, it's time to give up. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (soft)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check whether we need to allocate more btree pages to split. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result.split_pages &gt; fpm-&gt;btree_recycle_count)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; pages_needed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; recycle_page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Allocate the required number of pages and split each one in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * turn.&nbsp; This should never fail, because if we've got enough<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * spans of free pages kicking around that we need additional<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * storage space just to remember them all, then we should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * certainly have enough to expand the btree, which should only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ever use a tiny number of pages compared to the number under<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * management.&nbsp; If it does, something's badly screwed up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pages_needed = result.split_pages - fpm-&gt;btree_recycle_count;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; pages_needed; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1319" title="utils/mmgr/freepage.c:1319">FreePageManagerGetInternal</a>(fpm, <span class="Constant">1</span>, &amp;recycle_page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;free page manager btree is corrupt&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L934" title="utils/mmgr/freepage.c:934">FreePageBtreeRecycle</a>(fpm, recycle_page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The act of allocating pages to recycle may have invalidated the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * results of our previous btree research, so <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> it. (We could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recheck whether <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of our split-avoidance strategies that were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not viable <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> are, but it hardly seems worthwhile, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we don't bother. Consolidation can't be possible <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wasn't previously.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1064" title="utils/mmgr/freepage.c:1064">FreePageBtreeSearch</a>(fpm, first_page, &amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The act of allocating pages for use in constructing our btree<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should never cause <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> page to become more full, so the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * split depth should be no greater than the old one, and perhaps<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * less if we fortuitously allocated a chunk that freed up a slot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on the page we need to update.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(result.split_pages &lt;= fpm-&gt;btree_recycle_count);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we still need to perform a split, do it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result.split_pages &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *split_target = result.page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *child = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; key = first_page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *newsibling;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *parent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Identify parent page, which must receive downlink. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent = relptr_access(base, split_target-&gt;hdr.parent);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Split the page - downlink not added yet. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newsibling = <a href="#L1201" title="utils/mmgr/freepage.c:1201">FreePageBtreeSplitPage</a>(fpm, split_target);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At this point in the loop, we're always carrying a pending<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * insertion.&nbsp; On the first pass, it's the actual key we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * trying to insert; on subsequent passes, it's the downlink<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that needs to be added as a result of the split performed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * during the previous loop iteration.&nbsp; Since we've just split<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the page, there's definitely room on one of the two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * resulting pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (child == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *insert_into;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insert_into = key &lt; newsibling-&gt;u.leaf_key[<span class="Constant">0</span>].first_page ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; split_target : newsibling;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index = <a href="#L1170" title="utils/mmgr/freepage.c:1170">FreePageBtreeSearchLeaf</a>(insert_into, key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L917" title="utils/mmgr/freepage.c:917">FreePageBtreeInsertLeaf</a>(insert_into, index, key, npages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index == <span class="Constant">0</span> &amp;&amp; insert_into == split_target)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L501" title="utils/mmgr/freepage.c:501">FreePageBtreeAdjustAncestorKeys</a>(fpm, split_target);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *insert_into;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insert_into =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key &lt; newsibling-&gt;u.internal_key[<span class="Constant">0</span>].first_page ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; split_target : newsibling;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index = <a href="#L1140" title="utils/mmgr/freepage.c:1140">FreePageBtreeSearchInternal</a>(insert_into, key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L900" title="utils/mmgr/freepage.c:900">FreePageBtreeInsertInternal</a>(base, insert_into, index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key, child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relptr_store(base, child-&gt;hdr.parent, insert_into);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index == <span class="Constant">0</span> &amp;&amp; insert_into == split_target)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L501" title="utils/mmgr/freepage.c:501">FreePageBtreeAdjustAncestorKeys</a>(fpm, split_target);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If the page we just split has no parent, split the root. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *newroot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newroot = <a href="#L880" title="utils/mmgr/freepage.c:880">FreePageBtreeGetRecycled</a>(fpm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newroot-&gt;hdr.magic = <a href="#L65" title="utils/mmgr/freepage.c:65">FREE_PAGE_INTERNAL_MAGIC</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newroot-&gt;hdr.nused = <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relptr_store(base, newroot-&gt;hdr.parent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="#L108" title="utils/mmgr/freepage.c:108">FreePageBtree</a> *) <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newroot-&gt;u.internal_key[<span class="Constant">0</span>].first_page =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L863" title="utils/mmgr/freepage.c:863">FreePageBtreeFirstKey</a>(split_target);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relptr_store(base, newroot-&gt;u.internal_key[<span class="Constant">0</span>].child,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; split_target);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relptr_store(base, split_target-&gt;hdr.parent, newroot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newroot-&gt;u.internal_key[<span class="Constant">1</span>].first_page =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L863" title="utils/mmgr/freepage.c:863">FreePageBtreeFirstKey</a>(newsibling);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relptr_store(base, newroot-&gt;u.internal_key[<span class="Constant">1</span>].child,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newsibling);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relptr_store(base, newsibling-&gt;hdr.parent, newroot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relptr_store(base, fpm-&gt;btree_root, newroot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fpm-&gt;btree_depth++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If the parent page isn't full, insert the downlink. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key = newsibling-&gt;u.internal_key[<span class="Constant">0</span>].first_page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent-&gt;hdr.nused &lt; <a href="#L100" title="utils/mmgr/freepage.c:100">FPM_ITEMS_PER_INTERNAL_PAGE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index = <a href="#L1140" title="utils/mmgr/freepage.c:1140">FreePageBtreeSearchInternal</a>(parent, key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L900" title="utils/mmgr/freepage.c:900">FreePageBtreeInsertInternal</a>(base, parent, index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key, newsibling);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relptr_store(base, newsibling-&gt;hdr.parent, parent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L501" title="utils/mmgr/freepage.c:501">FreePageBtreeAdjustAncestorKeys</a>(fpm, parent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The parent also needs to be split, so loop around. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child = newsibling;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; split_target = parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The loop above did the insert, so just need to update the free<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list, and we're done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1871" title="utils/mmgr/freepage.c:1871">FreePagePushSpanLeader</a>(fpm, first_page, npages);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> npages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Physically add the key to the page. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(result.page-&gt;hdr.nused &lt; <a href="#L103" title="utils/mmgr/freepage.c:103">FPM_ITEMS_PER_LEAF_PAGE</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L917" title="utils/mmgr/freepage.c:917">FreePageBtreeInsertLeaf</a>(result.page, result.index, first_page, npages);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If new first key on page, ancestors might need adjustment. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result.index == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L501" title="utils/mmgr/freepage.c:501">FreePageBtreeAdjustAncestorKeys</a>(fpm, result.page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Put it on the free list. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1871" title="utils/mmgr/freepage.c:1871">FreePagePushSpanLeader</a>(fpm, first_page, npages);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> npages;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove a <a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> from the linked-list that contains it, either<br/></li>
<li></span><span class="Comment"> * because we're changing the size of the span, or because we're allocating it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1843">&#x200c;</a></span><span class="linkable">FreePagePopSpanLeader</span>(FreePageManager *fpm, Size pageno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *base = fpm_segment_base(fpm);<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *span;<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *prev;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; span = (<a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *) fpm_page_to_pointer(base, pageno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = relptr_access(base, span-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>);<br/></li>
<li>&nbsp; &nbsp; prev = relptr_access(base, span-&gt;prev);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relptr_copy(<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-&gt;prev, span-&gt;prev);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (prev != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relptr_copy(prev-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>, span-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; f = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(span-&gt;npages, FPM_NUM_FREELISTS) - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(relptr_offset(fpm-&gt;freelist[f]) == pageno * FPM_PAGE_SIZE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relptr_copy(fpm-&gt;freelist[f], span-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize a new <a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> and put it on the appropriate free list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1871">&#x200c;</a></span><span class="linkable">FreePagePushSpanLeader</span>(FreePageManager *fpm, Size first_page, Size npages)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *base = fpm_segment_base(fpm);<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; f = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(npages, FPM_NUM_FREELISTS) - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *head = relptr_access(base, fpm-&gt;freelist[f]);<br/></li>
<li>&nbsp; &nbsp; <a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *span;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; span = (<a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *) fpm_page_to_pointer(base, first_page);<br/></li>
<li>&nbsp; &nbsp; span-&gt;magic = <a href="#L63" title="utils/mmgr/freepage.c:63">FREE_PAGE_SPAN_LEADER_MAGIC</a>;<br/></li>
<li>&nbsp; &nbsp; span-&gt;npages = npages;<br/></li>
<li>&nbsp; &nbsp; relptr_store(base, span-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>, head);<br/></li>
<li>&nbsp; &nbsp; relptr_store(base, span-&gt;prev, (<a href="#L68" title="utils/mmgr/freepage.c:68">FreePageSpanLeader</a> *) <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (head != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relptr_store(base, head-&gt;prev, span);<br/></li>
<li>&nbsp; &nbsp; relptr_store(base, fpm-&gt;freelist[f], span);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
