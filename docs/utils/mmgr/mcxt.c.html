<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/mmgr/mcxt.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/mmgr/mcxt.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L152">CacheMemoryContext</a></li>
<li><a href="#L155">CurTransactionContext</a></li>
<li><a href="#L143">CurrentMemoryContext</a></li>
<li><a href="#L150">ErrorContext</a></li>
<li><a href="#L153">MessageContext</a></li>
<li><a href="#L158">PortalContext</a></li>
<li><a href="#L151">PostmasterContext</a></li>
<li><a href="#L149">TopMemoryContext</a></li>
<li><a href="#L154">TopTransactionContext</a></li>
<li><a href="#L46">mcxt_methods</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L286">BogusFree</a></li>
<li><a href="#L301">BogusGetChunkContext</a></li>
<li><a href="#L309">BogusGetChunkSpace</a></li>
<li><a href="#L293">BogusRealloc</a></li>
<li><a href="#L707">GetMemoryChunkContext</a></li>
<li><a href="#L220">GetMemoryChunkHeader</a></li>
<li><a href="#L191">GetMemoryChunkMethodID</a></li>
<li><a href="#L721">GetMemoryChunkSpace</a></li>
<li><a href="#L1271">HandleLogMemoryContextInterrupt</a></li>
<li><a href="#L1180">MemoryContextAlloc</a></li>
<li><a href="#L1408">MemoryContextAllocAligned</a></li>
<li><a href="#L1237">MemoryContextAllocExtended</a></li>
<li><a href="#L1639">MemoryContextAllocHuge</a></li>
<li><a href="#L1214">MemoryContextAllocZero</a></li>
<li><a href="#L1147">MemoryContextAllocationFailure</a></li>
<li><a href="#L694">MemoryContextAllowInCriticalSection</a></li>
<li><a href="#L585">MemoryContextCallResetCallbacks</a></li>
<li><a href="#L1052">MemoryContextCheck</a></li>
<li><a href="#L1100">MemoryContextCreate</a></li>
<li><a href="#L454">MemoryContextDelete</a></li>
<li><a href="#L539">MemoryContextDeleteChildren</a></li>
<li><a href="#L496">MemoryContextDeleteOnly</a></li>
<li><a href="#L731">MemoryContextGetParent</a></li>
<li><a href="#L339">MemoryContextInit</a></li>
<li><a href="#L743">MemoryContextIsEmpty</a></li>
<li><a href="#L762">MemoryContextMemAllocated</a></li>
<li><a href="#L786">MemoryContextMemConsumed</a></li>
<li><a href="#L568">MemoryContextRegisterResetCallback</a></li>
<li><a href="#L383">MemoryContextReset</a></li>
<li><a href="#L433">MemoryContextResetChildren</a></li>
<li><a href="#L402">MemoryContextResetOnly</a></li>
<li><a href="#L612">MemoryContextSetIdentifier</a></li>
<li><a href="#L637">MemoryContextSetParent</a></li>
<li><a href="#L1167">MemoryContextSizeFailure</a></li>
<li><a href="#L814">MemoryContextStats</a></li>
<li><a href="#L829">MemoryContextStatsDetail</a></li>
<li><a href="#L876">MemoryContextStatsInternal</a></li>
<li><a href="#L973">MemoryContextStatsPrint</a></li>
<li><a href="#L1682">MemoryContextStrdup</a></li>
<li><a href="#L257">MemoryContextTraverseNext</a></li>
<li><a href="#L1288">ProcessLogMemoryContextInterrupt</a></li>
<li><a href="#L1316">palloc</a></li>
<li><a href="#L1346">palloc0</a></li>
<li><a href="#L1510">palloc_aligned</a></li>
<li><a href="#L1367">palloc_extended</a></li>
<li><a href="#L1723">pchomp</a></li>
<li><a href="#L1520">pfree</a></li>
<li><a href="#L1706">pnstrdup</a></li>
<li><a href="#L1695">pstrdup</a></li>
<li><a href="#L1540">repalloc</a></li>
<li><a href="#L1618">repalloc0</a></li>
<li><a href="#L1581">repalloc_extended</a></li>
<li><a href="#L1671">repalloc_huge</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L175">AssertNotInCriticalSection</a></li>
<li><a href="#L40">BOGUS_MCTX</a></li>
<li><a href="#L137">BOGUS_MCTX</a></li>
<li><a href="#L182">MCXT_METHOD</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * mcxt.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; POSTGRES memory context management code.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This module handles context management operations that are independent<br/></li>
<li></span><span class="Comment"> * of the particular kind of context being operated on.&nbsp; It calls<br/></li>
<li></span><span class="Comment"> * context-type-specific operations via the function pointers in a<br/></li>
<li></span><span class="Comment"> * context's MemoryContextMethods struct.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/mmgr/mcxt.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;mb/pg_wchar.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memdebug.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils_memorychunk.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L286" title="utils/mmgr/mcxt.c:286">BogusFree</a>(<span class="Type">void</span> *pointer);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> *<a href="#L293" title="utils/mmgr/mcxt.c:293">BogusRealloc</a>(<span class="Type">void</span> *pointer, Size size, <span class="Type">int</span> flags);<br/></li>
<li><span class="Type">static</span> MemoryContext <a href="#L301" title="utils/mmgr/mcxt.c:301">BogusGetChunkContext</a>(<span class="Type">void</span> *pointer);<br/></li>
<li><span class="Type">static</span> Size <a href="#L309" title="utils/mmgr/mcxt.c:309">BogusGetChunkSpace</a>(<span class="Type">void</span> *pointer);<br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; GLOBAL MEMORY&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li><a id="L40">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BOGUS_MCTX</span>(id) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; [id].free_p = <a href="#L286" title="utils/mmgr/mcxt.c:286">BogusFree</a>, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; [id].realloc = <a href="#L293" title="utils/mmgr/mcxt.c:293">BogusRealloc</a>, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; [id].get_chunk_context = <a href="#L301" title="utils/mmgr/mcxt.c:301">BogusGetChunkContext</a>, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; [id].get_chunk_space = <a href="#L309" title="utils/mmgr/mcxt.c:309">BogusGetChunkSpace</a><br/></li>
<li></span><br/></li>
<li><a id="L46">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> MemoryContextMethods <span class="linkable">mcxt_methods</span>[] = {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* aset.c */<br/></li>
<li></span>&nbsp; &nbsp; [MCTX_ASET_ID].alloc = <a href="aset.c.html#L967" title="utils/mmgr/aset.c:967">AllocSetAlloc</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_ASET_ID].free_p = <a href="aset.c.html#L1062" title="utils/mmgr/aset.c:1062">AllocSetFree</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_ASET_ID].realloc = <a href="aset.c.html#L1169" title="utils/mmgr/aset.c:1169">AllocSetRealloc</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_ASET_ID].reset = <a href="aset.c.html#L537" title="utils/mmgr/aset.c:537">AllocSetReset</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_ASET_ID].delete_context = <a href="aset.c.html#L607" title="utils/mmgr/aset.c:607">AllocSetDelete</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_ASET_ID].get_chunk_context = <a href="aset.c.html#L1433" title="utils/mmgr/aset.c:1433">AllocSetGetChunkContext</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_ASET_ID].get_chunk_space = <a href="aset.c.html#L1462" title="utils/mmgr/aset.c:1462">AllocSetGetChunkSpace</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_ASET_ID].is_empty = <a href="aset.c.html#L1496" title="utils/mmgr/aset.c:1496">AllocSetIsEmpty</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_ASET_ID].stats = <a href="aset.c.html#L1521" title="utils/mmgr/aset.c:1521">AllocSetStats</a>,<br/></li>
<li><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; [MCTX_ASET_ID].check = <a href="aset.c.html#L1599" title="utils/mmgr/aset.c:1599">AllocSetCheck</a>,<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* generation.c */<br/></li>
<li></span>&nbsp; &nbsp; [MCTX_GENERATION_ID].alloc = <a href="generation.c.html#L527" title="utils/mmgr/generation.c:527">GenerationAlloc</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_GENERATION_ID].free_p = <a href="generation.c.html#L689" title="utils/mmgr/generation.c:689">GenerationFree</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_GENERATION_ID].realloc = <a href="generation.c.html#L800" title="utils/mmgr/generation.c:800">GenerationRealloc</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_GENERATION_ID].reset = <a href="generation.c.html#L283" title="utils/mmgr/generation.c:283">GenerationReset</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_GENERATION_ID].delete_context = <a href="generation.c.html#L328" title="utils/mmgr/generation.c:328">GenerationDelete</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_GENERATION_ID].get_chunk_context = <a href="generation.c.html#L942" title="utils/mmgr/generation.c:942">GenerationGetChunkContext</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_GENERATION_ID].get_chunk_space = <a href="generation.c.html#L968" title="utils/mmgr/generation.c:968">GenerationGetChunkSpace</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_GENERATION_ID].is_empty = <a href="generation.c.html#L997" title="utils/mmgr/generation.c:997">GenerationIsEmpty</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_GENERATION_ID].stats = <a href="generation.c.html#L1028" title="utils/mmgr/generation.c:1028">GenerationStats</a>,<br/></li>
<li><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; [MCTX_GENERATION_ID].check = <a href="generation.c.html#L1088" title="utils/mmgr/generation.c:1088">GenerationCheck</a>,<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* slab.c */<br/></li>
<li></span>&nbsp; &nbsp; [MCTX_SLAB_ID].alloc = <a href="slab.c.html#L630" title="utils/mmgr/slab.c:630">SlabAlloc</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_SLAB_ID].free_p = <a href="slab.c.html#L701" title="utils/mmgr/slab.c:701">SlabFree</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_SLAB_ID].realloc = <a href="slab.c.html#L826" title="utils/mmgr/slab.c:826">SlabRealloc</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_SLAB_ID].reset = <a href="slab.c.html#L431" title="utils/mmgr/slab.c:431">SlabReset</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_SLAB_ID].delete_context = <a href="slab.c.html#L485" title="utils/mmgr/slab.c:485">SlabDelete</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_SLAB_ID].get_chunk_context = <a href="slab.c.html#L863" title="utils/mmgr/slab.c:863">SlabGetChunkContext</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_SLAB_ID].get_chunk_space = <a href="slab.c.html#L887" title="utils/mmgr/slab.c:887">SlabGetChunkSpace</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_SLAB_ID].is_empty = <a href="slab.c.html#L912" title="utils/mmgr/slab.c:912">SlabIsEmpty</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_SLAB_ID].stats = <a href="slab.c.html#L929" title="utils/mmgr/slab.c:929">SlabStats</a>,<br/></li>
<li><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; [MCTX_SLAB_ID].check = <a href="slab.c.html#L997" title="utils/mmgr/slab.c:997">SlabCheck</a>,<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* alignedalloc.c */<br/></li>
<li></span>&nbsp; &nbsp; [MCTX_ALIGNED_REDIRECT_ID].alloc = <span class="Constant">NULL</span>,&nbsp; &nbsp; <span class="Comment">/* not required */<br/></li>
<li></span>&nbsp; &nbsp; [MCTX_ALIGNED_REDIRECT_ID].free_p = <a href="alignedalloc.c.html#L29" title="utils/mmgr/alignedalloc.c:29">AlignedAllocFree</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_ALIGNED_REDIRECT_ID].realloc = <a href="alignedalloc.c.html#L60" title="utils/mmgr/alignedalloc.c:60">AlignedAllocRealloc</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_ALIGNED_REDIRECT_ID].reset = <span class="Constant">NULL</span>,&nbsp; &nbsp; <span class="Comment">/* not required */<br/></li>
<li></span>&nbsp; &nbsp; [MCTX_ALIGNED_REDIRECT_ID].delete_context = <span class="Constant">NULL</span>,&nbsp; &nbsp; <span class="Comment">/* not required */<br/></li>
<li></span>&nbsp; &nbsp; [MCTX_ALIGNED_REDIRECT_ID].get_chunk_context = <a href="alignedalloc.c.html#L121" title="utils/mmgr/alignedalloc.c:121">AlignedAllocGetChunkContext</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_ALIGNED_REDIRECT_ID].get_chunk_space = <a href="alignedalloc.c.html#L143" title="utils/mmgr/alignedalloc.c:143">AlignedAllocGetChunkSpace</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_ALIGNED_REDIRECT_ID].is_empty = <span class="Constant">NULL</span>, <span class="Comment">/* not required */<br/></li>
<li></span>&nbsp; &nbsp; [MCTX_ALIGNED_REDIRECT_ID].stats = <span class="Constant">NULL</span>,&nbsp; &nbsp; <span class="Comment">/* not required */<br/></li>
<li></span><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; [MCTX_ALIGNED_REDIRECT_ID].check = <span class="Constant">NULL</span>,&nbsp; &nbsp; <span class="Comment">/* not required */<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* bump.c */<br/></li>
<li></span>&nbsp; &nbsp; [MCTX_BUMP_ID].alloc = <a href="bump.c.html#L491" title="utils/mmgr/bump.c:491">BumpAlloc</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_BUMP_ID].free_p = <a href="bump.c.html#L617" title="utils/mmgr/bump.c:617">BumpFree</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_BUMP_ID].realloc = <a href="bump.c.html#L627" title="utils/mmgr/bump.c:627">BumpRealloc</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_BUMP_ID].reset = <a href="bump.c.html#L243" title="utils/mmgr/bump.c:243">BumpReset</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_BUMP_ID].delete_context = <a href="bump.c.html#L278" title="utils/mmgr/bump.c:278">BumpDelete</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_BUMP_ID].get_chunk_context = <a href="bump.c.html#L638" title="utils/mmgr/bump.c:638">BumpGetChunkContext</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_BUMP_ID].get_chunk_space = <a href="bump.c.html#L649" title="utils/mmgr/bump.c:649">BumpGetChunkSpace</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_BUMP_ID].is_empty = <a href="bump.c.html#L660" title="utils/mmgr/bump.c:660">BumpIsEmpty</a>,<br/></li>
<li>&nbsp; &nbsp; [MCTX_BUMP_ID].stats = <a href="bump.c.html#L688" title="utils/mmgr/bump.c:688">BumpStats</a>,<br/></li>
<li><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; [MCTX_BUMP_ID].check = <a href="bump.c.html#L738" title="utils/mmgr/bump.c:738">BumpCheck</a>,<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reserved and unused IDs should have dummy entries here.&nbsp; This allows us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to fail cleanly if a bogus pointer is passed to <a href="#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> or the like.&nbsp; It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seems sufficient to provide routines for the methods that might get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * invoked from inspection of a chunk (see <a href="#L182" title="utils/mmgr/mcxt.c:182">MCXT_METHOD</a> calls below).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L40" title="utils/mmgr/mcxt.c:40">BOGUS_MCTX</a>(MCTX_1_RESERVED_GLIBC_ID),<br/></li>
<li>&nbsp; &nbsp; <a href="#L40" title="utils/mmgr/mcxt.c:40">BOGUS_MCTX</a>(MCTX_2_RESERVED_GLIBC_ID),<br/></li>
<li>&nbsp; &nbsp; <a href="#L40" title="utils/mmgr/mcxt.c:40">BOGUS_MCTX</a>(MCTX_8_UNUSED_ID),<br/></li>
<li>&nbsp; &nbsp; <a href="#L40" title="utils/mmgr/mcxt.c:40">BOGUS_MCTX</a>(MCTX_9_UNUSED_ID),<br/></li>
<li>&nbsp; &nbsp; <a href="#L40" title="utils/mmgr/mcxt.c:40">BOGUS_MCTX</a>(MCTX_10_UNUSED_ID),<br/></li>
<li>&nbsp; &nbsp; <a href="#L40" title="utils/mmgr/mcxt.c:40">BOGUS_MCTX</a>(MCTX_11_UNUSED_ID),<br/></li>
<li>&nbsp; &nbsp; <a href="#L40" title="utils/mmgr/mcxt.c:40">BOGUS_MCTX</a>(MCTX_12_UNUSED_ID),<br/></li>
<li>&nbsp; &nbsp; <a href="#L40" title="utils/mmgr/mcxt.c:40">BOGUS_MCTX</a>(MCTX_13_UNUSED_ID),<br/></li>
<li>&nbsp; &nbsp; <a href="#L40" title="utils/mmgr/mcxt.c:40">BOGUS_MCTX</a>(MCTX_14_UNUSED_ID),<br/></li>
<li>&nbsp; &nbsp; <a href="#L40" title="utils/mmgr/mcxt.c:40">BOGUS_MCTX</a>(MCTX_0_RESERVED_UNUSEDMEM_ID),<br/></li>
<li>&nbsp; &nbsp; <a href="#L40" title="utils/mmgr/mcxt.c:40">BOGUS_MCTX</a>(MCTX_15_RESERVED_WIPEDMEM_ID)<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L137">&#x200c;</a><span class="PreProc">#undef <span class="linkable">BOGUS_MCTX</span><br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Default memory context for allocations.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L143">&#x200c;</a></span>MemoryContext <span class="linkable">CurrentMemoryContext</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Standard top-level contexts. For a description of the purpose of each<br/></li>
<li></span><span class="Comment"> * of these contexts, refer to src/backend/utils/mmgr/README<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L149">&#x200c;</a></span>MemoryContext <span class="linkable">TopMemoryContext</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L150">&#x200c;</a>MemoryContext <span class="linkable">ErrorContext</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L151">&#x200c;</a>MemoryContext <span class="linkable">PostmasterContext</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L152">&#x200c;</a>MemoryContext <span class="linkable">CacheMemoryContext</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L153">&#x200c;</a>MemoryContext <span class="linkable">MessageContext</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L154">&#x200c;</a>MemoryContext <span class="linkable">TopTransactionContext</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L155">&#x200c;</a>MemoryContext <span class="linkable">CurTransactionContext</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* This is a transient link to the active portal's memory context: */<br/></li>
<li><a id="L158">&#x200c;</a></span>MemoryContext <span class="linkable">PortalContext</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L496" title="utils/mmgr/mcxt.c:496">MemoryContextDeleteOnly</a>(MemoryContext context);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L585" title="utils/mmgr/mcxt.c:585">MemoryContextCallResetCallbacks</a>(MemoryContext context);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L876" title="utils/mmgr/mcxt.c:876">MemoryContextStatsInternal</a>(MemoryContext context, <span class="Type">int</span> level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> max_level, <span class="Type">int</span> max_children,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MemoryContextCounters *totals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> print_to_stderr);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L973" title="utils/mmgr/mcxt.c:973">MemoryContextStatsPrint</a>(MemoryContext context, <span class="Type">void</span> *passthru,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *stats_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> print_to_stderr);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * You should not do memory allocations within a critical section, because<br/></li>
<li></span><span class="Comment"> * an out-of-memory error will be escalated to a PANIC. To enforce that<br/></li>
<li></span><span class="Comment"> * rule, the allocation <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> Assert that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L175">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">AssertNotInCriticalSection</span>(context) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; Assert(<a href="../init/globals.c.html#L43" title="utils/init/globals.c:43">CritSectionCount</a> == </span><span class="Constant">0</span><span class="PreProc"> || (context)-&gt;allowInCritSection)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Call the given function in the MemoryContextMethods for the memory context<br/></li>
<li></span><span class="Comment"> * type that 'pointer' belongs to.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L182">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MCXT_METHOD</span>(pointer, method) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="#L46" title="utils/mmgr/mcxt.c:46">mcxt_methods</a>[<a href="#L191" title="utils/mmgr/mcxt.c:191">GetMemoryChunkMethodID</a>(pointer)].method<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L191" title="utils/mmgr/mcxt.c:191">GetMemoryChunkMethodID</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return the MemoryContextMethodID from the uint64 chunk header which<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; directly precedes 'pointer'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> MemoryContextMethodID<br/></li>
<li><a id="L191">&#x200c;</a><span class="linkable">GetMemoryChunkMethodID</span>(<span class="Type">const</span> <span class="Type">void</span> *pointer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; header;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to detect bogus pointers handed to us, poorly though we can.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Presumably, a pointer that isn't MAXALIGNED isn't pointing at an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocated chunk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(pointer == (<span class="Type">const</span> <span class="Type">void</span> *) MAXALIGN(pointer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allow access to the uint64 header */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED((<span class="Type">char</span> *) pointer - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint64), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint64));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; header = *((<span class="Type">const</span> uint64 *) ((<span class="Type">const</span> <span class="Type">char</span> *) pointer - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint64)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Disallow access to the uint64 header */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS((<span class="Type">char</span> *) pointer - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint64), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint64));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (MemoryContextMethodID) (header &amp; MEMORY_CONTEXT_METHODID_MASK);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L220" title="utils/mmgr/mcxt.c:220">GetMemoryChunkHeader</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return the uint64 chunk header which directly precedes 'pointer'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is only used after <a href="#L191" title="utils/mmgr/mcxt.c:191">GetMemoryChunkMethodID</a>, so no need for error checks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> uint64<br/></li>
<li><a id="L220">&#x200c;</a><span class="linkable">GetMemoryChunkHeader</span>(<span class="Type">const</span> <span class="Type">void</span> *pointer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; header;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allow access to the uint64 header */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED((<span class="Type">char</span> *) pointer - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint64), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint64));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; header = *((<span class="Type">const</span> uint64 *) ((<span class="Type">const</span> <span class="Type">char</span> *) pointer - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint64)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Disallow access to the uint64 header */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS((<span class="Type">char</span> *) pointer - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint64), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint64));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> header;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L257" title="utils/mmgr/mcxt.c:257">MemoryContextTraverseNext</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Helper function to traverse all descendants of a memory context<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; without recursion.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Recursion could lead to out-of-stack errors with deep context hierarchies,<br/></li>
<li></span><span class="Comment"> * which would be unpleasant in error <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> code paths.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To process 'context' and all its descendants, use a loop like this:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; &lt;process 'context'&gt;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; for (MemoryContext curr = context-&gt;firstchild;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curr != NULL;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curr = <a href="#L257" title="utils/mmgr/mcxt.c:257">MemoryContextTraverseNext</a>(curr, context))<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; {<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &lt;process 'curr'&gt;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; }<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This visits all the contexts in pre-order, that is a node is visited<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> its children.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> MemoryContext<br/></li>
<li><a id="L257">&#x200c;</a><span class="linkable">MemoryContextTraverseNext</span>(MemoryContext curr, MemoryContext top)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* After processing a node, traverse to its first child if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (curr-&gt;firstchild != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> curr-&gt;firstchild;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * After processing a childless node, traverse to its <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> sibling if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there is one.&nbsp; If there isn't, traverse back up to the parent (which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has already been visited, and <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> so have all its descendants).&nbsp; We're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done if that is &quot;top&quot;, otherwise traverse to its <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> sibling if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> moving up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (curr-&gt;nextchild == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; curr = curr-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curr == top)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> curr-&gt;nextchild;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Support routines to trap use of invalid memory context method IDs<br/></li>
<li></span><span class="Comment"> * (from calling <a href="#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> or the like on a bogus pointer).&nbsp; As a possible<br/></li>
<li></span><span class="Comment"> * aid in debugging, we report the header <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> along with the pointer<br/></li>
<li></span><span class="Comment"> * address (if we got here, there must be an accessible header <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L286">&#x200c;</a></span><span class="linkable">BogusFree</span>(<span class="Type">void</span> *pointer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> called with invalid pointer </span><span class="Special">%p</span><span class="Constant"> (header 0x</span><span class="Special">%016llx</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pointer, (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">long</span>) <a href="#L220" title="utils/mmgr/mcxt.c:220">GetMemoryChunkHeader</a>(pointer));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> *<br/></li>
<li><a id="L293">&#x200c;</a><span class="linkable">BogusRealloc</span>(<span class="Type">void</span> *pointer, Size size, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a> called with invalid pointer </span><span class="Special">%p</span><span class="Constant"> (header 0x</span><span class="Special">%016llx</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pointer, (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">long</span>) <a href="#L220" title="utils/mmgr/mcxt.c:220">GetMemoryChunkHeader</a>(pointer));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> MemoryContext<br/></li>
<li><a id="L301">&#x200c;</a><span class="linkable">BogusGetChunkContext</span>(<span class="Type">void</span> *pointer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L707" title="utils/mmgr/mcxt.c:707">GetMemoryChunkContext</a> called with invalid pointer </span><span class="Special">%p</span><span class="Constant"> (header 0x</span><span class="Special">%016llx</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pointer, (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">long</span>) <a href="#L220" title="utils/mmgr/mcxt.c:220">GetMemoryChunkHeader</a>(pointer));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Size<br/></li>
<li><a id="L309">&#x200c;</a><span class="linkable">BogusGetChunkSpace</span>(<span class="Type">void</span> *pointer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a> called with invalid pointer </span><span class="Special">%p</span><span class="Constant"> (header 0x</span><span class="Special">%016llx</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pointer, (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">long</span>) <a href="#L220" title="utils/mmgr/mcxt.c:220">GetMemoryChunkHeader</a>(pointer));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; EXPORTED ROUTINES&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L339" title="utils/mmgr/mcxt.c:339">MemoryContextInit</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Start up the memory-context subsystem.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This must be called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> creating contexts or allocating memory in<br/></li>
<li></span><span class="Comment"> * contexts.&nbsp; <a href="#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a> and <a href="#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a> are initialized here;<br/></li>
<li></span><span class="Comment"> * other contexts must be created afterwards.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In normal multi-backend operation, this is called once during<br/></li>
<li></span><span class="Comment"> * postmaster startup, and not at all by individual backend startup<br/></li>
<li></span><span class="Comment"> * (since the backends inherit an already-initialized context subsystem<br/></li>
<li></span><span class="Comment"> * by virtue of being forked off the postmaster).&nbsp; But in an EXEC_BACKEND<br/></li>
<li></span><span class="Comment"> * build, each process must do this for itself.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In a standalone backend this must be called during backend startup.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L339">&#x200c;</a></span><span class="linkable">MemoryContextInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a> == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> <a href="#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, which is the parent of all others.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a> = AllocSetContextCreate((MemoryContext) <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Not having <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other place to point <a href="#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>, make it point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to <a href="#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>.&nbsp; Caller should change this soon!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> = <a href="#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize <a href="#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a> as an <a href="aset.c.html#L152" title="utils/mmgr/aset.c:152">AllocSetContext</a> with slow growth rate ---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we don't really expect much to be allocated in it. More to the point,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * require it to contain at least 8K at all times. This is the only case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where retained memory in a context is *essential* --- we want to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sure <a href="#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a> still has some memory even if we've run out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * elsewhere! Also, allow allocations in <a href="#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a> within a critical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * section. Otherwise a PANIC will cause an assertion failure in the error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reporting code, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> printing out the real cause of the failure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This should be the last step in this function, as elog.c assumes memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * management works once <a href="#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a> is non-null.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a> = AllocSetContextCreate(<a href="#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">8</span> * <span class="Constant">1024</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">8</span> * <span class="Constant">1024</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">8</span> * <span class="Constant">1024</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L694" title="utils/mmgr/mcxt.c:694">MemoryContextAllowInCriticalSection</a>(<a href="#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a>, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Release all space allocated within a context and delete all its<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; descendant contexts (but not the named context itself).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L383">&#x200c;</a></span><span class="linkable">MemoryContextReset</span>(MemoryContext context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(MemoryContextIsValid(context));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* save a function call in common case where there are no children */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;firstchild != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L539" title="utils/mmgr/mcxt.c:539">MemoryContextDeleteChildren</a>(context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* save a function call if no pallocs since startup or last reset */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!context-&gt;isReset)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L402" title="utils/mmgr/mcxt.c:402">MemoryContextResetOnly</a>(context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L402" title="utils/mmgr/mcxt.c:402">MemoryContextResetOnly</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Release all space allocated within a context.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Nothing is done to the context's descendant contexts.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L402">&#x200c;</a></span><span class="linkable">MemoryContextResetOnly</span>(MemoryContext context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(MemoryContextIsValid(context));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if no pallocs since startup or last reset */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!context-&gt;isReset)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L585" title="utils/mmgr/mcxt.c:585">MemoryContextCallResetCallbacks</a>(context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If context-&gt;ident points into the context's memory, it will become<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a dangling pointer.&nbsp; We could prevent that by setting it to NULL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here, but that would break valid coding patterns that keep the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ident elsewhere, e.g. in a parent context.&nbsp; So for <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the programmer got it right.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;methods-&gt;reset(context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;isReset = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_DESTROY_MEMPOOL(context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_CREATE_MEMPOOL(context, <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L433" title="utils/mmgr/mcxt.c:433">MemoryContextResetChildren</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Release all space allocated within a context's descendants,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; but don't delete the contexts themselves.&nbsp; The named context<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; itself is not touched.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L433">&#x200c;</a></span><span class="linkable">MemoryContextResetChildren</span>(MemoryContext context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(MemoryContextIsValid(context));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (MemoryContext curr = context-&gt;firstchild;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curr != <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curr = <a href="#L257" title="utils/mmgr/mcxt.c:257">MemoryContextTraverseNext</a>(curr, context))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L402" title="utils/mmgr/mcxt.c:402">MemoryContextResetOnly</a>(curr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> a context and its descendants, and release all space<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; allocated therein.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The type-specific delete routine removes all storage for the context,<br/></li>
<li></span><span class="Comment"> * but we have to deal with descendant nodes here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L454">&#x200c;</a></span><span class="linkable">MemoryContextDelete</span>(MemoryContext context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext curr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(MemoryContextIsValid(context));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> subcontexts from the bottom up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: Do not use recursion here.&nbsp; A &quot;stack depth limit exceeded&quot; error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would be unpleasant if we're already in the process of cleaning up from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction abort.&nbsp; We also cannot use <a href="#L257" title="utils/mmgr/mcxt.c:257">MemoryContextTraverseNext</a>() here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because we modify the tree as we go.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; curr = context;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext parent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Descend down until we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a leaf context with no children */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (curr-&gt;firstchild != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curr = curr-&gt;firstchild;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> at a leaf with no children. Free it and continue from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parent.&nbsp; Or if this was the original node, we're all done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; parent = curr-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L496" title="utils/mmgr/mcxt.c:496">MemoryContextDeleteOnly</a>(curr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curr == context)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; curr = parent;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine of <a href="#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>,<br/></li>
<li></span><span class="Comment"> * to delete a context that has no children.<br/></li>
<li></span><span class="Comment"> * We must also delink the context from its parent, if it has one.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L496">&#x200c;</a></span><span class="linkable">MemoryContextDeleteOnly</span>(MemoryContext context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(MemoryContextIsValid(context));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We had better not be deleting <a href="#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a> ... */<br/></li>
<li></span>&nbsp; &nbsp; Assert(context != <a href="#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And not <a href="#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>, either */<br/></li>
<li></span>&nbsp; &nbsp; Assert(context != <a href="#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* All the children should've been deleted already */<br/></li>
<li></span>&nbsp; &nbsp; Assert(context-&gt;firstchild == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's not entirely clear whether 'tis better to do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> or after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * delinking the context; but an error in a callback will likely result in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leaking the whole context (if it's not a root context) if we do it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after, so let's do it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L585" title="utils/mmgr/mcxt.c:585">MemoryContextCallResetCallbacks</a>(context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We delink the context from its parent <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> deleting it, so that if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there's an error we won't have deleted/busted contexts still attached<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the context tree.&nbsp; Better a leak than a crash.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L637" title="utils/mmgr/mcxt.c:637">MemoryContextSetParent</a>(context, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also reset the context's ident pointer, in case it points into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * context.&nbsp; This would only matter if someone tries to get stats on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (already unlinked) context, which is unlikely, but let's be safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; context-&gt;ident = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context-&gt;methods-&gt;delete_context(context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; VALGRIND_DESTROY_MEMPOOL(context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L539" title="utils/mmgr/mcxt.c:539">MemoryContextDeleteChildren</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> all the descendants of the named context and release all<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; space allocated therein.&nbsp; The named context itself is not touched.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L539">&#x200c;</a></span><span class="linkable">MemoryContextDeleteChildren</span>(MemoryContext context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(MemoryContextIsValid(context));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a> will delink the child from me, so just iterate as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * long as there is a child.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (context-&gt;firstchild != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(context-&gt;firstchild);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L568" title="utils/mmgr/mcxt.c:568">MemoryContextRegisterResetCallback</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Register a function to be called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> context reset/delete.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Such callbacks will be called in reverse order of registration.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller is responsible for allocating a MemoryContextCallback struct<br/></li>
<li></span><span class="Comment"> * to hold the info about this callback request, and for filling in the<br/></li>
<li></span><span class="Comment"> * &quot;func&quot; and &quot;arg&quot; fields in the struct to show what function to call with<br/></li>
<li></span><span class="Comment"> * what argument.&nbsp; Typically the callback struct should be allocated within<br/></li>
<li></span><span class="Comment"> * the specified context, since that means it will automatically be freed<br/></li>
<li></span><span class="Comment"> * when no longer needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There is no API for deregistering a callback once registered.&nbsp; If you<br/></li>
<li></span><span class="Comment"> * want it to not do anything anymore, adjust the state pointed to by its<br/></li>
<li></span><span class="Comment"> * &quot;arg&quot; to indicate that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L568">&#x200c;</a></span><span class="linkable">MemoryContextRegisterResetCallback</span>(MemoryContext context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MemoryContextCallback *cb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(MemoryContextIsValid(context));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push onto head so this will be called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> older registrants. */<br/></li>
<li></span>&nbsp; &nbsp; cb-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = context-&gt;reset_cbs;<br/></li>
<li>&nbsp; &nbsp; context-&gt;reset_cbs = cb;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the context as non-reset (it probably is already). */<br/></li>
<li></span>&nbsp; &nbsp; context-&gt;isReset = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L585" title="utils/mmgr/mcxt.c:585">MemoryContextCallResetCallbacks</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Internal function to call all registered callbacks for context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L585">&#x200c;</a></span><span class="linkable">MemoryContextCallResetCallbacks</span>(MemoryContext context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContextCallback *cb;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We pop each callback from the list <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling.&nbsp; That way, if an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * error occurs inside the callback, we won't try to call it a second time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the likely event that we reset or delete the context later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> ((cb = context-&gt;reset_cbs) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;reset_cbs = cb-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cb-&gt;func(cb-&gt;arg);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L612" title="utils/mmgr/mcxt.c:612">MemoryContextSetIdentifier</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set the identifier string for a memory context.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * An identifier can be provided to <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> distinguish among different contexts<br/></li>
<li></span><span class="Comment"> * of the same kind in memory context stats dumps.&nbsp; The identifier string<br/></li>
<li></span><span class="Comment"> * must live at least as long as the context it is for; typically it is<br/></li>
<li></span><span class="Comment"> * allocated inside that context, so that it automatically goes away on<br/></li>
<li></span><span class="Comment"> * context deletion.&nbsp; Pass id = NULL to forget <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> old identifier.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L612">&#x200c;</a></span><span class="linkable">MemoryContextSetIdentifier</span>(MemoryContext context, <span class="Type">const</span> <span class="Type">char</span> *id)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(MemoryContextIsValid(context));<br/></li>
<li>&nbsp; &nbsp; context-&gt;ident = id;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L637" title="utils/mmgr/mcxt.c:637">MemoryContextSetParent</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Change a context to belong to a new parent (or no parent).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We provide this as an API function because it is sometimes useful to<br/></li>
<li></span><span class="Comment"> * change a context's lifespan after creation.&nbsp; For example, a context<br/></li>
<li></span><span class="Comment"> * might be created underneath a transient context, filled with data,<br/></li>
<li></span><span class="Comment"> * and then reparented underneath <a href="#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a> to make it long-lived.<br/></li>
<li></span><span class="Comment"> * In this way no special effort is needed to get rid of the context in case<br/></li>
<li></span><span class="Comment"> * a failure occurs <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> its contents are completely set up.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Callers often assume that this function cannot fail, so don't put <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * elog(ERROR) calls in it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A possible caller error is to reparent a context under itself, creating<br/></li>
<li></span><span class="Comment"> * a loop in the context graph.&nbsp; We assert here that context != new_parent,<br/></li>
<li></span><span class="Comment"> * but checking for multi-level loops seems more trouble than it's worth.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L637">&#x200c;</a></span><span class="linkable">MemoryContextSetParent</span>(MemoryContext context, MemoryContext new_parent)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(MemoryContextIsValid(context));<br/></li>
<li>&nbsp; &nbsp; Assert(context != new_parent);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fast path if it's got correct parent already */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (new_parent == context-&gt;parent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Delink from existing parent, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;parent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext parent = context-&gt;parent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;prevchild != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;prevchild-&gt;nextchild = context-&gt;nextchild;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(parent-&gt;firstchild == context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent-&gt;firstchild = context-&gt;nextchild;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;nextchild != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;nextchild-&gt;prevchild = context-&gt;prevchild;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And relink */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (new_parent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(MemoryContextIsValid(new_parent));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;parent = new_parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;prevchild = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;nextchild = new_parent-&gt;firstchild;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_parent-&gt;firstchild != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_parent-&gt;firstchild-&gt;prevchild = context;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_parent-&gt;firstchild = context;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;parent = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;prevchild = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;nextchild = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L694" title="utils/mmgr/mcxt.c:694">MemoryContextAllowInCriticalSection</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Allow/disallow allocations in this memory context within a critical<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; section.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Normally, memory allocations are not allowed within a critical section,<br/></li>
<li></span><span class="Comment"> * because a failure would lead to PANIC.&nbsp; There are a few exceptions to<br/></li>
<li></span><span class="Comment"> * that, like allocations related to debugging code that is not supposed to<br/></li>
<li></span><span class="Comment"> * be enabled in production.&nbsp; This function can be used to exempt specific<br/></li>
<li></span><span class="Comment"> * memory contexts from the assertion in <a href="#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L694">&#x200c;</a></span><span class="linkable">MemoryContextAllowInCriticalSection</span>(MemoryContext context, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allow)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(MemoryContextIsValid(context));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context-&gt;allowInCritSection = allow;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L707" title="utils/mmgr/mcxt.c:707">GetMemoryChunkContext</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given a currently-allocated chunk, determine the MemoryContext that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the chunk belongs to.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MemoryContext<br/></li>
<li><a id="L707">&#x200c;</a><span class="linkable">GetMemoryChunkContext</span>(<span class="Type">void</span> *pointer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L182" title="utils/mmgr/mcxt.c:182">MCXT_METHOD</a>(pointer, get_chunk_context) (pointer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given a currently-allocated chunk, determine the total space<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; it occupies (including all memory-allocation overhead).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is useful for measuring the total space occupied by a set of<br/></li>
<li></span><span class="Comment"> * allocated chunks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L721">&#x200c;</a><span class="linkable">GetMemoryChunkSpace</span>(<span class="Type">void</span> *pointer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L182" title="utils/mmgr/mcxt.c:182">MCXT_METHOD</a>(pointer, get_chunk_space) (pointer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L731" title="utils/mmgr/mcxt.c:731">MemoryContextGetParent</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get the parent context (if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) of the specified context<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MemoryContext<br/></li>
<li><a id="L731">&#x200c;</a><span class="linkable">MemoryContextGetParent</span>(MemoryContext context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(MemoryContextIsValid(context));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> context-&gt;parent;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L743" title="utils/mmgr/mcxt.c:743">MemoryContextIsEmpty</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Is a memory context empty of <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> allocated space?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L743">&#x200c;</a></span><span class="linkable">MemoryContextIsEmpty</span>(MemoryContext context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(MemoryContextIsValid(context));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we consider a memory context nonempty if it has <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> children;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * perhaps this should be changed later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;firstchild != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise use the type-specific inquiry */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> context-&gt;methods-&gt;is_empty(context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find the memory allocated to blocks for this memory context. If recurse is<br/></li>
<li></span><span class="Comment"> * true, also include children.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L762">&#x200c;</a><span class="linkable">MemoryContextMemAllocated</span>(MemoryContext context, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recurse)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; total = context-&gt;mem_allocated;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(MemoryContextIsValid(context));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (recurse)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (MemoryContext curr = context-&gt;firstchild;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curr != <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curr = <a href="#L257" title="utils/mmgr/mcxt.c:257">MemoryContextTraverseNext</a>(curr, context))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total += curr-&gt;mem_allocated;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> total;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the memory consumption statistics about the given context and its<br/></li>
<li></span><span class="Comment"> * children.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L786">&#x200c;</a></span><span class="linkable">MemoryContextMemConsumed</span>(MemoryContext context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MemoryContextCounters *consumed)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(MemoryContextIsValid(context));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(consumed, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*consumed));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Examine the context itself */<br/></li>
<li></span>&nbsp; &nbsp; context-&gt;methods-&gt;stats(context, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, consumed, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Examine children, using iteration not recursion */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (MemoryContext curr = context-&gt;firstchild;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curr != <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curr = <a href="#L257" title="utils/mmgr/mcxt.c:257">MemoryContextTraverseNext</a>(curr, context))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; curr-&gt;methods-&gt;stats(curr, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, consumed, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L814" title="utils/mmgr/mcxt.c:814">MemoryContextStats</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Print statistics about the named context and all its descendants.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is just a debugging utility, so it's not very fancy.&nbsp; However, we do<br/></li>
<li></span><span class="Comment"> * make some effort to summarize when the output would otherwise be very long.<br/></li>
<li></span><span class="Comment"> * The statistics are sent to stderr.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L814">&#x200c;</a></span><span class="linkable">MemoryContextStats</span>(MemoryContext context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Hard-wired limits are usually good enough */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L829" title="utils/mmgr/mcxt.c:829">MemoryContextStatsDetail</a>(context, <span class="Constant">100</span>, <span class="Constant">100</span>, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L829" title="utils/mmgr/mcxt.c:829">MemoryContextStatsDetail</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Entry point for use if you want to vary the number of child contexts shown.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If print_to_stderr is true, <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> statistics about the memory contexts<br/></li>
<li></span><span class="Comment"> * with fprintf(stderr), otherwise use ereport().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L829">&#x200c;</a></span><span class="linkable">MemoryContextStatsDetail</span>(MemoryContext context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> max_level, <span class="Type">int</span> max_children,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> print_to_stderr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContextCounters grand_totals;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;grand_totals, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(grand_totals));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L876" title="utils/mmgr/mcxt.c:876">MemoryContextStatsInternal</a>(context, <span class="Constant">0</span>, max_level, max_children,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;grand_totals, print_to_stderr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (print_to_stderr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Grand total: </span><span class="Special">%zu</span><span class="Constant"> bytes in </span><span class="Special">%zu</span><span class="Constant"> blocks; </span><span class="Special">%zu</span><span class="Constant"> free (</span><span class="Special">%zu</span><span class="Constant"> chunks); </span><span class="Special">%zu</span><span class="Constant"> used</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grand_totals.totalspace, grand_totals.nblocks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grand_totals.freespace, grand_totals.freechunks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grand_totals.totalspace - grand_totals.freespace);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use LOG_SERVER_ONLY to prevent the memory contexts from being sent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the connected client.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't buffer the information about all memory contexts in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backend into StringInfo and log it as one message.&nbsp; That would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * require the buffer to be enlarged, risking an OOM as there could be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a large number of memory contexts in a backend.&nbsp; Instead, we log<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one message per memory context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG_SERVER_ONLY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1413" title="utils/error/elog.c:1413">errhidestmt</a>(<span class="Constant">true</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1432" title="utils/error/elog.c:1432">errhidecontext</a>(<span class="Constant">true</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;Grand total: </span><span class="Special">%zu</span><span class="Constant"> bytes in </span><span class="Special">%zu</span><span class="Constant"> blocks; </span><span class="Special">%zu</span><span class="Constant"> free (</span><span class="Special">%zu</span><span class="Constant"> chunks); </span><span class="Special">%zu</span><span class="Constant"> used&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; grand_totals.totalspace, grand_totals.nblocks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; grand_totals.freespace, grand_totals.freechunks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; grand_totals.totalspace - grand_totals.freespace)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L876" title="utils/mmgr/mcxt.c:876">MemoryContextStatsInternal</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; One recursion level for <a href="#L814" title="utils/mmgr/mcxt.c:814">MemoryContextStats</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Print stats for this context if possible, but in <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case accumulate counts<br/></li>
<li></span><span class="Comment"> * into *totals (if not NULL).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L876">&#x200c;</a></span><span class="linkable">MemoryContextStatsInternal</span>(MemoryContext context, <span class="Type">int</span> level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> max_level, <span class="Type">int</span> max_children,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MemoryContextCounters *totals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> print_to_stderr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext child;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ichild;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(MemoryContextIsValid(context));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Examine the context itself */<br/></li>
<li></span>&nbsp; &nbsp; context-&gt;methods-&gt;stats(context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L973" title="utils/mmgr/mcxt.c:973">MemoryContextStatsPrint</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) &amp;level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totals, print_to_stderr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Examine children.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are past the recursion depth limit or already running low on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stack, do not <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> them explicitly but just summarize them. Similarly,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if there are more than max_children of them, we do not <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> the rest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * explicitly, but just summarize them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; child = context-&gt;firstchild;<br/></li>
<li>&nbsp; &nbsp; ichild = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (level &lt; max_level &amp;&amp; !<a href="../../tcop/postgres.c.html#L3545" title="tcop/postgres.c:3545">stack_is_too_deep</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; child != <span class="Constant">NULL</span> &amp;&amp; ichild &lt; max_children;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; child = child-&gt;nextchild, ichild++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L876" title="utils/mmgr/mcxt.c:876">MemoryContextStatsInternal</a>(child, level + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; max_level, max_children,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; totals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; print_to_stderr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (child != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Summarize the rest of the children, avoiding recursion. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextCounters local_totals;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;local_totals, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(local_totals));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ichild = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (child != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child-&gt;methods-&gt;stats(child, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, &amp;local_totals, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ichild++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child = <a href="#L257" title="utils/mmgr/mcxt.c:257">MemoryContextTraverseNext</a>(child, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (print_to_stderr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt;= level; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;&nbsp; &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant"> more child contexts containing </span><span class="Special">%zu</span><span class="Constant"> total in </span><span class="Special">%zu</span><span class="Constant"> blocks; </span><span class="Special">%zu</span><span class="Constant"> free (</span><span class="Special">%zu</span><span class="Constant"> chunks); </span><span class="Special">%zu</span><span class="Constant"> used</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ichild,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local_totals.totalspace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local_totals.nblocks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local_totals.freespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local_totals.freechunks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local_totals.totalspace - local_totals.freespace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG_SERVER_ONLY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1413" title="utils/error/elog.c:1413">errhidestmt</a>(<span class="Constant">true</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1432" title="utils/error/elog.c:1432">errhidecontext</a>(<span class="Constant">true</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;level: </span><span class="Special">%d</span><span class="Constant">; </span><span class="Special">%d</span><span class="Constant"> more child contexts containing </span><span class="Special">%zu</span><span class="Constant"> total in </span><span class="Special">%zu</span><span class="Constant"> blocks; </span><span class="Special">%zu</span><span class="Constant"> free (</span><span class="Special">%zu</span><span class="Constant"> chunks); </span><span class="Special">%zu</span><span class="Constant"> used&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ichild,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; local_totals.totalspace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; local_totals.nblocks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; local_totals.freespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; local_totals.freechunks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; local_totals.totalspace - local_totals.freespace)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (totals)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totals-&gt;nblocks += local_totals.nblocks;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totals-&gt;freechunks += local_totals.freechunks;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totals-&gt;totalspace += local_totals.totalspace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totals-&gt;freespace += local_totals.freespace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L973" title="utils/mmgr/mcxt.c:973">MemoryContextStatsPrint</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Print callback used by <a href="#L876" title="utils/mmgr/mcxt.c:876">MemoryContextStatsInternal</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, the passthru pointer just points to &quot;int level&quot;; later we might<br/></li>
<li></span><span class="Comment"> * make that more complicated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L973">&#x200c;</a></span><span class="linkable">MemoryContextStatsPrint</span>(MemoryContext context, <span class="Type">void</span> *passthru,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *stats_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> print_to_stderr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; level = *(<span class="Type">int</span> *) passthru;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *name = context-&gt;name;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *ident = context-&gt;ident;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; truncated_ident[<span class="Constant">110</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It seems preferable to label dynahash contexts with just the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * name.&nbsp; Those are already unique enough, so the &quot;dynahash&quot; part isn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * very helpful, and this way is more consistent with pre-v11 practice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ident &amp;&amp; strcmp(name, <span class="Constant">&quot;dynahash&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; name = ident;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ident = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; truncated_ident[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ident)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Some contexts may have very long identifiers (e.g., SQL queries).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Arbitrarily truncate at 100 bytes, but be careful not to break<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multibyte characters.&nbsp; Also, replace ASCII control characters, such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as newlines, with spaces.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idlen = strlen(ident);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; truncated = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcpy(truncated_ident, <span class="Constant">&quot;: &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i = strlen(truncated_ident);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (idlen &gt; <span class="Constant">100</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idlen = <a href="../mb/mbutils.c.html#L1083" title="utils/mb/mbutils.c:1083">pg_mbcliplen</a>(ident, idlen, <span class="Constant">100</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; truncated = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (idlen-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> c = *ident++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (c &lt; <span class="Constant">' '</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c = <span class="Constant">' '</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; truncated_ident[i++] = c;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; truncated_ident[i] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (truncated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcat(truncated_ident, <span class="Constant">&quot;...&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (print_to_stderr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; level; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;&nbsp; &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">%s%s\n</span><span class="Constant">&quot;</span>, name, stats_string, truncated_ident);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG_SERVER_ONLY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1413" title="utils/error/elog.c:1413">errhidestmt</a>(<span class="Constant">true</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1432" title="utils/error/elog.c:1432">errhidecontext</a>(<span class="Constant">true</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;level: </span><span class="Special">%d</span><span class="Constant">; </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">%s%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; level, name, stats_string, truncated_ident)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1052" title="utils/mmgr/mcxt.c:1052">MemoryContextCheck</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Check all chunks in the named context and its children.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is just a debugging utility, so it's not fancy.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1052">&#x200c;</a></span><span class="linkable">MemoryContextCheck</span>(MemoryContext context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(MemoryContextIsValid(context));<br/></li>
<li>&nbsp; &nbsp; context-&gt;methods-&gt;check(context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (MemoryContext curr = context-&gt;firstchild;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curr != <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curr = <a href="#L257" title="utils/mmgr/mcxt.c:257">MemoryContextTraverseNext</a>(curr, context))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(MemoryContextIsValid(curr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; curr-&gt;methods-&gt;check(curr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1100" title="utils/mmgr/mcxt.c:1100">MemoryContextCreate</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Context-type-independent part of context creation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is only intended to be called by context-type-specific<br/></li>
<li></span><span class="Comment"> * context creation routines, not by the unwashed masses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The memory context creation procedure goes like this:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 1.&nbsp; Context-type-specific routine makes some initial space allocation,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; including enough space for the context header.&nbsp; If it fails,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; it can ereport() with no damage done.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 2.&nbsp; &nbsp; Context-type-specific routine sets up all type-specific fields of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the header (those beyond MemoryContextData proper), as well as <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; other management fields it needs to have a fully valid context.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Usually, failure in this step is impossible, but if it's possible<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the initial space allocation should be freed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> ereport'ing.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 3.&nbsp; &nbsp; Context-type-specific routine calls <a href="#L1100" title="utils/mmgr/mcxt.c:1100">MemoryContextCreate</a>() to fill in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the generic header fields and link the context into the context tree.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 4.&nbsp; We return to the context-type-specific routine, which finishes<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; up type-specific initialization.&nbsp; This routine can <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> do things<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; that might fail (like allocate more memory), so long as it's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; sure the node is left in a state that delete will handle.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * node: the as-yet-uninitialized common part of the context header node.<br/></li>
<li></span><span class="Comment"> * tag: NodeTag code identifying the memory context type.<br/></li>
<li></span><span class="Comment"> * method_id: MemoryContextMethodID of the context-type being created.<br/></li>
<li></span><span class="Comment"> * parent: parent context, or NULL if this will be a top-level context.<br/></li>
<li></span><span class="Comment"> * name: name of context (must be statically allocated).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Context routines generally assume that <a href="#L1100" title="utils/mmgr/mcxt.c:1100">MemoryContextCreate</a> can't fail,<br/></li>
<li></span><span class="Comment"> * so this can contain Assert but not elog/ereport.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1100">&#x200c;</a></span><span class="linkable">MemoryContextCreate</span>(MemoryContext node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NodeTag tag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextMethodID method_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext parent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Creating new memory contexts is not allowed in a critical section */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../init/globals.c.html#L43" title="utils/init/globals.c:43">CritSectionCount</a> == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize all standard fields of memory context header */<br/></li>
<li></span>&nbsp; &nbsp; node-&gt;type = tag;<br/></li>
<li>&nbsp; &nbsp; node-&gt;isReset = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;methods = &amp;<a href="#L46" title="utils/mmgr/mcxt.c:46">mcxt_methods</a>[method_id];<br/></li>
<li>&nbsp; &nbsp; node-&gt;parent = parent;<br/></li>
<li>&nbsp; &nbsp; node-&gt;firstchild = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;mem_allocated = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;prevchild = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;name = name;<br/></li>
<li>&nbsp; &nbsp; node-&gt;ident = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; node-&gt;reset_cbs = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK to link node into context tree */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;nextchild = parent-&gt;firstchild;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent-&gt;firstchild != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent-&gt;firstchild-&gt;prevchild = node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent-&gt;firstchild = node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* inherit allowInCritSection flag from parent */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;allowInCritSection = parent-&gt;allowInCritSection;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;nextchild = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;allowInCritSection = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; VALGRIND_CREATE_MEMPOOL(node, <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1147" title="utils/mmgr/mcxt.c:1147">MemoryContextAllocationFailure</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; For use by MemoryContextMethods implementations to handle when malloc<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; returns NULL.&nbsp; The behavior is specific to whether MCXT_ALLOC_NO_OOM<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; is in 'flags'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L1147">&#x200c;</a><span class="linkable">MemoryContextAllocationFailure</span>(MemoryContext context, Size size, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; MCXT_ALLOC_NO_OOM) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L814" title="utils/mmgr/mcxt.c:814">MemoryContextStats</a>(<a href="#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failed on request of size </span><span class="Special">%zu</span><span class="Constant"> in memory context </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; size, context-&gt;name)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1167" title="utils/mmgr/mcxt.c:1167">MemoryContextSizeFailure</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; For use by MemoryContextMethods implementations to handle invalid<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; memory allocation request sizes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1167">&#x200c;</a></span><span class="linkable">MemoryContextSizeFailure</span>(MemoryContext context, Size size, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid memory alloc request size </span><span class="Special">%zu</span><span class="Constant">&quot;</span>, size);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Allocate space within the specified context.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This could be turned into a macro, but we'd have to import<br/></li>
<li></span><span class="Comment"> * nodes/memnodes.h into postgres.h which seems a bad idea.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L1180">&#x200c;</a><span class="linkable">MemoryContextAlloc</span>(MemoryContext context, Size size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(MemoryContextIsValid(context));<br/></li>
<li>&nbsp; &nbsp; <a href="#L175" title="utils/mmgr/mcxt.c:175">AssertNotInCriticalSection</a>(context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context-&gt;isReset = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For efficiency reasons, we purposefully offload the handling of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocation failures to the MemoryContextMethods implementation as this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allows these checks to be performed only when an actual malloc needs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be done to request more memory from the OS.&nbsp; Additionally, not having<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to execute <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> instructions after this call allows the compiler to use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the sibling call optimization.&nbsp; If you're considering adding code after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this call, consider making it the responsibility of the 'alloc'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ret = context-&gt;methods-&gt;alloc(context, size, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; VALGRIND_MEMPOOL_ALLOC(context, ret, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Like <a href="#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>, but clears allocated memory<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; We could just call <a href="#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a> then clear the memory, but this<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; is a very common combination, so we provide the combined operation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L1214">&#x200c;</a><span class="linkable">MemoryContextAllocZero</span>(MemoryContext context, Size size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(MemoryContextIsValid(context));<br/></li>
<li>&nbsp; &nbsp; <a href="#L175" title="utils/mmgr/mcxt.c:175">AssertNotInCriticalSection</a>(context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context-&gt;isReset = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = context-&gt;methods-&gt;alloc(context, size, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; VALGRIND_MEMPOOL_ALLOC(context, ret, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemSetAligned(ret, <span class="Constant">0</span>, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1237" title="utils/mmgr/mcxt.c:1237">MemoryContextAllocExtended</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Allocate space within the specified context using the given flags.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L1237">&#x200c;</a><span class="linkable">MemoryContextAllocExtended</span>(MemoryContext context, Size size, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(MemoryContextIsValid(context));<br/></li>
<li>&nbsp; &nbsp; <a href="#L175" title="utils/mmgr/mcxt.c:175">AssertNotInCriticalSection</a>(context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!((flags &amp; MCXT_ALLOC_HUGE) != <span class="Constant">0</span> ? AllocHugeSizeIsValid(size) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AllocSizeIsValid(size)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid memory alloc request size </span><span class="Special">%zu</span><span class="Constant">&quot;</span>, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context-&gt;isReset = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = context-&gt;methods-&gt;alloc(context, size, flags);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(ret == <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; VALGRIND_MEMPOOL_ALLOC(context, ret, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; MCXT_ALLOC_ZERO) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSetAligned(ret, <span class="Constant">0</span>, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1271" title="utils/mmgr/mcxt.c:1271">HandleLogMemoryContextInterrupt</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Handle receipt of an interrupt indicating logging of memory<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; contexts.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All the actual work is deferred to <a href="#L1288" title="utils/mmgr/mcxt.c:1288">ProcessLogMemoryContextInterrupt</a>(),<br/></li>
<li></span><span class="Comment"> * because we cannot safely emit a log message inside the signal handler.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1271">&#x200c;</a></span><span class="linkable">HandleLogMemoryContextInterrupt</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../init/globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../init/globals.c.html#L39" title="utils/init/globals.c:39">LogMemoryContextPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* latch will be set by <a href="../../storage/ipc/procsignal.c.html#L635" title="storage/ipc/procsignal.c:635">procsignal_sigusr1_handler</a> */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1288" title="utils/mmgr/mcxt.c:1288">ProcessLogMemoryContextInterrupt</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Perform logging of memory contexts of this backend process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Any backend that participates in <a href="../../storage/ipc/procsignal.c.html#L99" title="storage/ipc/procsignal.c:99">ProcSignal</a> signaling must arrange<br/></li>
<li></span><span class="Comment"> * to call this function if we see <a href="../init/globals.c.html#L39" title="utils/init/globals.c:39">LogMemoryContextPending</a> set.<br/></li>
<li></span><span class="Comment"> * It is called from CHECK_FOR_INTERRUPTS(), which is enough because<br/></li>
<li></span><span class="Comment"> * the target process for logging of memory contexts is a backend.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1288">&#x200c;</a></span><span class="linkable">ProcessLogMemoryContextInterrupt</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../init/globals.c.html#L39" title="utils/init/globals.c:39">LogMemoryContextPending</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use LOG_SERVER_ONLY to prevent this message from being sent to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * connected client.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ereport(LOG_SERVER_ONLY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1413" title="utils/error/elog.c:1413">errhidestmt</a>(<span class="Constant">true</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1432" title="utils/error/elog.c:1432">errhidecontext</a>(<span class="Constant">true</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logging memory contexts of PID </span><span class="Special">%d</span><span class="Constant">&quot;</span>, <a href="../init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When a backend process is consuming huge memory, logging all its memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contexts might overrun available disk space. To prevent this, we limit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the depth of the hierarchy, as well as the number of child contexts to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * log per parent to 100.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As with <a href="#L814" title="utils/mmgr/mcxt.c:814">MemoryContextStats</a>(), we suppose that practical cases where the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> gets long will typically be huge numbers of siblings under the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same parent context; while the additional debugging value from seeing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * details about individual siblings beyond 100 will not be large.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L829" title="utils/mmgr/mcxt.c:829">MemoryContextStatsDetail</a>(<a href="#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, <span class="Constant">100</span>, <span class="Constant">100</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void</span> *<br/></li>
<li><a id="L1316">&#x200c;</a><span class="linkable">palloc</span>(Size size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* duplicates <a href="#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a> to avoid increased overhead */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *ret;<br/></li>
<li>&nbsp; &nbsp; MemoryContext context = <a href="#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(MemoryContextIsValid(context));<br/></li>
<li>&nbsp; &nbsp; <a href="#L175" title="utils/mmgr/mcxt.c:175">AssertNotInCriticalSection</a>(context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context-&gt;isReset = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For efficiency reasons, we purposefully offload the handling of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocation failures to the MemoryContextMethods implementation as this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allows these checks to be performed only when an actual malloc needs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be done to request more memory from the OS.&nbsp; Additionally, not having<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to execute <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> instructions after this call allows the compiler to use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the sibling call optimization.&nbsp; If you're considering adding code after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this call, consider making it the responsibility of the 'alloc'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ret = context-&gt;methods-&gt;alloc(context, size, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We expect OOM to be handled by the alloc function */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ret != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; VALGRIND_MEMPOOL_ALLOC(context, ret, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void</span> *<br/></li>
<li><a id="L1346">&#x200c;</a><span class="linkable">palloc0</span>(Size size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* duplicates <a href="#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a> to avoid increased overhead */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *ret;<br/></li>
<li>&nbsp; &nbsp; MemoryContext context = <a href="#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(MemoryContextIsValid(context));<br/></li>
<li>&nbsp; &nbsp; <a href="#L175" title="utils/mmgr/mcxt.c:175">AssertNotInCriticalSection</a>(context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context-&gt;isReset = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = context-&gt;methods-&gt;alloc(context, size, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; VALGRIND_MEMPOOL_ALLOC(context, ret, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemSetAligned(ret, <span class="Constant">0</span>, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void</span> *<br/></li>
<li><a id="L1367">&#x200c;</a><span class="linkable">palloc_extended</span>(Size size, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* duplicates <a href="#L1237" title="utils/mmgr/mcxt.c:1237">MemoryContextAllocExtended</a> to avoid increased overhead */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *ret;<br/></li>
<li>&nbsp; &nbsp; MemoryContext context = <a href="#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(MemoryContextIsValid(context));<br/></li>
<li>&nbsp; &nbsp; <a href="#L175" title="utils/mmgr/mcxt.c:175">AssertNotInCriticalSection</a>(context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context-&gt;isReset = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = context-&gt;methods-&gt;alloc(context, size, flags);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(ret == <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; VALGRIND_MEMPOOL_ALLOC(context, ret, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; MCXT_ALLOC_ZERO) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSetAligned(ret, <span class="Constant">0</span>, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1408" title="utils/mmgr/mcxt.c:1408">MemoryContextAllocAligned</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Allocate 'size' bytes of memory in 'context' aligned to 'alignto'<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; bytes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently, we align addresses by requesting additional bytes from the<br/></li>
<li></span><span class="Comment"> * MemoryContext's standard allocator function and then aligning the returned<br/></li>
<li></span><span class="Comment"> * address by the required alignment.&nbsp; This means that the given MemoryContext<br/></li>
<li></span><span class="Comment"> * must support providing us with a chunk of memory that's larger than 'size'.<br/></li>
<li></span><span class="Comment"> * For allocators such as Slab, that's not going to work, as slab only allows<br/></li>
<li></span><span class="Comment"> * chunks of the size that's specified when the context is created.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'alignto' must be a power of 2.<br/></li>
<li></span><span class="Comment"> * 'flags' may be 0 or set the same as <a href="#L1237" title="utils/mmgr/mcxt.c:1237">MemoryContextAllocExtended</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L1408">&#x200c;</a><span class="linkable">MemoryContextAllocAligned</span>(MemoryContext context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size size, Size alignto, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryChunk *alignedchunk;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; alloc_size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *unaligned;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *aligned;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* wouldn't make much sense to waste that much space */<br/></li>
<li></span>&nbsp; &nbsp; Assert(alignto &lt; (<span class="Constant">128</span> * <span class="Constant">1024</span> * <span class="Constant">1024</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ensure alignto is a power of 2 */<br/></li>
<li></span>&nbsp; &nbsp; Assert((alignto &amp; (alignto - <span class="Constant">1</span>)) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the alignment requirements are less than what we already guarantee<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then just use the standard allocation function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(alignto &lt;= MAXIMUM_ALIGNOF))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1237" title="utils/mmgr/mcxt.c:1237">MemoryContextAllocExtended</a>(context, size, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We implement aligned pointers by simply allocating enough memory for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the requested size plus the alignment and an additional &quot;redirection&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MemoryChunk.&nbsp; This additional MemoryChunk is required for operations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * such as <a href="#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> when used on the pointer returned by this function.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use this redirection MemoryChunk in order to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the pointer to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory that was returned by the <a href="#L1237" title="utils/mmgr/mcxt.c:1237">MemoryContextAllocExtended</a> call below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do that by &quot;borrowing&quot; the block offset field and instead of using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the offset into the owning block, we use it to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * original allocated address.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Here we must allocate enough extra memory so that we can still align<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the pointer returned by <a href="#L1237" title="utils/mmgr/mcxt.c:1237">MemoryContextAllocExtended</a> and also have enough<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * space for the redirection MemoryChunk.&nbsp; Since allocations will already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be at least aligned by MAXIMUM_ALIGNOF, we can subtract that amount<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the allocation size to save a little memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; alloc_size = size + PallocAlignedExtraBytes(alignto);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* ensure there's space for a <a href="../../lib/rbtree.c.html#L63" title="lib/rbtree.c:63">sentinel</a> byte */<br/></li>
<li></span>&nbsp; &nbsp; alloc_size += <span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* perform the actual allocation */<br/></li>
<li></span>&nbsp; &nbsp; unaligned = <a href="#L1237" title="utils/mmgr/mcxt.c:1237">MemoryContextAllocExtended</a>(context, alloc_size, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set the aligned pointer */<br/></li>
<li></span>&nbsp; &nbsp; aligned = (<span class="Type">void</span> *) TYPEALIGN(alignto, (<span class="Type">char</span> *) unaligned +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MemoryChunk));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; alignedchunk = PointerGetMemoryChunk(aligned);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We set the redirect MemoryChunk so that the block offset calculation is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used to point back to the 'unaligned' allocated chunk.&nbsp; This allows us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to use MemoryChunkGetBlock() to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the unaligned chunk when we need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to perform operations such as <a href="#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>() and <a href="#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We store 'alignto' in the MemoryChunk's 'value' so that we know what<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the alignment was set to should we ever be asked to realloc this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pointer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemoryChunkSetHdrMask(alignedchunk, unaligned, alignto,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MCTX_ALIGNED_REDIRECT_ID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* double check we produced a correctly aligned pointer */<br/></li>
<li></span>&nbsp; &nbsp; Assert((<span class="Type">void</span> *) TYPEALIGN(alignto, aligned) == aligned);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; alignedchunk-&gt;requested_size = size;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set mark to catch clobber of &quot;unused&quot; space */<br/></li>
<li></span>&nbsp; &nbsp; set_sentinel(aligned, size);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the bytes <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the redirection header as noaccess */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(unaligned,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">char</span> *) alignedchunk - (<span class="Type">char</span> *) unaligned);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Disallow access to the redirection chunk header. */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(alignedchunk, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MemoryChunk));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> aligned;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1510" title="utils/mmgr/mcxt.c:1510">palloc_aligned</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Allocate 'size' bytes returning a pointer that's aligned to the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 'alignto' boundary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently, we align addresses by requesting additional bytes from the<br/></li>
<li></span><span class="Comment"> * MemoryContext's standard allocator function and then aligning the returned<br/></li>
<li></span><span class="Comment"> * address by the required alignment.&nbsp; This means that the given MemoryContext<br/></li>
<li></span><span class="Comment"> * must support providing us with a chunk of memory that's larger than 'size'.<br/></li>
<li></span><span class="Comment"> * For allocators such as Slab, that's not going to work, as slab only allows<br/></li>
<li></span><span class="Comment"> * chunks of the size that's specified when the context is created.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'alignto' must be a power of 2.<br/></li>
<li></span><span class="Comment"> * 'flags' may be 0 or set the same as <a href="#L1237" title="utils/mmgr/mcxt.c:1237">MemoryContextAllocExtended</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L1510">&#x200c;</a><span class="linkable">palloc_aligned</span>(Size size, Size alignto, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1408" title="utils/mmgr/mcxt.c:1408">MemoryContextAllocAligned</a>(<a href="#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>, size, alignto, flags);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Release an allocated chunk.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1520">&#x200c;</a></span><span class="linkable">pfree</span>(<span class="Type">void</span> *pointer)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_VALGRIND<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextMethodID method = <a href="#L191" title="utils/mmgr/mcxt.c:191">GetMemoryChunkMethodID</a>(pointer);<br/></li>
<li>&nbsp; &nbsp; MemoryContext context = <a href="#L707" title="utils/mmgr/mcxt.c:707">GetMemoryChunkContext</a>(pointer);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L182" title="utils/mmgr/mcxt.c:182">MCXT_METHOD</a>(pointer, free_p) (pointer);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_VALGRIND<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (method != MCTX_ALIGNED_REDIRECT_ID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MEMPOOL_FREE(context, pointer);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Adjust the size of a previously allocated chunk.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L1540">&#x200c;</a><span class="linkable">repalloc</span>(<span class="Type">void</span> *pointer, Size size)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_VALGRIND<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextMethodID method = <a href="#L191" title="utils/mmgr/mcxt.c:191">GetMemoryChunkMethodID</a>(pointer);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#if defined(USE_ASSERT_CHECKING) || defined(USE_VALGRIND)<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext context = <a href="#L707" title="utils/mmgr/mcxt.c:707">GetMemoryChunkContext</a>(pointer);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L175" title="utils/mmgr/mcxt.c:175">AssertNotInCriticalSection</a>(context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* isReset must be false already */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!context-&gt;isReset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For efficiency reasons, we purposefully offload the handling of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocation failures to the MemoryContextMethods implementation as this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allows these checks to be performed only when an actual malloc needs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be done to request more memory from the OS.&nbsp; Additionally, not having<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to execute <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> instructions after this call allows the compiler to use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the sibling call optimization.&nbsp; If you're considering adding code after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this call, consider making it the responsibility of the 'realloc'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ret = <a href="#L182" title="utils/mmgr/mcxt.c:182">MCXT_METHOD</a>(pointer, realloc) (pointer, size, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_VALGRIND<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (method != MCTX_ALIGNED_REDIRECT_ID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1581" title="utils/mmgr/mcxt.c:1581">repalloc_extended</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Adjust the size of a previously allocated chunk,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; with HUGE and NO_OOM options.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L1581">&#x200c;</a><span class="linkable">repalloc_extended</span>(<span class="Type">void</span> *pointer, Size size, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#if defined(USE_ASSERT_CHECKING) || defined(USE_VALGRIND)<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext context = <a href="#L707" title="utils/mmgr/mcxt.c:707">GetMemoryChunkContext</a>(pointer);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L175" title="utils/mmgr/mcxt.c:175">AssertNotInCriticalSection</a>(context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* isReset must be false already */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!context-&gt;isReset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For efficiency reasons, we purposefully offload the handling of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocation failures to the MemoryContextMethods implementation as this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allows these checks to be performed only when an actual malloc needs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be done to request more memory from the OS.&nbsp; Additionally, not having<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to execute <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> instructions after this call allows the compiler to use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the sibling call optimization.&nbsp; If you're considering adding code after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this call, consider making it the responsibility of the 'realloc'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ret = <a href="#L182" title="utils/mmgr/mcxt.c:182">MCXT_METHOD</a>(pointer, realloc) (pointer, size, flags);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(ret == <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; VALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1618" title="utils/mmgr/mcxt.c:1618">repalloc0</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Adjust the size of a previously allocated chunk and zero out the added<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; space.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L1618">&#x200c;</a><span class="linkable">repalloc0</span>(<span class="Type">void</span> *pointer, Size oldsize, Size size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* catch wrong argument order */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(oldsize &gt; size))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid <a href="#L1618" title="utils/mmgr/mcxt.c:1618">repalloc0</a> call: oldsize </span><span class="Special">%zu</span><span class="Constant">, new size </span><span class="Special">%zu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldsize, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = <a href="#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(pointer, size);<br/></li>
<li>&nbsp; &nbsp; memset((<span class="Type">char</span> *) ret + oldsize, <span class="Constant">0</span>, (size - oldsize));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1639" title="utils/mmgr/mcxt.c:1639">MemoryContextAllocHuge</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Allocate (possibly-expansive) space within the specified context.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See considerations in comment at MaxAllocHugeSize.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L1639">&#x200c;</a><span class="linkable">MemoryContextAllocHuge</span>(MemoryContext context, Size size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(MemoryContextIsValid(context));<br/></li>
<li>&nbsp; &nbsp; <a href="#L175" title="utils/mmgr/mcxt.c:175">AssertNotInCriticalSection</a>(context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context-&gt;isReset = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For efficiency reasons, we purposefully offload the handling of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocation failures to the MemoryContextMethods implementation as this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allows these checks to be performed only when an actual malloc needs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be done to request more memory from the OS.&nbsp; Additionally, not having<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to execute <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> instructions after this call allows the compiler to use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the sibling call optimization.&nbsp; If you're considering adding code after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this call, consider making it the responsibility of the 'alloc'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ret = context-&gt;methods-&gt;alloc(context, size, MCXT_ALLOC_HUGE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; VALGRIND_MEMPOOL_ALLOC(context, ret, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1671" title="utils/mmgr/mcxt.c:1671">repalloc_huge</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Adjust the size of a previously allocated chunk, permitting a large<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; value.&nbsp; The previous allocation need not have been &quot;huge&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L1671">&#x200c;</a><span class="linkable">repalloc_huge</span>(<span class="Type">void</span> *pointer, Size size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* this one seems not worth its own implementation */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1581" title="utils/mmgr/mcxt.c:1581">repalloc_extended</a>(pointer, size, MCXT_ALLOC_HUGE);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Like strdup(), but allocate from the specified context<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L1682">&#x200c;</a><span class="linkable">MemoryContextStrdup</span>(MemoryContext context, <span class="Type">const</span> <span class="Type">char</span> *string)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *nstr;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len = strlen(string) + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nstr = (<span class="Type">char</span> *) <a href="#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(context, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(nstr, string, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nstr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">char</span> *<br/></li>
<li><a id="L1695">&#x200c;</a><span class="linkable">pstrdup</span>(<span class="Type">const</span> <span class="Type">char</span> *in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(<a href="#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>, in);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1706" title="utils/mmgr/mcxt.c:1706">pnstrdup</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Like <a href="#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(), but append null byte to a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; not-necessarily-null-terminated input string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L1706">&#x200c;</a><span class="linkable">pnstrdup</span>(<span class="Type">const</span> <span class="Type">char</span> *in, Size len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *out;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = strnlen(in, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; out = <a href="#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; memcpy(out, in, len);<br/></li>
<li>&nbsp; &nbsp; out[len] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> out;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make copy of string with all trailing <a href="../../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a> characters removed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L1723">&#x200c;</a><span class="linkable">pchomp</span>(<span class="Type">const</span> <span class="Type">char</span> *in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; n = strlen(in);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (n &gt; <span class="Constant">0</span> &amp;&amp; in[n - <span class="Constant">1</span>] == <span class="Special">'\n'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1706" title="utils/mmgr/mcxt.c:1706">pnstrdup</a>(in, n);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
