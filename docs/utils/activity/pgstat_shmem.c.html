<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/activity/pgstat_shmem.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/activity/pgstat_shmem.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L62">dsh_params</a></li>
<li><a href="#L82">pgStatEntryRefHash</a></li>
<li><a href="#L91">pgStatEntryRefHashContext</a></li>
<li><a href="#L83">pgStatSharedRefAge</a></li>
<li><a href="#L90">pgStatSharedRefContext</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L24">PgStat_EntryRefHashEntry</a></li>
<li><a href="#L29">PgStat_EntryRefHashEntry</a></li>
<li><a href="#L55">ReleaseMatchCB</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L141">StatsShmemInit</a></li>
<li><a href="#L127">StatsShmemSize</a></li>
<li><a href="#L727">match_db</a></li>
<li><a href="#L984">match_kind</a></li>
<li><a href="#L323">pgstat_acquire_entry_ref</a></li>
<li><a href="#L218">pgstat_attach_shmem</a></li>
<li><a href="#L238">pgstat_detach_shmem</a></li>
<li><a href="#L896">pgstat_drop_all_entries</a></li>
<li><a href="#L809">pgstat_drop_database_and_contents</a></li>
<li><a href="#L859">pgstat_drop_entry</a></li>
<li><a href="#L774">pgstat_drop_entry_internal</a></li>
<li><a href="#L106">pgstat_dsa_init_size</a></li>
<li><a href="#L749">pgstat_free_entry</a></li>
<li><a href="#L651">pgstat_gc_entry_refs</a></li>
<li><a href="#L398">pgstat_get_entry_ref</a></li>
<li><a href="#L342">pgstat_get_entry_ref_cached</a></li>
<li><a href="#L613">pgstat_get_entry_ref_locked</a></li>
<li><a href="#L259">pgstat_init_entry</a></li>
<li><a href="#L576">pgstat_lock_entry</a></li>
<li><a href="#L592">pgstat_lock_entry_shared</a></li>
<li><a href="#L635">pgstat_need_entry_refs_gc</a></li>
<li><a href="#L288">pgstat_reinit_entry</a></li>
<li><a href="#L715">pgstat_release_all_entry_refs</a></li>
<li><a href="#L735">pgstat_release_db_entry_refs</a></li>
<li><a href="#L522">pgstat_release_entry_ref</a></li>
<li><a href="#L685">pgstat_release_matching_entry_refs</a></li>
<li><a href="#L629">pgstat_request_entry_refs_gc</a></li>
<li><a href="#L990">pgstat_reset_entries_of_kind</a></li>
<li><a href="#L934">pgstat_reset_entry</a></li>
<li><a href="#L954">pgstat_reset_matching_entries</a></li>
<li><a href="#L996">pgstat_setup_memcxt</a></li>
<li><a href="#L307">pgstat_setup_shared_refs</a></li>
<li><a href="#L604">pgstat_unlock_entry</a></li>
<li><a href="#L918">shared_stat_reset_contents</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L21">PGSTAT_ENTRY_REF_HASH_SIZE</a></li>
<li><a href="#L43">SH_DECLARE</a></li>
<li><a href="#L42">SH_DEFINE</a></li>
<li><a href="#L34">SH_ELEMENT_TYPE</a></li>
<li><a href="#L39">SH_EQUAL</a></li>
<li><a href="#L37">SH_HASH_KEY</a></li>
<li><a href="#L36">SH_KEY</a></li>
<li><a href="#L35">SH_KEY_TYPE</a></li>
<li><a href="#L33">SH_PREFIX</a></li>
<li><a href="#L41">SH_SCOPE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/* -------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * pgstat_shmem.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Storage of stats entries in shared memory<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2001-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/activity/pgstat_shmem.c<br/></li>
<li></span><span class="Comment"> * -------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/shmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pgstat_internal.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L21">&#x200c;</a><span class="PreProc">#define <span class="linkable">PGSTAT_ENTRY_REF_HASH_SIZE</span>&nbsp; &nbsp; </span><span class="Constant">128<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table entry for finding the PgStat_EntryRef for a key */<br/></li>
<li><a id="L24">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">PgStat_EntryRefHashEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PgStat_HashKey key;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; status;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for simplehash use */<br/></li>
<li></span>&nbsp; &nbsp; PgStat_EntryRef *entry_ref;<br/></li>
<li><a id="L29">&#x200c;</a>} <span class="linkable">PgStat_EntryRefHashEntry</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* for references to shared statistics entries */<br/></li>
<li><a id="L33">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_PREFIX</span> pgstat_entry_ref_hash<br/></li>
<li><a id="L34">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_ELEMENT_TYPE</span> <a href="#L24" title="utils/activity/pgstat_shmem.c:24">PgStat_EntryRefHashEntry</a><br/></li>
<li><a id="L35">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_KEY_TYPE</span> PgStat_HashKey<br/></li>
<li><a id="L36">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_KEY</span> key<br/></li>
<li><a id="L37">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_HASH_KEY</span>(tb, key) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; pgstat_hash_hash_key(&amp;key, </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(PgStat_HashKey), </span><span class="Constant">NULL</span><span class="PreProc">)<br/></li>
<li><a id="L39">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_EQUAL</span>(tb, a, b) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; pgstat_cmp_hash_key(&amp;a, &amp;b, </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(PgStat_HashKey), </span><span class="Constant">NULL</span><span class="PreProc">) == </span><span class="Constant">0<br/></li>
<li><a id="L41">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_SCOPE</span> </span><span class="Type">static</span><span class="PreProc"> </span><span class="Type">inline<br/></li>
<li><a id="L42">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_DEFINE</span><br/></li>
<li><a id="L43">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_DECLARE</span><br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/simplehash.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L809" title="utils/activity/pgstat_shmem.c:809">pgstat_drop_database_and_contents</a>(Oid dboid);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L749" title="utils/activity/pgstat_shmem.c:749">pgstat_free_entry</a>(PgStatShared_HashEntry *shent, dshash_seq_status *hstat);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L522" title="utils/activity/pgstat_shmem.c:522">pgstat_release_entry_ref</a>(PgStat_HashKey key, PgStat_EntryRef *entry_ref, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> discard_pending);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L635" title="utils/activity/pgstat_shmem.c:635">pgstat_need_entry_refs_gc</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L651" title="utils/activity/pgstat_shmem.c:651">pgstat_gc_entry_refs</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L715" title="utils/activity/pgstat_shmem.c:715">pgstat_release_all_entry_refs</a>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> discard_pending);<br/></li>
<li><a id="L55">&#x200c;</a><span class="Type">typedef</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> (*<span class="linkable">ReleaseMatchCB</span>) (<a href="#L24" title="utils/activity/pgstat_shmem.c:24">PgStat_EntryRefHashEntry</a> *, Datum data);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L685" title="utils/activity/pgstat_shmem.c:685">pgstat_release_matching_entry_refs</a>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> discard_pending, <a href="#L55" title="utils/activity/pgstat_shmem.c:55">ReleaseMatchCB</a> match, Datum match_data);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L996" title="utils/activity/pgstat_shmem.c:996">pgstat_setup_memcxt</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* parameter for the shared <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> */<br/></li>
<li><a id="L62">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> dshash_parameters <span class="linkable">dsh_params</span> = {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PgStat_HashKey),<br/></li>
<li>&nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PgStatShared_HashEntry),<br/></li>
<li>&nbsp; &nbsp; pgstat_cmp_hash_key,<br/></li>
<li>&nbsp; &nbsp; pgstat_hash_hash_key,<br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/dshash.c.html#L590" title="lib/dshash.c:590">dshash_memcpy</a>,<br/></li>
<li>&nbsp; &nbsp; LWTRANCHE_PGSTATS_HASH<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../postmaster/postmaster.c.html#L177" title="postmaster/postmaster.c:177">Backend</a> local references to shared stats entries. If there are pending<br/></li>
<li></span><span class="Comment"> * updates to a stats entry, the PgStat_EntryRef is added to the <a href="pgstat.c.html#L218" title="utils/activity/pgstat.c:218">pgStatPending</a><br/></li>
<li></span><span class="Comment"> * list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When a stats entry is dropped each backend needs to release its reference<br/></li>
<li></span><span class="Comment"> * to it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the memory can be released. To <a href="../adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> that<br/></li>
<li></span><span class="Comment"> * <a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shmem-&gt;gc_request_count is incremented - which each backend<br/></li>
<li></span><span class="Comment"> * compares to their copy of <a href="#L83" title="utils/activity/pgstat_shmem.c:83">pgStatSharedRefAge</a> on a regular basis.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L82">&#x200c;</a></span><span class="Type">static</span> pgstat_entry_ref_hash_hash *<span class="linkable">pgStatEntryRefHash</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L83">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">pgStatSharedRefAge</span> = <span class="Constant">0</span>; <span class="Comment">/* cache age of pgStatShmLookupCache */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Memory contexts containing the <a href="#L82" title="utils/activity/pgstat_shmem.c:82">pgStatEntryRefHash</a> table and the<br/></li>
<li></span><span class="Comment"> * pgStatSharedRef entries respectively. Kept separate to make it easier to<br/></li>
<li></span><span class="Comment"> * track / attribute memory usage.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L90">&#x200c;</a></span><span class="Type">static</span> MemoryContext <span class="linkable">pgStatSharedRefContext</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L91">&#x200c;</a><span class="Type">static</span> MemoryContext <span class="linkable">pgStatEntryRefHashContext</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Public <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> called from postmaster follow<br/></li>
<li></span><span class="Comment"> * ------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The size of the shared memory allocation for stats stored in the shared<br/></li>
<li></span><span class="Comment"> * stats <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table. This allocation will be done as part of the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> shared<br/></li>
<li></span><span class="Comment"> * memory, rather than dynamic shared memory, allowing it to be initialized in<br/></li>
<li></span><span class="Comment"> * postmaster.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Size<br/></li>
<li><a id="L106">&#x200c;</a><span class="linkable">pgstat_dsa_init_size</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; sz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The dshash header / initial buckets array needs to fit into &quot;plain&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared memory, but it's beneficial to not need dsm segments<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * immediately. A size of 256kB seems works well and is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * disproportional compared to other constant sized shared memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocations. NB: To avoid DSMs further, the user can configure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/ipc/dsm_impl.c.html#L115" title="storage/ipc/dsm_impl.c:115">min_dynamic_shared_memory</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sz = <span class="Constant">256</span> * <span class="Constant">1024</span>;<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../mmgr/dsa.c.html#L1196" title="utils/mmgr/dsa.c:1196">dsa_minimum_size</a>() &lt;= sz);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> MAXALIGN(sz);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute shared memory space needed for cumulative statistics<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L127">&#x200c;</a><span class="linkable">StatsShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; sz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sz = MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PgStat_ShmemControl));<br/></li>
<li>&nbsp; &nbsp; sz = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(sz, <a href="#L106" title="utils/activity/pgstat_shmem.c:106">pgstat_dsa_init_size</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> sz;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize cumulative statistics system during startup<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L141">&#x200c;</a></span><span class="linkable">StatsShmemInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; sz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sz = <a href="#L127" title="utils/activity/pgstat_shmem.c:127">StatsShmemSize</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shmem = (PgStat_ShmemControl *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;Shared Memory Stats&quot;</span>, sz, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a>&nbsp;&nbsp; *dsa;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/dshash.c.html#L103" title="lib/dshash.c:103">dshash_table</a> *dsh;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PgStat_ShmemControl *ctl = <a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shmem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p = (<span class="Type">char</span> *) ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the allocation of <a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shmem itself */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; p += MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PgStat_ShmemControl));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create a small dsa allocation in plain shared memory. This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * required because postmaster cannot use dsm segments. It also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * provides a small efficiency win.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ctl-&gt;raw_dsa_area = p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p += MAXALIGN(<a href="#L106" title="utils/activity/pgstat_shmem.c:106">pgstat_dsa_init_size</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dsa = dsa_create_in_place(ctl-&gt;raw_dsa_area,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L106" title="utils/activity/pgstat_shmem.c:106">pgstat_dsa_init_size</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LWTRANCHE_PGSTATS_DSA, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/dsa.c.html#L975" title="utils/mmgr/dsa.c:975">dsa_pin</a>(dsa);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To ensure dshash is created in &quot;plain&quot; shared memory, temporarily<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * limit size of dsa to the initial size of the dsa.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/dsa.c.html#L1018" title="utils/mmgr/dsa.c:1018">dsa_set_size_limit</a>(dsa, <a href="#L106" title="utils/activity/pgstat_shmem.c:106">pgstat_dsa_init_size</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * With the limit in place, create the dshash table. </span><span class="Todo">XXX</span><span class="Comment">: It'd be nice<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if there were dshash_create_in_place().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dsh = <a href="../../lib/dshash.c.html#L206" title="lib/dshash.c:206">dshash_create</a>(dsa, &amp;<a href="../../storage/ipc/dsm_registry.c.html#L50" title="storage/ipc/dsm_registry.c:50">dsh_params</a>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl-&gt;hash_handle = <a href="../../lib/dshash.c.html#L367" title="lib/dshash.c:367">dshash_get_hash_table_handle</a>(dsh);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lift limit set above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/dsa.c.html#L1018" title="utils/mmgr/dsa.c:1018">dsa_set_size_limit</a>(dsa, -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Postmaster will never access these again, thus free the local<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dsa/dshash references.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/dshash.c.html#L307" title="lib/dshash.c:307">dshash_detach</a>(dsh);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/dsa.c.html#L1952" title="utils/mmgr/dsa.c:1952">dsa_detach</a>(dsa);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_u64(&amp;ctl-&gt;gc_request_count, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> fixed-numbered stats */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L709" title="storage/lmgr/lwlock.c:709">LWLockInitialize</a>(&amp;ctl-&gt;archiver.lock, LWTRANCHE_PGSTATS_DATA);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L709" title="storage/lmgr/lwlock.c:709">LWLockInitialize</a>(&amp;ctl-&gt;bgwriter.lock, LWTRANCHE_PGSTATS_DATA);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L709" title="storage/lmgr/lwlock.c:709">LWLockInitialize</a>(&amp;ctl-&gt;checkpointer.lock, LWTRANCHE_PGSTATS_DATA);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L709" title="storage/lmgr/lwlock.c:709">LWLockInitialize</a>(&amp;ctl-&gt;slru.lock, LWTRANCHE_PGSTATS_DATA);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L709" title="storage/lmgr/lwlock.c:709">LWLockInitialize</a>(&amp;ctl-&gt;wal.lock, LWTRANCHE_PGSTATS_DATA);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; BACKEND_NUM_TYPES; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L709" title="storage/lmgr/lwlock.c:709">LWLockInitialize</a>(&amp;ctl-&gt;io.locks[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LWTRANCHE_PGSTATS_DATA);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(found);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L218">&#x200c;</a></span><span class="linkable">pgstat_attach_shmem</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.dsa == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* stats shared memory persists for the backend lifetime */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.dsa = <a href="../mmgr/dsa.c.html#L545" title="utils/mmgr/dsa.c:545">dsa_attach_in_place</a>(<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shmem-&gt;raw_dsa_area,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/dsa.c.html#L635" title="utils/mmgr/dsa.c:635">dsa_pin_mapping</a>(<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.dsa);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shared_hash = <a href="../../lib/dshash.c.html#L270" title="lib/dshash.c:270">dshash_attach</a>(<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.dsa, &amp;<a href="../../storage/ipc/dsm_registry.c.html#L50" title="storage/ipc/dsm_registry.c:50">dsh_params</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shmem-&gt;hash_handle, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L238">&#x200c;</a></span><span class="linkable">pgstat_detach_shmem</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.dsa);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we shouldn't leave references to shared stats */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L715" title="utils/activity/pgstat_shmem.c:715">pgstat_release_all_entry_refs</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/dshash.c.html#L307" title="lib/dshash.c:307">dshash_detach</a>(<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shared_hash);<br/></li>
<li>&nbsp; &nbsp; <a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shared_hash = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/dsa.c.html#L1952" title="utils/mmgr/dsa.c:1952">dsa_detach</a>(<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.dsa);<br/></li>
<li>&nbsp; &nbsp; <a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.dsa = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Maintenance of shared memory stats entries<br/></li>
<li></span><span class="Comment"> * ------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>PgStatShared_Common *<br/></li>
<li><a id="L259">&#x200c;</a><span class="linkable">pgstat_init_entry</span>(PgStat_Kind kind,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PgStatShared_HashEntry *shhashent)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create new stats entry. */<br/></li>
<li></span>&nbsp; &nbsp; dsa_pointer chunk;<br/></li>
<li>&nbsp; &nbsp; PgStatShared_Common *shheader;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize refcount to 1, marking it as valid / not dropped. The entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't be freed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the initialization because it can't be found as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * long as we hold the dshash partition lock. Caller needs to increase<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * further if a longer lived reference is needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_init_u32(&amp;shhashent-&gt;refcount, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; shhashent-&gt;dropped = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; chunk = dsa_allocate0(<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.dsa, <a href="pgstat.c.html#L1263" title="utils/activity/pgstat.c:1263">pgstat_get_kind_info</a>(kind)-&gt;shared_size);<br/></li>
<li>&nbsp; &nbsp; shheader = <a href="../mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.dsa, chunk);<br/></li>
<li>&nbsp; &nbsp; shheader-&gt;magic = <span class="Constant">0xdeadbeef</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Link the new entry from the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> entry. */<br/></li>
<li></span>&nbsp; &nbsp; shhashent-&gt;body = chunk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L709" title="storage/lmgr/lwlock.c:709">LWLockInitialize</a>(&amp;shheader-&gt;lock, LWTRANCHE_PGSTATS_DATA);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> shheader;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> PgStatShared_Common *<br/></li>
<li><a id="L288">&#x200c;</a><span class="linkable">pgstat_reinit_entry</span>(PgStat_Kind kind, PgStatShared_HashEntry *shhashent)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PgStatShared_Common *shheader;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; shheader = <a href="../mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.dsa, shhashent-&gt;body);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* mark as not dropped anymore */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_fetch_add_u32(&amp;shhashent-&gt;refcount, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; shhashent-&gt;dropped = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* reinitialize content */<br/></li>
<li></span>&nbsp; &nbsp; Assert(shheader-&gt;magic == <span class="Constant">0xdeadbeef</span>);<br/></li>
<li>&nbsp; &nbsp; memset(pgstat_get_entry_data(kind, shheader), <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pgstat_get_entry_len(kind));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> shheader;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L307">&#x200c;</a></span><span class="linkable">pgstat_setup_shared_refs</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (likely(<a href="#L82" title="utils/activity/pgstat_shmem.c:82">pgStatEntryRefHash</a> != <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L82" title="utils/activity/pgstat_shmem.c:82">pgStatEntryRefHash</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_entry_ref_hash_create(<a href="#L91" title="utils/activity/pgstat_shmem.c:91">pgStatEntryRefHashContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L21" title="utils/activity/pgstat_shmem.c:21">PGSTAT_ENTRY_REF_HASH_SIZE</a>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="utils/activity/pgstat_shmem.c:83">pgStatSharedRefAge</a> = pg_atomic_read_u64(&amp;<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shmem-&gt;gc_request_count);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L83" title="utils/activity/pgstat_shmem.c:83">pgStatSharedRefAge</a> != <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function for <a href="#L398" title="utils/activity/pgstat_shmem.c:398">pgstat_get_entry_ref</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L323">&#x200c;</a></span><span class="linkable">pgstat_acquire_entry_ref</span>(PgStat_EntryRef *entry_ref,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PgStatShared_HashEntry *shhashent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PgStatShared_Common *shheader)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(shheader-&gt;magic == <span class="Constant">0xdeadbeef</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(pg_atomic_read_u32(&amp;shhashent-&gt;refcount) &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_atomic_fetch_add_u32(&amp;shhashent-&gt;refcount, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/dshash.c.html#L558" title="lib/dshash.c:558">dshash_release_lock</a>(<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shared_hash, shhashent);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entry_ref-&gt;shared_stats = shheader;<br/></li>
<li>&nbsp; &nbsp; entry_ref-&gt;shared_entry = shhashent;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function for <a href="#L398" title="utils/activity/pgstat_shmem.c:398">pgstat_get_entry_ref</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L342">&#x200c;</a></span><span class="linkable">pgstat_get_entry_ref_cached</span>(PgStat_HashKey key, PgStat_EntryRef **entry_ref_p)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; <a href="#L24" title="utils/activity/pgstat_shmem.c:24">PgStat_EntryRefHashEntry</a> *cache_entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We immediately insert a cache entry, because it avoids 1) multiple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hashtable lookups in case of a cache <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> 2) having to deal with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * out-of-memory errors after incrementing PgStatShared_Common-&gt;refcount.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; cache_entry = pgstat_entry_ref_hash_insert(<a href="#L82" title="utils/activity/pgstat_shmem.c:82">pgStatEntryRefHash</a>, key, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found || !cache_entry-&gt;entry_ref)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PgStat_EntryRef *entry_ref;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache_entry-&gt;entry_ref = entry_ref =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="#L90" title="utils/activity/pgstat_shmem.c:90">pgStatSharedRefContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PgStat_EntryRef));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry_ref-&gt;shared_stats = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry_ref-&gt;shared_entry = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry_ref-&gt;pending = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (cache_entry-&gt;entry_ref-&gt;shared_stats == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(cache_entry-&gt;entry_ref-&gt;pending == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PgStat_EntryRef *entry_ref <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry_ref = cache_entry-&gt;entry_ref;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(entry_ref-&gt;shared_entry != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(entry_ref-&gt;shared_stats != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(entry_ref-&gt;shared_stats-&gt;magic == <span class="Constant">0xdeadbeef</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should have at least our reference */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(pg_atomic_read_u32(&amp;entry_ref-&gt;shared_entry-&gt;refcount) &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *entry_ref_p = cache_entry-&gt;entry_ref;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> found;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get a shared stats reference. If create is true, the shared stats object is<br/></li>
<li></span><span class="Comment"> * created if it does not exist.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When create is true, and created_entry is non-NULL, it'll be set to true<br/></li>
<li></span><span class="Comment"> * if the entry is newly created, false otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PgStat_EntryRef *<br/></li>
<li><a id="L398">&#x200c;</a><span class="linkable">pgstat_get_entry_ref</span>(PgStat_Kind kind, Oid dboid, Oid objoid, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> create,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *created_entry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PgStat_HashKey key = {.kind = kind,.dboid = dboid,.objoid = objoid};<br/></li>
<li>&nbsp; &nbsp; PgStatShared_HashEntry *shhashent;<br/></li>
<li>&nbsp; &nbsp; PgStatShared_Common *shheader = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; PgStat_EntryRef *entry_ref;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * passing in created_entry only makes sense if we possibly could create<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(create || created_entry == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="pgstat.c.html#L1277" title="utils/activity/pgstat.c:1277">pgstat_assert_is_up</a>();<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shared_hash != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shmem-&gt;is_shutdown);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L996" title="utils/activity/pgstat_shmem.c:996">pgstat_setup_memcxt</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L307" title="utils/activity/pgstat_shmem.c:307">pgstat_setup_shared_refs</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (created_entry != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *created_entry = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if other backends dropped stats that could not be deleted because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * somebody held references to it. If so, check this backend's references.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is not expected to happen often. The location of the check is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> random, but this is a relatively frequently called path, so better<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than most.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L635" title="utils/activity/pgstat_shmem.c:635">pgstat_need_entry_refs_gc</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L651" title="utils/activity/pgstat_shmem.c:651">pgstat_gc_entry_refs</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First check the lookup cache hashtable in local memory. If we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * match here we can avoid taking locks / causing contention.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L342" title="utils/activity/pgstat_shmem.c:342">pgstat_get_entry_ref_cached</a>(key, &amp;entry_ref))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> entry_ref;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(entry_ref != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do a lookup in the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table first - it's quite likely that the entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already exists, and that way we only need a shared lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; shhashent = <a href="../../lib/dshash.c.html#L390" title="lib/dshash.c:390">dshash_find</a>(<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shared_hash, &amp;key, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (create &amp;&amp; !shhashent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; shfound;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's possible that somebody created the entry since the above<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lookup. If so, fall through to the same path as if we'd have if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already had been created <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the <a href="../../lib/dshash.c.html#L390" title="lib/dshash.c:390">dshash_find</a>() calls.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; shhashent = <a href="../../lib/dshash.c.html#L433" title="lib/dshash.c:433">dshash_find_or_insert</a>(<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shared_hash, &amp;key, &amp;shfound);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!shfound)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shheader = <a href="#L259" title="utils/activity/pgstat_shmem.c:259">pgstat_init_entry</a>(kind, shhashent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="utils/activity/pgstat_shmem.c:323">pgstat_acquire_entry_ref</a>(entry_ref, shhashent, shheader);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (created_entry != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *created_entry = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> entry_ref;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!shhashent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're not creating, delete the reference again. In all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * likelihood it's just a stats lookup - no point wasting memory for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shared ref to nothing...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L522" title="utils/activity/pgstat_shmem.c:522">pgstat_release_entry_ref</a>(key, entry_ref, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Can get here either because <a href="../../lib/dshash.c.html#L390" title="lib/dshash.c:390">dshash_find</a>() found a match, or if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../lib/dshash.c.html#L433" title="lib/dshash.c:433">dshash_find_or_insert</a>() found a concurrently inserted entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shhashent-&gt;dropped &amp;&amp; create)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There are legitimate cases where the old stats entry might not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * yet have been dropped by the time it's reused. The most obvious<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case are replication slot stats, where a new slot can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * created with the same index just after dropping. But oid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wraparound can lead to other cases as well. We just reset the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stats to their plain state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shheader = <a href="#L288" title="utils/activity/pgstat_shmem.c:288">pgstat_reinit_entry</a>(kind, shhashent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="utils/activity/pgstat_shmem.c:323">pgstat_acquire_entry_ref</a>(entry_ref, shhashent, shheader);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (created_entry != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *created_entry = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> entry_ref;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (shhashent-&gt;dropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/dshash.c.html#L558" title="lib/dshash.c:558">dshash_release_lock</a>(<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shared_hash, shhashent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L522" title="utils/activity/pgstat_shmem.c:522">pgstat_release_entry_ref</a>(key, entry_ref, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shheader = <a href="../mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.dsa, shhashent-&gt;body);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L323" title="utils/activity/pgstat_shmem.c:323">pgstat_acquire_entry_ref</a>(entry_ref, shhashent, shheader);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> entry_ref;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L522">&#x200c;</a></span><span class="linkable">pgstat_release_entry_ref</span>(PgStat_HashKey key, PgStat_EntryRef *entry_ref,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> discard_pending)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entry_ref &amp;&amp; entry_ref-&gt;pending)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (discard_pending)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="pgstat.c.html#L1156" title="utils/activity/pgstat.c:1156">pgstat_delete_pending_entry</a>(entry_ref);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;releasing ref with pending data&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entry_ref &amp;&amp; entry_ref-&gt;shared_stats)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(entry_ref-&gt;shared_stats-&gt;magic == <span class="Constant">0xdeadbeef</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(entry_ref-&gt;pending == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This can't race with another backend looking up the stats entry and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * increasing the refcount because it is not &quot;legal&quot; to create<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * additional references to dropped entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_atomic_fetch_sub_u32(&amp;entry_ref-&gt;shared_entry-&gt;refcount, <span class="Constant">1</span>) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PgStatShared_HashEntry *shent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're the last referrer to this entry, try to drop the shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* only dropped entries can reach a 0 refcount */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(entry_ref-&gt;shared_entry-&gt;dropped);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shent = <a href="../../lib/dshash.c.html#L390" title="lib/dshash.c:390">dshash_find</a>(<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shared_hash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;entry_ref-&gt;shared_entry-&gt;key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!shent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> just referenced shared stats entry&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(pg_atomic_read_u32(&amp;entry_ref-&gt;shared_entry-&gt;refcount) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(entry_ref-&gt;shared_entry == shent);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L749" title="utils/activity/pgstat_shmem.c:749">pgstat_free_entry</a>(shent, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!pgstat_entry_ref_hash_delete(<a href="#L82" title="utils/activity/pgstat_shmem.c:82">pgStatEntryRefHash</a>, key))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;entry ref vanished <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> deletion&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entry_ref)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(entry_ref);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L576">&#x200c;</a></span><span class="linkable">pgstat_lock_entry</span>(PgStat_EntryRef *entry_ref, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nowait)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock = &amp;entry_ref-&gt;shared_stats-&gt;lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nowait)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../storage/lmgr/lwlock.c.html#L1341" title="storage/lmgr/lwlock.c:1341">LWLockConditionalAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Separate from <a href="#L576" title="utils/activity/pgstat_shmem.c:576">pgstat_lock_entry</a>() as most callers will need to lock<br/></li>
<li></span><span class="Comment"> * exclusively.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L592">&#x200c;</a></span><span class="linkable">pgstat_lock_entry_shared</span>(PgStat_EntryRef *entry_ref, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nowait)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock = &amp;entry_ref-&gt;shared_stats-&gt;lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nowait)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../storage/lmgr/lwlock.c.html#L1341" title="storage/lmgr/lwlock.c:1341">LWLockConditionalAcquire</a>(lock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L604">&#x200c;</a></span><span class="linkable">pgstat_unlock_entry</span>(PgStat_EntryRef *entry_ref)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;entry_ref-&gt;shared_stats-&gt;lock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function to fetch and lock shared stats.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PgStat_EntryRef *<br/></li>
<li><a id="L613">&#x200c;</a><span class="linkable">pgstat_get_entry_ref_locked</span>(PgStat_Kind kind, Oid dboid, Oid objoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nowait)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PgStat_EntryRef *entry_ref;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> shared table stats entry corresponding to the local entry */<br/></li>
<li></span>&nbsp; &nbsp; entry_ref = <a href="#L398" title="utils/activity/pgstat_shmem.c:398">pgstat_get_entry_ref</a>(kind, dboid, objoid, <span class="Constant">true</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* lock the shared entry to protect the content, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> if failed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L576" title="utils/activity/pgstat_shmem.c:576">pgstat_lock_entry</a>(entry_ref, nowait))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> entry_ref;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L629">&#x200c;</a></span><span class="linkable">pgstat_request_entry_refs_gc</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_atomic_fetch_add_u64(&amp;<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shmem-&gt;gc_request_count, <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L635">&#x200c;</a></span><span class="linkable">pgstat_need_entry_refs_gc</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; curage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L82" title="utils/activity/pgstat_shmem.c:82">pgStatEntryRefHash</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* should have been initialized when creating <a href="#L82" title="utils/activity/pgstat_shmem.c:82">pgStatEntryRefHash</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L83" title="utils/activity/pgstat_shmem.c:83">pgStatSharedRefAge</a> != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; curage = pg_atomic_read_u64(&amp;<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shmem-&gt;gc_request_count);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L83" title="utils/activity/pgstat_shmem.c:83">pgStatSharedRefAge</a> != curage;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L651">&#x200c;</a></span><span class="linkable">pgstat_gc_entry_refs</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pgstat_entry_ref_hash_iterator i;<br/></li>
<li>&nbsp; &nbsp; <a href="#L24" title="utils/activity/pgstat_shmem.c:24">PgStat_EntryRefHashEntry</a> *ent;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; curage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; curage = pg_atomic_read_u64(&amp;<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shmem-&gt;gc_request_count);<br/></li>
<li>&nbsp; &nbsp; Assert(curage != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Some entries have been dropped. Invalidate cache pointer to them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pgstat_entry_ref_hash_start_iterate(<a href="#L82" title="utils/activity/pgstat_shmem.c:82">pgStatEntryRefHash</a>, &amp;i);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((ent = pgstat_entry_ref_hash_iterate(<a href="#L82" title="utils/activity/pgstat_shmem.c:82">pgStatEntryRefHash</a>, &amp;i)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PgStat_EntryRef *entry_ref = ent-&gt;entry_ref;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!entry_ref-&gt;shared_stats ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; entry_ref-&gt;shared_stats-&gt;magic == <span class="Constant">0xdeadbeef</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!entry_ref-&gt;shared_entry-&gt;dropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cannot gc shared ref that has pending data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry_ref-&gt;pending != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L522" title="utils/activity/pgstat_shmem.c:522">pgstat_release_entry_ref</a>(ent-&gt;key, entry_ref, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="utils/activity/pgstat_shmem.c:83">pgStatSharedRefAge</a> = curage;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L685">&#x200c;</a></span><span class="linkable">pgstat_release_matching_entry_refs</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> discard_pending, <a href="#L55" title="utils/activity/pgstat_shmem.c:55">ReleaseMatchCB</a> match,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum match_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pgstat_entry_ref_hash_iterator i;<br/></li>
<li>&nbsp; &nbsp; <a href="#L24" title="utils/activity/pgstat_shmem.c:24">PgStat_EntryRefHashEntry</a> *ent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L82" title="utils/activity/pgstat_shmem.c:82">pgStatEntryRefHash</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_entry_ref_hash_start_iterate(<a href="#L82" title="utils/activity/pgstat_shmem.c:82">pgStatEntryRefHash</a>, &amp;i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((ent = pgstat_entry_ref_hash_iterate(<a href="#L82" title="utils/activity/pgstat_shmem.c:82">pgStatEntryRefHash</a>, &amp;i))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ent-&gt;entry_ref != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (match &amp;&amp; !match(ent, match_data))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L522" title="utils/activity/pgstat_shmem.c:522">pgstat_release_entry_ref</a>(ent-&gt;key, ent-&gt;entry_ref, discard_pending);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Release all local references to shared stats entries.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When a process exits it cannot do so while still holding references onto<br/></li>
<li></span><span class="Comment"> * stats entries, otherwise the shared stats entries could never be freed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L715">&#x200c;</a></span><span class="linkable">pgstat_release_all_entry_refs</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> discard_pending)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L82" title="utils/activity/pgstat_shmem.c:82">pgStatEntryRefHash</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L685" title="utils/activity/pgstat_shmem.c:685">pgstat_release_matching_entry_refs</a>(discard_pending, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L82" title="utils/activity/pgstat_shmem.c:82">pgStatEntryRefHash</a>-&gt;members == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; pgstat_entry_ref_hash_destroy(<a href="#L82" title="utils/activity/pgstat_shmem.c:82">pgStatEntryRefHash</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L82" title="utils/activity/pgstat_shmem.c:82">pgStatEntryRefHash</a> = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L727">&#x200c;</a></span><span class="linkable">match_db</span>(<a href="#L24" title="utils/activity/pgstat_shmem.c:24">PgStat_EntryRefHashEntry</a> *ent, Datum match_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dboid = DatumGetObjectId(match_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ent-&gt;key.dboid == dboid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L735">&#x200c;</a></span><span class="linkable">pgstat_release_db_entry_refs</span>(Oid dboid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L685" title="utils/activity/pgstat_shmem.c:685">pgstat_release_matching_entry_refs</a>( <span class="Comment">/* discard pending = */</span> <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L727" title="utils/activity/pgstat_shmem.c:727">match_db</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(dboid));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Dropping and resetting of stats entries<br/></li>
<li></span><span class="Comment"> * ------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L749">&#x200c;</a></span><span class="linkable">pgstat_free_entry</span>(PgStatShared_HashEntry *shent, dshash_seq_status *hstat)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dsa_pointer pdsa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch dsa pointer <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> deleting entry - that way we can free the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory after releasing the lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pdsa = shent-&gt;body;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!hstat)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/dshash.c.html#L541" title="lib/dshash.c:541">dshash_delete_entry</a>(<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shared_hash, shent);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/dshash.c.html#L757" title="lib/dshash.c:757">dshash_delete_current</a>(hstat);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/dsa.c.html#L826" title="utils/mmgr/dsa.c:826">dsa_free</a>(<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.dsa, pdsa);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper for both <a href="#L809" title="utils/activity/pgstat_shmem.c:809">pgstat_drop_database_and_contents</a>() and<br/></li>
<li></span><span class="Comment"> * <a href="#L859" title="utils/activity/pgstat_shmem.c:859">pgstat_drop_entry</a>(). If hstat is non-null delete the shared entry using<br/></li>
<li></span><span class="Comment"> * <a href="../../lib/dshash.c.html#L757" title="lib/dshash.c:757">dshash_delete_current</a>(), otherwise use <a href="../../lib/dshash.c.html#L541" title="lib/dshash.c:541">dshash_delete_entry</a>(). In either<br/></li>
<li></span><span class="Comment"> * case the entry needs to be already locked.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L774">&#x200c;</a></span><span class="linkable">pgstat_drop_entry_internal</span>(PgStatShared_HashEntry *shent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dshash_seq_status *hstat)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(shent-&gt;body != InvalidDsaPointer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* should already have released local reference */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L82" title="utils/activity/pgstat_shmem.c:82">pgStatEntryRefHash</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!pgstat_entry_ref_hash_lookup(<a href="#L82" title="utils/activity/pgstat_shmem.c:82">pgStatEntryRefHash</a>, shent-&gt;key));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Signal that the entry is dropped - this will eventually cause other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backends to release their references.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (shent-&gt;dropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;can only drop stats once&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; shent-&gt;dropped = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* release refcount marking entry as not dropped */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pg_atomic_sub_fetch_u32(&amp;shent-&gt;refcount, <span class="Constant">1</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L749" title="utils/activity/pgstat_shmem.c:749">pgstat_free_entry</a>(shent, hstat);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!hstat)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/dshash.c.html#L558" title="lib/dshash.c:558">dshash_release_lock</a>(<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shared_hash, shent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Drop stats for the database and all the objects inside that database.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L809">&#x200c;</a></span><span class="linkable">pgstat_drop_database_and_contents</span>(Oid dboid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dshash_seq_status hstat;<br/></li>
<li>&nbsp; &nbsp; PgStatShared_HashEntry *p;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; not_freed_count = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(OidIsValid(dboid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shared_hash != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This backend might very well be the only backend holding a reference to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * about-to-be-dropped entries. Ensure that we're not preventing it from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * being cleaned up till later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Doing this separately from the dshash iteration below avoids having to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do so while holding a partition lock on the shared hashtable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L735" title="utils/activity/pgstat_shmem.c:735">pgstat_release_db_entry_refs</a>(dboid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* some of the dshash entries are to be removed, take exclusive lock. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../lib/dshash.c.html#L638" title="lib/dshash.c:638">dshash_seq_init</a>(&amp;hstat, <a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shared_hash, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((p = <a href="../../lib/dshash.c.html#L657" title="lib/dshash.c:657">dshash_seq_next</a>(&amp;hstat)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p-&gt;dropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p-&gt;key.dboid != dboid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L774" title="utils/activity/pgstat_shmem.c:774">pgstat_drop_entry_internal</a>(p, &amp;hstat))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Even statistics for a dropped database might currently be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * accessed (consider e.g. database stats for pg_stat_database).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; not_freed_count++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/dshash.c.html#L747" title="lib/dshash.c:747">dshash_seq_term</a>(&amp;hstat);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If some of the stats data could not be freed, signal the reference<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * holders to run garbage collection of their cached pgStatShmLookupCache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (not_freed_count &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L629" title="utils/activity/pgstat_shmem.c:629">pgstat_request_entry_refs_gc</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L859">&#x200c;</a></span><span class="linkable">pgstat_drop_entry</span>(PgStat_Kind kind, Oid dboid, Oid objoid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PgStat_HashKey key = {.kind = kind,.dboid = dboid,.objoid = objoid};<br/></li>
<li>&nbsp; &nbsp; PgStatShared_HashEntry *shent;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; freed = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* delete local reference */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L82" title="utils/activity/pgstat_shmem.c:82">pgStatEntryRefHash</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L24" title="utils/activity/pgstat_shmem.c:24">PgStat_EntryRefHashEntry</a> *lohashent =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_entry_ref_hash_lookup(<a href="#L82" title="utils/activity/pgstat_shmem.c:82">pgStatEntryRefHash</a>, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lohashent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L522" title="utils/activity/pgstat_shmem.c:522">pgstat_release_entry_ref</a>(lohashent-&gt;key, lohashent-&gt;entry_ref,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* mark entry in shared hashtable as deleted, drop if possible */<br/></li>
<li></span>&nbsp; &nbsp; shent = <a href="../../lib/dshash.c.html#L390" title="lib/dshash.c:390">dshash_find</a>(<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shared_hash, &amp;key, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (shent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freed = <a href="#L774" title="utils/activity/pgstat_shmem.c:774">pgstat_drop_entry_internal</a>(shent, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Database stats contain other stats. Drop those as well when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dropping the database. </span><span class="Todo">XXX</span><span class="Comment">: Perhaps this should be done in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * slightly more principled way? But not obvious what that'd look<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * like, and so far this is the only case...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key.kind == PGSTAT_KIND_DATABASE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L809" title="utils/activity/pgstat_shmem.c:809">pgstat_drop_database_and_contents</a>(key.dboid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> freed;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L896">&#x200c;</a></span><span class="linkable">pgstat_drop_all_entries</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dshash_seq_status hstat;<br/></li>
<li>&nbsp; &nbsp; PgStatShared_HashEntry *ps;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; not_freed_count = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/dshash.c.html#L638" title="lib/dshash.c:638">dshash_seq_init</a>(&amp;hstat, <a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shared_hash, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((ps = <a href="../../lib/dshash.c.html#L657" title="lib/dshash.c:657">dshash_seq_next</a>(&amp;hstat)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ps-&gt;dropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L774" title="utils/activity/pgstat_shmem.c:774">pgstat_drop_entry_internal</a>(ps, &amp;hstat))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; not_freed_count++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/dshash.c.html#L747" title="lib/dshash.c:747">dshash_seq_term</a>(&amp;hstat);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (not_freed_count &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L629" title="utils/activity/pgstat_shmem.c:629">pgstat_request_entry_refs_gc</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L918">&#x200c;</a></span><span class="linkable">shared_stat_reset_contents</span>(PgStat_Kind kind, PgStatShared_Common *header,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimestampTz ts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> PgStat_KindInfo *kind_info = <a href="pgstat.c.html#L1263" title="utils/activity/pgstat.c:1263">pgstat_get_kind_info</a>(kind);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(pgstat_get_entry_data(kind, header), <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pgstat_get_entry_len(kind));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (kind_info-&gt;reset_timestamp_cb)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; kind_info-&gt;reset_timestamp_cb(header, ts);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reset one variable-numbered stats entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L934">&#x200c;</a></span><span class="linkable">pgstat_reset_entry</span>(PgStat_Kind kind, Oid dboid, Oid objoid, TimestampTz ts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PgStat_EntryRef *entry_ref;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="pgstat.c.html#L1263" title="utils/activity/pgstat.c:1263">pgstat_get_kind_info</a>(kind)-&gt;fixed_amount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entry_ref = <a href="#L398" title="utils/activity/pgstat_shmem.c:398">pgstat_get_entry_ref</a>(kind, dboid, objoid, <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!entry_ref || entry_ref-&gt;shared_entry-&gt;dropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L576" title="utils/activity/pgstat_shmem.c:576">pgstat_lock_entry</a>(entry_ref, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L918" title="utils/activity/pgstat_shmem.c:918">shared_stat_reset_contents</a>(kind, entry_ref-&gt;shared_stats, ts);<br/></li>
<li>&nbsp; &nbsp; <a href="#L604" title="utils/activity/pgstat_shmem.c:604">pgstat_unlock_entry</a>(entry_ref);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Scan through the shared hashtable of stats, resetting statistics if<br/></li>
<li></span><span class="Comment"> * approved by the provided do_reset() function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L954">&#x200c;</a></span><span class="linkable">pgstat_reset_matching_entries</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> (*do_reset) (PgStatShared_HashEntry *, Datum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum match_data, TimestampTz ts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dshash_seq_status hstat;<br/></li>
<li>&nbsp; &nbsp; PgStatShared_HashEntry *p;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* dshash entry is not modified, take shared lock */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../lib/dshash.c.html#L638" title="lib/dshash.c:638">dshash_seq_init</a>(&amp;hstat, <a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shared_hash, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((p = <a href="../../lib/dshash.c.html#L657" title="lib/dshash.c:657">dshash_seq_next</a>(&amp;hstat)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PgStatShared_Common *header;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p-&gt;dropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!do_reset(p, match_data))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; header = <a href="../mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.dsa, p-&gt;body);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;header-&gt;lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L918" title="utils/activity/pgstat_shmem.c:918">shared_stat_reset_contents</a>(p-&gt;key.kind, header, ts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;header-&gt;lock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/dshash.c.html#L747" title="lib/dshash.c:747">dshash_seq_term</a>(&amp;hstat);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L984">&#x200c;</a></span><span class="linkable">match_kind</span>(PgStatShared_HashEntry *p, Datum match_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> p-&gt;key.kind == DatumGetInt32(match_data);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L990">&#x200c;</a></span><span class="linkable">pgstat_reset_entries_of_kind</span>(PgStat_Kind kind, TimestampTz ts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L954" title="utils/activity/pgstat_shmem.c:954">pgstat_reset_matching_entries</a>(<a href="#L984" title="utils/activity/pgstat_shmem.c:984">match_kind</a>, Int32GetDatum(kind), ts);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L996">&#x200c;</a></span><span class="linkable">pgstat_setup_memcxt</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(!<a href="#L90" title="utils/activity/pgstat_shmem.c:90">pgStatSharedRefContext</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L90" title="utils/activity/pgstat_shmem.c:90">pgStatSharedRefContext</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;PgStat Shared Ref&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_SMALL_SIZES);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(!<a href="#L91" title="utils/activity/pgstat_shmem.c:91">pgStatEntryRefHashContext</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L91" title="utils/activity/pgstat_shmem.c:91">pgStatEntryRefHashContext</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;PgStat Shared Ref Hash&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_SMALL_SIZES);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
