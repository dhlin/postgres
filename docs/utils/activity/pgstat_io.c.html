<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/activity/pgstat_io.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/activity/pgstat_io.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L31">PendingIOStats</a></li>
<li><a href="#L32">have_iostats</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L24">PgStat_PendingIO</a></li>
<li><a href="#L28">PgStat_PendingIO</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L46">pgstat_bktype_io_stats_valid</a></li>
<li><a href="#L77">pgstat_count_io_op</a></li>
<li><a href="#L83">pgstat_count_io_op_n</a></li>
<li><a href="#L122">pgstat_count_io_op_time</a></li>
<li><a href="#L157">pgstat_fetch_stat_io</a></li>
<li><a href="#L173">pgstat_flush_io</a></li>
<li><a href="#L221">pgstat_get_io_context_name</a></li>
<li><a href="#L240">pgstat_get_io_object_name</a></li>
<li><a href="#L255">pgstat_io_reset_all_cb</a></li>
<li><a href="#L277">pgstat_io_snapshot_cb</a></li>
<li><a href="#L100">pgstat_prepare_io_time</a></li>
<li><a href="#L319">pgstat_tracks_io_bktype</a></li>
<li><a href="#L359">pgstat_tracks_io_object</a></li>
<li><a href="#L424">pgstat_tracks_io_op</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/* -------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * pgstat_io.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Implementation of IO statistics.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This file contains the implementation of IO statistics. It is kept separate<br/></li>
<li></span><span class="Comment"> * from pgstat.c to enforce the line between the statistics access / storage<br/></li>
<li></span><span class="Comment"> * implementation and the details about individual types of statistics.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2021-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/activity/pgstat_io.c<br/></li>
<li></span><span class="Comment"> * -------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;executor/instrument.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pgstat_internal.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L24">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">PgStat_PendingIO</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PgStat_Counter counts[IOOBJECT_NUM_TYPES][IOCONTEXT_NUM_TYPES][IOOP_NUM_TYPES];<br/></li>
<li>&nbsp; &nbsp; instr_time&nbsp; &nbsp; pending_times[IOOBJECT_NUM_TYPES][IOCONTEXT_NUM_TYPES][IOOP_NUM_TYPES];<br/></li>
<li><a id="L28">&#x200c;</a>} <span class="linkable">PgStat_PendingIO</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L31">&#x200c;</a><span class="Type">static</span> <a href="#L24" title="utils/activity/pgstat_io.c:24">PgStat_PendingIO</a> <span class="linkable">PendingIOStats</span>;<br/></li>
<li><a id="L32">&#x200c;</a><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">have_iostats</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check that stats have not been counted for <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> combination of IOObject,<br/></li>
<li></span><span class="Comment"> * IOContext, and IOOp which are not tracked for the passed-in BackendType. If<br/></li>
<li></span><span class="Comment"> * stats are tracked for this combination and IO times are non-zero, counts<br/></li>
<li></span><span class="Comment"> * should be non-zero.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The passed-in PgStat_BktypeIO must contain stats from the BackendType<br/></li>
<li></span><span class="Comment"> * specified by the second parameter. Caller is responsible for locking the<br/></li>
<li></span><span class="Comment"> * passed-in PgStat_BktypeIO, if needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L46">&#x200c;</a></span><span class="linkable">pgstat_bktype_io_stats_valid</span>(PgStat_BktypeIO *backend_io,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BackendType bktype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> io_object = <span class="Constant">0</span>; io_object &lt; IOOBJECT_NUM_TYPES; io_object++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> io_context = <span class="Constant">0</span>; io_context &lt; IOCONTEXT_NUM_TYPES; io_context++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> io_op = <span class="Constant">0</span>; io_op &lt; IOOP_NUM_TYPES; io_op++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we do track it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L424" title="utils/activity/pgstat_io.c:424">pgstat_tracks_io_op</a>(bktype, io_object, io_context, io_op))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ensure that if IO times are non-zero, counts are &gt; 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (backend_io-&gt;times[io_object][io_context][io_op] != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backend_io-&gt;counts[io_object][io_context][io_op] &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we don't track it, and it is not 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (backend_io-&gt;counts[io_object][io_context][io_op] != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L77">&#x200c;</a></span><span class="linkable">pgstat_count_io_op</span>(IOObject io_object, IOContext io_context, IOOp io_op)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="utils/activity/pgstat_io.c:83">pgstat_count_io_op_n</a>(io_object, io_context, io_op, <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L83">&#x200c;</a></span><span class="linkable">pgstat_count_io_op_n</span>(IOObject io_object, IOContext io_context, IOOp io_op, uint32 cnt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert((<span class="Type">unsigned</span> <span class="Type">int</span>) io_object &lt; IOOBJECT_NUM_TYPES);<br/></li>
<li>&nbsp; &nbsp; Assert((<span class="Type">unsigned</span> <span class="Type">int</span>) io_context &lt; IOCONTEXT_NUM_TYPES);<br/></li>
<li>&nbsp; &nbsp; Assert((<span class="Type">unsigned</span> <span class="Type">int</span>) io_op &lt; IOOP_NUM_TYPES);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L424" title="utils/activity/pgstat_io.c:424">pgstat_tracks_io_op</a>(<a href="../init/miscinit.c.html#L63" title="utils/init/miscinit.c:63">MyBackendType</a>, io_object, io_context, io_op));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L31" title="utils/activity/pgstat_io.c:31">PendingIOStats</a>.counts[io_object][io_context][io_op] += cnt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L32" title="utils/activity/pgstat_io.c:32">have_iostats</a> = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize the <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> timing for an IO operation, depending on an<br/></li>
<li></span><span class="Comment"> * IO timing GUC.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>instr_time<br/></li>
<li><a id="L100">&#x200c;</a><span class="linkable">pgstat_prepare_io_time</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> track_io_guc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; instr_time&nbsp; &nbsp; io_start;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (track_io_guc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_CURRENT(io_start);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There is no need to set io_start when an IO timing GUC is disabled,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> it to zero to avoid compiler warnings.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_ZERO(io_start);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> io_start;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Like <a href="#L83" title="utils/activity/pgstat_io.c:83">pgstat_count_io_op_n</a>() except it also accumulates time.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L122">&#x200c;</a></span><span class="linkable">pgstat_count_io_op_time</span>(IOObject io_object, IOContext io_context, IOOp io_op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instr_time start_time, uint32 cnt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/buffer/bufmgr.c.html#L142" title="storage/buffer/bufmgr.c:142">track_io_timing</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instr_time&nbsp; &nbsp; io_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_CURRENT(io_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SUBTRACT(io_time, start_time);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (io_op == IOOP_WRITE || io_op == IOOP_EXTEND)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_count_buffer_write_time(INSTR_TIME_GET_MICROSEC(io_time));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (io_object == IOOBJECT_RELATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_ADD(<a href="../../executor/instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>.shared_blk_write_time, io_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (io_object == IOOBJECT_TEMP_RELATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_ADD(<a href="../../executor/instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>.local_blk_write_time, io_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (io_op == IOOP_READ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_count_buffer_read_time(INSTR_TIME_GET_MICROSEC(io_time));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (io_object == IOOBJECT_RELATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_ADD(<a href="../../executor/instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>.shared_blk_read_time, io_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (io_object == IOOBJECT_TEMP_RELATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_ADD(<a href="../../executor/instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>.local_blk_read_time, io_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_ADD(<a href="#L31" title="utils/activity/pgstat_io.c:31">PendingIOStats</a>.pending_times[io_object][io_context][io_op],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; io_time);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="utils/activity/pgstat_io.c:83">pgstat_count_io_op_n</a>(io_object, io_context, io_op, cnt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>PgStat_IO *<br/></li>
<li><a id="L157">&#x200c;</a><span class="linkable">pgstat_fetch_stat_io</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="pgstat.c.html#L938" title="utils/activity/pgstat.c:938">pgstat_snapshot_fixed</a>(PGSTAT_KIND_IO);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> &amp;<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.snapshot.io;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Flush out locally pending IO statistics<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If no stats have been recorded, this function returns false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If nowait is true, this function returns true if the lock could not be<br/></li>
<li></span><span class="Comment"> * acquired. Otherwise, return false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L173">&#x200c;</a></span><span class="linkable">pgstat_flush_io</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nowait)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *bktype_lock;<br/></li>
<li>&nbsp; &nbsp; PgStat_BktypeIO *bktype_shstats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L32" title="utils/activity/pgstat_io.c:32">have_iostats</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bktype_lock = &amp;<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shmem-&gt;io.locks[<a href="../init/miscinit.c.html#L63" title="utils/init/miscinit.c:63">MyBackendType</a>];<br/></li>
<li>&nbsp; &nbsp; bktype_shstats =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shmem-&gt;io.stats.stats[<a href="../init/miscinit.c.html#L63" title="utils/init/miscinit.c:63">MyBackendType</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!nowait)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(bktype_lock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="../../storage/lmgr/lwlock.c.html#L1341" title="storage/lmgr/lwlock.c:1341">LWLockConditionalAcquire</a>(bktype_lock, LW_EXCLUSIVE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> io_object = <span class="Constant">0</span>; io_object &lt; IOOBJECT_NUM_TYPES; io_object++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> io_context = <span class="Constant">0</span>; io_context &lt; IOCONTEXT_NUM_TYPES; io_context++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> io_op = <span class="Constant">0</span>; io_op &lt; IOOP_NUM_TYPES; io_op++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instr_time&nbsp; &nbsp; time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bktype_shstats-&gt;counts[io_object][io_context][io_op] +=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L31" title="utils/activity/pgstat_io.c:31">PendingIOStats</a>.counts[io_object][io_context][io_op];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; time = <a href="#L31" title="utils/activity/pgstat_io.c:31">PendingIOStats</a>.pending_times[io_object][io_context][io_op];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bktype_shstats-&gt;times[io_object][io_context][io_op] +=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_GET_MICROSEC(time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L46" title="utils/activity/pgstat_io.c:46">pgstat_bktype_io_stats_valid</a>(bktype_shstats, <a href="../init/miscinit.c.html#L63" title="utils/init/miscinit.c:63">MyBackendType</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(bktype_lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;<a href="#L31" title="utils/activity/pgstat_io.c:31">PendingIOStats</a>, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L31" title="utils/activity/pgstat_io.c:31">PendingIOStats</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L32" title="utils/activity/pgstat_io.c:32">have_iostats</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L221">&#x200c;</a><span class="linkable">pgstat_get_io_context_name</span>(IOContext io_context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (io_context)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IOCONTEXT_BULKREAD:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;bulkread&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IOCONTEXT_BULKWRITE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;bulkwrite&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IOCONTEXT_NORMAL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;normal&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IOCONTEXT_VACUUM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;<a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized IOContext value: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, io_context);<br/></li>
<li>&nbsp; &nbsp; pg_unreachable();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L240">&#x200c;</a><span class="linkable">pgstat_get_io_object_name</span>(IOObject io_object)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (io_object)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IOOBJECT_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;relation&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> IOOBJECT_TEMP_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;temp relation&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized IOObject value: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, io_object);<br/></li>
<li>&nbsp; &nbsp; pg_unreachable();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L255">&#x200c;</a></span><span class="linkable">pgstat_io_reset_all_cb</span>(TimestampTz ts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; BACKEND_NUM_TYPES; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *bktype_lock = &amp;<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shmem-&gt;io.locks[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PgStat_BktypeIO *bktype_shstats = &amp;<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shmem-&gt;io.stats.stats[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(bktype_lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use the lock in the first BackendType's PgStat_BktypeIO to protect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the reset timestamp as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shmem-&gt;io.stats.stat_reset_timestamp = ts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(bktype_shstats, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*bktype_shstats));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(bktype_lock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L277">&#x200c;</a></span><span class="linkable">pgstat_io_snapshot_cb</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; BACKEND_NUM_TYPES; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *bktype_lock = &amp;<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shmem-&gt;io.locks[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PgStat_BktypeIO *bktype_shstats = &amp;<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shmem-&gt;io.stats.stats[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PgStat_BktypeIO *bktype_snap = &amp;<a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.snapshot.io.stats[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(bktype_lock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use the lock in the first BackendType's PgStat_BktypeIO to protect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the reset timestamp as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.snapshot.io.stat_reset_timestamp =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="pgstat.c.html#L193" title="utils/activity/pgstat.c:193">pgStatLocal</a>.shmem-&gt;io.stats.stat_reset_timestamp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* using struct assignment due to better type safety */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *bktype_snap = *bktype_shstats;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(bktype_lock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">* IO statistics are not collected for all BackendTypes.<br/></li>
<li></span><span class="Comment">*<br/></li>
<li></span><span class="Comment">* The following BackendTypes do not participate in the cumulative stats<br/></li>
<li></span><span class="Comment">* subsystem or do not perform IO on which we currently track:<br/></li>
<li></span><span class="Comment">* - Syslogger because it is not connected to shared memory<br/></li>
<li></span><span class="Comment">* - Archiver because most relevant archiving IO is delegated to a<br/></li>
<li></span><span class="Comment">*&nbsp;&nbsp; specialized command or module<br/></li>
<li></span><span class="Comment">* - WAL Receiver, WAL Writer, and WAL Summarizer IO are not tracked in<br/></li>
<li></span><span class="Comment">*&nbsp;&nbsp; pg_stat_io for <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment">*<br/></li>
<li></span><span class="Comment">* Function returns true if BackendType participates in the cumulative stats<br/></li>
<li></span><span class="Comment">* subsystem for IO and false if it does not.<br/></li>
<li></span><span class="Comment">*<br/></li>
<li></span><span class="Comment">* When adding a new BackendType, also consider adding relevant restrictions to<br/></li>
<li></span><span class="Comment">* <a href="#L359" title="utils/activity/pgstat_io.c:359">pgstat_tracks_io_object</a>() and <a href="#L424" title="utils/activity/pgstat_io.c:424">pgstat_tracks_io_op</a>().<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L319">&#x200c;</a></span><span class="linkable">pgstat_tracks_io_bktype</span>(BackendType bktype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * List every type so that new backend types <a href="../adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> a warning about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needing to adjust this switch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (bktype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_INVALID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_ARCHIVER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_LOGGER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_WAL_RECEIVER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_WAL_WRITER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_WAL_SUMMARIZER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_AUTOVAC_LAUNCHER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_AUTOVAC_WORKER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_BACKEND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_BG_WORKER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_BG_WRITER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_CHECKPOINTER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_SLOTSYNC_WORKER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_STANDALONE_BACKEND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_STARTUP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_WAL_SENDER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Some BackendTypes do not perform IO on certain IOObjects or in certain<br/></li>
<li></span><span class="Comment"> * IOContexts. Some IOObjects are never operated on in some IOContexts. Check<br/></li>
<li></span><span class="Comment"> * that the given BackendType is expected to do IO in the given IOContext and<br/></li>
<li></span><span class="Comment"> * on the given IOObject and that the given IOObject is expected to be operated<br/></li>
<li></span><span class="Comment"> * on in the given IOContext.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L359">&#x200c;</a></span><span class="linkable">pgstat_tracks_io_object</span>(BackendType bktype, IOObject io_object,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IOContext io_context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; no_temp_rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Some BackendTypes should never track IO statistics.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L319" title="utils/activity/pgstat_io.c:319">pgstat_tracks_io_bktype</a>(bktype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Currently, IO on temporary relations can only occur in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * IOCONTEXT_NORMAL IOContext.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (io_context != IOCONTEXT_NORMAL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; io_object == IOOBJECT_TEMP_RELATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In core Postgres, only regular backends and WAL Sender processes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * executing queries will use local buffers and operate on temporary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relations. Parallel workers will not use local buffers (see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/buffer/localbuf.c.html#L580" title="storage/buffer/localbuf.c:580">InitLocalBuffers</a>()); however, extensions leveraging background workers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have no such limitation, so track IO on IOOBJECT_TEMP_RELATION for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * BackendType B_BG_WORKER.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; no_temp_rel = bktype == B_AUTOVAC_LAUNCHER || bktype == B_BG_WRITER ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bktype == B_CHECKPOINTER || bktype == B_AUTOVAC_WORKER ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bktype == B_STANDALONE_BACKEND || bktype == B_STARTUP;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (no_temp_rel &amp;&amp; io_context == IOCONTEXT_NORMAL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; io_object == IOOBJECT_TEMP_RELATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Some BackendTypes do not currently perform <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> IO in certain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * IOContexts, and, while it may not be inherently incorrect for them to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do so, excluding those rows from the view makes the view easier to use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((bktype == B_CHECKPOINTER || bktype == B_BG_WRITER) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (io_context == IOCONTEXT_BULKREAD ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; io_context == IOCONTEXT_BULKWRITE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; io_context == IOCONTEXT_VACUUM))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bktype == B_AUTOVAC_LAUNCHER &amp;&amp; io_context == IOCONTEXT_VACUUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((bktype == B_AUTOVAC_WORKER || bktype == B_AUTOVAC_LAUNCHER) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; io_context == IOCONTEXT_BULKWRITE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Some BackendTypes will never do certain IOOps and some IOOps should not<br/></li>
<li></span><span class="Comment"> * occur in certain IOContexts or on certain IOObjects. Check that the given<br/></li>
<li></span><span class="Comment"> * IOOp is valid for the given BackendType in the given IOContext and on the<br/></li>
<li></span><span class="Comment"> * given IOObject. Note that there are currently no cases of an IOOp being<br/></li>
<li></span><span class="Comment"> * invalid for a particular BackendType only within a certain IOContext and/or<br/></li>
<li></span><span class="Comment"> * only on a certain IOObject.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L424">&#x200c;</a></span><span class="linkable">pgstat_tracks_io_op</span>(BackendType bktype, IOObject io_object,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IOContext io_context, IOOp io_op)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; strategy_io_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if (io_context, io_object) will never collect stats, we're done */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L359" title="utils/activity/pgstat_io.c:359">pgstat_tracks_io_object</a>(bktype, io_object, io_context))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Some BackendTypes will not do certain IOOps.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((bktype == B_BG_WRITER || bktype == B_CHECKPOINTER) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (io_op == IOOP_READ || io_op == IOOP_EVICT || io_op == IOOP_HIT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((bktype == B_AUTOVAC_LAUNCHER || bktype == B_BG_WRITER ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bktype == B_CHECKPOINTER) &amp;&amp; io_op == IOOP_EXTEND)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Temporary tables are not logged and thus do not require fsync'ing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Writeback is not requested for temporary tables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (io_object == IOOBJECT_TEMP_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (io_op == IOOP_FSYNC || io_op == IOOP_WRITEBACK))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Some IOOps are not valid in certain IOContexts and some IOOps are only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * valid in certain contexts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (io_context == IOCONTEXT_BULKREAD &amp;&amp; io_op == IOOP_EXTEND)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; strategy_io_context = io_context == IOCONTEXT_BULKREAD ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; io_context == IOCONTEXT_BULKWRITE || io_context == IOCONTEXT_VACUUM;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * IOOP_REUSE is only relevant when a BufferAccessStrategy is in use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!strategy_io_context &amp;&amp; io_op == IOOP_REUSE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * IOOP_FSYNC IOOps done by a backend using a BufferAccessStrategy are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * counted in the IOCONTEXT_NORMAL IOContext. See comment in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/smgr/md.c.html#L1353" title="storage/smgr/md.c:1353">register_dirty_segment</a>() for more details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strategy_io_context &amp;&amp; io_op == IOOP_FSYNC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
