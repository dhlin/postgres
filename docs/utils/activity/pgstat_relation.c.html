<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/activity/pgstat_relation.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/activity/pgstat_relation.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L31">TwoPhasePgStatRecord</a></li>
<li><a href="#L43">TwoPhasePgStatRecord</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L595">AtEOSubXact_PgStat_Relations</a></li>
<li><a href="#L537">AtEOXact_PgStat_Relations</a></li>
<li><a href="#L676">AtPrepare_PgStat_Relations</a></li>
<li><a href="#L714">PostPrepare_PgStat_Relations</a></li>
<li><a href="#L917">add_tabstat_xact_level</a></li>
<li><a href="#L944">ensure_tabstat_xact_level</a></li>
<li><a href="#L487">find_tabstat_entry</a></li>
<li><a href="#L132">pgstat_assoc_relation</a></li>
<li><a href="#L58">pgstat_copy_relation_stats</a></li>
<li><a href="#L401">pgstat_count_heap_delete</a></li>
<li><a href="#L360">pgstat_count_heap_insert</a></li>
<li><a href="#L375">pgstat_count_heap_update</a></li>
<li><a href="#L416">pgstat_count_truncate</a></li>
<li><a href="#L169">pgstat_create_relation</a></li>
<li><a href="#L180">pgstat_drop_relation</a></li>
<li><a href="#L456">pgstat_fetch_stat_tabentry</a></li>
<li><a href="#L466">pgstat_fetch_stat_tabentry_ext</a></li>
<li><a href="#L92">pgstat_init_relation</a></li>
<li><a href="#L898">pgstat_prep_relation_pending</a></li>
<li><a href="#L885">pgstat_relation_delete_pending_cb</a></li>
<li><a href="#L802">pgstat_relation_flush_cb</a></li>
<li><a href="#L277">pgstat_report_analyze</a></li>
<li><a href="#L211">pgstat_report_vacuum</a></li>
<li><a href="#L769">pgstat_twophase_postabort</a></li>
<li><a href="#L733">pgstat_twophase_postcommit</a></li>
<li><a href="#L153">pgstat_unlink_relation</a></li>
<li><a href="#L439">pgstat_update_heap_dead_tuples</a></li>
<li><a href="#L978">restore_truncdrop_counters</a></li>
<li><a href="#L963">save_truncdrop_counters</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/* -------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * pgstat_relation.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Implementation of relation statistics.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This file contains the implementation of function relation. It is kept<br/></li>
<li></span><span class="Comment"> * separate from pgstat.c to enforce the line between the statistics access /<br/></li>
<li></span><span class="Comment"> * storage implementation and the details about individual types of<br/></li>
<li></span><span class="Comment"> * statistics.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2001-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/activity/pgstat_relation.c<br/></li>
<li></span><span class="Comment"> * -------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/twophase_rmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/catalog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/autovacuum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pgstat_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* Record that's written to 2PC state file when pgstat state is persisted */<br/></li>
<li><a id="L31">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">TwoPhasePgStatRecord</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PgStat_Counter tuples_inserted; <span class="Comment">/* tuples inserted in xact */<br/></li>
<li></span>&nbsp; &nbsp; PgStat_Counter tuples_updated;&nbsp; &nbsp; <span class="Comment">/* tuples updated in xact */<br/></li>
<li></span>&nbsp; &nbsp; PgStat_Counter tuples_deleted;&nbsp; &nbsp; <span class="Comment">/* tuples deleted in xact */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* tuples i/u/d prior to truncate/drop */<br/></li>
<li></span>&nbsp; &nbsp; PgStat_Counter inserted_pre_truncdrop;<br/></li>
<li>&nbsp; &nbsp; PgStat_Counter updated_pre_truncdrop;<br/></li>
<li>&nbsp; &nbsp; PgStat_Counter deleted_pre_truncdrop;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; id;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* table's OID */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; shared;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* is it a shared catalog? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; truncdropped;&nbsp; &nbsp; <span class="Comment">/* was the relation truncated/dropped? */<br/></li>
<li><a id="L43">&#x200c;</a></span>} <span class="linkable">TwoPhasePgStatRecord</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> PgStat_TableStatus *<a href="#L898" title="utils/activity/pgstat_relation.c:898">pgstat_prep_relation_pending</a>(Oid rel_id, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isshared);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L917" title="utils/activity/pgstat_relation.c:917">add_tabstat_xact_level</a>(PgStat_TableStatus *pgstat_info, <span class="Type">int</span> nest_level);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L944" title="utils/activity/pgstat_relation.c:944">ensure_tabstat_xact_level</a>(PgStat_TableStatus *pgstat_info);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L963" title="utils/activity/pgstat_relation.c:963">save_truncdrop_counters</a>(PgStat_TableXactStatus *trans, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_drop);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L978" title="utils/activity/pgstat_relation.c:978">restore_truncdrop_counters</a>(PgStat_TableXactStatus *trans);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copy stats between relations. This is used for things like REINDEX<br/></li>
<li></span><span class="Comment"> * CONCURRENTLY.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L58">&#x200c;</a></span><span class="linkable">pgstat_copy_relation_stats</span>(Relation dst, Relation src)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PgStat_StatTabEntry *srcstats;<br/></li>
<li>&nbsp; &nbsp; PgStatShared_Relation *dstshstats;<br/></li>
<li>&nbsp; &nbsp; PgStat_EntryRef *dst_ref;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; srcstats = <a href="#L466" title="utils/activity/pgstat_relation.c:466">pgstat_fetch_stat_tabentry_ext</a>(src-&gt;rd_rel-&gt;relisshared,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(src));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!srcstats)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dst_ref = <a href="pgstat_shmem.c.html#L613" title="utils/activity/pgstat_shmem.c:613">pgstat_get_entry_ref_locked</a>(PGSTAT_KIND_RELATION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dst-&gt;rd_rel-&gt;relisshared ? InvalidOid : <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(dst),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dstshstats = (PgStatShared_Relation *) dst_ref-&gt;shared_stats;<br/></li>
<li>&nbsp; &nbsp; dstshstats-&gt;stats = *srcstats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="pgstat_shmem.c.html#L604" title="utils/activity/pgstat_shmem.c:604">pgstat_unlock_entry</a>(dst_ref);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize a relcache entry to count access statistics.&nbsp; Called whenever a<br/></li>
<li></span><span class="Comment"> * relation is opened.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume that a relcache entry's pgstat_info field is zeroed by relcache.c<br/></li>
<li></span><span class="Comment"> * when the relcache entry is made; thereafter it is long-lived data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This does not create a reference to a stats entry in shared memory, nor<br/></li>
<li></span><span class="Comment"> * allocate memory for the pending stats. That happens in<br/></li>
<li></span><span class="Comment"> * <a href="#L132" title="utils/activity/pgstat_relation.c:132">pgstat_assoc_relation</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L92">&#x200c;</a></span><span class="linkable">pgstat_init_relation</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; relkind = rel-&gt;rd_rel-&gt;relkind;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We only count stats for relations with storage and partitioned tables<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!RELKIND_HAS_STORAGE(relkind) &amp;&amp; relkind != RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;pgstat_enabled = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;pgstat_info = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="pgstat.c.html#L184" title="utils/activity/pgstat.c:184">pgstat_track_counts</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;pgstat_info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L153" title="utils/activity/pgstat_relation.c:153">pgstat_unlink_relation</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We're not counting at all */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;pgstat_enabled = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;pgstat_info = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel-&gt;pgstat_enabled = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare for statistics for this relation to be collected.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This ensures we have a reference to the stats entry <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> stats can be<br/></li>
<li></span><span class="Comment"> * generated. That is important because a relation drop in another connection<br/></li>
<li></span><span class="Comment"> * could otherwise lead to the stats entry being dropped, which then later<br/></li>
<li></span><span class="Comment"> * would get recreated when flushing stats.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is separate from <a href="#L92" title="utils/activity/pgstat_relation.c:92">pgstat_init_relation</a>() as it is not uncommon for<br/></li>
<li></span><span class="Comment"> * relcache entries to be opened without ever getting stats reported.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L132">&#x200c;</a></span><span class="linkable">pgstat_assoc_relation</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(rel-&gt;pgstat_enabled);<br/></li>
<li>&nbsp; &nbsp; Assert(rel-&gt;pgstat_info == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> or make the PgStat_TableStatus entry, and update link */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;pgstat_info = <a href="#L898" title="utils/activity/pgstat_relation.c:898">pgstat_prep_relation_pending</a>(RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relisshared);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't allow link a stats to multiple relcache entries */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rel-&gt;pgstat_info-&gt;relation == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* mark this relation as the owner */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;pgstat_info-&gt;relation = rel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Break the mutual link between a relcache entry and pending stats entry.<br/></li>
<li></span><span class="Comment"> * This must be called whenever one end of the link is removed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L153">&#x200c;</a></span><span class="linkable">pgstat_unlink_relation</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remove the link to stats info if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;pgstat_info == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* link sanity check */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rel-&gt;pgstat_info-&gt;relation == rel);<br/></li>
<li>&nbsp; &nbsp; rel-&gt;pgstat_info-&gt;relation = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;pgstat_info = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Ensure that stats are dropped if transaction aborts.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L169">&#x200c;</a></span><span class="linkable">pgstat_create_relation</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="pgstat_xact.c.html#L357" title="utils/activity/pgstat_xact.c:357">pgstat_create_transactional</a>(PGSTAT_KIND_RELATION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relisshared ? InvalidOid : <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Ensure that stats are dropped if transaction commits.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L180">&#x200c;</a></span><span class="linkable">pgstat_drop_relation</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nest_level = <a href="../../access/transam/xact.c.html#L926" title="access/transam/xact.c:926">GetCurrentTransactionNestLevel</a>();<br/></li>
<li>&nbsp; &nbsp; PgStat_TableStatus *pgstat_info;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="pgstat_xact.c.html#L379" title="utils/activity/pgstat_xact.c:379">pgstat_drop_transactional</a>(PGSTAT_KIND_RELATION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relisshared ? InvalidOid : <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!pgstat_should_count_relation(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Transactionally set counters to 0. That ensures that accesses to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_stat_xact_all_tables inside the transaction show 0.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pgstat_info = rel-&gt;pgstat_info;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pgstat_info-&gt;trans &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_info-&gt;trans-&gt;nest_level == nest_level)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L963" title="utils/activity/pgstat_relation.c:963">save_truncdrop_counters</a>(pgstat_info-&gt;trans, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_info-&gt;trans-&gt;tuples_inserted = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_info-&gt;trans-&gt;tuples_updated = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_info-&gt;trans-&gt;tuples_deleted = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Report that the table was just vacuumed and flush IO statistics.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L211">&#x200c;</a></span><span class="linkable">pgstat_report_vacuum</span>(Oid tableoid, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> shared,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PgStat_Counter livetuples, PgStat_Counter deadtuples)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PgStat_EntryRef *entry_ref;<br/></li>
<li>&nbsp; &nbsp; PgStatShared_Relation *shtabentry;<br/></li>
<li>&nbsp; &nbsp; PgStat_StatTabEntry *tabentry;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dboid = (shared ? InvalidOid : <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz ts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="pgstat.c.html#L184" title="utils/activity/pgstat.c:184">pgstat_track_counts</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store the data in the table's <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table entry. */<br/></li>
<li></span>&nbsp; &nbsp; ts = <a href="../adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* block acquiring lock for the same reason as <a href="pgstat_database.c.html#L55" title="utils/activity/pgstat_database.c:55">pgstat_report_autovac</a>() */<br/></li>
<li></span>&nbsp; &nbsp; entry_ref = <a href="pgstat_shmem.c.html#L613" title="utils/activity/pgstat_shmem.c:613">pgstat_get_entry_ref_locked</a>(PGSTAT_KIND_RELATION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dboid, tableoid, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; shtabentry = (PgStatShared_Relation *) entry_ref-&gt;shared_stats;<br/></li>
<li>&nbsp; &nbsp; tabentry = &amp;shtabentry-&gt;stats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tabentry-&gt;live_tuples = livetuples;<br/></li>
<li>&nbsp; &nbsp; tabentry-&gt;dead_tuples = deadtuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is quite possible that a non-aggressive VACUUM ended up skipping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * various pages, however, we'll zero the insert counter here regardless.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's currently used only to track when we need to perform an &quot;insert&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * autovacuum, which are mainly intended to freeze newly inserted tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Zeroing this may just mean we'll not try to <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> the table again<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * until enough tuples have been inserted to <a href="../adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> another insert<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * autovacuum.&nbsp; An anti-wraparound autovacuum will catch <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> persistent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stragglers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tabentry-&gt;ins_since_vacuum = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (AmAutoVacuumWorkerProcess())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tabentry-&gt;last_autovacuum_time = ts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tabentry-&gt;autovacuum_count++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tabentry-&gt;last_vacuum_time = ts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tabentry-&gt;vacuum_count++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="pgstat_shmem.c.html#L604" title="utils/activity/pgstat_shmem.c:604">pgstat_unlock_entry</a>(entry_ref);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Flush IO statistics <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. <a href="pgstat.c.html#L579" title="utils/activity/pgstat.c:579">pgstat_report_stat</a>() will flush IO stats,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * however this will not be called until after an entire autovacuum cycle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is done -- which will likely <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> many relations -- or until the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * VACUUM command has processed all tables and committed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="pgstat_io.c.html#L173" title="utils/activity/pgstat_io.c:173">pgstat_flush_io</a>(<span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Report that the table was just analyzed and flush IO statistics.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must provide new live- and dead-tuples estimates, as well as a<br/></li>
<li></span><span class="Comment"> * flag indicating whether to reset the mod_since_analyze counter.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L277">&#x200c;</a></span><span class="linkable">pgstat_report_analyze</span>(Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PgStat_Counter livetuples, PgStat_Counter deadtuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> resetcounter)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PgStat_EntryRef *entry_ref;<br/></li>
<li>&nbsp; &nbsp; PgStatShared_Relation *shtabentry;<br/></li>
<li>&nbsp; &nbsp; PgStat_StatTabEntry *tabentry;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dboid = (rel-&gt;rd_rel-&gt;relisshared ? InvalidOid : <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="pgstat.c.html#L184" title="utils/activity/pgstat.c:184">pgstat_track_counts</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unlike VACUUM, ANALYZE might be running inside a transaction that has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already inserted and/or deleted rows in the target table. ANALYZE will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have counted such rows as live or dead respectively. Because we will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * report our counts of such rows at transaction end, we should subtract<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * off these counts from the update we're making <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, else they'll be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * double-counted after commit.&nbsp; (This approach also ensures that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared stats entry ends up with the right numbers if we abort instead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of committing.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Waste no time on partitioned tables, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pgstat_should_count_relation(rel) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relkind != RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PgStat_TableXactStatus *trans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (trans = rel-&gt;pgstat_info-&gt;trans; trans; trans = trans-&gt;<a href="../adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; livetuples -= trans-&gt;tuples_inserted - trans-&gt;tuples_deleted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deadtuples -= trans-&gt;tuples_updated + trans-&gt;tuples_deleted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* count stuff inserted by already-aborted subxacts, too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; deadtuples -= rel-&gt;pgstat_info-&gt;counts.delta_dead_tuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Since ANALYZE's counts are estimates, we could have underflowed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; livetuples = Max(livetuples, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; deadtuples = Max(deadtuples, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* block acquiring lock for the same reason as <a href="pgstat_database.c.html#L55" title="utils/activity/pgstat_database.c:55">pgstat_report_autovac</a>() */<br/></li>
<li></span>&nbsp; &nbsp; entry_ref = <a href="pgstat_shmem.c.html#L613" title="utils/activity/pgstat_shmem.c:613">pgstat_get_entry_ref_locked</a>(PGSTAT_KIND_RELATION, dboid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* can't get dropped while accessed */<br/></li>
<li></span>&nbsp; &nbsp; Assert(entry_ref != <span class="Constant">NULL</span> &amp;&amp; entry_ref-&gt;shared_stats != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; shtabentry = (PgStatShared_Relation *) entry_ref-&gt;shared_stats;<br/></li>
<li>&nbsp; &nbsp; tabentry = &amp;shtabentry-&gt;stats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tabentry-&gt;live_tuples = livetuples;<br/></li>
<li>&nbsp; &nbsp; tabentry-&gt;dead_tuples = deadtuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If commanded, reset mod_since_analyze to zero.&nbsp; This forgets <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * changes that were committed while the ANALYZE was in progress, but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have no good way to estimate how many of those there were.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (resetcounter)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tabentry-&gt;mod_since_analyze = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (AmAutoVacuumWorkerProcess())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tabentry-&gt;last_autoanalyze_time = <a href="../adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tabentry-&gt;autoanalyze_count++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tabentry-&gt;last_analyze_time = <a href="../adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tabentry-&gt;analyze_count++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="pgstat_shmem.c.html#L604" title="utils/activity/pgstat_shmem.c:604">pgstat_unlock_entry</a>(entry_ref);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* see <a href="#L211" title="utils/activity/pgstat_relation.c:211">pgstat_report_vacuum</a>() */<br/></li>
<li></span>&nbsp; &nbsp; <a href="pgstat_io.c.html#L173" title="utils/activity/pgstat_io.c:173">pgstat_flush_io</a>(<span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * count a tuple insertion of n tuples<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L360">&#x200c;</a></span><span class="linkable">pgstat_count_heap_insert</span>(Relation rel, PgStat_Counter n)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pgstat_should_count_relation(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PgStat_TableStatus *pgstat_info = rel-&gt;pgstat_info;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L944" title="utils/activity/pgstat_relation.c:944">ensure_tabstat_xact_level</a>(pgstat_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_info-&gt;trans-&gt;tuples_inserted += n;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * count a tuple update<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L375">&#x200c;</a></span><span class="linkable">pgstat_count_heap_update</span>(Relation rel, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> hot, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> newpage)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!(hot &amp;&amp; newpage));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pgstat_should_count_relation(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PgStat_TableStatus *pgstat_info = rel-&gt;pgstat_info;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L944" title="utils/activity/pgstat_relation.c:944">ensure_tabstat_xact_level</a>(pgstat_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_info-&gt;trans-&gt;tuples_updated++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples_hot_updated and tuples_newpage_updated counters are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nontransactional, so just advance them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_info-&gt;counts.tuples_hot_updated++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (newpage)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_info-&gt;counts.tuples_newpage_updated++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * count a tuple deletion<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L401">&#x200c;</a></span><span class="linkable">pgstat_count_heap_delete</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pgstat_should_count_relation(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PgStat_TableStatus *pgstat_info = rel-&gt;pgstat_info;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L944" title="utils/activity/pgstat_relation.c:944">ensure_tabstat_xact_level</a>(pgstat_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_info-&gt;trans-&gt;tuples_deleted++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * update tuple counters due to truncate<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L416">&#x200c;</a></span><span class="linkable">pgstat_count_truncate</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pgstat_should_count_relation(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PgStat_TableStatus *pgstat_info = rel-&gt;pgstat_info;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L944" title="utils/activity/pgstat_relation.c:944">ensure_tabstat_xact_level</a>(pgstat_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L963" title="utils/activity/pgstat_relation.c:963">save_truncdrop_counters</a>(pgstat_info-&gt;trans, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_info-&gt;trans-&gt;tuples_inserted = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_info-&gt;trans-&gt;tuples_updated = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_info-&gt;trans-&gt;tuples_deleted = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * update dead-tuples count<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The semantics of this are that we are reporting the nontransactional<br/></li>
<li></span><span class="Comment"> * recovery of &quot;delta&quot; dead tuples; so delta_dead_tuples decreases<br/></li>
<li></span><span class="Comment"> * rather than increasing, and the change goes straight into the per-table<br/></li>
<li></span><span class="Comment"> * counter, not into transactional state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L439">&#x200c;</a></span><span class="linkable">pgstat_update_heap_dead_tuples</span>(Relation rel, <span class="Type">int</span> delta)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pgstat_should_count_relation(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PgStat_TableStatus *pgstat_info = rel-&gt;pgstat_info;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_info-&gt;counts.delta_dead_tuples -= delta;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Support function for the SQL-callable pgstat* <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>. Returns<br/></li>
<li></span><span class="Comment"> * the collected statistics for one table or NULL. NULL doesn't mean<br/></li>
<li></span><span class="Comment"> * that the table doesn't exist, just that there are no statistics, so the<br/></li>
<li></span><span class="Comment"> * caller is better off to report ZERO instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PgStat_StatTabEntry *<br/></li>
<li><a id="L456">&#x200c;</a><span class="linkable">pgstat_fetch_stat_tabentry</span>(Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L466" title="utils/activity/pgstat_relation.c:466">pgstat_fetch_stat_tabentry_ext</a>(<a href="../../catalog/catalog.c.html#L243" title="catalog/catalog.c:243">IsSharedRelation</a>(relid), relid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * More efficient version of <a href="#L456" title="utils/activity/pgstat_relation.c:456">pgstat_fetch_stat_tabentry</a>(), allowing to specify<br/></li>
<li></span><span class="Comment"> * whether the to-be-accessed table is a shared relation or not.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PgStat_StatTabEntry *<br/></li>
<li><a id="L466">&#x200c;</a><span class="linkable">pgstat_fetch_stat_tabentry_ext</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> shared, Oid reloid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dboid = (shared ? InvalidOid : <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (PgStat_StatTabEntry *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="pgstat.c.html#L812" title="utils/activity/pgstat.c:812">pgstat_fetch_entry</a>(PGSTAT_KIND_RELATION, dboid, reloid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing PgStat_TableStatus entry for rel<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Find <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing PgStat_TableStatus entry for rel_id in the current<br/></li>
<li></span><span class="Comment"> * database. If not found, try finding from shared tables.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If an entry is found, copy it and increment the copy's counters with their<br/></li>
<li></span><span class="Comment"> * subtransaction counterparts, then return the copy.&nbsp; The caller may need to<br/></li>
<li></span><span class="Comment"> * <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>() the copy.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If no entry found, return NULL, don't create a new one.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PgStat_TableStatus *<br/></li>
<li><a id="L487">&#x200c;</a><span class="linkable">find_tabstat_entry</span>(Oid rel_id)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PgStat_EntryRef *entry_ref;<br/></li>
<li>&nbsp; &nbsp; PgStat_TableXactStatus *trans;<br/></li>
<li>&nbsp; &nbsp; PgStat_TableStatus *tabentry = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; PgStat_TableStatus *tablestatus = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entry_ref = <a href="pgstat.c.html#L1143" title="utils/activity/pgstat.c:1143">pgstat_fetch_pending_entry</a>(PGSTAT_KIND_RELATION, <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>, rel_id);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!entry_ref)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry_ref = <a href="pgstat.c.html#L1143" title="utils/activity/pgstat.c:1143">pgstat_fetch_pending_entry</a>(PGSTAT_KIND_RELATION, InvalidOid, rel_id);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!entry_ref)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> tablestatus;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tabentry = (PgStat_TableStatus *) entry_ref-&gt;pending;<br/></li>
<li>&nbsp; &nbsp; tablestatus = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PgStat_TableStatus));<br/></li>
<li>&nbsp; &nbsp; *tablestatus = *tabentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset tablestatus-&gt;trans in the copy of PgStat_TableStatus as it may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * point to a shared memory area.&nbsp; Its data is saved below, so removing it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * does not matter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tablestatus-&gt;trans = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Live subtransaction counts are not included yet.&nbsp; This is not a hot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * code path so reconcile tuples_inserted, tuples_updated and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuples_deleted even if the caller may not be interested in this data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (trans = tabentry-&gt;trans; trans != <span class="Constant">NULL</span>; trans = trans-&gt;<a href="../adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tablestatus-&gt;counts.tuples_inserted += trans-&gt;tuples_inserted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tablestatus-&gt;counts.tuples_updated += trans-&gt;tuples_updated;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tablestatus-&gt;counts.tuples_deleted += trans-&gt;tuples_deleted;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tablestatus;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform relation stats specific end-of-transaction work. Helper for<br/></li>
<li></span><span class="Comment"> * <a href="pgstat_xact.c.html#L40" title="utils/activity/pgstat_xact.c:40">AtEOXact_PgStat</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Transfer transactional insert/update counts into the base tabstat entries.<br/></li>
<li></span><span class="Comment"> * We don't bother to free <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the transactional state, since it's all in<br/></li>
<li></span><span class="Comment"> * <a href="../mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a> and will go away anyway.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L537">&#x200c;</a></span><span class="linkable">AtEOXact_PgStat_Relations</span>(PgStat_SubXactStatus *xact_state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PgStat_TableXactStatus *trans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (trans = xact_state-&gt;first; trans != <span class="Constant">NULL</span>; trans = trans-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PgStat_TableStatus *tabstat;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(trans-&gt;nest_level == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(trans-&gt;<a href="../adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tabstat = trans-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(tabstat-&gt;trans == trans);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* restore pre-truncate/drop stats (if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) in case of aborted xact */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isCommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L978" title="utils/activity/pgstat_relation.c:978">restore_truncdrop_counters</a>(trans);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* count attempted actions regardless of commit/abort */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tabstat-&gt;counts.tuples_inserted += trans-&gt;tuples_inserted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tabstat-&gt;counts.tuples_updated += trans-&gt;tuples_updated;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tabstat-&gt;counts.tuples_deleted += trans-&gt;tuples_deleted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isCommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tabstat-&gt;counts.truncdropped = trans-&gt;truncdropped;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (trans-&gt;truncdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* forget live/dead stats seen by backend thus far */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tabstat-&gt;counts.delta_live_tuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tabstat-&gt;counts.delta_dead_tuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* insert adds a live tuple, delete removes one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tabstat-&gt;counts.delta_live_tuples +=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trans-&gt;tuples_inserted - trans-&gt;tuples_deleted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* update and delete each create a dead tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tabstat-&gt;counts.delta_dead_tuples +=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trans-&gt;tuples_updated + trans-&gt;tuples_deleted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* insert, update, delete each count as one change event */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tabstat-&gt;counts.changed_tuples +=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trans-&gt;tuples_inserted + trans-&gt;tuples_updated +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trans-&gt;tuples_deleted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* inserted tuples are dead, deleted tuples are unaffected */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tabstat-&gt;counts.delta_dead_tuples +=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trans-&gt;tuples_inserted + trans-&gt;tuples_updated;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* an aborted xact generates no changed_tuple events */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tabstat-&gt;trans = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform relation stats specific end-of-sub-transaction work. Helper for<br/></li>
<li></span><span class="Comment"> * <a href="pgstat_xact.c.html#L112" title="utils/activity/pgstat_xact.c:112">AtEOSubXact_PgStat</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Transfer transactional insert/update counts into the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> higher<br/></li>
<li></span><span class="Comment"> * subtransaction state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L595">&#x200c;</a></span><span class="linkable">AtEOSubXact_PgStat_Relations</span>(PgStat_SubXactStatus *xact_state, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit, <span class="Type">int</span> nestDepth)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PgStat_TableXactStatus *trans;<br/></li>
<li>&nbsp; &nbsp; PgStat_TableXactStatus *next_trans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (trans = xact_state-&gt;first; trans != <span class="Constant">NULL</span>; trans = next_trans)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PgStat_TableStatus *tabstat;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; next_trans = trans-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(trans-&gt;nest_level == nestDepth);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tabstat = trans-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(tabstat-&gt;trans == trans);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isCommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (trans-&gt;<a href="../adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> &amp;&amp; trans-&gt;<a href="../adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;nest_level == nestDepth - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (trans-&gt;truncdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* propagate the truncate/drop status one level up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L963" title="utils/activity/pgstat_relation.c:963">save_truncdrop_counters</a>(trans-&gt;<a href="../adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* replace <a href="../adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> xact stats with ours */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trans-&gt;<a href="../adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;tuples_inserted = trans-&gt;tuples_inserted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trans-&gt;<a href="../adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;tuples_updated = trans-&gt;tuples_updated;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trans-&gt;<a href="../adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;tuples_deleted = trans-&gt;tuples_deleted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trans-&gt;<a href="../adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;tuples_inserted += trans-&gt;tuples_inserted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trans-&gt;<a href="../adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;tuples_updated += trans-&gt;tuples_updated;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trans-&gt;<a href="../adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;tuples_deleted += trans-&gt;tuples_deleted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tabstat-&gt;trans = trans-&gt;<a href="../adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(trans);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When there isn't an immediate parent state, we can just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reuse the record instead of going through a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>/<a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pushup (this works since it's all in <a href="../mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyway).&nbsp; We have to re-link it into the parent level,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * though, and that might mean pushing a new entry into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="pgstat_xact.c.html#L33" title="utils/activity/pgstat_xact.c:33">pgStatXactStack</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PgStat_SubXactStatus *upper_xact_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper_xact_state = <a href="pgstat_xact.c.html#L236" title="utils/activity/pgstat_xact.c:236">pgstat_get_xact_stack_level</a>(nestDepth - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trans-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = upper_xact_state-&gt;first;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper_xact_state-&gt;first = trans;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trans-&gt;nest_level = nestDepth - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * On abort, update top-level tabstat counts, then forget the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subtransaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first restore <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> obliterated by truncate/drop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L978" title="utils/activity/pgstat_relation.c:978">restore_truncdrop_counters</a>(trans);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* count attempted actions regardless of commit/abort */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tabstat-&gt;counts.tuples_inserted += trans-&gt;tuples_inserted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tabstat-&gt;counts.tuples_updated += trans-&gt;tuples_updated;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tabstat-&gt;counts.tuples_deleted += trans-&gt;tuples_deleted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* inserted tuples are dead, deleted tuples are unaffected */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tabstat-&gt;counts.delta_dead_tuples +=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trans-&gt;tuples_inserted + trans-&gt;tuples_updated;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tabstat-&gt;trans = trans-&gt;<a href="../adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(trans);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate 2PC <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> for all the pending transaction-dependent relation<br/></li>
<li></span><span class="Comment"> * stats.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L676">&#x200c;</a></span><span class="linkable">AtPrepare_PgStat_Relations</span>(PgStat_SubXactStatus *xact_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PgStat_TableXactStatus *trans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (trans = xact_state-&gt;first; trans != <span class="Constant">NULL</span>; trans = trans-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PgStat_TableStatus *tabstat <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L31" title="utils/activity/pgstat_relation.c:31">TwoPhasePgStatRecord</a> record;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(trans-&gt;nest_level == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(trans-&gt;<a href="../adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tabstat = trans-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(tabstat-&gt;trans == trans);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record.tuples_inserted = trans-&gt;tuples_inserted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record.tuples_updated = trans-&gt;tuples_updated;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record.tuples_deleted = trans-&gt;tuples_deleted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record.inserted_pre_truncdrop = trans-&gt;inserted_pre_truncdrop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record.updated_pre_truncdrop = trans-&gt;updated_pre_truncdrop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record.deleted_pre_truncdrop = trans-&gt;deleted_pre_truncdrop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record.id = tabstat-&gt;id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record.shared = tabstat-&gt;shared;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record.truncdropped = trans-&gt;truncdropped;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/twophase.c.html#L1280" title="access/transam/twophase.c:1280">RegisterTwoPhaseRecord</a>(TWOPHASE_RM_PGSTAT_ID, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;record, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L31" title="utils/activity/pgstat_relation.c:31">TwoPhasePgStatRecord</a>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * All we need do here is unlink the transaction stats state from the<br/></li>
<li></span><span class="Comment"> * nontransactional state.&nbsp; The nontransactional action counts will be<br/></li>
<li></span><span class="Comment"> * reported to the stats system immediately, while the effects on live and<br/></li>
<li></span><span class="Comment"> * dead tuple counts are preserved in the 2PC state file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: <a href="#L537" title="utils/activity/pgstat_relation.c:537">AtEOXact_PgStat_Relations</a> is not called during PREPARE.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L714">&#x200c;</a></span><span class="linkable">PostPrepare_PgStat_Relations</span>(PgStat_SubXactStatus *xact_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PgStat_TableXactStatus *trans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (trans = xact_state-&gt;first; trans != <span class="Constant">NULL</span>; trans = trans-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PgStat_TableStatus *tabstat;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tabstat = trans-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tabstat-&gt;trans = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * 2PC processing routine for COMMIT PREPARED case.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Load the saved counts into our local pgstats state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L733">&#x200c;</a></span><span class="linkable">pgstat_twophase_postcommit</span>(TransactionId xid, uint16 info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *recdata, uint32 len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L31" title="utils/activity/pgstat_relation.c:31">TwoPhasePgStatRecord</a> *rec = (<a href="#L31" title="utils/activity/pgstat_relation.c:31">TwoPhasePgStatRecord</a> *) recdata;<br/></li>
<li>&nbsp; &nbsp; PgStat_TableStatus *pgstat_info;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find or create a tabstat entry for the rel */<br/></li>
<li></span>&nbsp; &nbsp; pgstat_info = <a href="#L898" title="utils/activity/pgstat_relation.c:898">pgstat_prep_relation_pending</a>(rec-&gt;id, rec-&gt;shared);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Same math as in <a href="pgstat_xact.c.html#L40" title="utils/activity/pgstat_xact.c:40">AtEOXact_PgStat</a>, commit case */<br/></li>
<li></span>&nbsp; &nbsp; pgstat_info-&gt;counts.tuples_inserted += rec-&gt;tuples_inserted;<br/></li>
<li>&nbsp; &nbsp; pgstat_info-&gt;counts.tuples_updated += rec-&gt;tuples_updated;<br/></li>
<li>&nbsp; &nbsp; pgstat_info-&gt;counts.tuples_deleted += rec-&gt;tuples_deleted;<br/></li>
<li>&nbsp; &nbsp; pgstat_info-&gt;counts.truncdropped = rec-&gt;truncdropped;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rec-&gt;truncdropped)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* forget live/dead stats seen by backend thus far */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_info-&gt;counts.delta_live_tuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_info-&gt;counts.delta_dead_tuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pgstat_info-&gt;counts.delta_live_tuples +=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rec-&gt;tuples_inserted - rec-&gt;tuples_deleted;<br/></li>
<li>&nbsp; &nbsp; pgstat_info-&gt;counts.delta_dead_tuples +=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rec-&gt;tuples_updated + rec-&gt;tuples_deleted;<br/></li>
<li>&nbsp; &nbsp; pgstat_info-&gt;counts.changed_tuples +=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rec-&gt;tuples_inserted + rec-&gt;tuples_updated +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rec-&gt;tuples_deleted;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * 2PC processing routine for ROLLBACK PREPARED case.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Load the saved counts into our local pgstats state, but treat them<br/></li>
<li></span><span class="Comment"> * as aborted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L769">&#x200c;</a></span><span class="linkable">pgstat_twophase_postabort</span>(TransactionId xid, uint16 info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *recdata, uint32 len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L31" title="utils/activity/pgstat_relation.c:31">TwoPhasePgStatRecord</a> *rec = (<a href="#L31" title="utils/activity/pgstat_relation.c:31">TwoPhasePgStatRecord</a> *) recdata;<br/></li>
<li>&nbsp; &nbsp; PgStat_TableStatus *pgstat_info;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find or create a tabstat entry for the rel */<br/></li>
<li></span>&nbsp; &nbsp; pgstat_info = <a href="#L898" title="utils/activity/pgstat_relation.c:898">pgstat_prep_relation_pending</a>(rec-&gt;id, rec-&gt;shared);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Same math as in <a href="pgstat_xact.c.html#L40" title="utils/activity/pgstat_xact.c:40">AtEOXact_PgStat</a>, abort case */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rec-&gt;truncdropped)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rec-&gt;tuples_inserted = rec-&gt;inserted_pre_truncdrop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rec-&gt;tuples_updated = rec-&gt;updated_pre_truncdrop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rec-&gt;tuples_deleted = rec-&gt;deleted_pre_truncdrop;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pgstat_info-&gt;counts.tuples_inserted += rec-&gt;tuples_inserted;<br/></li>
<li>&nbsp; &nbsp; pgstat_info-&gt;counts.tuples_updated += rec-&gt;tuples_updated;<br/></li>
<li>&nbsp; &nbsp; pgstat_info-&gt;counts.tuples_deleted += rec-&gt;tuples_deleted;<br/></li>
<li>&nbsp; &nbsp; pgstat_info-&gt;counts.delta_dead_tuples +=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rec-&gt;tuples_inserted + rec-&gt;tuples_updated;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Flush out pending stats for the entry<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If nowait is true, this function returns false if lock could not<br/></li>
<li></span><span class="Comment"> * immediately acquired, otherwise true is returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Some of the stats are copied to the corresponding pending database stats<br/></li>
<li></span><span class="Comment"> * entry when successfully flushing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L802">&#x200c;</a></span><span class="linkable">pgstat_relation_flush_cb</span>(PgStat_EntryRef *entry_ref, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nowait)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">const</span> PgStat_TableCounts all_zeroes;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dboid;<br/></li>
<li>&nbsp; &nbsp; PgStat_TableStatus *lstats; <span class="Comment">/* pending stats entry&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PgStatShared_Relation *shtabstats;<br/></li>
<li>&nbsp; &nbsp; PgStat_StatTabEntry *tabentry;&nbsp; &nbsp; <span class="Comment">/* table entry of shared stats */<br/></li>
<li></span>&nbsp; &nbsp; PgStat_StatDBEntry *dbentry;&nbsp; &nbsp; <span class="Comment">/* pending database entry */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; dboid = entry_ref-&gt;shared_entry-&gt;key.dboid;<br/></li>
<li>&nbsp; &nbsp; lstats = (PgStat_TableStatus *) entry_ref-&gt;pending;<br/></li>
<li>&nbsp; &nbsp; shtabstats = (PgStatShared_Relation *) entry_ref-&gt;shared_stats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ignore entries that didn't accumulate <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> actual counts, such as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indexes that were opened by the <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> but not used.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (memcmp(&amp;lstats-&gt;counts, &amp;all_zeroes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PgStat_TableCounts)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="pgstat_shmem.c.html#L576" title="utils/activity/pgstat_shmem.c:576">pgstat_lock_entry</a>(entry_ref, nowait))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* add the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to the shared entry. */<br/></li>
<li></span>&nbsp; &nbsp; tabentry = &amp;shtabstats-&gt;stats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tabentry-&gt;numscans += lstats-&gt;counts.numscans;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lstats-&gt;counts.numscans)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz t = <a href="../../access/transam/xact.c.html#L888" title="access/transam/xact.c:888">GetCurrentTransactionStopTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (t &gt; tabentry-&gt;lastscan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tabentry-&gt;lastscan = t;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; tabentry-&gt;tuples_returned += lstats-&gt;counts.tuples_returned;<br/></li>
<li>&nbsp; &nbsp; tabentry-&gt;tuples_fetched += lstats-&gt;counts.tuples_fetched;<br/></li>
<li>&nbsp; &nbsp; tabentry-&gt;tuples_inserted += lstats-&gt;counts.tuples_inserted;<br/></li>
<li>&nbsp; &nbsp; tabentry-&gt;tuples_updated += lstats-&gt;counts.tuples_updated;<br/></li>
<li>&nbsp; &nbsp; tabentry-&gt;tuples_deleted += lstats-&gt;counts.tuples_deleted;<br/></li>
<li>&nbsp; &nbsp; tabentry-&gt;tuples_hot_updated += lstats-&gt;counts.tuples_hot_updated;<br/></li>
<li>&nbsp; &nbsp; tabentry-&gt;tuples_newpage_updated += lstats-&gt;counts.tuples_newpage_updated;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If table was truncated/dropped, first reset the live/dead counters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lstats-&gt;counts.truncdropped)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tabentry-&gt;live_tuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tabentry-&gt;dead_tuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tabentry-&gt;ins_since_vacuum = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tabentry-&gt;live_tuples += lstats-&gt;counts.delta_live_tuples;<br/></li>
<li>&nbsp; &nbsp; tabentry-&gt;dead_tuples += lstats-&gt;counts.delta_dead_tuples;<br/></li>
<li>&nbsp; &nbsp; tabentry-&gt;mod_since_analyze += lstats-&gt;counts.changed_tuples;<br/></li>
<li>&nbsp; &nbsp; tabentry-&gt;ins_since_vacuum += lstats-&gt;counts.tuples_inserted;<br/></li>
<li>&nbsp; &nbsp; tabentry-&gt;blocks_fetched += lstats-&gt;counts.blocks_fetched;<br/></li>
<li>&nbsp; &nbsp; tabentry-&gt;blocks_hit += lstats-&gt;counts.blocks_hit;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clamp live_tuples in case of negative delta_live_tuples */<br/></li>
<li></span>&nbsp; &nbsp; tabentry-&gt;live_tuples = Max(tabentry-&gt;live_tuples, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Likewise for dead_tuples */<br/></li>
<li></span>&nbsp; &nbsp; tabentry-&gt;dead_tuples = Max(tabentry-&gt;dead_tuples, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="pgstat_shmem.c.html#L604" title="utils/activity/pgstat_shmem.c:604">pgstat_unlock_entry</a>(entry_ref);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The entry was successfully flushed, add the same to database stats */<br/></li>
<li></span>&nbsp; &nbsp; dbentry = <a href="pgstat_database.c.html#L333" title="utils/activity/pgstat_database.c:333">pgstat_prep_database_pending</a>(dboid);<br/></li>
<li>&nbsp; &nbsp; dbentry-&gt;tuples_returned += lstats-&gt;counts.tuples_returned;<br/></li>
<li>&nbsp; &nbsp; dbentry-&gt;tuples_fetched += lstats-&gt;counts.tuples_fetched;<br/></li>
<li>&nbsp; &nbsp; dbentry-&gt;tuples_inserted += lstats-&gt;counts.tuples_inserted;<br/></li>
<li>&nbsp; &nbsp; dbentry-&gt;tuples_updated += lstats-&gt;counts.tuples_updated;<br/></li>
<li>&nbsp; &nbsp; dbentry-&gt;tuples_deleted += lstats-&gt;counts.tuples_deleted;<br/></li>
<li>&nbsp; &nbsp; dbentry-&gt;blocks_fetched += lstats-&gt;counts.blocks_fetched;<br/></li>
<li>&nbsp; &nbsp; dbentry-&gt;blocks_hit += lstats-&gt;counts.blocks_hit;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L885">&#x200c;</a></span><span class="linkable">pgstat_relation_delete_pending_cb</span>(PgStat_EntryRef *entry_ref)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PgStat_TableStatus *pending = (PgStat_TableStatus *) entry_ref-&gt;pending;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pending-&gt;relation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L153" title="utils/activity/pgstat_relation.c:153">pgstat_unlink_relation</a>(pending-&gt;relation);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find or create a PgStat_TableStatus entry for rel. New entry is created and<br/></li>
<li></span><span class="Comment"> * initialized if not exists.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> PgStat_TableStatus *<br/></li>
<li><a id="L898">&#x200c;</a><span class="linkable">pgstat_prep_relation_pending</span>(Oid rel_id, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isshared)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PgStat_EntryRef *entry_ref;<br/></li>
<li>&nbsp; &nbsp; PgStat_TableStatus *pending;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entry_ref = <a href="pgstat.c.html#L1105" title="utils/activity/pgstat.c:1105">pgstat_prep_pending_entry</a>(PGSTAT_KIND_RELATION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isshared ? InvalidOid : <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel_id, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; pending = entry_ref-&gt;pending;<br/></li>
<li>&nbsp; &nbsp; pending-&gt;id = rel_id;<br/></li>
<li>&nbsp; &nbsp; pending-&gt;shared = isshared;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pending;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * add a new (sub)transaction state record<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L917">&#x200c;</a></span><span class="linkable">add_tabstat_xact_level</span>(PgStat_TableStatus *pgstat_info, <span class="Type">int</span> nest_level)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PgStat_SubXactStatus *xact_state;<br/></li>
<li>&nbsp; &nbsp; PgStat_TableXactStatus *trans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is the first rel to be modified at the current nest level, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first have to <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> a transaction stack entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; xact_state = <a href="pgstat_xact.c.html#L236" title="utils/activity/pgstat_xact.c:236">pgstat_get_xact_stack_level</a>(nest_level);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now make a per-table stack entry */<br/></li>
<li></span>&nbsp; &nbsp; trans = (PgStat_TableXactStatus *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(<a href="../mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PgStat_TableXactStatus));<br/></li>
<li>&nbsp; &nbsp; trans-&gt;nest_level = nest_level;<br/></li>
<li>&nbsp; &nbsp; trans-&gt;<a href="../adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = pgstat_info-&gt;trans;<br/></li>
<li>&nbsp; &nbsp; trans-&gt;parent = pgstat_info;<br/></li>
<li>&nbsp; &nbsp; trans-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = xact_state-&gt;first;<br/></li>
<li>&nbsp; &nbsp; xact_state-&gt;first = trans;<br/></li>
<li>&nbsp; &nbsp; pgstat_info-&gt;trans = trans;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add a new (sub)transaction record if needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L944">&#x200c;</a></span><span class="linkable">ensure_tabstat_xact_level</span>(PgStat_TableStatus *pgstat_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nest_level = <a href="../../access/transam/xact.c.html#L926" title="access/transam/xact.c:926">GetCurrentTransactionNestLevel</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pgstat_info-&gt;trans == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_info-&gt;trans-&gt;nest_level != nest_level)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L917" title="utils/activity/pgstat_relation.c:917">add_tabstat_xact_level</a>(pgstat_info, nest_level);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Whenever a table is truncated/dropped, we save its i/u/d counters so that<br/></li>
<li></span><span class="Comment"> * they can be cleared, and if the (sub)xact that executed the truncate/drop<br/></li>
<li></span><span class="Comment"> * later aborts, the counters can be restored to the saved (pre-truncate/drop)<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that for truncate we do this on the first truncate in <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> particular<br/></li>
<li></span><span class="Comment"> * subxact level only.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L963">&#x200c;</a></span><span class="linkable">save_truncdrop_counters</span>(PgStat_TableXactStatus *trans, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_drop)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!trans-&gt;truncdropped || is_drop)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trans-&gt;inserted_pre_truncdrop = trans-&gt;tuples_inserted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trans-&gt;updated_pre_truncdrop = trans-&gt;tuples_updated;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trans-&gt;deleted_pre_truncdrop = trans-&gt;tuples_deleted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trans-&gt;truncdropped = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * restore counters when a truncate aborts<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L978">&#x200c;</a></span><span class="linkable">restore_truncdrop_counters</span>(PgStat_TableXactStatus *trans)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (trans-&gt;truncdropped)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trans-&gt;tuples_inserted = trans-&gt;inserted_pre_truncdrop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trans-&gt;tuples_updated = trans-&gt;updated_pre_truncdrop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trans-&gt;tuples_deleted = trans-&gt;deleted_pre_truncdrop;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
