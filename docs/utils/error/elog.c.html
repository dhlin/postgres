<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/error/elog.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/error/elog.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L112">Log_destination</a></li>
<li><a href="#L113">Log_destination_string</a></li>
<li><a href="#L110">Log_error_verbosity</a></li>
<li><a href="#L111">Log_line_prefix</a></li>
<li><a href="#L96">PG_exception_stack</a></li>
<li><a href="#L118">backtrace_function_list</a></li>
<li><a href="#L107">emit_log_hook</a></li>
<li><a href="#L94">error_context_stack</a></li>
<li><a href="#L149">errordata</a></li>
<li><a href="#L151">errordata_stack_depth</a></li>
<li><a href="#L164">formatted_log_time</a></li>
<li><a href="#L163">formatted_start_time</a></li>
<li><a href="#L133">openlog_done</a></li>
<li><a href="#L153">recursion_depth</a></li>
<li><a href="#L1627">save_format_domain</a></li>
<li><a href="#L1626">save_format_errnumber</a></li>
<li><a href="#L159">saved_timeval</a></li>
<li><a href="#L160">saved_timeval_set</a></li>
<li><a href="#L135">syslog_facility</a></li>
<li><a href="#L134">syslog_ident</a></li>
<li><a href="#L114">syslog_sequence_numbers</a></li>
<li><a href="#L115">syslog_split_messages</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1731">CopyErrorData</a></li>
<li><a href="#L2077">DebugFileOpen</a></li>
<li><a href="#L1672">EmitErrorReport</a></li>
<li><a href="#L1836">FlushErrorState</a></li>
<li><a href="#L1787">FreeErrorData</a></li>
<li><a href="#L1799">FreeErrorDataContents</a></li>
<li><a href="#L2441">GetACPEncoding</a></li>
<li><a href="#L2025">GetErrorContextStack</a></li>
<li><a href="#L1920">ReThrowError</a></li>
<li><a href="#L1861">ThrowErrorData</a></li>
<li><a href="#L3688">append_with_tabs</a></li>
<li><a href="#L2192">assign_backtrace_functions</a></li>
<li><a href="#L2263">assign_log_destination</a></li>
<li><a href="#L2304">assign_syslog_facility</a></li>
<li><a href="#L2272">assign_syslog_ident</a></li>
<li><a href="#L2133">check_backtrace_functions</a></li>
<li><a href="#L2201">check_log_destination</a></li>
<li><a href="#L2697">check_log_of_query</a></li>
<li><a href="#L1514">err_generic_string</a></li>
<li><a href="#L309">err_gettext</a></li>
<li><a href="#L3446">err_sendstring</a></li>
<li><a href="#L1094">errbacktrace</a></li>
<li><a href="#L859">errcode</a></li>
<li><a href="#L882">errcode_for_file_access</a></li>
<li><a href="#L955">errcode_for_socket_access</a></li>
<li><a href="#L1367">errcontext_msg</a></li>
<li><a href="#L1205">errdetail</a></li>
<li><a href="#L1232">errdetail_internal</a></li>
<li><a href="#L1253">errdetail_log</a></li>
<li><a href="#L1274">errdetail_log_plural</a></li>
<li><a href="#L1297">errdetail_plural</a></li>
<li><a href="#L477">errfinish</a></li>
<li><a href="#L1432">errhidecontext</a></li>
<li><a href="#L1413">errhidestmt</a></li>
<li><a href="#L1319">errhint</a></li>
<li><a href="#L1341">errhint_plural</a></li>
<li><a href="#L1072">errmsg</a></li>
<li><a href="#L1159">errmsg_internal</a></li>
<li><a href="#L1182">errmsg_plural</a></li>
<li><a href="#L3636">error_severity</a></li>
<li><a href="#L1448">errposition</a></li>
<li><a href="#L687">errsave_finish</a></li>
<li><a href="#L635">errsave_start</a></li>
<li><a href="#L346">errstart</a></li>
<li><a href="#L330">errstart_cold</a></li>
<li><a href="#L1639">format_elog_string</a></li>
<li><a href="#L2720">get_backend_type_for_log</a></li>
<li><a href="#L757">get_error_stack_entry</a></li>
<li><a href="#L2623">get_formatted_log_time</a></li>
<li><a href="#L2673">get_formatted_start_time</a></li>
<li><a href="#L1563">geterrcode</a></li>
<li><a href="#L1580">geterrposition</a></li>
<li><a href="#L1597">getinternalerrposition</a></li>
<li><a href="#L297">in_error_recursion_trouble</a></li>
<li><a href="#L1464">internalerrposition</a></li>
<li><a href="#L1484">internalerrquery</a></li>
<li><a href="#L205">is_log_level_output</a></li>
<li><a href="#L2773">log_line_prefix</a></li>
<li><a href="#L2782">log_status_format</a></li>
<li><a href="#L831">matches_backtrace_functions</a></li>
<li><a href="#L276">message_level_is_interesting</a></li>
<li><a href="#L1970">pg_re_throw</a></li>
<li><a href="#L1630">pre_format_elog_string</a></li>
<li><a href="#L2742">process_log_prefix_padding</a></li>
<li><a href="#L2661">reset_formatted_start_time</a></li>
<li><a href="#L3458">send_message_to_frontend</a></li>
<li><a href="#L3155">send_message_to_server_log</a></li>
<li><a href="#L1118">set_backtrace</a></li>
<li><a href="#L1393">set_errcontext_domain</a></li>
<li><a href="#L1550">set_errdata_field</a></li>
<li><a href="#L784">set_stack_entry_domain</a></li>
<li><a href="#L801">set_stack_entry_location</a></li>
<li><a href="#L248">should_output_to_client</a></li>
<li><a href="#L239">should_output_to_server</a></li>
<li><a href="#L3135">unpack_sql_state</a></li>
<li><a href="#L2545">write_console</a></li>
<li><a href="#L2455">write_eventlog</a></li>
<li><a href="#L3395">write_pipe_chunks</a></li>
<li><a href="#L3707">write_stderr</a></li>
<li><a href="#L2329">write_syslog</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L168">CHECK_STACK_DEPTH</a></li>
<li><a href="#L147">ERRORDATA_STACK_SIZE</a></li>
<li><a href="#L991">EVALUATE_MESSAGE</a></li>
<li><a href="#L1027">EVALUATE_MESSAGE_PLURAL</a></li>
<li><a href="#L162">FORMATTED_TS_LEN</a></li>
<li><a href="#L130">PG_SYSLOG_LIMIT</a></li>
<li><a href="#L89">_</a></li>
<li><a href="#L90">_</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * elog.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; error logging and reporting<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Because of the extremely high rate at which log messages can be generated,<br/></li>
<li></span><span class="Comment"> * we need to be mindful of the performance cost of obtaining <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> information<br/></li>
<li></span><span class="Comment"> * that may be logged.&nbsp; Also, it's important to keep in mind that this code may<br/></li>
<li></span><span class="Comment"> * get called from within an aborted transaction, in which case operations<br/></li>
<li></span><span class="Comment"> * such as syscache lookups are unsafe.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Some notes about recursion and errors during error processing:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We need to be robust about recursive-error scenarios --- for example,<br/></li>
<li></span><span class="Comment"> * if we run out of memory, it's important to be able to report that fact.<br/></li>
<li></span><span class="Comment"> * There are a number of considerations that go into this.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * First, distinguish between re-entrant use and actual recursion.&nbsp; It<br/></li>
<li></span><span class="Comment"> * is possible for an error or warning message to be emitted while the<br/></li>
<li></span><span class="Comment"> * parameters for an error message are being computed.&nbsp; In this case<br/></li>
<li></span><span class="Comment"> * <a href="#L346" title="utils/error/elog.c:346">errstart</a> has been called for the outer message, and some field <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * may have already been saved, but we are not actually recursing.&nbsp; We handle<br/></li>
<li></span><span class="Comment"> * this by providing a (small) stack of ErrorData <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.&nbsp; The inner message<br/></li>
<li></span><span class="Comment"> * can be computed and sent without disturbing the state of the outer message.<br/></li>
<li></span><span class="Comment"> * (If the inner message is actually an error, this isn't very interesting<br/></li>
<li></span><span class="Comment"> * because control won't come back to the outer message generator ... but<br/></li>
<li></span><span class="Comment"> * if the inner message is only debug or log data, this is critical.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Second, actual recursion will occur if an error is reported by one of<br/></li>
<li></span><span class="Comment"> * the elog.c routines or something they call.&nbsp; By far the most probable<br/></li>
<li></span><span class="Comment"> * scenario of this sort is &quot;out of memory&quot;; and it's also the nastiest<br/></li>
<li></span><span class="Comment"> * to handle because we'd likely also run out of memory while trying to<br/></li>
<li></span><span class="Comment"> * report this error!&nbsp; Our escape hatch for this case is to reset the<br/></li>
<li></span><span class="Comment"> * <a href="../mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a> to empty <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> trying to process the inner error.&nbsp; Since<br/></li>
<li></span><span class="Comment"> * <a href="../mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a> is guaranteed to have at least 8K of space in it (see mcxt.c),<br/></li>
<li></span><span class="Comment"> * we should be able to process an &quot;out of memory&quot; message successfully.<br/></li>
<li></span><span class="Comment"> * Since we lose the prior error state due to the reset, we won't be able<br/></li>
<li></span><span class="Comment"> * to return to processing the original error, but we wouldn't have anyway.<br/></li>
<li></span><span class="Comment"> * (<a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: the escape hatch is not used for recursive situations where the<br/></li>
<li></span><span class="Comment"> * inner message is of less than ERROR severity; in that case we just<br/></li>
<li></span><span class="Comment"> * try to process it and return normally.&nbsp; Usually this will work, but if<br/></li>
<li></span><span class="Comment"> * it ends up in infinite recursion, we will PANIC due to error stack<br/></li>
<li></span><span class="Comment"> * overflow.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/error/elog.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;time.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;ctype.h&gt;<br/></li>
<li></span><span class="PreProc">#ifdef HAVE_SYSLOG<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;syslog.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef HAVE_EXECINFO_H<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;execinfo.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/libpq.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;mb/pg_wchar.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/miscnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/bgworker.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/postmaster.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/syslogger.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/tcopprot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc_hooks.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/ps_status.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/varlena.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* In this module, access gettext() via <a href="#L309" title="utils/error/elog.c:309">err_gettext</a>() */<br/></li>
<li><a id="L89">&#x200c;</a></span><span class="PreProc">#undef <span class="linkable">_</span><br/></li>
<li><a id="L90">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">_</span>(x) <a href="#L309" title="utils/error/elog.c:309">err_gettext</a>(x)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* Global variables */<br/></li>
<li><a id="L94">&#x200c;</a></span>ErrorContextCallback *<span class="linkable">error_context_stack</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><a id="L96">&#x200c;</a>sigjmp_buf *<span class="linkable">PG_exception_stack</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Type">extern</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="../../postmaster/postmaster.c.html#L353" title="postmaster/postmaster.c:353">redirection_done</a>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Hook for intercepting messages <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> they are sent to the server log.<br/></li>
<li></span><span class="Comment"> * Note that the hook will not get called for messages that are suppressed<br/></li>
<li></span><span class="Comment"> * by <a href="../misc/guc_tables.c.html#L524" title="utils/misc/guc_tables.c:524">log_min_messages</a>.&nbsp; Also note that logging hooks implemented in preload<br/></li>
<li></span><span class="Comment"> * libraries will <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> log messages that are generated <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment"> * library is loaded.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L107">&#x200c;</a></span>emit_log_hook_type <span class="linkable">emit_log_hook</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* GUC parameters */<br/></li>
<li><a id="L110">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">Log_error_verbosity</span> = PGERROR_DEFAULT;<br/></li>
<li><a id="L111">&#x200c;</a><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">Log_line_prefix</span> = <span class="Constant">NULL</span>; <span class="Comment">/* format for extra log line info */<br/></li>
<li><a id="L112">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">Log_destination</span> = LOG_DESTINATION_STDERR;<br/></li>
<li><a id="L113">&#x200c;</a><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">Log_destination_string</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L114">&#x200c;</a><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">syslog_sequence_numbers</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L115">&#x200c;</a><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">syslog_split_messages</span> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Processed form of <a href="../misc/guc_tables.c.html#L533" title="utils/misc/guc_tables.c:533">backtrace_functions</a> GUC */<br/></li>
<li><a id="L118">&#x200c;</a></span><span class="Type">static</span> <span class="Type">char</span> *<span class="linkable">backtrace_function_list</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HAVE_SYSLOG<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Max string length to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> to syslog().&nbsp; Note that this doesn't count the<br/></li>
<li></span><span class="Comment"> * sequence-number prefix we add, and of course it doesn't count the prefix<br/></li>
<li></span><span class="Comment"> * added by syslog itself.&nbsp; Solaris and sysklogd truncate the final message<br/></li>
<li></span><span class="Comment"> * at 1024 bytes, so this value leaves 124 bytes for those <a href="../../regex/regc_lex.c.html#L99" title="regex/regc_lex.c:99">prefixes</a>.&nbsp; (Most<br/></li>
<li></span><span class="Comment"> * other syslog implementations seem to have limits of 2KB or so.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifndef <a href="#L130" title="utils/error/elog.c:130">PG_SYSLOG_LIMIT</a><br/></li>
<li><a id="L130">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PG_SYSLOG_LIMIT</span> </span><span class="Constant">900<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L133">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">openlog_done</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L134">&#x200c;</a><span class="Type">static</span> <span class="Type">char</span> *<span class="linkable">syslog_ident</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L135">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">syslog_facility</span> = LOG_LOCAL0;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2329" title="utils/error/elog.c:2329">write_syslog</a>(<span class="Type">int</span> level, <span class="Type">const</span> <span class="Type">char</span> *line);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span><span class="Type">extern</span> <span class="Type">char</span> *<a href="../misc/guc_tables.c.html#L511" title="utils/misc/guc_tables.c:511">event_source</a>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2455" title="utils/error/elog.c:2455">write_eventlog</a>(<span class="Type">int</span> level, <span class="Type">const</span> <span class="Type">char</span> *line, <span class="Type">int</span> len);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* We provide a small stack of ErrorData <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> for re-entrant cases */<br/></li>
<li><a id="L147">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ERRORDATA_STACK_SIZE</span>&nbsp; </span><span class="Constant">5<br/></li>
<li></span><br/></li>
<li><a id="L149">&#x200c;</a><span class="Type">static</span> ErrorData <span class="linkable">errordata</span>[<a href="#L147" title="utils/error/elog.c:147">ERRORDATA_STACK_SIZE</a>];<br/></li>
<li><br/></li>
<li><a id="L151">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">errordata_stack_depth</span> = -<span class="Constant">1</span>; <span class="Comment">/* index of topmost active frame */<br/></li>
<li></span><br/></li>
<li><a id="L153">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">recursion_depth</span> = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* to detect actual recursion */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Saved timeval and buffers for formatted timestamps that might be used by<br/></li>
<li></span><span class="Comment"> * <a href="#L2773" title="utils/error/elog.c:2773">log_line_prefix</a>, csv logs and JSON logs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L159">&#x200c;</a></span><span class="Type">static</span> <span class="Type">struct</span> timeval <span class="linkable">saved_timeval</span>;<br/></li>
<li><a id="L160">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">saved_timeval_set</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><a id="L162">&#x200c;</a><span class="PreProc">#define <span class="linkable">FORMATTED_TS_LEN</span> </span><span class="Constant">128<br/></li>
<li><a id="L163">&#x200c;</a></span><span class="Type">static</span> <span class="Type">char</span> <span class="linkable">formatted_start_time</span>[<a href="#L162" title="utils/error/elog.c:162">FORMATTED_TS_LEN</a>];<br/></li>
<li><a id="L164">&#x200c;</a><span class="Type">static</span> <span class="Type">char</span> <span class="linkable">formatted_log_time</span>[<a href="#L162" title="utils/error/elog.c:162">FORMATTED_TS_LEN</a>];<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* Macro for checking <a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a> is reasonable */<br/></li>
<li><a id="L168">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CHECK_STACK_DEPTH</span>() \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a> &lt; </span><span class="Constant">0</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a> = -</span><span class="Constant">1</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR, (<a href="#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(</span><span class="Constant">&quot;<a href="#L346" title="utils/error/elog.c:346">errstart</a> was not called&quot;</span><span class="PreProc">))); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; } \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<a href="#L309" title="utils/error/elog.c:309">err_gettext</a>(<span class="Type">const</span> <span class="Type">char</span> *str) pg_attribute_format_arg(<span class="Constant">1</span>);<br/></li>
<li><span class="Type">static</span> ErrorData *<a href="#L757" title="utils/error/elog.c:757">get_error_stack_entry</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L784" title="utils/error/elog.c:784">set_stack_entry_domain</a>(ErrorData *edata, <span class="Type">const</span> <span class="Type">char</span> *domain);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L801" title="utils/error/elog.c:801">set_stack_entry_location</a>(ErrorData *edata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *filename, <span class="Type">int</span> lineno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *funcname);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L831" title="utils/error/elog.c:831">matches_backtrace_functions</a>(<span class="Type">const</span> <span class="Type">char</span> *funcname);<br/></li>
<li><span class="Type">static</span> pg_noinline <span class="Type">void</span> <a href="#L1118" title="utils/error/elog.c:1118">set_backtrace</a>(ErrorData *edata, <span class="Type">int</span> num_skip);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1550" title="utils/error/elog.c:1550">set_errdata_field</a>(MemoryContextData *cxt, <span class="Type">char</span> **ptr, <span class="Type">const</span> <span class="Type">char</span> *str);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1799" title="utils/error/elog.c:1799">FreeErrorDataContents</a>(ErrorData *edata);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2545" title="utils/error/elog.c:2545">write_console</a>(<span class="Type">const</span> <span class="Type">char</span> *line, <span class="Type">int</span> len);<br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<a href="#L2742" title="utils/error/elog.c:2742">process_log_prefix_padding</a>(<span class="Type">const</span> <span class="Type">char</span> *p, <span class="Type">int</span> *ppadding);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2773" title="utils/error/elog.c:2773">log_line_prefix</a>(StringInfo buf, ErrorData *edata);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3155" title="utils/error/elog.c:3155">send_message_to_server_log</a>(ErrorData *edata);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3458" title="utils/error/elog.c:3458">send_message_to_frontend</a>(ErrorData *edata);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3688" title="utils/error/elog.c:3688">append_with_tabs</a>(StringInfo buf, <span class="Type">const</span> <span class="Type">char</span> *str);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L205" title="utils/error/elog.c:205">is_log_level_output</a> -- is elevel logically &gt;= log_min_level?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use this for tests that should consider LOG to sort out-of-order,<br/></li>
<li></span><span class="Comment"> * between ERROR and FATAL.&nbsp; Generally this is the right thing for testing<br/></li>
<li></span><span class="Comment"> * whether a message should go to the postmaster log, whereas a simple &gt;=<br/></li>
<li></span><span class="Comment"> * test is correct for testing whether the message should go to the client.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L205">&#x200c;</a></span><span class="linkable">is_log_level_output</span>(<span class="Type">int</span> elevel, <span class="Type">int</span> log_min_level)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (elevel == LOG || elevel == LOG_SERVER_ONLY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (log_min_level == LOG || log_min_level &lt;= ERROR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (elevel == WARNING_CLIENT_ONLY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* never sent to log, regardless of log_min_level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (log_min_level == LOG)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* elevel != LOG */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (elevel &gt;= FATAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Neither is LOG */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (elevel &gt;= log_min_level)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Policy-setting subroutines.&nbsp; These are fairly simple, but it seems wise<br/></li>
<li></span><span class="Comment"> * to have the code in just one place.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L239" title="utils/error/elog.c:239">should_output_to_server</a> --- should message of given elevel go to the log?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L239">&#x200c;</a></span><span class="linkable">should_output_to_server</span>(<span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L205" title="utils/error/elog.c:205">is_log_level_output</a>(elevel, <a href="../misc/guc_tables.c.html#L524" title="utils/misc/guc_tables.c:524">log_min_messages</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L248" title="utils/error/elog.c:248">should_output_to_client</a> --- should message of given elevel go to the client?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L248">&#x200c;</a></span><span class="linkable">should_output_to_client</span>(<span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../tcop/postgres.c.html#L90" title="tcop/postgres.c:90">whereToSendOutput</a> == DestRemote &amp;&amp; elevel != LOG_SERVER_ONLY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../misc/guc_tables.c.html#L525" title="utils/misc/guc_tables.c:525">client_min_messages</a> is honored only after we complete the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * authentication handshake.&nbsp; This is required both for security<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reasons and because many clients can't handle NOTICE messages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * during authentication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../postmaster/postmaster.c.html#L350" title="postmaster/postmaster.c:350">ClientAuthInProgress</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (elevel &gt;= ERROR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (elevel &gt;= <a href="../misc/guc_tables.c.html#L525" title="utils/misc/guc_tables.c:525">client_min_messages</a> || elevel == INFO);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L276" title="utils/error/elog.c:276">message_level_is_interesting</a> --- would ereport/elog do anything?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if ereport/elog with this elevel will not be a no-op.<br/></li>
<li></span><span class="Comment"> * This is useful to short-circuit <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> expensive preparatory work that<br/></li>
<li></span><span class="Comment"> * might be needed for a logging message.&nbsp; There is no point in<br/></li>
<li></span><span class="Comment"> * prepending this to a bare ereport/elog call, however.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L276">&#x200c;</a></span><span class="linkable">message_level_is_interesting</span>(<span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Keep this in sync with the decision-making in <a href="#L346" title="utils/error/elog.c:346">errstart</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (elevel &gt;= ERROR ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L239" title="utils/error/elog.c:239">should_output_to_server</a>(elevel) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L248" title="utils/error/elog.c:248">should_output_to_client</a>(elevel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L297" title="utils/error/elog.c:297">in_error_recursion_trouble</a> --- are we at risk of infinite error recursion?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function exists to provide common control of various fallback steps<br/></li>
<li></span><span class="Comment"> * that we take if we think we are facing infinite error recursion.&nbsp; See the<br/></li>
<li></span><span class="Comment"> * callers for details.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L297">&#x200c;</a></span><span class="linkable">in_error_recursion_trouble</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pull the plug if recurse more than once */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L153" title="utils/error/elog.c:153">recursion_depth</a> &gt; <span class="Constant">2</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * One of those fallback steps is to stop trying to localize the error<br/></li>
<li></span><span class="Comment"> * message, since there's a significant probability that that's exactly<br/></li>
<li></span><span class="Comment"> * what's causing the recursion.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L309">&#x200c;</a><span class="linkable">err_gettext</span>(<span class="Type">const</span> <span class="Type">char</span> *str)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef ENABLE_NLS<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L297" title="utils/error/elog.c:297">in_error_recursion_trouble</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> str;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> gettext(str);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> str;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L330" title="utils/error/elog.c:330">errstart_cold</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; A simple wrapper around <a href="#L346" title="utils/error/elog.c:346">errstart</a>, but hinted to be &quot;cold&quot;.&nbsp; Supporting<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; compilers are more likely to move code for branches containing this<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; function into an area away from the calling function's code.&nbsp; This can<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; result in more commonly executed code being more <a href="../../regex/regc_nfa.c.html#L3479" title="regex/regc_nfa.c:3479">compact</a> and fitting<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; on fewer cache lines.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>pg_attribute_cold <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L330">&#x200c;</a></span><span class="linkable">errstart_cold</span>(<span class="Type">int</span> elevel, <span class="Type">const</span> <span class="Type">char</span> *domain)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L346" title="utils/error/elog.c:346">errstart</a>(elevel, domain);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L346" title="utils/error/elog.c:346">errstart</a> --- begin an error-reporting cycle<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Create and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> error stack entry.&nbsp; Subsequently, <a href="#L1072" title="utils/error/elog.c:1072">errmsg</a>() and<br/></li>
<li></span><span class="Comment"> * perhaps other routines will be called to further populate the stack entry.<br/></li>
<li></span><span class="Comment"> * Finally, <a href="#L477" title="utils/error/elog.c:477">errfinish</a>() will be called to actually process the error report.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true in normal case.&nbsp; Returns false to short-circuit the error<br/></li>
<li></span><span class="Comment"> * report (if it's a warning or <a href="../adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> and not to be reported anywhere).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L346">&#x200c;</a></span><span class="linkable">errstart</span>(<span class="Type">int</span> elevel, <span class="Type">const</span> <span class="Type">char</span> *domain)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; output_to_server;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; output_to_client = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check some cases in which we want to promote an error into a more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * severe error.&nbsp; None of this logic applies for non-error messages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (elevel &gt;= ERROR)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are inside a critical section, all errors become PANIC<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * errors.&nbsp; See miscadmin.h.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../init/globals.c.html#L43" title="utils/init/globals.c:43">CritSectionCount</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elevel = PANIC;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check reasons for treating ERROR as FATAL:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 1. we have no handler to pass the error to (implies we are in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * postmaster or in backend startup).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 2. <a href="../init/globals.c.html#L120" title="utils/init/globals.c:120">ExitOnAnyError</a> mode switch is set (initdb uses this).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 3. the error occurred after <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a> has begun to run.&nbsp; (It's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>'s responsibility to see that this doesn't turn into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * infinite recursion!)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (elevel == ERROR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L96" title="utils/error/elog.c:96">PG_exception_stack</a> == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../init/globals.c.html#L120" title="utils/init/globals.c:120">ExitOnAnyError</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L40" title="storage/ipc/ipc.c:40">proc_exit_inprogress</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elevel = FATAL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the error level is ERROR or more, <a href="#L477" title="utils/error/elog.c:477">errfinish</a> is not going to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * return to caller; therefore, if there is <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> stacked error already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in progress it will be lost.&nbsp; This is more or less okay, except we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do not want to have a FATAL or PANIC error downgraded because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reporting process was interrupted by a <a href="../adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-grade error.&nbsp; So check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the stack and make sure we panic if panic is warranted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt;= <a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elevel = Max(elevel, <a href="#L149" title="utils/error/elog.c:149">errordata</a>[i].elevel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now decide whether we need to process this report at all; if it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * warning or less and not enabled for logging, just return false without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * starting up <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error logging machinery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; output_to_server = <a href="#L239" title="utils/error/elog.c:239">should_output_to_server</a>(elevel);<br/></li>
<li>&nbsp; &nbsp; output_to_client = <a href="#L248" title="utils/error/elog.c:248">should_output_to_client</a>(elevel);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (elevel &lt; ERROR &amp;&amp; !output_to_server &amp;&amp; !output_to_client)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to do some actual work.&nbsp; Make sure that memory context<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initialization has finished, else we can't do anything useful.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Oops, hard crash time; very little we can do safely here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3707" title="utils/error/elog.c:3707">write_stderr</a>(<span class="Constant">&quot;error occurred <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> error message processing is available</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; exit(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Okay, crank up a stack entry to store the info in.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>++ &gt; <span class="Constant">0</span> &amp;&amp; elevel &gt;= ERROR)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Oops, error during error processing.&nbsp; Clear <a href="../mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a> as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * discussed at top of file.&nbsp; We will not return to the original<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error's reporter or handler, so we don't need it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(<a href="../mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Infinite error recursion might be due to something broken in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * context traceback routine.&nbsp; Abandon them too.&nbsp; We also abandon<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attempting to <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> the error statement (which, if long, could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * itself be the source of the recursive failure).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L297" title="utils/error/elog.c:297">in_error_recursion_trouble</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L94" title="utils/error/elog.c:94">error_context_stack</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize data for this error frame */<br/></li>
<li></span>&nbsp; &nbsp; edata = <a href="#L757" title="utils/error/elog.c:757">get_error_stack_entry</a>();<br/></li>
<li>&nbsp; &nbsp; edata-&gt;elevel = elevel;<br/></li>
<li>&nbsp; &nbsp; edata-&gt;output_to_server = output_to_server;<br/></li>
<li>&nbsp; &nbsp; edata-&gt;output_to_client = output_to_client;<br/></li>
<li>&nbsp; &nbsp; <a href="#L784" title="utils/error/elog.c:784">set_stack_entry_domain</a>(edata, domain);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Select default <a href="#L859" title="utils/error/elog.c:859">errcode</a> based on elevel */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (elevel &gt;= ERROR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; edata-&gt;sqlerrcode = ERRCODE_INTERNAL_ERROR;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (elevel &gt;= WARNING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; edata-&gt;sqlerrcode = ERRCODE_WARNING;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; edata-&gt;sqlerrcode = ERRCODE_SUCCESSFUL_COMPLETION;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Any allocations for this error state level should go into <a href="../mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; edata-&gt;assoc_context = <a href="../mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L477" title="utils/error/elog.c:477">errfinish</a> --- end an error-reporting cycle<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Produce the appropriate error report(s) and pop the error stack.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If elevel, as passed to <a href="#L346" title="utils/error/elog.c:346">errstart</a>(), is ERROR or worse, control does not<br/></li>
<li></span><span class="Comment"> * return to the caller.&nbsp; See elog.h for the error level definitions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L477">&#x200c;</a></span><span class="linkable">errfinish</span>(<span class="Type">const</span> <span class="Type">char</span> *filename, <span class="Type">int</span> lineno, <span class="Type">const</span> <span class="Type">char</span> *funcname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elevel;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback *econtext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>++;<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save the last few bits of error state into the stack entry */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L801" title="utils/error/elog.c:801">set_stack_entry_location</a>(edata, filename, lineno, funcname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elevel = edata-&gt;elevel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do processing in <a href="../mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a>, which we hope has enough reserved space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to report an error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Collect backtrace, if enabled and we didn't already */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!edata-&gt;backtrace &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((edata-&gt;funcname &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc_tables.c.html#L533" title="utils/misc/guc_tables.c:533">backtrace_functions</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L831" title="utils/error/elog.c:831">matches_backtrace_functions</a>(edata-&gt;funcname)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (edata-&gt;sqlerrcode == ERRCODE_INTERNAL_ERROR &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc_tables.c.html#L534" title="utils/misc/guc_tables.c:534">backtrace_on_internal_error</a>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1118" title="utils/error/elog.c:1118">set_backtrace</a>(edata, <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> context callback <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; Errors occurring in callback<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> will be treated as recursive errors --- this ensures we will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoid infinite recursion (see <a href="#L346" title="utils/error/elog.c:346">errstart</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (econtext = <a href="#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; econtext != <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; econtext = econtext-&gt;previous)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;callback(econtext-&gt;arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If ERROR (not more nor less) we pass it off to the current handler.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Printing it and popping the stack is the responsibility of the handler.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (elevel == ERROR)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We do some minimal <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> longjmp'ing so that handlers can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * execute in a reasonably sane state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset <a href="../init/globals.c.html#L41" title="utils/init/globals.c:41">InterruptHoldoffCount</a> in case we ereport'd from inside an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interrupt holdoff section.&nbsp; (We assume here that no handler will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * itself be inside a holdoff section.&nbsp; If necessary, such a handler<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could save and restore <a href="../init/globals.c.html#L41" title="utils/init/globals.c:41">InterruptHoldoffCount</a> for itself, but this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should make life easier for most.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../init/globals.c.html#L41" title="utils/init/globals.c:41">InterruptHoldoffCount</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../init/globals.c.html#L42" title="utils/init/globals.c:42">QueryCancelHoldoffCount</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../init/globals.c.html#L43" title="utils/init/globals.c:43">CritSectionCount</a> = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* should be unnecessary, but... */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we leave <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> set to <a href="../mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a>. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * handler should reset it to something else soon.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Emit the message to the right places */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1672" title="utils/error/elog.c:1672">EmitErrorReport</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now free up subsidiary data attached to stack entry, and release it */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1799" title="utils/error/elog.c:1799">FreeErrorDataContents</a>(edata);<br/></li>
<li>&nbsp; &nbsp; <a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exit error-handling context */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Perform error recovery action as specified by elevel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (elevel == FATAL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For a FATAL error, we let <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a> clean up and exit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we just reported a startup failure, the client will disconnect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on receiving it, so don't <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more to the client.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L96" title="utils/error/elog.c:96">PG_exception_stack</a> == <span class="Constant">NULL</span> &amp;&amp; <a href="../../tcop/postgres.c.html#L90" title="tcop/postgres.c:90">whereToSendOutput</a> == DestRemote)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L90" title="tcop/postgres.c:90">whereToSendOutput</a> = DestNone;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fflush here is just to improve the odds that we get to see the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error message, in case things are so hosed that <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a> crashes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Any other code you might be tempted to add here should probably be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in an <a href="../../storage/ipc/ipc.c.html#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a> or <a href="../../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a> callback instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fflush(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Let the cumulative stats system know. Only mark the session as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * terminated by fatal error if there is no other known cause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../activity/pgstat_database.c.html#L32" title="utils/activity/pgstat_database.c:32">pgStatSessionEndCause</a> == DISCONNECT_NORMAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../activity/pgstat_database.c.html#L32" title="utils/activity/pgstat_database.c:32">pgStatSessionEndCause</a> = DISCONNECT_FATAL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do normal process-exit <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>, then return exit code 1 to indicate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * FATAL termination.&nbsp; The postmaster may or may not consider this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * worthy of panic, depending on which subprocess returns it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (elevel &gt;= PANIC)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Serious crash time. Postmaster will observe SIGABRT process exit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * status and kill the other backends too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: what if we are *in* the postmaster?&nbsp; abort() won't kill our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * children...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fflush(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; abort();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for cancel/<a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> interrupt first --- this is so that the user can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stop a query emitting tons of notice or warning messages, even if it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in a loop that otherwise fails to check for interrupts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L635" title="utils/error/elog.c:635">errsave_start</a> --- begin a &quot;soft&quot; error-reporting cycle<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If &quot;context&quot; isn't an ErrorSaveContext node, this behaves as<br/></li>
<li></span><span class="Comment"> * <a href="#L346" title="utils/error/elog.c:346">errstart</a>(ERROR, domain), and the errsave() macro ends up acting<br/></li>
<li></span><span class="Comment"> * exactly like ereport(ERROR, ...).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If &quot;context&quot; is an ErrorSaveContext node, but the node creator only wants<br/></li>
<li></span><span class="Comment"> * notification of the fact of a soft error without <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> details, we just set<br/></li>
<li></span><span class="Comment"> * the error_occurred flag in the ErrorSaveContext node and return false,<br/></li>
<li></span><span class="Comment"> * which will cause us to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the remaining error processing steps.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Otherwise, create and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> error stack entry and return true.<br/></li>
<li></span><span class="Comment"> * Subsequently, <a href="#L1072" title="utils/error/elog.c:1072">errmsg</a>() and perhaps other routines will be called to further<br/></li>
<li></span><span class="Comment"> * populate the stack entry.&nbsp; Finally, <a href="#L687" title="utils/error/elog.c:687">errsave_finish</a>() will be called to<br/></li>
<li></span><span class="Comment"> * tidy up.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L635">&#x200c;</a></span><span class="linkable">errsave_start</span>(<span class="Type">struct</span> Node *context, <span class="Type">const</span> <span class="Type">char</span> *domain)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorSaveContext *escontext;<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do we have a context for soft error reporting?&nbsp; If not, just punt to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L346" title="utils/error/elog.c:346">errstart</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (context == <span class="Constant">NULL</span> || !IsA(context, ErrorSaveContext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L346" title="utils/error/elog.c:346">errstart</a>(ERROR, domain);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report that a soft error was detected */<br/></li>
<li></span>&nbsp; &nbsp; escontext = (ErrorSaveContext *) context;<br/></li>
<li>&nbsp; &nbsp; escontext-&gt;error_occurred = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing else to do if caller wants no further details */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!escontext-&gt;details_wanted)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Okay, crank up a stack entry to store the info in.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize data for this error frame */<br/></li>
<li></span>&nbsp; &nbsp; edata = <a href="#L757" title="utils/error/elog.c:757">get_error_stack_entry</a>();<br/></li>
<li>&nbsp; &nbsp; edata-&gt;elevel = LOG;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* signal all is well to <a href="#L687" title="utils/error/elog.c:687">errsave_finish</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L784" title="utils/error/elog.c:784">set_stack_entry_domain</a>(edata, domain);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Select default <a href="#L859" title="utils/error/elog.c:859">errcode</a> based on the assumed elevel of ERROR */<br/></li>
<li></span>&nbsp; &nbsp; edata-&gt;sqlerrcode = ERRCODE_INTERNAL_ERROR;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Any allocations for this error state level should go into the caller's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * context.&nbsp; We don't need to pollute <a href="../mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a>, or even require it to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exist, in this code path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; edata-&gt;assoc_context = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L687" title="utils/error/elog.c:687">errsave_finish</a> --- end a &quot;soft&quot; error-reporting cycle<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If <a href="#L635" title="utils/error/elog.c:635">errsave_start</a>() decided this was a regular error, behave as<br/></li>
<li></span><span class="Comment"> * <a href="#L477" title="utils/error/elog.c:477">errfinish</a>().&nbsp; Otherwise, package up the error details and save<br/></li>
<li></span><span class="Comment"> * them in the ErrorSaveContext node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L687">&#x200c;</a></span><span class="linkable">errsave_finish</span>(<span class="Type">struct</span> Node *context, <span class="Type">const</span> <span class="Type">char</span> *filename, <span class="Type">int</span> lineno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *funcname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorSaveContext *escontext = (ErrorSaveContext *) context;<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* verify stack depth <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> accessing *edata */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="#L635" title="utils/error/elog.c:635">errsave_start</a> punted to <a href="#L346" title="utils/error/elog.c:346">errstart</a>, then elevel will be ERROR or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * perhaps even PANIC.&nbsp; Punt likewise to <a href="#L477" title="utils/error/elog.c:477">errfinish</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;elevel &gt;= ERROR)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L477" title="utils/error/elog.c:477">errfinish</a>(filename, lineno, funcname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_unreachable();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Else, we should package up the stack entry contents and deliver them to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the caller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save the last few bits of error state into the stack entry */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L801" title="utils/error/elog.c:801">set_stack_entry_location</a>(edata, filename, lineno, funcname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Replace the LOG value that <a href="#L635" title="utils/error/elog.c:635">errsave_start</a> inserted */<br/></li>
<li></span>&nbsp; &nbsp; edata-&gt;elevel = ERROR;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> calling backtrace and context <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, which are more likely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to cause trouble than provide useful context; they might act on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assumption that a transaction abort is about to occur.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make a copy of the error info for the caller.&nbsp; All the subsidiary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * strings are already in the caller's context, so it's sufficient to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * flat-copy the stack entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; escontext-&gt;error_data = palloc_object(ErrorData);<br/></li>
<li>&nbsp; &nbsp; memcpy(escontext-&gt;error_data, edata, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ErrorData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exit error-handling context */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>--;<br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>--;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L757" title="utils/error/elog.c:757">get_error_stack_entry</a> --- allocate and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> a new stack entry<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The entry should be freed, when we're done with it, by calling<br/></li>
<li></span><span class="Comment"> * <a href="#L1799" title="utils/error/elog.c:1799">FreeErrorDataContents</a>() and then decrementing <a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returning the entry's address is just a notational convenience,<br/></li>
<li></span><span class="Comment"> * since it had better be <a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>].<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Although the error stack is not large, we don't expect to run out of space.<br/></li>
<li></span><span class="Comment"> * Using more than one entry implies a new error report during error recovery,<br/></li>
<li></span><span class="Comment"> * which is possible but already suggests we're in trouble.&nbsp; If we exhaust the<br/></li>
<li></span><span class="Comment"> * stack, almost certainly we are in an infinite loop of errors during error<br/></li>
<li></span><span class="Comment"> * recovery, so we give up and PANIC.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (Note that this is distinct from the <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a> checks, which<br/></li>
<li></span><span class="Comment"> * guard against recursion while handling a single stack entry.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ErrorData *<br/></li>
<li><a id="L757">&#x200c;</a><span class="linkable">get_error_stack_entry</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate error frame */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a> &gt;= <a href="#L147" title="utils/error/elog.c:147">ERRORDATA_STACK_SIZE</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wups, stack not big enough */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a> = -<span class="Constant">1</span>; <span class="Comment">/* make room on stack */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC, (<a href="#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;<a href="#L147" title="utils/error/elog.c:147">ERRORDATA_STACK_SIZE</a> exceeded&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize error frame to all zeroes/NULLs */<br/></li>
<li></span>&nbsp; &nbsp; edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li>&nbsp; &nbsp; memset(edata, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ErrorData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save errno immediately to ensure error parameter eval can't change it */<br/></li>
<li></span>&nbsp; &nbsp; edata-&gt;saved_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> edata;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L784" title="utils/error/elog.c:784">set_stack_entry_domain</a> --- fill in the internationalization domain<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L784">&#x200c;</a></span><span class="linkable">set_stack_entry_domain</span>(ErrorData *edata, <span class="Type">const</span> <span class="Type">char</span> *domain)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the default text domain is the backend's */<br/></li>
<li></span>&nbsp; &nbsp; edata-&gt;domain = domain ? domain : PG_TEXTDOMAIN(<span class="Constant">&quot;postgres&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> context_domain the same way (see <a href="#L1393" title="utils/error/elog.c:1393">set_errcontext_domain</a>()) */<br/></li>
<li></span>&nbsp; &nbsp; edata-&gt;context_domain = edata-&gt;domain;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L801" title="utils/error/elog.c:801">set_stack_entry_location</a> --- fill in code-location details<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Store the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of __FILE__, __LINE__, and __func__ from the call site.<br/></li>
<li></span><span class="Comment"> * We make an effort to normalize __FILE__, since compilers are inconsistent<br/></li>
<li></span><span class="Comment"> * about how much of the path they'll include, and we'd prefer that the<br/></li>
<li></span><span class="Comment"> * behavior not depend on that (especially, that it not vary with build path).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L801">&#x200c;</a></span><span class="linkable">set_stack_entry_location</span>(ErrorData *edata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *filename, <span class="Type">int</span> lineno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *funcname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (filename)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *slash;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep only base name, useful especially for vpath builds */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; slash = strrchr(filename, <span class="Constant">'/'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slash)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filename = slash + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Some Windows compilers use backslashes in __FILE__ strings */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; slash = strrchr(filename, <span class="Special">'\\'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slash)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filename = slash + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; edata-&gt;filename = filename;<br/></li>
<li>&nbsp; &nbsp; edata-&gt;lineno = lineno;<br/></li>
<li>&nbsp; &nbsp; edata-&gt;funcname = funcname;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L831" title="utils/error/elog.c:831">matches_backtrace_functions</a> --- checks whether the given funcname matches<br/></li>
<li></span><span class="Comment"> * <a href="../misc/guc_tables.c.html#L533" title="utils/misc/guc_tables.c:533">backtrace_functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See <a href="#L2133" title="utils/error/elog.c:2133">check_backtrace_functions</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L831">&#x200c;</a></span><span class="linkable">matches_backtrace_functions</span>(<span class="Type">const</span> <span class="Type">char</span> *funcname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *p;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L118" title="utils/error/elog.c:118">backtrace_function_list</a> || funcname == <span class="Constant">NULL</span> || funcname[<span class="Constant">0</span>] == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; p = <a href="#L118" title="utils/error/elog.c:118">backtrace_function_list</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p == <span class="Special">'\0'</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of <a href="#L118" title="utils/error/elog.c:118">backtrace_function_list</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(funcname, p) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p += strlen(p) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L859" title="utils/error/elog.c:859">errcode</a> --- add SQLSTATE error code to the current error<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The code is expected to be represented as per MAKE_SQLSTATE().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L859">&#x200c;</a></span><span class="linkable">errcode</span>(<span class="Type">int</span> sqlerrcode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we don't bother incrementing <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; edata-&gt;sqlerrcode = sqlerrcode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return value does not matter */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L882" title="utils/error/elog.c:882">errcode_for_file_access</a> --- add SQLSTATE error code to the current error<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The SQLSTATE code is chosen based on the saved errno value.&nbsp; We assume<br/></li>
<li></span><span class="Comment"> * that the failing operation was some type of disk file access.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: the primary error message string should generally include %m<br/></li>
<li></span><span class="Comment"> * when this is used.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L882">&#x200c;</a></span><span class="linkable">errcode_for_file_access</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we don't bother incrementing <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (edata-&gt;saved_errno)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Permission-denied failures */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">EPERM</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not super-user */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">EACCES</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Permission denied */<br/></li>
<li></span><span class="PreProc">#ifdef EROFS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">EROFS</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Read only file system */<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; edata-&gt;sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* File not found */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">ENOENT</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No such file or directory */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; edata-&gt;sqlerrcode = ERRCODE_UNDEFINED_FILE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Duplicate file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">EEXIST</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* File exists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; edata-&gt;sqlerrcode = ERRCODE_DUPLICATE_FILE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wrong object type or state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">ENOTDIR</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not a directory */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">EISDIR</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Is a directory */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">ENOTEMPTY</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Directory not empty */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; edata-&gt;sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Insufficient resources */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">ENOSPC</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No space left on device */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; edata-&gt;sqlerrcode = ERRCODE_DISK_FULL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">ENOMEM</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Out of memory */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; edata-&gt;sqlerrcode = ERRCODE_OUT_OF_MEMORY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">ENFILE</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* File table overflow */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">EMFILE</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Too many open files */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; edata-&gt;sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Hardware failure */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">EIO</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* I/O error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; edata-&gt;sqlerrcode = ERRCODE_IO_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* All else is classified as <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> errors */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; edata-&gt;sqlerrcode = ERRCODE_INTERNAL_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return value does not matter */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a> --- add SQLSTATE error code to the current error<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The SQLSTATE code is chosen based on the saved errno value.&nbsp; We assume<br/></li>
<li></span><span class="Comment"> * that the failing operation was some type of <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> access.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: the primary error message string should generally include %m<br/></li>
<li></span><span class="Comment"> * when this is used.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L955">&#x200c;</a></span><span class="linkable">errcode_for_socket_access</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we don't bother incrementing <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (edata-&gt;saved_errno)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Loss of connection */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ALL_CONNECTION_FAILURE_ERRNOS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; edata-&gt;sqlerrcode = ERRCODE_CONNECTION_FAILURE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* All else is classified as <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> errors */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; edata-&gt;sqlerrcode = ERRCODE_INTERNAL_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return value does not matter */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This macro handles expansion of a format string and associated parameters;<br/></li>
<li></span><span class="Comment"> * it's common code for <a href="#L1072" title="utils/error/elog.c:1072">errmsg</a>(), <a href="#L1205" title="utils/error/elog.c:1205">errdetail</a>(), etc.&nbsp; Must be called inside<br/></li>
<li></span><span class="Comment"> * a routine that is declared like &quot;const char *fmt, ...&quot; and has an edata<br/></li>
<li></span><span class="Comment"> * pointer set up.&nbsp; The message is assigned to edata-&gt;targetfield, or<br/></li>
<li></span><span class="Comment"> * appended to it if appendval is true.&nbsp; The message is subject to translation<br/></li>
<li></span><span class="Comment"> * if translateit is true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a> the buffer rather than just transferring its storage<br/></li>
<li></span><span class="Comment"> * to the edata field because the buffer might be considerably larger than<br/></li>
<li></span><span class="Comment"> * really necessary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L991">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EVALUATE_MESSAGE</span>(domain, targetfield, appendval, translateit)&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData&nbsp; &nbsp; buf; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* Internationalize the error format string */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> ((translateit) &amp;&amp; !<a href="#L297" title="utils/error/elog.c:297">in_error_recursion_trouble</a>()) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fmt = dgettext((domain), fmt);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;buf); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> ((appendval) &amp;&amp; edata-&gt;targetfield) { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, edata-&gt;targetfield); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, </span><span class="Special">'\n'</span><span class="PreProc">); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; } \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* Generate actual output --- have to use appendStringInfoVA */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">for</span><span class="PreProc"> (;;) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Type">va_list</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; args; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Type">int</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needed; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = edata-&gt;saved_errno; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; va_start(args, fmt); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needed = appendStringInfoVA(&amp;buf, fmt, args); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; va_end(args); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (needed == </span><span class="Constant">0</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">break</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; enlargeStringInfo(&amp;buf, needed); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; } \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* Save the completed message into the stack item */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (edata-&gt;targetfield) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(edata-&gt;targetfield); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; edata-&gt;targetfield = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(buf.data); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf.data); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; }<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Same as above, except for pluralized error messages.&nbsp; The calling routine<br/></li>
<li></span><span class="Comment"> * must be declared like &quot;const char *fmt_singular, const char *fmt_plural,<br/></li>
<li></span><span class="Comment"> * unsigned long n, ...&quot;.&nbsp; Translation is assumed always wanted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L1027">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EVALUATE_MESSAGE_PLURAL</span>(domain, targetfield, appendval)&nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Type">const</span><span class="PreProc"> </span><span class="Type">char</span><span class="PreProc">&nbsp; &nbsp; &nbsp;&nbsp; *fmt; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData&nbsp; &nbsp; buf; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* Internationalize the error format string */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (!<a href="#L297" title="utils/error/elog.c:297">in_error_recursion_trouble</a>()) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fmt = dngettext((domain), fmt_singular, fmt_plural, n); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">else</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fmt = (n == </span><span class="Constant">1</span><span class="PreProc"> ? fmt_singular : fmt_plural); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;buf); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> ((appendval) &amp;&amp; edata-&gt;targetfield) { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, edata-&gt;targetfield); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, </span><span class="Special">'\n'</span><span class="PreProc">); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; } \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* Generate actual output --- have to use appendStringInfoVA */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">for</span><span class="PreProc"> (;;) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Type">va_list</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; args; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Type">int</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needed; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = edata-&gt;saved_errno; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; va_start(args, n); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needed = appendStringInfoVA(&amp;buf, fmt, args); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; va_end(args); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (needed == </span><span class="Constant">0</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">break</span><span class="PreProc">; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; enlargeStringInfo(&amp;buf, needed); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; } \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* Save the completed message into the stack item */</span><span class="PreProc"> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (edata-&gt;targetfield) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(edata-&gt;targetfield); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; edata-&gt;targetfield = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(buf.data); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf.data); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; }<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1072" title="utils/error/elog.c:1072">errmsg</a> --- add a primary error message text to the current error<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In addition to the usual %-escapes recognized by printf, &quot;%m&quot; in<br/></li>
<li></span><span class="Comment"> * fmt is replaced by the error message for the caller's value of errno.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: no <a href="../../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a> is needed at the end of the fmt string, since<br/></li>
<li></span><span class="Comment"> * ereport will provide one for the output methods that need it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1072">&#x200c;</a></span><span class="linkable">errmsg</span>(<span class="Type">const</span> <span class="Type">char</span> *fmt,...)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>++;<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(edata-&gt;assoc_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; edata-&gt;message_id = fmt;<br/></li>
<li>&nbsp; &nbsp; <a href="#L991" title="utils/error/elog.c:991">EVALUATE_MESSAGE</a>(edata-&gt;domain, message, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return value does not matter */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add a backtrace to the containing ereport() call.&nbsp; This is intended to be<br/></li>
<li></span><span class="Comment"> * added temporarily during debugging.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1094">&#x200c;</a></span><span class="linkable">errbacktrace</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>++;<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(edata-&gt;assoc_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1118" title="utils/error/elog.c:1118">set_backtrace</a>(edata, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute backtrace data and add it to the supplied ErrorData.&nbsp; num_skip<br/></li>
<li></span><span class="Comment"> * specifies how many inner frames to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>.&nbsp; Use this to avoid showing the<br/></li>
<li></span><span class="Comment"> * <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> backtrace support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in the backtrace.&nbsp; This requires that<br/></li>
<li></span><span class="Comment"> * this and related <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are not inlined.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1118">&#x200c;</a></span><span class="linkable">set_backtrace</span>(ErrorData *edata, <span class="Type">int</span> num_skip)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData errtrace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;errtrace);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HAVE_BACKTRACE_SYMBOLS<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf[<span class="Constant">100</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nframes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; **strfrms;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nframes = backtrace(buf, lengthof(buf));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strfrms = backtrace_symbols(buf, nframes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strfrms == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = num_skip; i &lt; nframes; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;errtrace, <span class="Constant">&quot;</span><span class="Special">\n%s</span><span class="Constant">&quot;</span>, strfrms[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; free(strfrms);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; appendStringInfoString(&amp;errtrace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;backtrace generation is not supported by this installation&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; edata-&gt;backtrace = errtrace.data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1159" title="utils/error/elog.c:1159">errmsg_internal</a> --- add a primary error message text to the current error<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exactly like <a href="#L1072" title="utils/error/elog.c:1072">errmsg</a>() except that strings passed to <a href="#L1159" title="utils/error/elog.c:1159">errmsg_internal</a><br/></li>
<li></span><span class="Comment"> * are not translated, and are customarily left out of the<br/></li>
<li></span><span class="Comment"> * internationalization message dictionary.&nbsp; This should be used for &quot;can't<br/></li>
<li></span><span class="Comment"> * happen&quot; cases that are probably not worth spending translation effort on.<br/></li>
<li></span><span class="Comment"> * We also use this for certain cases where we *must* not try to <a href="../adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a><br/></li>
<li></span><span class="Comment"> * the message because the translation would fail and result in infinite<br/></li>
<li></span><span class="Comment"> * error recursion.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1159">&#x200c;</a></span><span class="linkable">errmsg_internal</span>(<span class="Type">const</span> <span class="Type">char</span> *fmt,...)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>++;<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(edata-&gt;assoc_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; edata-&gt;message_id = fmt;<br/></li>
<li>&nbsp; &nbsp; <a href="#L991" title="utils/error/elog.c:991">EVALUATE_MESSAGE</a>(edata-&gt;domain, message, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return value does not matter */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1182" title="utils/error/elog.c:1182">errmsg_plural</a> --- add a primary error message text to the current error,<br/></li>
<li></span><span class="Comment"> * with support for pluralization of the message text<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1182">&#x200c;</a></span><span class="linkable">errmsg_plural</span>(<span class="Type">const</span> <span class="Type">char</span> *fmt_singular, <span class="Type">const</span> <span class="Type">char</span> *fmt_plural,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">long</span> n,...)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>++;<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(edata-&gt;assoc_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; edata-&gt;message_id = fmt_singular;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1027" title="utils/error/elog.c:1027">EVALUATE_MESSAGE_PLURAL</a>(edata-&gt;domain, message, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return value does not matter */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1205" title="utils/error/elog.c:1205">errdetail</a> --- add a detail error message text to the current error<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1205">&#x200c;</a></span><span class="linkable">errdetail</span>(<span class="Type">const</span> <span class="Type">char</span> *fmt,...)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>++;<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(edata-&gt;assoc_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L991" title="utils/error/elog.c:991">EVALUATE_MESSAGE</a>(edata-&gt;domain, detail, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return value does not matter */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1232" title="utils/error/elog.c:1232">errdetail_internal</a> --- add a detail error message text to the current error<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exactly like <a href="#L1205" title="utils/error/elog.c:1205">errdetail</a>() except that strings passed to<br/></li>
<li></span><span class="Comment"> * <a href="#L1232" title="utils/error/elog.c:1232">errdetail_internal</a> are not translated, and are customarily left out of the<br/></li>
<li></span><span class="Comment"> * internationalization message dictionary.&nbsp; This should be used for detail<br/></li>
<li></span><span class="Comment"> * messages that seem not worth translating for one reason or another<br/></li>
<li></span><span class="Comment"> * (typically, that they don't seem to be useful to average users).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1232">&#x200c;</a></span><span class="linkable">errdetail_internal</span>(<span class="Type">const</span> <span class="Type">char</span> *fmt,...)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>++;<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(edata-&gt;assoc_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L991" title="utils/error/elog.c:991">EVALUATE_MESSAGE</a>(edata-&gt;domain, detail, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return value does not matter */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1253" title="utils/error/elog.c:1253">errdetail_log</a> --- add a detail_log error message text to the current error<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1253">&#x200c;</a></span><span class="linkable">errdetail_log</span>(<span class="Type">const</span> <span class="Type">char</span> *fmt,...)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>++;<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(edata-&gt;assoc_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L991" title="utils/error/elog.c:991">EVALUATE_MESSAGE</a>(edata-&gt;domain, detail_log, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return value does not matter */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1274" title="utils/error/elog.c:1274">errdetail_log_plural</a> --- add a detail_log error message text to the current error<br/></li>
<li></span><span class="Comment"> * with support for pluralization of the message text<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1274">&#x200c;</a></span><span class="linkable">errdetail_log_plural</span>(<span class="Type">const</span> <span class="Type">char</span> *fmt_singular, <span class="Type">const</span> <span class="Type">char</span> *fmt_plural,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">unsigned</span> <span class="Type">long</span> n,...)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>++;<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(edata-&gt;assoc_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1027" title="utils/error/elog.c:1027">EVALUATE_MESSAGE_PLURAL</a>(edata-&gt;domain, detail_log, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return value does not matter */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1297" title="utils/error/elog.c:1297">errdetail_plural</a> --- add a detail error message text to the current error,<br/></li>
<li></span><span class="Comment"> * with support for pluralization of the message text<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1297">&#x200c;</a></span><span class="linkable">errdetail_plural</span>(<span class="Type">const</span> <span class="Type">char</span> *fmt_singular, <span class="Type">const</span> <span class="Type">char</span> *fmt_plural,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">unsigned</span> <span class="Type">long</span> n,...)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>++;<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(edata-&gt;assoc_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1027" title="utils/error/elog.c:1027">EVALUATE_MESSAGE_PLURAL</a>(edata-&gt;domain, detail, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return value does not matter */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1319" title="utils/error/elog.c:1319">errhint</a> --- add a hint error message text to the current error<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1319">&#x200c;</a></span><span class="linkable">errhint</span>(<span class="Type">const</span> <span class="Type">char</span> *fmt,...)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>++;<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(edata-&gt;assoc_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L991" title="utils/error/elog.c:991">EVALUATE_MESSAGE</a>(edata-&gt;domain, hint, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return value does not matter */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1341" title="utils/error/elog.c:1341">errhint_plural</a> --- add a hint error message text to the current error,<br/></li>
<li></span><span class="Comment"> * with support for pluralization of the message text<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1341">&#x200c;</a></span><span class="linkable">errhint_plural</span>(<span class="Type">const</span> <span class="Type">char</span> *fmt_singular, <span class="Type">const</span> <span class="Type">char</span> *fmt_plural,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">unsigned</span> <span class="Type">long</span> n,...)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>++;<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(edata-&gt;assoc_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1027" title="utils/error/elog.c:1027">EVALUATE_MESSAGE_PLURAL</a>(edata-&gt;domain, hint, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return value does not matter */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1367" title="utils/error/elog.c:1367">errcontext_msg</a> --- add a context error message text to the current error<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike other cases, multiple calls are allowed to build up a stack of<br/></li>
<li></span><span class="Comment"> * context information.&nbsp; We assume earlier calls represent more-closely-nested<br/></li>
<li></span><span class="Comment"> * states.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1367">&#x200c;</a></span><span class="linkable">errcontext_msg</span>(<span class="Type">const</span> <span class="Type">char</span> *fmt,...)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>++;<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(edata-&gt;assoc_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L991" title="utils/error/elog.c:991">EVALUATE_MESSAGE</a>(edata-&gt;context_domain, context, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return value does not matter */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1393" title="utils/error/elog.c:1393">set_errcontext_domain</a> --- set message domain to be used by errcontext()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L1367" title="utils/error/elog.c:1367">errcontext_msg</a>() can be called from a different module than the original<br/></li>
<li></span><span class="Comment"> * ereport(), so we cannot use the message domain passed in <a href="#L346" title="utils/error/elog.c:346">errstart</a>() to<br/></li>
<li></span><span class="Comment"> * <a href="../adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> it.&nbsp; Instead, each <a href="#L1367" title="utils/error/elog.c:1367">errcontext_msg</a>() call should be preceded by<br/></li>
<li></span><span class="Comment"> * a <a href="#L1393" title="utils/error/elog.c:1393">set_errcontext_domain</a>() call to specify the domain.&nbsp; This is usually<br/></li>
<li></span><span class="Comment"> * done transparently by the errcontext() macro.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1393">&#x200c;</a></span><span class="linkable">set_errcontext_domain</span>(<span class="Type">const</span> <span class="Type">char</span> *domain)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we don't bother incrementing <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the default text domain is the backend's */<br/></li>
<li></span>&nbsp; &nbsp; edata-&gt;context_domain = domain ? domain : PG_TEXTDOMAIN(<span class="Constant">&quot;postgres&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return value does not matter */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1413" title="utils/error/elog.c:1413">errhidestmt</a> --- optionally suppress STATEMENT: field of log entry<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be called if the message text already includes the statement.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1413">&#x200c;</a></span><span class="linkable">errhidestmt</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> hide_stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we don't bother incrementing <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; edata-&gt;hide_stmt = hide_stmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return value does not matter */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1432" title="utils/error/elog.c:1432">errhidecontext</a> --- optionally suppress CONTEXT: field of log entry<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should only be used for verbose debugging messages where the repeated<br/></li>
<li></span><span class="Comment"> * inclusion of context would bloat the log volume too much.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1432">&#x200c;</a></span><span class="linkable">errhidecontext</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> hide_ctx)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we don't bother incrementing <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; edata-&gt;hide_ctx = hide_ctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return value does not matter */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1448" title="utils/error/elog.c:1448">errposition</a> --- add cursor position to the current error<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1448">&#x200c;</a></span><span class="linkable">errposition</span>(<span class="Type">int</span> cursorpos)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we don't bother incrementing <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; edata-&gt;cursorpos = cursorpos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return value does not matter */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1464" title="utils/error/elog.c:1464">internalerrposition</a> --- add <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> cursor position to the current error<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1464">&#x200c;</a></span><span class="linkable">internalerrposition</span>(<span class="Type">int</span> cursorpos)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we don't bother incrementing <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; edata-&gt;internalpos = cursorpos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return value does not matter */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1484" title="utils/error/elog.c:1484">internalerrquery</a> --- add <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> query text to the current error<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Can also pass NULL to drop the <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> query text entry.&nbsp; This case<br/></li>
<li></span><span class="Comment"> * is intended for use in error callback subroutines that are editorializing<br/></li>
<li></span><span class="Comment"> * on the layout of the error report.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1484">&#x200c;</a></span><span class="linkable">internalerrquery</span>(<span class="Type">const</span> <span class="Type">char</span> *query)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we don't bother incrementing <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;internalquery)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(edata-&gt;internalquery);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; edata-&gt;internalquery = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (query)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; edata-&gt;internalquery = <a href="../mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(edata-&gt;assoc_context, query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return value does not matter */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1514" title="utils/error/elog.c:1514">err_generic_string</a> -- used to set individual ErrorData string fields<br/></li>
<li></span><span class="Comment"> * identified by PG_DIAG_xxx codes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This intentionally only supports fields that don't use localized strings,<br/></li>
<li></span><span class="Comment"> * so that there are no translation considerations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Most potential callers should not use this directly, but instead prefer<br/></li>
<li></span><span class="Comment"> * higher-level abstractions, such as <a href="../cache/relcache.c.html#L5962" title="utils/cache/relcache.c:5962">errtablecol</a>() (see relcache.c).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1514">&#x200c;</a></span><span class="linkable">err_generic_string</span>(<span class="Type">int</span> field, <span class="Type">const</span> <span class="Type">char</span> *str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we don't bother incrementing <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (field)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PG_DIAG_SCHEMA_NAME:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1550" title="utils/error/elog.c:1550">set_errdata_field</a>(edata-&gt;assoc_context, &amp;edata-&gt;schema_name, str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PG_DIAG_TABLE_NAME:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1550" title="utils/error/elog.c:1550">set_errdata_field</a>(edata-&gt;assoc_context, &amp;edata-&gt;table_name, str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PG_DIAG_COLUMN_NAME:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1550" title="utils/error/elog.c:1550">set_errdata_field</a>(edata-&gt;assoc_context, &amp;edata-&gt;column_name, str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PG_DIAG_DATATYPE_NAME:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1550" title="utils/error/elog.c:1550">set_errdata_field</a>(edata-&gt;assoc_context, &amp;edata-&gt;datatype_name, str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PG_DIAG_CONSTRAINT_NAME:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1550" title="utils/error/elog.c:1550">set_errdata_field</a>(edata-&gt;assoc_context, &amp;edata-&gt;constraint_name, str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unsupported ErrorData field id: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, field);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return value does not matter */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1550" title="utils/error/elog.c:1550">set_errdata_field</a> --- set an ErrorData string field<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1550">&#x200c;</a></span><span class="linkable">set_errdata_field</span>(MemoryContextData *cxt, <span class="Type">char</span> **ptr, <span class="Type">const</span> <span class="Type">char</span> *str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(*ptr == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; *ptr = <a href="../mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(cxt, str);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1563" title="utils/error/elog.c:1563">geterrcode</a> --- return the currently set SQLSTATE error code<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is only intended for use in error callback subroutines, since there<br/></li>
<li></span><span class="Comment"> * is no other place outside elog.c where the concept is meaningful.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1563">&#x200c;</a></span><span class="linkable">geterrcode</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we don't bother incrementing <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> edata-&gt;sqlerrcode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1580" title="utils/error/elog.c:1580">geterrposition</a> --- return the currently set error position (0 if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is only intended for use in error callback subroutines, since there<br/></li>
<li></span><span class="Comment"> * is no other place outside elog.c where the concept is meaningful.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1580">&#x200c;</a></span><span class="linkable">geterrposition</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we don't bother incrementing <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> edata-&gt;cursorpos;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1597" title="utils/error/elog.c:1597">getinternalerrposition</a> --- same for <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> error position<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is only intended for use in error callback subroutines, since there<br/></li>
<li></span><span class="Comment"> * is no other place outside elog.c where the concept is meaningful.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1597">&#x200c;</a></span><span class="linkable">getinternalerrposition</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we don't bother incrementing <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> edata-&gt;internalpos;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Functions to allow construction of error message strings separately from<br/></li>
<li></span><span class="Comment"> * the ereport() call itself.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The expected calling convention is<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1630" title="utils/error/elog.c:1630">pre_format_elog_string</a>(errno, domain), var = <a href="#L1639" title="utils/error/elog.c:1639">format_elog_string</a>(format,...)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * which can be hidden behind a macro such as GUC_check_errdetail().&nbsp; We<br/></li>
<li></span><span class="Comment"> * assume that <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> called in the arguments of <a href="#L1639" title="utils/error/elog.c:1639">format_elog_string</a>()<br/></li>
<li></span><span class="Comment"> * cannot result in re-entrant use of these <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> --- otherwise the wrong<br/></li>
<li></span><span class="Comment"> * text domain might be used, or the wrong errno substituted for %m.&nbsp; This is<br/></li>
<li></span><span class="Comment"> * okay for the current usage with GUC check hooks, but might need further<br/></li>
<li></span><span class="Comment"> * effort someday.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result of <a href="#L1639" title="utils/error/elog.c:1639">format_elog_string</a>() is stored in <a href="../mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a>, and will<br/></li>
<li></span><span class="Comment"> * therefore survive until <a href="#L1836" title="utils/error/elog.c:1836">FlushErrorState</a>() is called.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L1626">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">save_format_errnumber</span>;<br/></li>
<li><a id="L1627">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<span class="linkable">save_format_domain</span>;<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1630">&#x200c;</a></span><span class="linkable">pre_format_elog_string</span>(<span class="Type">int</span> errnumber, <span class="Type">const</span> <span class="Type">char</span> *domain)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save errno <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> evaluation of argument <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> can change it */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1626" title="utils/error/elog.c:1626">save_format_errnumber</a> = errnumber;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save caller's text domain */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1627" title="utils/error/elog.c:1627">save_format_domain</a> = domain;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">char</span> *<br/></li>
<li><a id="L1639">&#x200c;</a><span class="linkable">format_elog_string</span>(<span class="Type">const</span> <span class="Type">char</span> *fmt,...)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; &nbsp; errdata;<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize a mostly-dummy error frame */<br/></li>
<li></span>&nbsp; &nbsp; edata = &amp;errdata;<br/></li>
<li>&nbsp; &nbsp; MemSet(edata, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ErrorData));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the default text domain is the backend's */<br/></li>
<li></span>&nbsp; &nbsp; edata-&gt;domain = <a href="#L1627" title="utils/error/elog.c:1627">save_format_domain</a> ? <a href="#L1627" title="utils/error/elog.c:1627">save_format_domain</a> : PG_TEXTDOMAIN(<span class="Constant">&quot;postgres&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set the errno to be used to interpret %m */<br/></li>
<li></span>&nbsp; &nbsp; edata-&gt;saved_errno = <a href="#L1626" title="utils/error/elog.c:1626">save_format_errnumber</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; edata-&gt;message_id = fmt;<br/></li>
<li>&nbsp; &nbsp; <a href="#L991" title="utils/error/elog.c:991">EVALUATE_MESSAGE</a>(edata-&gt;domain, message, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> edata-&gt;message;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Actual output of the top-of-stack error message<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the ereport(ERROR) case this is called from <a href="../../tcop/postgres.c.html#L4152" title="tcop/postgres.c:4152">PostgresMain</a> (or not at all,<br/></li>
<li></span><span class="Comment"> * if the error is caught by somebody).&nbsp; For all other severity levels this<br/></li>
<li></span><span class="Comment"> * is called by <a href="#L477" title="utils/error/elog.c:477">errfinish</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1672">&#x200c;</a></span><span class="linkable">EmitErrorReport</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>++;<br/></li>
<li>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(edata-&gt;assoc_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset the formatted timestamp fields <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> emitting <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> logs.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * includes all the log destinations and <a href="#L107" title="utils/error/elog.c:107">emit_log_hook</a>, as the latter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could use <a href="#L2773" title="utils/error/elog.c:2773">log_line_prefix</a> or the formatted timestamps.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L160" title="utils/error/elog.c:160">saved_timeval_set</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L164" title="utils/error/elog.c:164">formatted_log_time</a>[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call hook <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> sending message to log.&nbsp; The hook function is allowed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to turn off edata-&gt;output_to_server, so we must recheck that afterward.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Making <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other change in the content of edata is not considered<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * supported.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: the reason why the hook can only turn off output_to_server, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not turn it on, is that it'd be unreliable: we will never get here at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all if <a href="#L346" title="utils/error/elog.c:346">errstart</a>() deems the message uninteresting.&nbsp; A hook that could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * make decisions in that direction would have to hook into <a href="#L346" title="utils/error/elog.c:346">errstart</a>(),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where it would have much less information available.&nbsp; <a href="#L107" title="utils/error/elog.c:107">emit_log_hook</a> is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * intended for custom log filtering and custom log message transmission<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mechanisms.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The log hook has access to both the translated and original English<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * error message text, which is passed through to allow it to be used as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * message identifier. Note that the original text is not available for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * detail, detail_log, hint and context text elements.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;output_to_server &amp;&amp; <a href="#L107" title="utils/error/elog.c:107">emit_log_hook</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L107" title="utils/error/elog.c:107">emit_log_hook</a>) (edata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Send to server log, if enabled */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;output_to_server)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3155" title="utils/error/elog.c:3155">send_message_to_server_log</a>(edata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Send to client, if enabled */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;output_to_client)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3458" title="utils/error/elog.c:3458">send_message_to_frontend</a>(edata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>--;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1731" title="utils/error/elog.c:1731">CopyErrorData</a> --- obtain a copy of the topmost error stack entry<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is only for use in error handler code.&nbsp; The data is copied into the<br/></li>
<li></span><span class="Comment"> * current memory context, so callers should always switch away from<br/></li>
<li></span><span class="Comment"> * <a href="../mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a> first; otherwise it will be lost when <a href="#L1836" title="utils/error/elog.c:1836">FlushErrorState</a> is done.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ErrorData *<br/></li>
<li><a id="L1731">&#x200c;</a><span class="linkable">CopyErrorData</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *newedata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we don't increment <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a> because out-of-memory here does not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indicate a problem within the error subsystem.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L168" title="utils/error/elog.c:168">CHECK_STACK_DEPTH</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> != <a href="../mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy the struct itself */<br/></li>
<li></span>&nbsp; &nbsp; newedata = (ErrorData *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ErrorData));<br/></li>
<li>&nbsp; &nbsp; memcpy(newedata, edata, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ErrorData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make copies of separately-allocated fields */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newedata-&gt;message)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;message = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(newedata-&gt;message);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newedata-&gt;detail)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;detail = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(newedata-&gt;detail);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newedata-&gt;detail_log)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;detail_log = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(newedata-&gt;detail_log);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newedata-&gt;hint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;hint = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(newedata-&gt;hint);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newedata-&gt;context)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;context = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(newedata-&gt;context);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newedata-&gt;backtrace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;backtrace = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(newedata-&gt;backtrace);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newedata-&gt;schema_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;schema_name = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(newedata-&gt;schema_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newedata-&gt;table_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;table_name = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(newedata-&gt;table_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newedata-&gt;column_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;column_name = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(newedata-&gt;column_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newedata-&gt;datatype_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;datatype_name = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(newedata-&gt;datatype_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newedata-&gt;constraint_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;constraint_name = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(newedata-&gt;constraint_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newedata-&gt;internalquery)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;internalquery = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(newedata-&gt;internalquery);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use the calling context for string allocation */<br/></li>
<li></span>&nbsp; &nbsp; newedata-&gt;assoc_context = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newedata;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1787" title="utils/error/elog.c:1787">FreeErrorData</a> --- free the structure returned by <a href="#L1731" title="utils/error/elog.c:1731">CopyErrorData</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Error handlers should use this in preference to assuming they know all<br/></li>
<li></span><span class="Comment"> * the separately-allocated fields.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1787">&#x200c;</a></span><span class="linkable">FreeErrorData</span>(ErrorData *edata)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1799" title="utils/error/elog.c:1799">FreeErrorDataContents</a>(edata);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(edata);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1799" title="utils/error/elog.c:1799">FreeErrorDataContents</a> --- free the subsidiary data of an ErrorData.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This can be used on either an error stack entry or a copied ErrorData.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1799">&#x200c;</a></span><span class="linkable">FreeErrorDataContents</span>(ErrorData *edata)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;message)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(edata-&gt;message);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;detail)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(edata-&gt;detail);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;detail_log)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(edata-&gt;detail_log);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;hint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(edata-&gt;hint);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;context)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(edata-&gt;context);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;backtrace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(edata-&gt;backtrace);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;schema_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(edata-&gt;schema_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;table_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(edata-&gt;table_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;column_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(edata-&gt;column_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;datatype_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(edata-&gt;datatype_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;constraint_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(edata-&gt;constraint_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;internalquery)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(edata-&gt;internalquery);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1836" title="utils/error/elog.c:1836">FlushErrorState</a> --- flush the error state after error recovery<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be called by an error handler after it's done processing<br/></li>
<li></span><span class="Comment"> * the error; or as soon as it's done <a href="#L1731" title="utils/error/elog.c:1731">CopyErrorData</a>, if it intends to<br/></li>
<li></span><span class="Comment"> * do stuff that is likely to provoke another error.&nbsp; You are not &quot;out&quot; of<br/></li>
<li></span><span class="Comment"> * the error subsystem until you have done this.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1836">&#x200c;</a></span><span class="linkable">FlushErrorState</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset stack to empty.&nbsp; The only case where it would be more than one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deep is if we serviced an error that interrupted construction of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * another message.&nbsp; We assume control escaped out of that message<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * construction and won't ever go back.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a> = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> all data in <a href="../mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(<a href="../mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1861" title="utils/error/elog.c:1861">ThrowErrorData</a> --- report an error described by an ErrorData structure<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is somewhat like <a href="#L1920" title="utils/error/elog.c:1920">ReThrowError</a>, but it allows elevels besides ERROR,<br/></li>
<li></span><span class="Comment"> * and the boolean flags such as output_to_server are computed via the<br/></li>
<li></span><span class="Comment"> * default rules rather than being copied from the given ErrorData.<br/></li>
<li></span><span class="Comment"> * This is primarily used to re-report errors originally reported by<br/></li>
<li></span><span class="Comment"> * background worker processes and then propagated (with or without<br/></li>
<li></span><span class="Comment"> * modification) to the backend responsible for them.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1861">&#x200c;</a></span><span class="linkable">ThrowErrorData</span>(ErrorData *edata)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *newedata;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L346" title="utils/error/elog.c:346">errstart</a>(edata-&gt;elevel, edata-&gt;domain))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* error is not to be reported at all */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; newedata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>++;<br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(newedata-&gt;assoc_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy the supplied fields to the error stack entry. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;sqlerrcode != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;sqlerrcode = edata-&gt;sqlerrcode;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;message)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;message = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(edata-&gt;message);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;detail)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;detail = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(edata-&gt;detail);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;detail_log)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;detail_log = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(edata-&gt;detail_log);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;hint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;hint = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(edata-&gt;hint);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;context)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;context = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(edata-&gt;context);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;backtrace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;backtrace = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(edata-&gt;backtrace);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* assume message_id is not available */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;schema_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;schema_name = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(edata-&gt;schema_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;table_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;table_name = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(edata-&gt;table_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;column_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;column_name = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(edata-&gt;column_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;datatype_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;datatype_name = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(edata-&gt;datatype_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;constraint_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;constraint_name = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(edata-&gt;constraint_name);<br/></li>
<li>&nbsp; &nbsp; newedata-&gt;cursorpos = edata-&gt;cursorpos;<br/></li>
<li>&nbsp; &nbsp; newedata-&gt;internalpos = edata-&gt;internalpos;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;internalquery)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;internalquery = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(edata-&gt;internalquery);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process the error. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L477" title="utils/error/elog.c:477">errfinish</a>(edata-&gt;filename, edata-&gt;lineno, edata-&gt;funcname);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1920" title="utils/error/elog.c:1920">ReThrowError</a> --- re-throw a previously copied error<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A handler can do <a href="#L1731" title="utils/error/elog.c:1731">CopyErrorData</a>/<a href="#L1836" title="utils/error/elog.c:1836">FlushErrorState</a> to get out of the error<br/></li>
<li></span><span class="Comment"> * subsystem, then do some processing, and finally <a href="#L1920" title="utils/error/elog.c:1920">ReThrowError</a> to re-throw<br/></li>
<li></span><span class="Comment"> * the original error.&nbsp; This is slower than just PG_RE_THROW() but should<br/></li>
<li></span><span class="Comment"> * be used if the &quot;some processing&quot; is likely to incur another error.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1920">&#x200c;</a></span><span class="linkable">ReThrowError</span>(ErrorData *edata)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *newedata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(edata-&gt;elevel == ERROR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push the data back into the error context */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>++;<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newedata = <a href="#L757" title="utils/error/elog.c:757">get_error_stack_entry</a>();<br/></li>
<li>&nbsp; &nbsp; memcpy(newedata, edata, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ErrorData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make copies of separately-allocated fields */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newedata-&gt;message)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;message = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(newedata-&gt;message);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newedata-&gt;detail)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;detail = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(newedata-&gt;detail);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newedata-&gt;detail_log)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;detail_log = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(newedata-&gt;detail_log);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newedata-&gt;hint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;hint = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(newedata-&gt;hint);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newedata-&gt;context)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;context = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(newedata-&gt;context);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newedata-&gt;backtrace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;backtrace = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(newedata-&gt;backtrace);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newedata-&gt;schema_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;schema_name = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(newedata-&gt;schema_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newedata-&gt;table_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;table_name = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(newedata-&gt;table_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newedata-&gt;column_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;column_name = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(newedata-&gt;column_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newedata-&gt;datatype_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;datatype_name = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(newedata-&gt;datatype_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newedata-&gt;constraint_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;constraint_name = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(newedata-&gt;constraint_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newedata-&gt;internalquery)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newedata-&gt;internalquery = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(newedata-&gt;internalquery);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset the assoc_context to be <a href="../mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a> */<br/></li>
<li></span>&nbsp; &nbsp; newedata-&gt;assoc_context = <a href="../mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>--;<br/></li>
<li>&nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1970" title="utils/error/elog.c:1970">pg_re_throw</a> --- out-of-line implementation of PG_RE_THROW() macro<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1970">&#x200c;</a></span><span class="linkable">pg_re_throw</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If possible, throw the error to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> outer setjmp handler */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L96" title="utils/error/elog.c:96">PG_exception_stack</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; siglongjmp(*<a href="#L96" title="utils/error/elog.c:96">PG_exception_stack</a>, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we get here, elog(ERROR) was thrown inside a PG_TRY block, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we have <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> exited only to discover that there is no outer setjmp<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * handler to pass the error to.&nbsp; Had the error been thrown outside<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the block to begin with, we'd have promoted the error to FATAL, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the correct behavior is to make it FATAL <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>; that is, emit it and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then call <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ErrorData&nbsp; *edata = &amp;<a href="#L149" title="utils/error/elog.c:149">errordata</a>[<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a> &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(edata-&gt;elevel == ERROR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; edata-&gt;elevel = FATAL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At least in principle, the increase in severity could have changed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * where-to-output decisions, so recalculate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; edata-&gt;output_to_server = <a href="#L239" title="utils/error/elog.c:239">should_output_to_server</a>(FATAL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; edata-&gt;output_to_client = <a href="#L248" title="utils/error/elog.c:248">should_output_to_client</a>(FATAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can use <a href="#L477" title="utils/error/elog.c:477">errfinish</a>() for the rest, but we don't want it to call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error context routines a second time.&nbsp; Since we know we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about to exit, it should be OK to just clear the context stack.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L94" title="utils/error/elog.c:94">error_context_stack</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L477" title="utils/error/elog.c:477">errfinish</a>(edata-&gt;filename, edata-&gt;lineno, edata-&gt;funcname);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Doesn't return ... */<br/></li>
<li></span>&nbsp; &nbsp; <a href="assert.c.html#L30" title="utils/error/assert.c:30">ExceptionalCondition</a>(<span class="Constant">&quot;<a href="#L1970" title="utils/error/elog.c:1970">pg_re_throw</a> tried to return&quot;</span>, <span class="Constant">__FILE__</span>, <span class="Constant">__LINE__</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2025" title="utils/error/elog.c:2025">GetErrorContextStack</a> - Return the context stack, for display/diags<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>'d string in the caller's context which includes the PG<br/></li>
<li></span><span class="Comment"> * error call stack.&nbsp; It is the caller's responsibility to ensure this string<br/></li>
<li></span><span class="Comment"> * is <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>'d (or its context cleaned up) when done.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This information is collected by traversing the error contexts and calling<br/></li>
<li></span><span class="Comment"> * each context's callback function, each of which is expected to call<br/></li>
<li></span><span class="Comment"> * errcontext() to return a string which can be presented to the user.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L2025">&#x200c;</a><span class="linkable">GetErrorContextStack</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorData&nbsp; *edata;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback *econtext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Crank up a stack entry to store the info in.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; edata = <a href="#L757" title="utils/error/elog.c:757">get_error_stack_entry</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up assoc_context to be the caller's context, so <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> allocations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done (which will include edata-&gt;context) will use their context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; edata-&gt;assoc_context = <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> context callback <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to collect the context information<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into edata-&gt;context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Errors occurring in callback <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> should go through the regular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * error handling code which should handle <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> recursive errors, though we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * double-check above, just in case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (econtext = <a href="#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; econtext != <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; econtext = econtext-&gt;previous)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; econtext-&gt;callback(econtext-&gt;arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clean ourselves off the stack, <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> allocations done should have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using edata-&gt;assoc_context, which we set up earlier to be the caller's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * context, so we're free to just remove our entry off the stack and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decrement recursion depth and exit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L151" title="utils/error/elog.c:151">errordata_stack_depth</a>--;<br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="utils/error/elog.c:153">recursion_depth</a>--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Return a pointer to the string the caller asked for, which should have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * been allocated in their context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> edata-&gt;context;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialization of error output file<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2077">&#x200c;</a></span><span class="linkable">DebugFileOpen</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; istty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../init/globals.c.html#L76" title="utils/init/globals.c:76">OutputFileName</a>[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A debug-output file name was given.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure we can write the file, and <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out if it's a tty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((fd = open(<a href="../init/globals.c.html#L76" title="utils/init/globals.c:76">OutputFileName</a>, O_CREAT | O_APPEND | O_WRONLY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="PreProc">0</span><span class="Constant">666</span>)) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, <a href="../init/globals.c.html#L76" title="utils/init/globals.c:76">OutputFileName</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; istty = isatty(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; close(fd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Redirect our stderr to the debug output file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!freopen(<a href="../init/globals.c.html#L76" title="utils/init/globals.c:76">OutputFileName</a>, <span class="Constant">&quot;a&quot;</span>, <span class="Constant">stderr</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not reopen file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> as stderr: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../init/globals.c.html#L76" title="utils/init/globals.c:76">OutputFileName</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the file is a tty and we're running under the postmaster, try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> stdout there as well (if it isn't a tty then stderr will block<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * out stdout, so we may as well let stdout go wherever it was going<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (istty &amp;&amp; <a href="../init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!freopen(<a href="../init/globals.c.html#L76" title="utils/init/globals.c:76">OutputFileName</a>, <span class="Constant">&quot;a&quot;</span>, <span class="Constant">stdout</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not reopen file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> as stdout: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../init/globals.c.html#L76" title="utils/init/globals.c:76">OutputFileName</a>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for <a href="../misc/guc_tables.c.html#L533" title="utils/misc/guc_tables.c:533">backtrace_functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We split the input string, where commas separate function names<br/></li>
<li></span><span class="Comment"> * and certain whitespace chars are ignored, into a \0-separated (and<br/></li>
<li></span><span class="Comment"> * \0\0-terminated) list of function names.&nbsp; This formulation allows<br/></li>
<li></span><span class="Comment"> * easy scanning when an error is thrown while avoiding the use of<br/></li>
<li></span><span class="Comment"> * non-reentrant strtok(), as well as keeping the output data in a<br/></li>
<li></span><span class="Comment"> * single <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>() chunk.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2133">&#x200c;</a></span><span class="linkable">check_backtrace_functions</span>(<span class="Type">char</span> **<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvallen = strlen(*<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *someval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; validlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allow characters that can be C identifiers and commas as separators, as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * well as some whitespace for readability.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; validlen = strspn(*<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;0123456789_&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;abcdefghijklmnopqrstuvwxyz&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;, </span><span class="Special">\n\t</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (validlen != newvallen)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;Invalid character&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>[<span class="Constant">0</span>] == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *extra = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate space for the output and create the copy.&nbsp; We could discount<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whitespace chars to save some memory, but it doesn't seem worth the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trouble.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; someval = <a href="../misc/guc.c.html#L640" title="utils/misc/guc.c:640">guc_malloc</a>(ERROR, newvallen + <span class="Constant">1</span> + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>, j = <span class="Constant">0</span>; i &lt; newvallen; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((*<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)[i] == <span class="Constant">','</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; someval[j++] = <span class="Special">'\0'</span>;&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> item */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((*<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)[i] == <span class="Constant">' '</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (*<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)[i] == <span class="Special">'\n'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (*<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)[i] == <span class="Special">'\t'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore these */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; someval[j++] = (*<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)[i];&nbsp; &nbsp; <span class="Comment">/* copy anything else */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* two \0s end the setting */<br/></li>
<li></span>&nbsp; &nbsp; someval[j] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; someval[j + <span class="Constant">1</span>] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *extra = someval;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC assign_hook for <a href="../misc/guc_tables.c.html#L533" title="utils/misc/guc_tables.c:533">backtrace_functions</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2192">&#x200c;</a></span><span class="linkable">assign_backtrace_functions</span>(<span class="Type">const</span> <span class="Type">char</span> *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L118" title="utils/error/elog.c:118">backtrace_function_list</a> = (<span class="Type">char</span> *) extra;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for log_destination<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2201">&#x200c;</a></span><span class="linkable">check_log_destination</span>(<span class="Type">char</span> **<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *rawstring;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *elemlist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newlogdest = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *myextra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Need a modifiable copy of string */<br/></li>
<li></span>&nbsp; &nbsp; rawstring = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(*<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Parse string into list of identifiers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../adt/varlena.c.html#L3457" title="utils/adt/varlena.c:3457">SplitIdentifierString</a>(rawstring, <span class="Constant">','</span>, &amp;elemlist))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* syntax error in list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;List syntax is invalid.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rawstring);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(elemlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, elemlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tok = (<span class="Type">char</span> *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_strcasecmp(tok, <span class="Constant">&quot;stderr&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newlogdest |= LOG_DESTINATION_STDERR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strcasecmp(tok, <span class="Constant">&quot;csvlog&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newlogdest |= LOG_DESTINATION_CSVLOG;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strcasecmp(tok, <span class="Constant">&quot;jsonlog&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newlogdest |= LOG_DESTINATION_JSONLOG;<br/></li>
<li><span class="PreProc">#ifdef HAVE_SYSLOG<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strcasecmp(tok, <span class="Constant">&quot;syslog&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newlogdest |= LOG_DESTINATION_SYSLOG;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strcasecmp(tok, <span class="Constant">&quot;eventlog&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newlogdest |= LOG_DESTINATION_EVENTLOG;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;Unrecognized key <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>, tok);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rawstring);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(elemlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rawstring);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(elemlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; myextra = (<span class="Type">int</span> *) <a href="../misc/guc.c.html#L640" title="utils/misc/guc.c:640">guc_malloc</a>(ERROR, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; *myextra = newlogdest;<br/></li>
<li>&nbsp; &nbsp; *extra = (<span class="Type">void</span> *) myextra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC assign_hook for log_destination<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2263">&#x200c;</a></span><span class="linkable">assign_log_destination</span>(<span class="Type">const</span> <span class="Type">char</span> *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L112" title="utils/error/elog.c:112">Log_destination</a> = *((<span class="Type">int</span> *) extra);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC assign_hook for <a href="#L134" title="utils/error/elog.c:134">syslog_ident</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2272">&#x200c;</a></span><span class="linkable">assign_syslog_ident</span>(<span class="Type">const</span> <span class="Type">char</span> *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef HAVE_SYSLOG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * guc.c is likely to call us repeatedly with same parameters, so don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * thrash the syslog connection unnecessarily.&nbsp; Also, we do not re-open<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the connection until needed, since this routine will get called whether<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or not <a href="#L112" title="utils/error/elog.c:112">Log_destination</a> actually mentions syslog.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we make our own copy of the ident string rather than relying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on guc.c's.&nbsp; This may be overly paranoid, but it ensures that we cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * accidentally free a string that syslog is still using.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L134" title="utils/error/elog.c:134">syslog_ident</a> == <span class="Constant">NULL</span> || strcmp(<a href="#L134" title="utils/error/elog.c:134">syslog_ident</a>, <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L133" title="utils/error/elog.c:133">openlog_done</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; closelog();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L133" title="utils/error/elog.c:133">openlog_done</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; free(<a href="#L134" title="utils/error/elog.c:134">syslog_ident</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L134" title="utils/error/elog.c:134">syslog_ident</a> = strdup(<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if the strdup fails, we will cope in <a href="#L2329" title="utils/error/elog.c:2329">write_syslog</a>() */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Without syslog support, just ignore it */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC assign_hook for <a href="../misc/guc_tables.c.html#L588" title="utils/misc/guc_tables.c:588">syslog_facility</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2304">&#x200c;</a></span><span class="linkable">assign_syslog_facility</span>(<span class="Type">int</span> <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef HAVE_SYSLOG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As above, don't thrash the syslog connection unnecessarily.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../misc/guc_tables.c.html#L588" title="utils/misc/guc_tables.c:588">syslog_facility</a> != <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L133" title="utils/error/elog.c:133">openlog_done</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; closelog();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L133" title="utils/error/elog.c:133">openlog_done</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc_tables.c.html#L588" title="utils/misc/guc_tables.c:588">syslog_facility</a> = <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Without syslog support, just ignore it */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HAVE_SYSLOG<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write a message line to syslog<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2329">&#x200c;</a></span><span class="linkable">write_syslog</span>(<span class="Type">int</span> level, <span class="Type">const</span> <span class="Type">char</span> *line)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">unsigned</span> <span class="Type">long</span> seq = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *nlpos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Open syslog connection if not done yet */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L133" title="utils/error/elog.c:133">openlog_done</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; openlog(<a href="#L134" title="utils/error/elog.c:134">syslog_ident</a> ? <a href="#L134" title="utils/error/elog.c:134">syslog_ident</a> : <span class="Constant">&quot;postgres&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOG_PID | LOG_NDELAY | LOG_NOWAIT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc_tables.c.html#L588" title="utils/misc/guc_tables.c:588">syslog_facility</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L133" title="utils/error/elog.c:133">openlog_done</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We add a sequence number to each log message to suppress &quot;same&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * messages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; seq++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Our problem here is that many syslog implementations don't handle long<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * messages in an acceptable manner. While this function doesn't <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fact, it does work around by splitting up messages into smaller pieces.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We divide into multiple syslog() calls if message is too long or if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * message contains embedded <a href="../../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a>(s).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; len = strlen(line);<br/></li>
<li>&nbsp; &nbsp; nlpos = strchr(line, <span class="Special">'\n'</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L115" title="utils/error/elog.c:115">syslog_split_messages</a> &amp;&amp; (len &gt; <a href="#L130" title="utils/error/elog.c:130">PG_SYSLOG_LIMIT</a> || nlpos != <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunk_nr = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[<a href="#L130" title="utils/error/elog.c:130">PG_SYSLOG_LIMIT</a> + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buflen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if we start at a <a href="../../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a>, move ahead one char */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (line[<span class="Constant">0</span>] == <span class="Special">'\n'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; line++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we need to recompute the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a>'s position, too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nlpos = strchr(line, <span class="Special">'\n'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy one line, or as much as will fit, to buf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nlpos != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buflen = nlpos - line;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buflen = len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buflen = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(buflen, <a href="#L130" title="utils/error/elog.c:130">PG_SYSLOG_LIMIT</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(buf, line, buflen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf[buflen] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* trim to multibyte letter boundary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buflen = <a href="../mb/mbutils.c.html#L1083" title="utils/mb/mbutils.c:1083">pg_mbcliplen</a>(buf, buflen, buflen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buflen &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf[buflen] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* already <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> boundary? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (line[buflen] != <span class="Special">'\0'</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) line[buflen]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* try to divide at <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> boundary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = buflen - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (i &gt; <span class="Constant">0</span> &amp;&amp; !isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) buf[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt; <span class="Constant">0</span>)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else couldn't divide <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> boundary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buflen = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf[i] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunk_nr++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L114" title="utils/error/elog.c:114">syslog_sequence_numbers</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; syslog(level, <span class="Constant">&quot;[</span><span class="Special">%lu</span><span class="Constant">-</span><span class="Special">%d</span><span class="Constant">] </span><span class="Special">%s</span><span class="Constant">&quot;</span>, seq, chunk_nr, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; syslog(level, <span class="Constant">&quot;[</span><span class="Special">%d</span><span class="Constant">] </span><span class="Special">%s</span><span class="Constant">&quot;</span>, chunk_nr, buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; line += buflen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len -= buflen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* message short enough */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L114" title="utils/error/elog.c:114">syslog_sequence_numbers</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; syslog(level, <span class="Constant">&quot;[</span><span class="Special">%lu</span><span class="Constant">] </span><span class="Special">%s</span><span class="Constant">&quot;</span>, seq, line);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; syslog(level, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, line);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* HAVE_SYSLOG */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the PostgreSQL equivalent of the Windows ANSI code page.&nbsp; &quot;ANSI&quot; system<br/></li>
<li></span><span class="Comment"> * interfaces (e.g. CreateFileA()) expect string arguments in this encoding.<br/></li>
<li></span><span class="Comment"> * Every process in a given system will <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the same value at all times.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2441">&#x200c;</a></span><span class="linkable">GetACPEncoding</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; encoding = -<span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (encoding == -<span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; encoding = pg_codepage_to_encoding(GetACP());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> encoding;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write a message line to the windows event log<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2455">&#x200c;</a></span><span class="linkable">write_eventlog</span>(<span class="Type">int</span> level, <span class="Type">const</span> <span class="Type">char</span> *line, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WCHAR&nbsp; &nbsp; &nbsp;&nbsp; *utf16;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eventlevel = EVENTLOG_ERROR_TYPE;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> HANDLE evtHandle = INVALID_HANDLE_VALUE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (evtHandle == INVALID_HANDLE_VALUE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; evtHandle = RegisterEventSource(<span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc_tables.c.html#L511" title="utils/misc/guc_tables.c:511">event_source</a> ? <a href="../misc/guc_tables.c.html#L511" title="utils/misc/guc_tables.c:511">event_source</a> : DEFAULT_EVENT_SOURCE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (evtHandle == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; evtHandle = INVALID_HANDLE_VALUE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (level)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DEBUG5:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DEBUG4:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DEBUG3:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DEBUG2:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DEBUG1:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOG:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOG_SERVER_ONLY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INFO:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> NOTICE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eventlevel = EVENTLOG_INFORMATION_TYPE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WARNING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WARNING_CLIENT_ONLY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eventlevel = EVENTLOG_WARNING_TYPE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ERROR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FATAL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PANIC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eventlevel = EVENTLOG_ERROR_TYPE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If message character encoding matches the encoding expected by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ReportEventA(), call it to avoid the hazards of conversion.&nbsp; Otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * try to convert the message to UTF16 and write it with ReportEventW().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fall back on ReportEventA() if conversion failed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> the structure required for conversion, also fall<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * through to writing unconverted if we have not yet set up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also verify that we are not on our way into error recursion trouble due<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to error messages thrown deep inside <a href="../mb/mbutils.c.html#L1766" title="utils/mb/mbutils.c:1766">pgwin32_message_to_UTF16</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L297" title="utils/error/elog.c:297">in_error_recursion_trouble</a>() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mb/mbutils.c.html#L1308" title="utils/mb/mbutils.c:1308">GetMessageEncoding</a>() != <a href="#L2441" title="utils/error/elog.c:2441">GetACPEncoding</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; utf16 = <a href="../mb/mbutils.c.html#L1766" title="utils/mb/mbutils.c:1766">pgwin32_message_to_UTF16</a>(line, len, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (utf16)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReportEventW(evtHandle,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; eventlevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* All events are Id 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (LPCWSTR *) &amp;utf16,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> Try ReportEventA() when ReportEventW() fails? */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(utf16);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; ReportEventA(evtHandle,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; eventlevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* All events are Id 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;line,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2545">&#x200c;</a></span><span class="linkable">write_console</span>(<span class="Type">const</span> <span class="Type">char</span> *line, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to convert the message to UTF16 and write it with WriteConsoleW().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fall back on write() if anything fails.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In contrast to <a href="#L2455" title="utils/error/elog.c:2455">write_eventlog</a>(), don't <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> straight to write() based<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on the applicable encodings.&nbsp; Unlike WriteConsoleW(), write() depends<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on the suitability of the console output code page.&nbsp; Since we put<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stderr into binary mode in <a href="../../postmaster/launch_backend.c.html#L569" title="postmaster/launch_backend.c:569">SubPostmasterMain</a>(), write() skips the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessary translation anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WriteConsoleW() will fail if stderr is redirected, so just fall through<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to writing unconverted to the logfile in this case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> the structure required for conversion, also fall<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * through to writing unconverted if we have not yet set up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L297" title="utils/error/elog.c:297">in_error_recursion_trouble</a>() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../postmaster/postmaster.c.html#L353" title="postmaster/postmaster.c:353">redirection_done</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WCHAR&nbsp; &nbsp; &nbsp;&nbsp; *utf16;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; utf16len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; utf16 = <a href="../mb/mbutils.c.html#L1766" title="utils/mb/mbutils.c:1766">pgwin32_message_to_UTF16</a>(line, len, &amp;utf16len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (utf16 != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HANDLE&nbsp; &nbsp; &nbsp; &nbsp; stdHandle;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DWORD&nbsp; &nbsp; &nbsp; &nbsp; written;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stdHandle = GetStdHandle(STD_ERROR_HANDLE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (WriteConsoleW(stdHandle, utf16, utf16len, &amp;written, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(utf16);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In case WriteConsoleW() failed, fall back to writing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * message unconverted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(utf16);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Conversion on non-win32 platforms is not implemented yet. It requires<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-throw version of <a href="../mb/mbutils.c.html#L356" title="utils/mb/mbutils.c:356">pg_do_encoding_conversion</a>(), that converts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unconvertible characters to '?' without errors.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: We have a no-throw version <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. It doesn't convert to '?' though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We ignore <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error from write() here.&nbsp; We have no useful way to report<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it ... certainly whining on stderr isn't likely to be productive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rc = write(fileno(<span class="Constant">stderr</span>), line, len);<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) rc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2623" title="utils/error/elog.c:2623">get_formatted_log_time</a> -- compute and get the log timestamp.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The timestamp is computed if not set yet, so as it is kept consistent<br/></li>
<li></span><span class="Comment"> * among all the log destinations that require it to be consistent.&nbsp; Note<br/></li>
<li></span><span class="Comment"> * that the computed timestamp is returned in a static buffer, not<br/></li>
<li></span><span class="Comment"> * <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>()'d.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L2623">&#x200c;</a><span class="linkable">get_formatted_log_time</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_time_t&nbsp; &nbsp; stamp_time;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; msbuf[<span class="Constant">13</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* leave if already computed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L164" title="utils/error/elog.c:164">formatted_log_time</a>[<span class="Constant">0</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L164" title="utils/error/elog.c:164">formatted_log_time</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L160" title="utils/error/elog.c:160">saved_timeval_set</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gettimeofday(&amp;<a href="#L159" title="utils/error/elog.c:159">saved_timeval</a>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="utils/error/elog.c:160">saved_timeval_set</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stamp_time = (pg_time_t) <a href="#L159" title="utils/error/elog.c:159">saved_timeval</a>.tv_sec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we expect that guc.c will ensure that log_timezone is set up (at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * least with a minimal GMT value) <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="#L111" title="utils/error/elog.c:111">Log_line_prefix</a> can become<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nonempty or CSV/JSON mode can be selected.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_strftime(<a href="#L164" title="utils/error/elog.c:164">formatted_log_time</a>, <a href="#L162" title="utils/error/elog.c:162">FORMATTED_TS_LEN</a>,<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* leave room for milliseconds... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;%Y-%m-</span><span class="Special">%d</span><span class="Constant"> %H:%M:</span><span class="Special">%S</span><span class="Constant">&nbsp; &nbsp;&nbsp; %Z&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_localtime(&amp;stamp_time, log_timezone));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* 'paste' milliseconds into place... */<br/></li>
<li></span>&nbsp; &nbsp; sprintf(msbuf, <span class="Constant">&quot;.</span><span class="Special">%03d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) (<a href="#L159" title="utils/error/elog.c:159">saved_timeval</a>.tv_usec / <span class="Constant">1000</span>));<br/></li>
<li>&nbsp; &nbsp; memcpy(<a href="#L164" title="utils/error/elog.c:164">formatted_log_time</a> + <span class="Constant">19</span>, msbuf, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L164" title="utils/error/elog.c:164">formatted_log_time</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2661" title="utils/error/elog.c:2661">reset_formatted_start_time</a> -- reset the start timestamp<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2661">&#x200c;</a></span><span class="linkable">reset_formatted_start_time</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L163" title="utils/error/elog.c:163">formatted_start_time</a>[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2673" title="utils/error/elog.c:2673">get_formatted_start_time</a> -- compute and get the start timestamp.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The timestamp is computed if not set yet.&nbsp; Note that the computed<br/></li>
<li></span><span class="Comment"> * timestamp is returned in a static buffer, not <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>()'d.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L2673">&#x200c;</a><span class="linkable">get_formatted_start_time</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_time_t&nbsp; &nbsp; stamp_time = (pg_time_t) <a href="../init/globals.c.html#L46" title="utils/init/globals.c:46">MyStartTime</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* leave if already computed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L163" title="utils/error/elog.c:163">formatted_start_time</a>[<span class="Constant">0</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L163" title="utils/error/elog.c:163">formatted_start_time</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we expect that guc.c will ensure that log_timezone is set up (at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * least with a minimal GMT value) <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="#L111" title="utils/error/elog.c:111">Log_line_prefix</a> can become<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nonempty or CSV/JSON mode can be selected.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_strftime(<a href="#L163" title="utils/error/elog.c:163">formatted_start_time</a>, <a href="#L162" title="utils/error/elog.c:162">FORMATTED_TS_LEN</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;%Y-%m-</span><span class="Special">%d</span><span class="Constant"> %H:%M:</span><span class="Special">%S</span><span class="Constant"> %Z&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_localtime(&amp;stamp_time, log_timezone));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L163" title="utils/error/elog.c:163">formatted_start_time</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2697" title="utils/error/elog.c:2697">check_log_of_query</a> -- check if a query can be logged<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2697">&#x200c;</a></span><span class="linkable">check_log_of_query</span>(ErrorData *edata)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* log required? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L205" title="utils/error/elog.c:205">is_log_level_output</a>(edata-&gt;elevel, <a href="../misc/guc_tables.c.html#L523" title="utils/misc/guc_tables.c:523">log_min_error_statement</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* query log wanted? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;hide_stmt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* query string available? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2720" title="utils/error/elog.c:2720">get_backend_type_for_log</a> -- backend type for log entries<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a pointer to a static buffer, not <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>()'d.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L2720">&#x200c;</a><span class="linkable">get_backend_type_for_log</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *backend_type_str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a> == <a href="../init/globals.c.html#L103" title="utils/init/globals.c:103">PostmasterPid</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; backend_type_str = <span class="Constant">&quot;postmaster&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../init/miscinit.c.html#L63" title="utils/init/miscinit.c:63">MyBackendType</a> == B_BG_WORKER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; backend_type_str = <a href="../../postmaster/postmaster.c.html#L185" title="postmaster/postmaster.c:185">MyBgworkerEntry</a>-&gt;bgw_type;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; backend_type_str = <a href="../init/miscinit.c.html#L263" title="utils/init/miscinit.c:263">GetBackendTypeDesc</a>(<a href="../init/miscinit.c.html#L63" title="utils/init/miscinit.c:63">MyBackendType</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> backend_type_str;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2742" title="utils/error/elog.c:2742">process_log_prefix_padding</a> --- helper function for processing the format<br/></li>
<li></span><span class="Comment"> * string in <a href="#L2773" title="utils/error/elog.c:2773">log_line_prefix</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: This function returns NULL if it finds something which<br/></li>
<li></span><span class="Comment"> * it deems invalid in the format string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L2742">&#x200c;</a><span class="linkable">process_log_prefix_padding</span>(<span class="Type">const</span> <span class="Type">char</span> *p, <span class="Type">int</span> *ppadding)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paddingsign = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; padding = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*p == <span class="Constant">'-'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p == <span class="Special">'\0'</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Did the buf end in %- ? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; paddingsign = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* generate an int version of the numerical string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (*p &gt;= <span class="Constant">'0'</span> &amp;&amp; *p &lt;= <span class="Constant">'9'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; padding = padding * <span class="Constant">10</span> + (*p++ - <span class="Constant">'0'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* format is invalid if it ends with the padding number */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*p == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; padding *= paddingsign;<br/></li>
<li>&nbsp; &nbsp; *ppadding = padding;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> p;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Format log status information using <a href="#L111" title="utils/error/elog.c:111">Log_line_prefix</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2773">&#x200c;</a></span><span class="linkable">log_line_prefix</span>(StringInfo buf, ErrorData *edata)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L2782" title="utils/error/elog.c:2782">log_status_format</a>(buf, <a href="#L111" title="utils/error/elog.c:111">Log_line_prefix</a>, edata);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Format log status info; append to the provided buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2782">&#x200c;</a></span><span class="linkable">log_status_format</span>(StringInfo buf, <span class="Type">const</span> <span class="Type">char</span> *format, ErrorData *edata)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* static counter for line numbers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">long</span> log_line_number = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* has counter been reset in current process? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; log_my_pid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; padding;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *p;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is one of the few places where we'd rather not inherit a static<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * variable's value from the postmaster.&nbsp; But since we will, reset it when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a> changes. <a href="../init/globals.c.html#L46" title="utils/init/globals.c:46">MyStartTime</a> also changes when <a href="../init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a> does, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reset the formatted start timestamp too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (log_my_pid != <a href="../init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; log_line_number = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; log_my_pid = <a href="../init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2661" title="utils/error/elog.c:2661">reset_formatted_start_time</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; log_line_number++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (format == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in case guc hasn't run yet */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (p = format; *p != <span class="Special">'\0'</span>; p++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p != <span class="Constant">'%'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* literal char, just copy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(buf, *p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must be a '%', so <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> char */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* format error - ignore it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*p == <span class="Constant">'%'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* string contains %% */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(buf, <span class="Constant">'%'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Process <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> formatting which may exist after the '%'.&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2742" title="utils/error/elog.c:2742">process_log_prefix_padding</a> moves p past the padding number if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: Since only '-', '0' to '9' are valid formatting characters we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can do a quick check here to pre-check for formatting. If the char<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is not formatting then we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> a useless function call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Further note: At least on some platforms, passing %*s rather than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * %s to appendStringInfo() is substantially slower, so many of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cases below avoid doing that unless non-zero padding is in fact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * specified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p &gt; <span class="Constant">'9'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; padding = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((p = <a href="#L2742" title="utils/error/elog.c:2742">process_log_prefix_padding</a>(p, &amp;padding)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* process the option */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (*p)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'a'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *appname = <a href="../misc/guc_tables.c.html#L546" title="utils/misc/guc_tables.c:546">application_name</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (appname == <span class="Constant">NULL</span> || *appname == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appname = <a href="#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;[unknown]&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%*s</span><span class="Constant">&quot;</span>, padding, appname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, appname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoSpaces(buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; padding &gt; <span class="Constant">0</span> ? padding : -padding);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'b'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *backend_type_str = <a href="#L2720" title="utils/error/elog.c:2720">get_backend_type_for_log</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%*s</span><span class="Constant">&quot;</span>, padding, backend_type_str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, backend_type_str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'u'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *username = <a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;user_name;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (username == <span class="Constant">NULL</span> || *username == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; username = <a href="#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;[unknown]&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%*s</span><span class="Constant">&quot;</span>, padding, username);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, username);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoSpaces(buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; padding &gt; <span class="Constant">0</span> ? padding : -padding);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'d'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *dbname = <a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;database_name;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dbname == <span class="Constant">NULL</span> || *dbname == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dbname = <a href="#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;[unknown]&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%*s</span><span class="Constant">&quot;</span>, padding, dbname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, dbname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoSpaces(buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; padding &gt; <span class="Constant">0</span> ? padding : -padding);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'c'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; strfbuf[<span class="Constant">128</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(strfbuf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(strfbuf) - <span class="Constant">1</span>, <span class="Constant">&quot;</span><span class="Special">%lx</span><span class="Constant">.</span><span class="Special">%x</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span>) (<a href="../init/globals.c.html#L46" title="utils/init/globals.c:46">MyStartTime</a>), <a href="../init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%*s</span><span class="Constant">&quot;</span>, padding, strfbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%lx</span><span class="Constant">.</span><span class="Special">%x</span><span class="Constant">&quot;</span>, (<span class="Type">long</span>) (<a href="../init/globals.c.html#L46" title="utils/init/globals.c:46">MyStartTime</a>), <a href="../init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'p'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%*d</span><span class="Constant">&quot;</span>, padding, <a href="../init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, <a href="../init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'P'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *leader = <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;lockGroupLeader;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Show the leader only for active parallel workers. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leaves out the leader of a parallel group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (leader == <span class="Constant">NULL</span> || leader-&gt;pid == <a href="../init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoSpaces(buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; padding &gt; <span class="Constant">0</span> ? padding : -padding);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%*d</span><span class="Constant">&quot;</span>, padding, leader-&gt;pid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, leader-&gt;pid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoSpaces(buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; padding &gt; <span class="Constant">0</span> ? padding : -padding);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'l'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%*ld</span><span class="Constant">&quot;</span>, padding, log_line_number);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%ld</span><span class="Constant">&quot;</span>, log_line_number);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'m'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* force a log timestamp reset */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L164" title="utils/error/elog.c:164">formatted_log_time</a>[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L2623" title="utils/error/elog.c:2623">get_formatted_log_time</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%*s</span><span class="Constant">&quot;</span>, padding, <a href="#L164" title="utils/error/elog.c:164">formatted_log_time</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, <a href="#L164" title="utils/error/elog.c:164">formatted_log_time</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'t'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_time_t&nbsp; &nbsp; stamp_time = (pg_time_t) time(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; strfbuf[<span class="Constant">128</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_strftime(strfbuf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(strfbuf),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;%Y-%m-</span><span class="Special">%d</span><span class="Constant"> %H:%M:</span><span class="Special">%S</span><span class="Constant"> %Z&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_localtime(&amp;stamp_time, log_timezone));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%*s</span><span class="Constant">&quot;</span>, padding, strfbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, strfbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'n'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; strfbuf[<span class="Constant">128</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L160" title="utils/error/elog.c:160">saved_timeval_set</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gettimeofday(&amp;<a href="#L159" title="utils/error/elog.c:159">saved_timeval</a>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="utils/error/elog.c:160">saved_timeval_set</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(strfbuf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(strfbuf), <span class="Constant">&quot;</span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%03d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span>) <a href="#L159" title="utils/error/elog.c:159">saved_timeval</a>.tv_sec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) (<a href="#L159" title="utils/error/elog.c:159">saved_timeval</a>.tv_usec / <span class="Constant">1000</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%*s</span><span class="Constant">&quot;</span>, padding, strfbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, strfbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'s'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *start_time = <a href="#L2673" title="utils/error/elog.c:2673">get_formatted_start_time</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%*s</span><span class="Constant">&quot;</span>, padding, start_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, start_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'i'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *psdisp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; displen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; psdisp = <a href="../misc/ps_status.c.html#L530" title="utils/misc/ps_status.c:530">get_ps_display</a>(&amp;displen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%*s</span><span class="Constant">&quot;</span>, padding, psdisp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(buf, psdisp, displen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoSpaces(buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; padding &gt; <span class="Constant">0</span> ? padding : -padding);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'r'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a> &amp;&amp; <a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;remote_host)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;remote_port &amp;&amp; <a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;remote_port[<span class="Constant">0</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This option is slightly special as the port<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * number may be appended onto the end. Here we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to build 1 string which contains the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remote_host and optionally the remote_port (if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set) so we can properly align the string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *hostport;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hostport = psprintf(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%s</span><span class="Constant">)&quot;</span>, <a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;remote_host, <a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;remote_port);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%*s</span><span class="Constant">&quot;</span>, padding, hostport);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(hostport);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%*s</span><span class="Constant">&quot;</span>, padding, <a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;remote_host);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* padding is 0, so we don't need a temp buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, <a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;remote_host);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;remote_port &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;remote_port[<span class="Constant">0</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;(</span><span class="Special">%s</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;remote_port);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoSpaces(buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; padding &gt; <span class="Constant">0</span> ? padding : -padding);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'h'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a> &amp;&amp; <a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;remote_host)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%*s</span><span class="Constant">&quot;</span>, padding, <a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;remote_host);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, <a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;remote_host);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoSpaces(buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; padding &gt; <span class="Constant">0</span> ? padding : -padding);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'q'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in postmaster and friends, stop if %q is seen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in a backend, just ignore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'v'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep VXID format in sync with lockfuncs.c */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a> != <span class="Constant">NULL</span> &amp;&amp; <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.procNumber != INVALID_PROC_NUMBER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; strfbuf[<span class="Constant">128</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(strfbuf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(strfbuf) - <span class="Constant">1</span>, <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.procNumber, <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.lxid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%*s</span><span class="Constant">&quot;</span>, padding, strfbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">&quot;</span>, <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.procNumber, <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.lxid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoSpaces(buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; padding &gt; <span class="Constant">0</span> ? padding : -padding);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'x'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%*u</span><span class="Constant">&quot;</span>, padding, <a href="../../access/transam/xact.c.html#L438" title="access/transam/xact.c:438">GetTopTransactionIdIfAny</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant">&quot;</span>, <a href="../../access/transam/xact.c.html#L438" title="access/transam/xact.c:438">GetTopTransactionIdIfAny</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'e'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%*s</span><span class="Constant">&quot;</span>, padding, <a href="#L3135" title="utils/error/elog.c:3135">unpack_sql_state</a>(edata-&gt;sqlerrcode));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, <a href="#L3135" title="utils/error/elog.c:3135">unpack_sql_state</a>(edata-&gt;sqlerrcode));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'Q'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (padding != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%*lld</span><span class="Constant">&quot;</span>, padding,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span>) <a href="../activity/backend_status.c.html#L1027" title="utils/activity/backend_status.c:1027">pgstat_get_my_query_id</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%lld</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span>) <a href="../activity/backend_status.c.html#L1027" title="utils/activity/backend_status.c:1027">pgstat_get_my_query_id</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* format error - ignore it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Unpack MAKE_SQLSTATE code. Note that this returns a pointer to a<br/></li>
<li></span><span class="Comment"> * static buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L3135">&#x200c;</a><span class="linkable">unpack_sql_state</span>(<span class="Type">int</span> sql_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">char</span> buf[<span class="Constant">12</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <span class="Constant">5</span>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf[i] = PGUNSIXBIT(sql_state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sql_state &gt;&gt;= <span class="Constant">6</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf[i] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write error report to server's log<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3155">&#x200c;</a></span><span class="linkable">send_message_to_server_log</span>(ErrorData *edata)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; fallback_to_stderr = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2773" title="utils/error/elog.c:2773">log_line_prefix</a>(&amp;buf, edata);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">:&nbsp; &quot;</span>, <a href="#L89" title="utils/error/elog.c:89">_</a>(<a href="#L3636" title="utils/error/elog.c:3636">error_severity</a>(edata-&gt;elevel)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L110" title="utils/error/elog.c:110">Log_error_verbosity</a> &gt;= PGERROR_VERBOSE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: &quot;</span>, <a href="#L3135" title="utils/error/elog.c:3135">unpack_sql_state</a>(edata-&gt;sqlerrcode));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;message)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3688" title="utils/error/elog.c:3688">append_with_tabs</a>(&amp;buf, edata-&gt;message);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3688" title="utils/error/elog.c:3688">append_with_tabs</a>(&amp;buf, <a href="#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;missing error text&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;cursorpos &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <a href="#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot; at character </span><span class="Special">%d</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; edata-&gt;cursorpos);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (edata-&gt;internalpos &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <a href="#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot; at character </span><span class="Special">%d</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; edata-&gt;internalpos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;buf, <span class="Special">'\n'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L110" title="utils/error/elog.c:110">Log_error_verbosity</a> &gt;= PGERROR_DEFAULT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;detail_log)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2773" title="utils/error/elog.c:2773">log_line_prefix</a>(&amp;buf, edata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <a href="#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;DETAIL:&nbsp; &quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3688" title="utils/error/elog.c:3688">append_with_tabs</a>(&amp;buf, edata-&gt;detail_log);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, <span class="Special">'\n'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (edata-&gt;detail)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2773" title="utils/error/elog.c:2773">log_line_prefix</a>(&amp;buf, edata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <a href="#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;DETAIL:&nbsp; &quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3688" title="utils/error/elog.c:3688">append_with_tabs</a>(&amp;buf, edata-&gt;detail);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, <span class="Special">'\n'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;hint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2773" title="utils/error/elog.c:2773">log_line_prefix</a>(&amp;buf, edata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <a href="#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;HINT:&nbsp; &quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3688" title="utils/error/elog.c:3688">append_with_tabs</a>(&amp;buf, edata-&gt;hint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, <span class="Special">'\n'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;internalquery)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2773" title="utils/error/elog.c:2773">log_line_prefix</a>(&amp;buf, edata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <a href="#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;QUERY:&nbsp; &quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3688" title="utils/error/elog.c:3688">append_with_tabs</a>(&amp;buf, edata-&gt;internalquery);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, <span class="Special">'\n'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;context &amp;&amp; !edata-&gt;hide_ctx)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2773" title="utils/error/elog.c:2773">log_line_prefix</a>(&amp;buf, edata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <a href="#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;CONTEXT:&nbsp; &quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3688" title="utils/error/elog.c:3688">append_with_tabs</a>(&amp;buf, edata-&gt;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, <span class="Special">'\n'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L110" title="utils/error/elog.c:110">Log_error_verbosity</a> &gt;= PGERROR_VERBOSE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* assume no newlines in funcname or filename... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;funcname &amp;&amp; edata-&gt;filename)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2773" title="utils/error/elog.c:2773">log_line_prefix</a>(&amp;buf, edata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <a href="#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;LOCATION:&nbsp; </span><span class="Special">%s</span><span class="Constant">, </span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%d\n</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; edata-&gt;funcname, edata-&gt;filename,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; edata-&gt;lineno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (edata-&gt;filename)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2773" title="utils/error/elog.c:2773">log_line_prefix</a>(&amp;buf, edata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <a href="#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;LOCATION:&nbsp; </span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%d\n</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; edata-&gt;filename, edata-&gt;lineno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;backtrace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2773" title="utils/error/elog.c:2773">log_line_prefix</a>(&amp;buf, edata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <a href="#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;BACKTRACE:&nbsp; &quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3688" title="utils/error/elog.c:3688">append_with_tabs</a>(&amp;buf, edata-&gt;backtrace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, <span class="Special">'\n'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the user wants the query that generated this error logged, do it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2697" title="utils/error/elog.c:2697">check_log_of_query</a>(edata))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2773" title="utils/error/elog.c:2773">log_line_prefix</a>(&amp;buf, edata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <a href="#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;STATEMENT:&nbsp; &quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3688" title="utils/error/elog.c:3688">append_with_tabs</a>(&amp;buf, <a href="../../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, <span class="Special">'\n'</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HAVE_SYSLOG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Write to syslog, if enabled */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L112" title="utils/error/elog.c:112">Log_destination</a> &amp; LOG_DESTINATION_SYSLOG)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; syslog_level;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (edata-&gt;elevel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DEBUG5:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DEBUG4:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DEBUG3:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DEBUG2:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DEBUG1:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; syslog_level = LOG_DEBUG;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOG:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOG_SERVER_ONLY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INFO:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; syslog_level = LOG_INFO;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> NOTICE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WARNING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WARNING_CLIENT_ONLY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; syslog_level = LOG_NOTICE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ERROR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; syslog_level = LOG_WARNING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FATAL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; syslog_level = LOG_ERR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PANIC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; syslog_level = LOG_CRIT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2329" title="utils/error/elog.c:2329">write_syslog</a>(syslog_level, buf.data);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* HAVE_SYSLOG */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Write to eventlog, if enabled */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L112" title="utils/error/elog.c:112">Log_destination</a> &amp; LOG_DESTINATION_EVENTLOG)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2455" title="utils/error/elog.c:2455">write_eventlog</a>(edata-&gt;elevel, buf.data, buf.len);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Write to csvlog, if enabled */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L112" title="utils/error/elog.c:112">Log_destination</a> &amp; LOG_DESTINATION_CSVLOG)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Send CSV data if it's safe to do so (syslogger doesn't need the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pipe).&nbsp; If this is not possible, fallback to an entry written to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stderr.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../postmaster/postmaster.c.html#L353" title="postmaster/postmaster.c:353">redirection_done</a> || <a href="../init/miscinit.c.html#L63" title="utils/init/miscinit.c:63">MyBackendType</a> == B_LOGGER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="csvlog.c.html#L63" title="utils/error/csvlog.c:63">write_csvlog</a>(edata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fallback_to_stderr = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Write to JSON log, if enabled */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L112" title="utils/error/elog.c:112">Log_destination</a> &amp; LOG_DESTINATION_JSONLOG)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Send JSON data if it's safe to do so (syslogger doesn't need the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pipe).&nbsp; If this is not possible, fallback to an entry written to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stderr.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../postmaster/postmaster.c.html#L353" title="postmaster/postmaster.c:353">redirection_done</a> || <a href="../init/miscinit.c.html#L63" title="utils/init/miscinit.c:63">MyBackendType</a> == B_LOGGER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonlog.c.html#L109" title="utils/error/jsonlog.c:109">write_jsonlog</a>(edata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fallback_to_stderr = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Write to stderr, if enabled or if required because of a previous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * limitation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((<a href="#L112" title="utils/error/elog.c:112">Log_destination</a> &amp; LOG_DESTINATION_STDERR) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L90" title="tcop/postgres.c:90">whereToSendOutput</a> == DestDebug ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fallback_to_stderr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use the chunking protocol if we know the syslogger should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * catching stderr output, and we are not ourselves the syslogger.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, just do a vanilla write to stderr.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../postmaster/postmaster.c.html#L353" title="postmaster/postmaster.c:353">redirection_done</a> &amp;&amp; <a href="../init/miscinit.c.html#L63" title="utils/init/miscinit.c:63">MyBackendType</a> != B_LOGGER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3395" title="utils/error/elog.c:3395">write_pipe_chunks</a>(buf.data, buf.len, LOG_DESTINATION_STDERR);<br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In a win32 service environment, there is no usable stderr. Capture<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anything going there and write it to the eventlog instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If stderr redirection is active, it was OK to write to stderr above<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because that's really a pipe to the syslogger process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pgwin32_is_service())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2455" title="utils/error/elog.c:2455">write_eventlog</a>(edata-&gt;elevel, buf.data, buf.len);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2545" title="utils/error/elog.c:2545">write_console</a>(buf.data, buf.len);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If in the syslogger process, try to write messages direct to file */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../init/miscinit.c.html#L63" title="utils/init/miscinit.c:63">MyBackendType</a> == B_LOGGER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/syslogger.c.html#L1094" title="postmaster/syslogger.c:1094">write_syslogger_file</a>(buf.data, buf.len, LOG_DESTINATION_STDERR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No more need of the message formatted for stderr */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf.data);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Send data to the syslogger using the chunked protocol<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: when there are multiple backends writing into the syslogger pipe,<br/></li>
<li></span><span class="Comment"> * it's critical that each write go into the pipe indivisibly, and not<br/></li>
<li></span><span class="Comment"> * get interleaved with data from other processes.&nbsp; Fortunately, the POSIX<br/></li>
<li></span><span class="Comment"> * spec requires that writes to pipes be atomic so long as they are not<br/></li>
<li></span><span class="Comment"> * more than PIPE_BUF bytes long.&nbsp; So we divide long messages into chunks<br/></li>
<li></span><span class="Comment"> * that are no more than that length, and <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> one chunk per write() call.<br/></li>
<li></span><span class="Comment"> * The collector process knows how to reassemble the chunks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Because of the atomic write requirement, there are only two possible<br/></li>
<li></span><span class="Comment"> * results from write() here: -1 for failure, or the requested number of<br/></li>
<li></span><span class="Comment"> * bytes.&nbsp; There is not really anything we can do about a failure; retry would<br/></li>
<li></span><span class="Comment"> * probably be an infinite loop, and we can't even report the error usefully.<br/></li>
<li></span><span class="Comment"> * (There is noplace else we could <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> it!)&nbsp; So we might as well just ignore<br/></li>
<li></span><span class="Comment"> * the result from write().&nbsp; However, on some platforms you get a compiler<br/></li>
<li></span><span class="Comment"> * warning from ignoring write()'s result, so do a little dance with casting<br/></li>
<li></span><span class="Comment"> * rc to void to shut up the compiler.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3395">&#x200c;</a></span><span class="linkable">write_pipe_chunks</span>(<span class="Type">char</span> *data, <span class="Type">int</span> len, <span class="Type">int</span> dest)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PipeProtoChunk p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd = fileno(<span class="Constant">stderr</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(len &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; p.proto.nuls[<span class="Constant">0</span>] = p.proto.nuls[<span class="Constant">1</span>] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; p.proto.pid = <a href="../init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>;<br/></li>
<li>&nbsp; &nbsp; p.proto.flags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dest == LOG_DESTINATION_STDERR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p.proto.flags |= PIPE_PROTO_DEST_STDERR;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (dest == LOG_DESTINATION_CSVLOG)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p.proto.flags |= PIPE_PROTO_DEST_CSVLOG;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (dest == LOG_DESTINATION_JSONLOG)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p.proto.flags |= PIPE_PROTO_DEST_JSONLOG;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* write all but the last chunk */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (len &gt; PIPE_MAX_PAYLOAD)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no need to set PIPE_PROTO_IS_LAST yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; p.proto.len = PIPE_MAX_PAYLOAD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(p.proto.data, data, PIPE_MAX_PAYLOAD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rc = write(fd, &amp;p, PIPE_HEADER_SIZE + PIPE_MAX_PAYLOAD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) rc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data += PIPE_MAX_PAYLOAD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len -= PIPE_MAX_PAYLOAD;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* write the last chunk */<br/></li>
<li></span>&nbsp; &nbsp; p.proto.flags |= PIPE_PROTO_IS_LAST;<br/></li>
<li>&nbsp; &nbsp; p.proto.len = len;<br/></li>
<li>&nbsp; &nbsp; memcpy(p.proto.data, data, len);<br/></li>
<li>&nbsp; &nbsp; rc = write(fd, &amp;p, PIPE_HEADER_SIZE + len);<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) rc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Append a text string to the error report being built for the client.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is ordinarily identical to <a href="../../libpq/pqformat.c.html#L195" title="libpq/pqformat.c:195">pq_sendstring</a>(), but if we are in<br/></li>
<li></span><span class="Comment"> * error recursion trouble we <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> encoding conversion, because of the<br/></li>
<li></span><span class="Comment"> * possibility that the problem is a failure in the encoding conversion<br/></li>
<li></span><span class="Comment"> * subsystem itself.&nbsp; Code elsewhere should ensure that the passed-in<br/></li>
<li></span><span class="Comment"> * strings will be plain 7-<a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> ASCII, and thus not in need of conversion,<br/></li>
<li></span><span class="Comment"> * in such cases.&nbsp; (In particular, we disable localization of error messages<br/></li>
<li></span><span class="Comment"> * to <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> ensure that's true.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3446">&#x200c;</a></span><span class="linkable">err_sendstring</span>(StringInfo buf, <span class="Type">const</span> <span class="Type">char</span> *str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L297" title="utils/error/elog.c:297">in_error_recursion_trouble</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L227" title="libpq/pqformat.c:227">pq_send_ascii_string</a>(buf, str);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L195" title="libpq/pqformat.c:195">pq_sendstring</a>(buf, str);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write error report to client<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3458">&#x200c;</a></span><span class="linkable">send_message_to_frontend</span>(ErrorData *edata)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData msgbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We no longer support pre-3.0 FE/BE protocol, except here.&nbsp; If a client<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tries to <a href="../../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> using an older protocol version, it's nice to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;protocol version not supported&quot; error in a format the client<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * understands.&nbsp; If protocol hasn't been set yet, early in backend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * startup, assume modern protocol.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_PROTOCOL_MAJOR(<a href="../init/globals.c.html#L28" title="utils/init/globals.c:28">FrontendProtocol</a>) &gt;= <span class="Constant">3</span> || <a href="../init/globals.c.html#L28" title="utils/init/globals.c:28">FrontendProtocol</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* New style with separate fields */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *sev;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; tbuf[<span class="Constant">12</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* 'N' (Notice) is for nonfatal conditions, 'E' is for errors */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;elevel &lt; ERROR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L88" title="libpq/pqformat.c:88">pq_beginmessage</a>(&amp;msgbuf, PqMsg_NoticeResponse);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L88" title="libpq/pqformat.c:88">pq_beginmessage</a>(&amp;msgbuf, PqMsg_ErrorResponse);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sev = <a href="#L3636" title="utils/error/elog.c:3636">error_severity</a>(edata-&gt;elevel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(&amp;msgbuf, PG_DIAG_SEVERITY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3446" title="utils/error/elog.c:3446">err_sendstring</a>(&amp;msgbuf, <a href="#L89" title="utils/error/elog.c:89">_</a>(sev));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(&amp;msgbuf, PG_DIAG_SEVERITY_NONLOCALIZED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3446" title="utils/error/elog.c:3446">err_sendstring</a>(&amp;msgbuf, sev);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(&amp;msgbuf, PG_DIAG_SQLSTATE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3446" title="utils/error/elog.c:3446">err_sendstring</a>(&amp;msgbuf, <a href="#L3135" title="utils/error/elog.c:3135">unpack_sql_state</a>(edata-&gt;sqlerrcode));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* M field is required per protocol, so always <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> something */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(&amp;msgbuf, PG_DIAG_MESSAGE_PRIMARY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;message)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3446" title="utils/error/elog.c:3446">err_sendstring</a>(&amp;msgbuf, edata-&gt;message);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3446" title="utils/error/elog.c:3446">err_sendstring</a>(&amp;msgbuf, <a href="#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;missing error text&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;detail)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(&amp;msgbuf, PG_DIAG_MESSAGE_DETAIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3446" title="utils/error/elog.c:3446">err_sendstring</a>(&amp;msgbuf, edata-&gt;detail);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* detail_log is intentionally not used here */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;hint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(&amp;msgbuf, PG_DIAG_MESSAGE_HINT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3446" title="utils/error/elog.c:3446">err_sendstring</a>(&amp;msgbuf, edata-&gt;hint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;context)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(&amp;msgbuf, PG_DIAG_CONTEXT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3446" title="utils/error/elog.c:3446">err_sendstring</a>(&amp;msgbuf, edata-&gt;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;schema_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(&amp;msgbuf, PG_DIAG_SCHEMA_NAME);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3446" title="utils/error/elog.c:3446">err_sendstring</a>(&amp;msgbuf, edata-&gt;schema_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;table_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(&amp;msgbuf, PG_DIAG_TABLE_NAME);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3446" title="utils/error/elog.c:3446">err_sendstring</a>(&amp;msgbuf, edata-&gt;table_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;column_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(&amp;msgbuf, PG_DIAG_COLUMN_NAME);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3446" title="utils/error/elog.c:3446">err_sendstring</a>(&amp;msgbuf, edata-&gt;column_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;datatype_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(&amp;msgbuf, PG_DIAG_DATATYPE_NAME);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3446" title="utils/error/elog.c:3446">err_sendstring</a>(&amp;msgbuf, edata-&gt;datatype_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;constraint_name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(&amp;msgbuf, PG_DIAG_CONSTRAINT_NAME);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3446" title="utils/error/elog.c:3446">err_sendstring</a>(&amp;msgbuf, edata-&gt;constraint_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;cursorpos &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(tbuf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tbuf), <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, edata-&gt;cursorpos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(&amp;msgbuf, PG_DIAG_STATEMENT_POSITION);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3446" title="utils/error/elog.c:3446">err_sendstring</a>(&amp;msgbuf, tbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;internalpos &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(tbuf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tbuf), <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, edata-&gt;internalpos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(&amp;msgbuf, PG_DIAG_INTERNAL_POSITION);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3446" title="utils/error/elog.c:3446">err_sendstring</a>(&amp;msgbuf, tbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;internalquery)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(&amp;msgbuf, PG_DIAG_INTERNAL_QUERY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3446" title="utils/error/elog.c:3446">err_sendstring</a>(&amp;msgbuf, edata-&gt;internalquery);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;filename)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(&amp;msgbuf, PG_DIAG_SOURCE_FILE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3446" title="utils/error/elog.c:3446">err_sendstring</a>(&amp;msgbuf, edata-&gt;filename);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;lineno &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(tbuf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tbuf), <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, edata-&gt;lineno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(&amp;msgbuf, PG_DIAG_SOURCE_LINE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3446" title="utils/error/elog.c:3446">err_sendstring</a>(&amp;msgbuf, tbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;funcname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(&amp;msgbuf, PG_DIAG_SOURCE_FUNCTION);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3446" title="utils/error/elog.c:3446">err_sendstring</a>(&amp;msgbuf, edata-&gt;funcname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(&amp;msgbuf, <span class="Special">'\0'</span>); <span class="Comment">/* terminator */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L296" title="libpq/pqformat.c:296">pq_endmessage</a>(&amp;msgbuf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Old style --- gin up a backwards-compatible message */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">:&nbsp; &quot;</span>, <a href="#L89" title="utils/error/elog.c:89">_</a>(<a href="#L3636" title="utils/error/elog.c:3636">error_severity</a>(edata-&gt;elevel)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;message)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, edata-&gt;message);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <a href="#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;missing error text&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, <span class="Special">'\n'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* 'N' (Notice) is for nonfatal conditions, 'E' is for errors */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqcomm.c.html#L1558" title="libpq/pqcomm.c:1558">pq_putmessage_v2</a>((edata-&gt;elevel &lt; ERROR) ? <span class="Constant">'N'</span> : <span class="Constant">'E'</span>, buf.data, buf.len + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf.data);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This flush is normally not necessary, since postgres.c will flush out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> data when control returns to the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop. But it seems best<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to leave it here, so that the client has some clue what happened if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backend dies <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> getting back to the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop ... error/notice<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * messages should not be a performance-critical path anyway, so an extra<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * flush won't hurt much ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pq_flush();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Support routines for formatting error messages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3636" title="utils/error/elog.c:3636">error_severity</a> --- get string representing elevel<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The string is not localized here, but we mark the strings for translation<br/></li>
<li></span><span class="Comment"> * so that callers can invoke <a href="#L89" title="utils/error/elog.c:89">_</a>() on the result.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L3636">&#x200c;</a><span class="linkable">error_severity</span>(<span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *prefix;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (elevel)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DEBUG1:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DEBUG2:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DEBUG3:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DEBUG4:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DEBUG5:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefix = gettext_noop(<span class="Constant">&quot;DEBUG&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOG:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOG_SERVER_ONLY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefix = gettext_noop(<span class="Constant">&quot;LOG&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INFO:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefix = gettext_noop(<span class="Constant">&quot;INFO&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> NOTICE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefix = gettext_noop(<span class="Constant">&quot;NOTICE&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WARNING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WARNING_CLIENT_ONLY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefix = gettext_noop(<span class="Constant">&quot;WARNING&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ERROR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefix = gettext_noop(<span class="Constant">&quot;ERROR&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FATAL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefix = gettext_noop(<span class="Constant">&quot;FATAL&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PANIC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefix = gettext_noop(<span class="Constant">&quot;PANIC&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefix = <span class="Constant">&quot;???&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> prefix;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L3688" title="utils/error/elog.c:3688">append_with_tabs</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Append the string to the StringInfo buffer, inserting a tab after <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3688">&#x200c;</a></span><span class="linkable">append_with_tabs</span>(StringInfo buf, <span class="Type">const</span> <span class="Type">char</span> *str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; ch;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((ch = *str++) != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoCharMacro(buf, ch);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ch == <span class="Special">'\n'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoCharMacro(buf, <span class="Special">'\t'</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write errors to stderr (or by <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> means when stderr is<br/></li>
<li></span><span class="Comment"> * not available). Used <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> ereport/elog can be used<br/></li>
<li></span><span class="Comment"> * safely (memory context, GUC load etc)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3707">&#x200c;</a></span><span class="linkable">write_stderr</span>(<span class="Type">const</span> <span class="Type">char</span> *fmt,...)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">va_list</span>&nbsp; &nbsp; &nbsp; &nbsp; ap;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; errbuf[<span class="Constant">2048</span>];&nbsp; &nbsp; <span class="Comment">/* Arbitrary size? */<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; fmt = <a href="#L89" title="utils/error/elog.c:89">_</a>(fmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; va_start(ap, fmt);<br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* On Unix, we just fprintf to stderr */<br/></li>
<li></span>&nbsp; &nbsp; vfprintf(<span class="Constant">stderr</span>, fmt, ap);<br/></li>
<li>&nbsp; &nbsp; fflush(<span class="Constant">stderr</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; vsnprintf(errbuf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(errbuf), fmt, ap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On Win32, we <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> to stderr if running on a console, or write to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * eventlog if running as a service<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pgwin32_is_service())&nbsp; &nbsp; <span class="Comment">/* Running as a service */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2455" title="utils/error/elog.c:2455">write_eventlog</a>(ERROR, errbuf, strlen(errbuf));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not running as service, write to stderr */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2545" title="utils/error/elog.c:2545">write_console</a>(errbuf, strlen(errbuf));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fflush(<span class="Constant">stderr</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; va_end(ap);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
