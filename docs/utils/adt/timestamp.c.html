<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/timestamp.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/timestamp.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L55">PgReloadTime</a></li>
<li><a href="#L52">PgStartTime</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L78">IntervalAggState</a></li>
<li><a href="#L85">IntervalAggState</a></li>
<li><a href="#L63">generate_series_timestamp_fctx</a></li>
<li><a href="#L72">generate_series_timestamptz_fctx</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1359">AdjustIntervalForTypmod</a></li>
<li><a href="#L366">AdjustTimestampForTypmod</a></li>
<li><a href="#L1607">EncodeSpecialInterval</a></li>
<li><a href="#L1596">EncodeSpecialTimestamp</a></li>
<li><a href="#L1654">GetCurrentTimestamp</a></li>
<li><a href="#L2168">GetEpochTime</a></li>
<li><a href="#L1672">GetSQLCurrentTimestamp</a></li>
<li><a href="#L1686">GetSQLLocalTimestamp</a></li>
<li><a href="#L5894">NonFiniteIntervalPart</a></li>
<li><a href="#L5284">NonFiniteTimestampTzPart</a></li>
<li><a href="#L2190">SetEpochTimestamp</a></li>
<li><a href="#L1730">TimestampDifference</a></li>
<li><a href="#L1790">TimestampDifferenceExceeds</a></li>
<li><a href="#L1766">TimestampDifferenceMilliseconds</a></li>
<li><a href="#L6261">TimestampTimestampTzRequiresRewrite</a></li>
<li><a href="#L123">anytimestamp_typmod_check</a></li>
<li><a href="#L102">anytimestamp_typmodin</a></li>
<li><a href="#L145">anytimestamp_typmodout</a></li>
<li><a href="#L1630">clock_timestamp</a></li>
<li><a href="#L5155">date2isoweek</a></li>
<li><a href="#L5210">date2isoyear</a></li>
<li><a href="#L5267">date2isoyearday</a></li>
<li><a href="#L3936">do_interval_accum</a></li>
<li><a href="#L3959">do_interval_discard</a></li>
<li><a href="#L2134">dt2local</a></li>
<li><a href="#L1874">dt2time</a></li>
<li><a href="#L6137">extract_interval</a></li>
<li><a href="#L5605">extract_timestamp</a></li>
<li><a href="#L5877">extract_timestamptz</a></li>
<li><a href="#L3491">finite_interval_mi</a></li>
<li><a href="#L3435">finite_interval_pl</a></li>
<li><a href="#L735">float8_timestamptz</a></li>
<li><a href="#L6494">generate_series_timestamp</a></li>
<li><a href="#L6660">generate_series_timestamptz</a></li>
<li><a href="#L6666">generate_series_timestamptz_at_zone</a></li>
<li><a href="#L6578">generate_series_timestamptz_internal</a></li>
<li><a href="#L3864">in_range_interval_interval</a></li>
<li><a href="#L3823">in_range_timestamp_interval</a></li>
<li><a href="#L3786">in_range_timestamptz_interval</a></li>
<li><a href="#L2047">interval2itm</a></li>
<li><a href="#L4155">interval_avg</a></li>
<li><a href="#L3990">interval_avg_accum</a></li>
<li><a href="#L4137">interval_avg_accum_inv</a></li>
<li><a href="#L4013">interval_avg_combine</a></li>
<li><a href="#L4094">interval_avg_deserialize</a></li>
<li><a href="#L4056">interval_avg_serialize</a></li>
<li><a href="#L2577">interval_cmp</a></li>
<li><a href="#L2505">interval_cmp_internal</a></li>
<li><a href="#L2483">interval_cmp_value</a></li>
<li><a href="#L3685">interval_div</a></li>
<li><a href="#L2523">interval_eq</a></li>
<li><a href="#L2155">interval_finite</a></li>
<li><a href="#L2568">interval_ge</a></li>
<li><a href="#L2550">interval_gt</a></li>
<li><a href="#L2593">interval_hash</a></li>
<li><a href="#L2611">interval_hash_extended</a></li>
<li><a href="#L900">interval_in</a></li>
<li><a href="#L3002">interval_justify_days</a></li>
<li><a href="#L2960">interval_justify_hours</a></li>
<li><a href="#L2880">interval_justify_interval</a></li>
<li><a href="#L3421">interval_larger</a></li>
<li><a href="#L2559">interval_le</a></li>
<li><a href="#L2541">interval_lt</a></li>
<li><a href="#L3506">interval_mi</a></li>
<li><a href="#L3555">interval_mul</a></li>
<li><a href="#L2532">interval_ne</a></li>
<li><a href="#L982">interval_out</a></li>
<li><a href="#L6131">interval_part</a></li>
<li><a href="#L5939">interval_part_common</a></li>
<li><a href="#L3450">interval_pl</a></li>
<li><a href="#L1006">interval_recv</a></li>
<li><a href="#L1337">interval_scale</a></li>
<li><a href="#L1031">interval_send</a></li>
<li><a href="#L2514">interval_sign</a></li>
<li><a href="#L3406">interval_smaller</a></li>
<li><a href="#L4195">interval_sum</a></li>
<li><a href="#L1274">interval_support</a></li>
<li><a href="#L5005">interval_trunc</a></li>
<li><a href="#L3393">interval_um</a></li>
<li><a href="#L3373">interval_um_internal</a></li>
<li><a href="#L1056">intervaltypmodin</a></li>
<li><a href="#L1221">intervaltypmodleastfield</a></li>
<li><a href="#L1135">intervaltypmodout</a></li>
<li><a href="#L5124">isoweek2date</a></li>
<li><a href="#L5104">isoweek2j</a></li>
<li><a href="#L5137">isoweekdate2date</a></li>
<li><a href="#L2077">itm2interval</a></li>
<li><a href="#L2115">itmin2interval</a></li>
<li><a href="#L558">lookup_timezone</a></li>
<li><a href="#L3914">makeIntervalAggState</a></li>
<li><a href="#L1539">make_interval</a></li>
<li><a href="#L654">make_timestamp</a></li>
<li><a href="#L572">make_timestamp_internal</a></li>
<li><a href="#L674">make_timestamptz</a></li>
<li><a href="#L695">make_timestamptz_at_timezone</a></li>
<li><a href="#L3675">mul_d_interval</a></li>
<li><a href="#L1618">now</a></li>
<li><a href="#L2631">overlaps_timestamp</a></li>
<li><a href="#L489">parse_sane_timezone</a></li>
<li><a href="#L1642">pg_conf_load_time</a></li>
<li><a href="#L1636">pg_postmaster_start_time</a></li>
<li><a href="#L1624">statement_timestamp</a></li>
<li><a href="#L2128">time2t</a></li>
<li><a href="#L1811">time_t_to_timestamptz</a></li>
<li><a href="#L1700">timeofday</a></li>
<li><a href="#L6344">timestamp2timestamptz</a></li>
<li><a href="#L6292">timestamp2timestamptz_opt_overflow</a></li>
<li><a href="#L1901">timestamp2tm</a></li>
<li><a href="#L4235">timestamp_age</a></li>
<li><a href="#L6680">timestamp_at_local</a></li>
<li><a href="#L4535">timestamp_bin</a></li>
<li><a href="#L2270">timestamp_cmp</a></li>
<li><a href="#L2210">timestamp_cmp_internal</a></li>
<li><a href="#L2400">timestamp_cmp_timestamptz</a></li>
<li><a href="#L2325">timestamp_cmp_timestamptz_internal</a></li>
<li><a href="#L2216">timestamp_eq</a></li>
<li><a href="#L2346">timestamp_eq_timestamptz</a></li>
<li><a href="#L2281">timestamp_fastcmp</a></li>
<li><a href="#L2147">timestamp_finite</a></li>
<li><a href="#L2261">timestamp_ge</a></li>
<li><a href="#L2391">timestamp_ge_timestamptz</a></li>
<li><a href="#L2243">timestamp_gt</a></li>
<li><a href="#L2373">timestamp_gt_timestamptz</a></li>
<li><a href="#L2309">timestamp_hash</a></li>
<li><a href="#L2315">timestamp_hash_extended</a></li>
<li><a href="#L164">timestamp_in</a></li>
<li><a href="#L6217">timestamp_izone</a></li>
<li><a href="#L2771">timestamp_larger</a></li>
<li><a href="#L2252">timestamp_le</a></li>
<li><a href="#L2382">timestamp_le_timestamptz</a></li>
<li><a href="#L2234">timestamp_lt</a></li>
<li><a href="#L2364">timestamp_lt_timestamptz</a></li>
<li><a href="#L2786">timestamp_mi</a></li>
<li><a href="#L3160">timestamp_mi_interval</a></li>
<li><a href="#L2225">timestamp_ne</a></li>
<li><a href="#L2355">timestamp_ne_timestamptz</a></li>
<li><a href="#L232">timestamp_out</a></li>
<li><a href="#L5599">timestamp_part</a></li>
<li><a href="#L5341">timestamp_part_common</a></li>
<li><a href="#L3049">timestamp_pl_interval</a></li>
<li><a href="#L258">timestamp_recv</a></li>
<li><a href="#L345">timestamp_scale</a></li>
<li><a href="#L291">timestamp_send</a></li>
<li><a href="#L2756">timestamp_smaller</a></li>
<li><a href="#L2291">timestamp_sortsupport</a></li>
<li><a href="#L325">timestamp_support</a></li>
<li><a href="#L6274">timestamp_timestamptz</a></li>
<li><a href="#L4606">timestamp_trunc</a></li>
<li><a href="#L6152">timestamp_zone</a></li>
<li><a href="#L302">timestamptypmodin</a></li>
<li><a href="#L310">timestamptypmodout</a></li>
<li><a href="#L6361">timestamptz2timestamp</a></li>
<li><a href="#L4381">timestamptz_age</a></li>
<li><a href="#L6686">timestamptz_at_local</a></li>
<li><a href="#L4740">timestamptz_bin</a></li>
<li><a href="#L2463">timestamptz_cmp_timestamp</a></li>
<li><a href="#L2409">timestamptz_eq_timestamp</a></li>
<li><a href="#L2454">timestamptz_ge_timestamp</a></li>
<li><a href="#L2436">timestamptz_gt_timestamp</a></li>
<li><a href="#L416">timestamptz_in</a></li>
<li><a href="#L6454">timestamptz_izone</a></li>
<li><a href="#L2445">timestamptz_le_timestamp</a></li>
<li><a href="#L2427">timestamptz_lt_timestamp</a></li>
<li><a href="#L3336">timestamptz_mi_interval</a></li>
<li><a href="#L3359">timestamptz_mi_interval_at_zone</a></li>
<li><a href="#L3312">timestamptz_mi_interval_internal</a></li>
<li><a href="#L2418">timestamptz_ne_timestamp</a></li>
<li><a href="#L785">timestamptz_out</a></li>
<li><a href="#L5871">timestamptz_part</a></li>
<li><a href="#L5614">timestamptz_part_common</a></li>
<li><a href="#L3327">timestamptz_pl_interval</a></li>
<li><a href="#L3348">timestamptz_pl_interval_at_zone</a></li>
<li><a href="#L3186">timestamptz_pl_interval_internal</a></li>
<li><a href="#L813">timestamptz_recv</a></li>
<li><a href="#L879">timestamptz_scale</a></li>
<li><a href="#L847">timestamptz_send</a></li>
<li><a href="#L6353">timestamptz_timestamp</a></li>
<li><a href="#L1853">timestamptz_to_str</a></li>
<li><a href="#L1833">timestamptz_to_time_t</a></li>
<li><a href="#L4958">timestamptz_trunc</a></li>
<li><a href="#L4814">timestamptz_trunc_internal</a></li>
<li><a href="#L4976">timestamptz_trunc_zone</a></li>
<li><a href="#L6390">timestamptz_zone</a></li>
<li><a href="#L858">timestamptztypmodin</a></li>
<li><a href="#L866">timestamptztypmodout</a></li>
<li><a href="#L1997">tm2timestamp</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L87">IA_TOTAL_COUNT</a></li>
<li><a href="#L49">SAMESIGN</a></li>
<li><a href="#L2647">TIMESTAMP_GT</a></li>
<li><a href="#L2746">TIMESTAMP_GT</a></li>
<li><a href="#L2649">TIMESTAMP_LT</a></li>
<li><a href="#L2747">TIMESTAMP_LT</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * timestamp.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Functions for the built-in SQL types &quot;timestamp&quot; and &quot;interval&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/timestamp.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;ctype.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/time.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/int.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/int128.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/supportnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/scansup.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/date.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datetime.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/float.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/<a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/sortsupport.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * gcc's -ffast-math switch breaks routines that expect exact results from<br/></li>
<li></span><span class="Comment"> * expressions like timeval / SECS_PER_HOUR, where timeval is double.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef __FAST_MATH__<br/></li>
<li></span><span class="PreProc">#error -ffast-math is known to </span><span class="Statement">break</span><span class="PreProc"> this code<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L49">&#x200c;</a><span class="PreProc">#define <span class="linkable">SAMESIGN</span>(a,b)&nbsp; &nbsp; (((a) &lt; </span><span class="Constant">0</span><span class="PreProc">) == ((b) &lt; </span><span class="Constant">0</span><span class="PreProc">))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Set at postmaster start */<br/></li>
<li><a id="L52">&#x200c;</a></span>TimestampTz <span class="linkable">PgStartTime</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Set at configuration reload */<br/></li>
<li><a id="L55">&#x200c;</a></span>TimestampTz <span class="linkable">PgReloadTime</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; current;<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; finish;<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp; &nbsp; step;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; step_sign;<br/></li>
<li><a id="L63">&#x200c;</a>} <span class="linkable">generate_series_timestamp_fctx</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz current;<br/></li>
<li>&nbsp; &nbsp; TimestampTz finish;<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp; &nbsp; step;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; step_sign;<br/></li>
<li>&nbsp; &nbsp; pg_tz&nbsp; &nbsp; &nbsp;&nbsp; *attimezone;<br/></li>
<li><a id="L72">&#x200c;</a>} <span class="linkable">generate_series_timestamptz_fctx</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The transition datatype for interval aggregates is declared as <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>.<br/></li>
<li></span><span class="Comment"> * It's a pointer to an <a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a> allocated in the aggregate context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L78">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">IntervalAggState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; N;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* count of finite intervals processed */<br/></li>
<li></span>&nbsp; &nbsp; Interval&nbsp; &nbsp; sumX;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* sum of finite intervals processed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* These counts are *not* included in N!&nbsp; Use <a href="#L87" title="utils/adt/timestamp.c:87">IA_TOTAL_COUNT</a>() as needed */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pInfcount;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* count of +infinity intervals */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; nInfcount;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* count of -infinity intervals */<br/></li>
<li><a id="L85">&#x200c;</a></span>} <span class="linkable">IntervalAggState</span>;<br/></li>
<li><br/></li>
<li><a id="L87">&#x200c;</a><span class="PreProc">#define <span class="linkable">IA_TOTAL_COUNT</span>(ia) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((ia)-&gt;N + (ia)-&gt;pInfcount + (ia)-&gt;nInfcount)<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> TimeOffset <a href="#L2128" title="utils/adt/timestamp.c:2128">time2t</a>(<span class="Type">const</span> <span class="Type">int</span> hour, <span class="Type">const</span> <span class="Type">int</span> min, <span class="Type">const</span> <span class="Type">int</span> sec, <span class="Type">const</span> fsec_t fsec);<br/></li>
<li><span class="Type">static</span> Timestamp <a href="#L2134" title="utils/adt/timestamp.c:2134">dt2local</a>(Timestamp dt, <span class="Type">int</span> timezone);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1359" title="utils/adt/timestamp.c:1359">AdjustIntervalForTypmod</a>(Interval *interval, int32 typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *escontext);<br/></li>
<li><span class="Type">static</span> TimestampTz <a href="#L6344" title="utils/adt/timestamp.c:6344">timestamp2timestamptz</a>(Timestamp timestamp);<br/></li>
<li><span class="Type">static</span> Timestamp <a href="#L6361" title="utils/adt/timestamp.c:6361">timestamptz2timestamp</a>(TimestampTz timestamp);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1607" title="utils/adt/timestamp.c:1607">EncodeSpecialInterval</a>(<span class="Type">const</span> Interval *interval, <span class="Type">char</span> *str);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3373" title="utils/adt/timestamp.c:3373">interval_um_internal</a>(<span class="Type">const</span> Interval *interval, Interval *result);<br/></li>
<li><br/></li>
<li><span class="Comment">/* common code for <a href="#L302" title="utils/adt/timestamp.c:302">timestamptypmodin</a> and <a href="#L858" title="utils/adt/timestamp.c:858">timestamptztypmodin</a> */<br/></li>
<li></span><span class="Type">static</span> int32<br/></li>
<li><a id="L102">&#x200c;</a><span class="linkable">anytimestamp_typmodin</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> istz, ArrayType *ta)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp;&nbsp; *tl;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tl = <a href="arrayutils.c.html#L233" title="utils/adt/arrayutils.c:233">ArrayGetIntegerTypmods</a>(ta, &amp;n);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're not too tense about good error message here because grammar<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shouldn't allow wrong number of modifiers for TIMESTAMP<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (n != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid type modifier&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L123" title="utils/adt/timestamp.c:123">anytimestamp_typmod_check</a>(istz, tl[<span class="Constant">0</span>]);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* exported so parse_expr.c can use it */<br/></li>
<li></span>int32<br/></li>
<li><a id="L123">&#x200c;</a><span class="linkable">anytimestamp_typmod_check</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> istz, int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typmod &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;TIMESTAMP(</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">%s</span><span class="Constant"> precision must not be negative&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typmod, (istz ? <span class="Constant">&quot; WITH TIME ZONE&quot;</span> : <span class="Constant">&quot;&quot;</span>))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typmod &gt; MAX_TIMESTAMP_PRECISION)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;TIMESTAMP(</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">%s</span><span class="Constant"> precision reduced to maximum allowed, </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typmod, (istz ? <span class="Constant">&quot; WITH TIME ZONE&quot;</span> : <span class="Constant">&quot;&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MAX_TIMESTAMP_PRECISION)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typmod = MAX_TIMESTAMP_PRECISION;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> typmod;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* common code for <a href="#L310" title="utils/adt/timestamp.c:310">timestamptypmodout</a> and <a href="#L866" title="utils/adt/timestamp.c:866">timestamptztypmodout</a> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L145">&#x200c;</a><span class="linkable">anytimestamp_typmodout</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> istz, int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *tz = istz ? <span class="Constant">&quot; with time zone&quot;</span> : <span class="Constant">&quot; without time zone&quot;</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typmod &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> psprintf(<span class="Constant">&quot;(</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">%s</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) typmod, tz);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(tz);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; USER I/O ROUTINES&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* <a href="#L164" title="utils/adt/timestamp.c:164">timestamp_in</a>()<br/></li>
<li></span><span class="Comment"> * Convert a string to <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> form.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L164">&#x200c;</a><span class="linkable">timestamp_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelem = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dtype;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *field[MAXDATEFIELDS];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[MAXDATEFIELDS];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; workbuf[MAXDATELEN + MAXDATEFIELDS];<br/></li>
<li>&nbsp; &nbsp; DateTimeErrorExtra extra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dterr = <a href="datetime.c.html#L754" title="utils/adt/datetime.c:754">ParseDateTime</a>(str, workbuf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(workbuf),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; field, ftype, MAXDATEFIELDS, &amp;nf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dterr == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="datetime.c.html#L978" title="utils/adt/datetime.c:978">DecodeDateTime</a>(field, ftype, nf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;dtype, tm, &amp;fsec, &amp;tz, &amp;extra);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dterr != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L4081" title="utils/adt/datetime.c:4081">DateTimeParseError</a>(dterr, &amp;extra, str, <span class="Constant">&quot;timestamp&quot;</span>, escontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (dtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1997" title="utils/adt/timestamp.c:1997">tm2timestamp</a>(tm, fsec, <span class="Constant">NULL</span>, &amp;result) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, str)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_EPOCH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2190" title="utils/adt/timestamp.c:2190">SetEpochTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_LATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TIMESTAMP_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_EARLY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TIMESTAMP_NOBEGIN(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected dtype </span><span class="Special">%d</span><span class="Constant"> while parsing timestamp </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dtype, str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TIMESTAMP_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L366" title="utils/adt/timestamp.c:366">AdjustTimestampForTypmod</a>(&amp;result, typmod, escontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMP(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L232" title="utils/adt/timestamp.c:232">timestamp_out</a>()<br/></li>
<li></span><span class="Comment"> * Convert a timestamp to external form.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L232">&#x200c;</a><span class="linkable">timestamp_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestamp = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[MAXDATELEN + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1596" title="utils/adt/timestamp.c:1596">EncodeSpecialTimestamp</a>(timestamp, buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, <span class="Constant">NULL</span>, tm, &amp;fsec, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L4331" title="utils/adt/datetime.c:4331">EncodeDateTime</a>(tm, fsec, <span class="Constant">false</span>, <span class="Constant">0</span>, <span class="Constant">NULL</span>, <a href="../init/globals.c.html#L122" title="utils/init/globals.c:122">DateStyle</a>, buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(buf);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L258" title="utils/adt/timestamp.c:258">timestamp_recv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to timestamp<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L258">&#x200c;</a><span class="linkable">timestamp_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelem = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestamp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; timestamp = (Timestamp) <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> check: see if <a href="#L232" title="utils/adt/timestamp.c:232">timestamp_out</a> would like it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* ok */</span> ;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, <span class="Constant">NULL</span>, tm, &amp;fsec, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>) != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !IS_VALID_TIMESTAMP(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L366" title="utils/adt/timestamp.c:366">AdjustTimestampForTypmod</a>(&amp;timestamp, typmod, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMP(timestamp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L291" title="utils/adt/timestamp.c:291">timestamp_send</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts timestamp to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L291">&#x200c;</a><span class="linkable">timestamp_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestamp = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(&amp;buf, timestamp);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L302">&#x200c;</a><span class="linkable">timestamptypmodin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *ta = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L102" title="utils/adt/timestamp.c:102">anytimestamp_typmodin</a>(<span class="Constant">false</span>, ta));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L310">&#x200c;</a><span class="linkable">timestamptypmodout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(<a href="#L145" title="utils/adt/timestamp.c:145">anytimestamp_typmodout</a>(<span class="Constant">false</span>, typmod));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L325" title="utils/adt/timestamp.c:325">timestamp_support</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Planner support function for the <a href="#L345" title="utils/adt/timestamp.c:345">timestamp_scale</a>() and <a href="#L879" title="utils/adt/timestamp.c:879">timestamptz_scale</a>()<br/></li>
<li></span><span class="Comment"> * length coercion <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> (we need not distinguish them here).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L325">&#x200c;</a><span class="linkable">timestamp_support</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rawreq = (Node *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *ret = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(rawreq, SupportRequestSimplify))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SupportRequestSimplify *req = (SupportRequestSimplify *) rawreq;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="datetime.c.html#L4829" title="utils/adt/datetime.c:4829">TemporalSimplify</a>(MAX_TIMESTAMP_PRECISION, (Node *) req-&gt;fcall);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L345" title="utils/adt/timestamp.c:345">timestamp_scale</a>()<br/></li>
<li></span><span class="Comment"> * Adjust time type for specified scale factor.<br/></li>
<li></span><span class="Comment"> * Used by PostgreSQL type system to stuff columns.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L345">&#x200c;</a><span class="linkable">timestamp_scale</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestamp = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = timestamp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L366" title="utils/adt/timestamp.c:366">AdjustTimestampForTypmod</a>(&amp;result, typmod, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMP(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L366" title="utils/adt/timestamp.c:366">AdjustTimestampForTypmod</a> --- round off a timestamp to suit given typmod<br/></li>
<li></span><span class="Comment"> * Works for either timestamp or timestamptz.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true on success, false on failure (if escontext points to an<br/></li>
<li></span><span class="Comment"> * ErrorSaveContext; otherwise errors are thrown).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L366">&#x200c;</a></span><span class="linkable">AdjustTimestampForTypmod</span>(Timestamp *time, int32 typmod, Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">const</span> int64 TimestampScales[MAX_TIMESTAMP_PRECISION + <span class="Constant">1</span>] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">1000000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">100000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">10000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">1000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">100</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">10</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">const</span> int64 TimestampOffsets[MAX_TIMESTAMP_PRECISION + <span class="Constant">1</span>] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">500000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">50000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">5000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">500</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">50</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">5</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TIMESTAMP_NOT_FINITE(*time)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (typmod != -<span class="Constant">1</span>) &amp;&amp; (typmod != MAX_TIMESTAMP_PRECISION))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typmod &lt; <span class="Constant">0</span> || typmod &gt; MAX_TIMESTAMP_PRECISION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp(</span><span class="Special">%d</span><span class="Constant">) precision must be between </span><span class="Special">%d</span><span class="Constant"> and </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typmod, <span class="Constant">0</span>, MAX_TIMESTAMP_PRECISION)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*time &gt;= INT64CONST(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *time = ((*time + TimestampOffsets[typmod]) / TimestampScales[typmod]) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampScales[typmod];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *time = -((((-*time) + TimestampOffsets[typmod]) / TimestampScales[typmod])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * TimestampScales[typmod]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L416" title="utils/adt/timestamp.c:416">timestamptz_in</a>()<br/></li>
<li></span><span class="Comment"> * Convert a string to <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> form.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L416">&#x200c;</a><span class="linkable">timestamptz_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelem = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; TimestampTz result;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dtype;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *field[MAXDATEFIELDS];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[MAXDATEFIELDS];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; workbuf[MAXDATELEN + MAXDATEFIELDS];<br/></li>
<li>&nbsp; &nbsp; DateTimeErrorExtra extra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dterr = <a href="datetime.c.html#L754" title="utils/adt/datetime.c:754">ParseDateTime</a>(str, workbuf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(workbuf),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; field, ftype, MAXDATEFIELDS, &amp;nf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dterr == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="datetime.c.html#L978" title="utils/adt/datetime.c:978">DecodeDateTime</a>(field, ftype, nf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;dtype, tm, &amp;fsec, &amp;tz, &amp;extra);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dterr != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L4081" title="utils/adt/datetime.c:4081">DateTimeParseError</a>(dterr, &amp;extra, str, <span class="Constant">&quot;timestamp with time zone&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; escontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (dtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1997" title="utils/adt/timestamp.c:1997">tm2timestamp</a>(tm, fsec, &amp;tz, &amp;result) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, str)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_EPOCH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2190" title="utils/adt/timestamp.c:2190">SetEpochTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_LATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TIMESTAMP_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_EARLY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TIMESTAMP_NOBEGIN(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected dtype </span><span class="Special">%d</span><span class="Constant"> while parsing timestamptz </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dtype, str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TIMESTAMP_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L366" title="utils/adt/timestamp.c:366">AdjustTimestampForTypmod</a>(&amp;result, typmod, escontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMPTZ(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Try to <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> a timezone specification, and return its timezone offset value<br/></li>
<li></span><span class="Comment"> * if it's acceptable.&nbsp; Otherwise, an error is thrown.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: some code paths update tm-&gt;tm_isdst, and some don't; current callers<br/></li>
<li></span><span class="Comment"> * don't care, so we don't bother being consistent.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L489">&#x200c;</a></span><span class="linkable">parse_sane_timezone</span>(<span class="Type">struct</span> pg_tm *tm, text *zone)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; tzname[TZ_STRLEN_MAX + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="varlena.c.html#L248" title="utils/adt/varlena.c:248">text_to_cstring_buffer</a>(zone, tzname, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tzname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up the requested timezone.&nbsp; First we try to interpret it as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> timezone specification; if <a href="datetime.c.html#L2996" title="utils/adt/datetime.c:2996">DecodeTimezone</a> decides it doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * like the format, we try timezone abbreviations and names.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note pg_tzset happily parses <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> input that <a href="datetime.c.html#L2996" title="utils/adt/datetime.c:2996">DecodeTimezone</a> would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reject.&nbsp; To avoid having it <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> input that would otherwise be seen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as invalid, it's enough to disallow having a digit in the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * position of our input string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *tzname))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> time zone&quot;</span>, tzname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Numeric time zones must have </span><span class="Special">\&quot;</span><span class="Constant">-</span><span class="Special">\&quot;</span><span class="Constant"> or </span><span class="Special">\&quot;</span><span class="Constant">+</span><span class="Special">\&quot;</span><span class="Constant"> as first character.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dterr = <a href="datetime.c.html#L2996" title="utils/adt/datetime.c:2996">DecodeTimezone</a>(tzname, &amp;tz);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dterr != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_tz&nbsp; &nbsp; &nbsp;&nbsp; *tzp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr == DTERR_TZDISP_OVERFLOW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> time zone </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>, tzname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (dterr != DTERR_BAD_FORMAT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;time zone </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not recognized&quot;</span>, tzname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; type = <a href="datetime.c.html#L3179" title="utils/adt/datetime.c:3179">DecodeTimezoneName</a>(tzname, &amp;val, &amp;tzp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (type == TZNAME_FIXED_OFFSET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fixed-offset abbreviation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz = -val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (type == TZNAME_DYNTZ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dynamic-offset abbreviation, resolve using specified time */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz = <a href="datetime.c.html#L1746" title="utils/adt/datetime.c:1746">DetermineTimeZoneAbbrevOffset</a>(tm, tzname, tzp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* full zone name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz = <a href="datetime.c.html#L1585" title="utils/adt/datetime.c:1585">DetermineTimeZoneOffset</a>(tm, tzp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tz;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Look up the requested timezone, returning a pg_tz struct.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is the same as <a href="datetime.c.html#L3234" title="utils/adt/datetime.c:3234">DecodeTimezoneNameToTz</a>, but starting with a text Datum.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> pg_tz *<br/></li>
<li><a id="L558">&#x200c;</a><span class="linkable">lookup_timezone</span>(text *zone)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; tzname[TZ_STRLEN_MAX + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="varlena.c.html#L248" title="utils/adt/varlena.c:248">text_to_cstring_buffer</a>(zone, tzname, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tzname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="datetime.c.html#L3234" title="utils/adt/datetime.c:3234">DecodeTimezoneNameToTz</a>(tzname);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L572" title="utils/adt/timestamp.c:572">make_timestamp_internal</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; workhorse for <a href="#L654" title="utils/adt/timestamp.c:654">make_timestamp</a> and <a href="#L674" title="utils/adt/timestamp.c:674">make_timestamptz</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Timestamp<br/></li>
<li><a id="L572">&#x200c;</a><span class="linkable">make_timestamp_internal</span>(<span class="Type">int</span> year, <span class="Type">int</span> month, <span class="Type">int</span> day,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> hour, <span class="Type">int</span> min, <span class="Type">double</span> sec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tm;<br/></li>
<li>&nbsp; &nbsp; TimeOffset&nbsp; &nbsp; date;<br/></li>
<li>&nbsp; &nbsp; TimeOffset&nbsp; &nbsp; time;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; bc = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tm.tm_year = year;<br/></li>
<li>&nbsp; &nbsp; tm.tm_mon = month;<br/></li>
<li>&nbsp; &nbsp; tm.tm_mday = day;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle negative years as BC */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tm.tm_year &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bc = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm.tm_year = -tm.tm_year;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dterr = <a href="datetime.c.html#L2497" title="utils/adt/datetime.c:2497">ValidateDate</a>(DTK_DATE_M, <span class="Constant">false</span>, <span class="Constant">false</span>, bc, &amp;tm);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dterr != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_FIELD_OVERFLOW),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;date field value out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">%d</span><span class="Constant">-</span><span class="Special">%02d</span><span class="Constant">-</span><span class="Special">%02d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; year, month, day)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!IS_VALID_JULIAN(tm.tm_year, tm.tm_mon, tm.tm_mday))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;date out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">%d</span><span class="Constant">-</span><span class="Special">%02d</span><span class="Constant">-</span><span class="Special">%02d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; year, month, day)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; date = <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(tm.tm_year, tm.tm_mon, tm.tm_mday) - POSTGRES_EPOCH_JDATE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for time overflow */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="date.c.html#L1451" title="utils/adt/date.c:1451">float_time_overflows</a>(hour, min, sec))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_FIELD_OVERFLOW),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;time field value out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">%d</span><span class="Constant">:</span><span class="Special">%02d</span><span class="Constant">:</span><span class="Special">%02g</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hour, min, sec)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This should match <a href="date.c.html#L1416" title="utils/adt/date.c:1416">tm2time</a> */<br/></li>
<li></span>&nbsp; &nbsp; time = (((hour * MINS_PER_HOUR + min) * SECS_PER_MINUTE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * USECS_PER_SEC) + (int64) rint(sec * USECS_PER_SEC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = date * USECS_PER_DAY + time;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for major overflow */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((result - time) / USECS_PER_DAY != date)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">%d</span><span class="Constant">-</span><span class="Special">%02d</span><span class="Constant">-</span><span class="Special">%02d</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">:</span><span class="Special">%02d</span><span class="Constant">:</span><span class="Special">%02g</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; year, month, day,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hour, min, sec)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for just-barely overflow (okay except time-of-day wraps) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* caution: we want to allow 1999-12-31 24:00:00 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((result &lt; <span class="Constant">0</span> &amp;&amp; date &gt; <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (result &gt; <span class="Constant">0</span> &amp;&amp; date &lt; -<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">%d</span><span class="Constant">-</span><span class="Special">%02d</span><span class="Constant">-</span><span class="Special">%02d</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">:</span><span class="Special">%02d</span><span class="Constant">:</span><span class="Special">%02g</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; year, month, day,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hour, min, sec)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* final <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> check catches just-out-of-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> timestamps */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IS_VALID_TIMESTAMP(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">%d</span><span class="Constant">-</span><span class="Special">%02d</span><span class="Constant">-</span><span class="Special">%02d</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">:</span><span class="Special">%02d</span><span class="Constant">:</span><span class="Special">%02g</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; year, month, day,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hour, min, sec)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L654" title="utils/adt/timestamp.c:654">make_timestamp</a>() - timestamp constructor<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L654">&#x200c;</a><span class="linkable">make_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; year = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; month = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; mday = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; hour = PG_GETARG_INT32(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; min = PG_GETARG_INT32(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; sec = PG_GETARG_FLOAT8(<span class="Constant">5</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L572" title="utils/adt/timestamp.c:572">make_timestamp_internal</a>(year, month, mday,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hour, min, sec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMP(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L674" title="utils/adt/timestamp.c:674">make_timestamptz</a>() - timestamp with time zone constructor<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L674">&#x200c;</a><span class="linkable">make_timestamptz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; year = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; month = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; mday = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; hour = PG_GETARG_INT32(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; min = PG_GETARG_INT32(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; sec = PG_GETARG_FLOAT8(<span class="Constant">5</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L572" title="utils/adt/timestamp.c:572">make_timestamp_internal</a>(year, month, mday,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hour, min, sec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMPTZ(<a href="#L6344" title="utils/adt/timestamp.c:6344">timestamp2timestamptz</a>(result));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Construct a timestamp with time zone.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; As above, but the time zone is specified as seventh argument.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L695">&#x200c;</a><span class="linkable">make_timestamptz_at_timezone</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; year = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; month = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; mday = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; hour = PG_GETARG_INT32(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; min = PG_GETARG_INT32(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; sec = PG_GETARG_FLOAT8(<span class="Constant">5</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *zone = PG_GETARG_TEXT_PP(<span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz result;<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestamp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; timestamp = <a href="#L572" title="utils/adt/timestamp.c:572">make_timestamp_internal</a>(year, month, mday,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hour, min, sec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, <span class="Constant">NULL</span>, &amp;tt, &amp;fsec, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tz = <a href="#L489" title="utils/adt/timestamp.c:489">parse_sane_timezone</a>(&amp;tt, zone);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L2134" title="utils/adt/timestamp.c:2134">dt2local</a>(timestamp, -tz);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!IS_VALID_TIMESTAMP(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMPTZ(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="formatting.c.html#L4368" title="utils/adt/formatting.c:4368">to_timestamp</a>(double precision)<br/></li>
<li></span><span class="Comment"> * Convert UNIX epoch to timestamptz.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L735">&#x200c;</a><span class="linkable">float8_timestamptz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; seconds = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Deal with NaN and infinite inputs ... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(seconds))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp cannot be NaN&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isinf(seconds))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (seconds &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TIMESTAMP_NOBEGIN(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TIMESTAMP_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (seconds &lt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (float8) SECS_PER_DAY * (DATETIME_MIN_JULIAN - UNIX_EPOCH_JDATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || seconds &gt;=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (float8) SECS_PER_DAY * (TIMESTAMP_END_JULIAN - UNIX_EPOCH_JDATE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">\&quot;%g\&quot;</span><span class="Constant">&quot;</span>, seconds)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Convert UNIX epoch to Postgres epoch */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; seconds -= ((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seconds = rint(seconds * USECS_PER_SEC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (int64) seconds;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recheck in case roundoff produces something just out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IS_VALID_TIMESTAMP(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">\&quot;%g\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GETARG_FLOAT8(<span class="Constant">0</span>))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMP(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L785" title="utils/adt/timestamp.c:785">timestamptz_out</a>()<br/></li>
<li></span><span class="Comment"> * Convert a timestamp to external form.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L785">&#x200c;</a><span class="linkable">timestamptz_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *tzn;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[MAXDATELEN + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(dt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1596" title="utils/adt/timestamp.c:1596">EncodeSpecialTimestamp</a>(dt, buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(dt, &amp;tz, tm, &amp;fsec, &amp;tzn, <span class="Constant">NULL</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L4331" title="utils/adt/datetime.c:4331">EncodeDateTime</a>(tm, fsec, <span class="Constant">true</span>, tz, tzn, <a href="../init/globals.c.html#L122" title="utils/init/globals.c:122">DateStyle</a>, buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(buf);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L813" title="utils/adt/timestamp.c:813">timestamptz_recv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to timestamptz<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L813">&#x200c;</a><span class="linkable">timestamptz_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelem = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz timestamp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; timestamp = (TimestampTz) <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> check: see if <a href="#L785" title="utils/adt/timestamp.c:785">timestamptz_out</a> would like it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* ok */</span> ;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, &amp;tz, tm, &amp;fsec, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>) != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !IS_VALID_TIMESTAMP(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L366" title="utils/adt/timestamp.c:366">AdjustTimestampForTypmod</a>(&amp;timestamp, typmod, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMPTZ(timestamp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L847" title="utils/adt/timestamp.c:847">timestamptz_send</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts timestamptz to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L847">&#x200c;</a><span class="linkable">timestamptz_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(&amp;buf, timestamp);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L858">&#x200c;</a><span class="linkable">timestamptztypmodin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *ta = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L102" title="utils/adt/timestamp.c:102">anytimestamp_typmodin</a>(<span class="Constant">true</span>, ta));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L866">&#x200c;</a><span class="linkable">timestamptztypmodout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(<a href="#L145" title="utils/adt/timestamp.c:145">anytimestamp_typmodout</a>(<span class="Constant">true</span>, typmod));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L879" title="utils/adt/timestamp.c:879">timestamptz_scale</a>()<br/></li>
<li></span><span class="Comment"> * Adjust time type for specified scale factor.<br/></li>
<li></span><span class="Comment"> * Used by PostgreSQL type system to stuff columns.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L879">&#x200c;</a><span class="linkable">timestamptz_scale</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = timestamp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L366" title="utils/adt/timestamp.c:366">AdjustTimestampForTypmod</a>(&amp;result, typmod, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMPTZ(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L900" title="utils/adt/timestamp.c:900">interval_in</a>()<br/></li>
<li></span><span class="Comment"> * Convert a string to <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> form.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * External format(s):<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Uses the generic date/time parsing and decoding routines.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L900">&#x200c;</a><span class="linkable">interval_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelem = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_itm_in tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *itm_in = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dtype;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *field[MAXDATEFIELDS];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[MAXDATEFIELDS];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; workbuf[<span class="Constant">256</span>];<br/></li>
<li>&nbsp; &nbsp; DateTimeErrorExtra extra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itm_in-&gt;tm_year = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; itm_in-&gt;tm_mon = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; itm_in-&gt;tm_mday = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; itm_in-&gt;tm_usec = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typmod &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = INTERVAL_RANGE(typmod);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = INTERVAL_FULL_RANGE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dterr = <a href="datetime.c.html#L754" title="utils/adt/datetime.c:754">ParseDateTime</a>(str, workbuf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(workbuf), field,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype, MAXDATEFIELDS, &amp;nf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dterr == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="datetime.c.html#L3353" title="utils/adt/datetime.c:3353">DecodeInterval</a>(field, ftype, nf, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;dtype, itm_in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if those <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> think it's a bad format, try ISO8601 style */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dterr == DTERR_BAD_FORMAT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="datetime.c.html#L3818" title="utils/adt/datetime.c:3818">DecodeISO8601Interval</a>(str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;dtype, itm_in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dterr != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr == DTERR_FIELD_OVERFLOW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = DTERR_INTERVAL_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L4081" title="utils/adt/datetime.c:4081">DateTimeParseError</a>(dterr, &amp;extra, str, <span class="Constant">&quot;interval&quot;</span>, escontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Interval *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (dtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DELTA:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2115" title="utils/adt/timestamp.c:2115">itmin2interval</a>(itm_in, result) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_LATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_EARLY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOBEGIN(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected dtype </span><span class="Special">%d</span><span class="Constant"> while parsing interval </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dtype, str);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1359" title="utils/adt/timestamp.c:1359">AdjustIntervalForTypmod</a>(result, typmod, escontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L982" title="utils/adt/timestamp.c:982">interval_out</a>()<br/></li>
<li></span><span class="Comment"> * Convert a time span to external form.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L982">&#x200c;</a><span class="linkable">interval_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *span = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_itm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *itm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[MAXDATELEN + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE(span))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1607" title="utils/adt/timestamp.c:1607">EncodeSpecialInterval</a>(span, buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2047" title="utils/adt/timestamp.c:2047">interval2itm</a>(*span, itm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L4574" title="utils/adt/datetime.c:4574">EncodeInterval</a>(itm, <a href="../init/globals.c.html#L124" title="utils/init/globals.c:124">IntervalStyle</a>, buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(buf);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1006" title="utils/adt/timestamp.c:1006">interval_recv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to interval<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1006">&#x200c;</a><span class="linkable">interval_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelem = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; interval = (Interval *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; interval-&gt;time = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(buf);<br/></li>
<li>&nbsp; &nbsp; interval-&gt;day = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(interval-&gt;day));<br/></li>
<li>&nbsp; &nbsp; interval-&gt;month = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(interval-&gt;month));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1359" title="utils/adt/timestamp.c:1359">AdjustIntervalForTypmod</a>(interval, typmod, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INTERVAL_P(interval);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1031" title="utils/adt/timestamp.c:1031">interval_send</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts interval to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1031">&#x200c;</a><span class="linkable">interval_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(&amp;buf, interval-&gt;time);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(&amp;buf, interval-&gt;day);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(&amp;buf, interval-&gt;month);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The interval typmod stores a &quot;<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot; in its high 16 bits and a &quot;precision&quot;<br/></li>
<li></span><span class="Comment"> * in its low 16 bits.&nbsp; Both contribute to defining the resolution of the<br/></li>
<li></span><span class="Comment"> * type.&nbsp; <a href="geo_spgist.c.html#L107" title="utils/adt/geo_spgist.c:107">Range</a> addresses resolution granules larger than one second, and<br/></li>
<li></span><span class="Comment"> * precision specifies resolution below one second.&nbsp; This representation can<br/></li>
<li></span><span class="Comment"> * express all SQL standard resolutions, but we implement them all in terms of<br/></li>
<li></span><span class="Comment"> * truncating rightward from some position.&nbsp; <a href="geo_spgist.c.html#L107" title="utils/adt/geo_spgist.c:107">Range</a> is a bitmap of permitted<br/></li>
<li></span><span class="Comment"> * fields, but only the temporally-smallest such field is significant to our<br/></li>
<li></span><span class="Comment"> * calculations.&nbsp; Precision is a count of sub-second decimal places to retain.<br/></li>
<li></span><span class="Comment"> * Setting all bits (INTERVAL_FULL_PRECISION) gives the same truncation<br/></li>
<li></span><span class="Comment"> * semantics as choosing MAX_INTERVAL_PRECISION.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1056">&#x200c;</a><span class="linkable">intervaltypmodin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *ta = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp;&nbsp; *tl;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tl = <a href="arrayutils.c.html#L233" title="utils/adt/arrayutils.c:233">ArrayGetIntegerTypmods</a>(ta, &amp;n);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tl[0] - interval <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> (fields bitmask)&nbsp; &nbsp; tl[1] - precision (optional)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note we must validate tl[0] even though it's normally guaranteed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * correct by the grammar --- consider SELECT 'foo'::&quot;interval&quot;(1000).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (n &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (tl[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(YEAR):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(MONTH):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(DAY):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(HOUR):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(MINUTE):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(SECOND):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_FULL_RANGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* all OK */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid INTERVAL type modifier&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tl[<span class="Constant">0</span>] != INTERVAL_FULL_RANGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typmod = INTERVAL_TYPMOD(INTERVAL_FULL_PRECISION, tl[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typmod = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (n == <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tl[<span class="Constant">1</span>] &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;INTERVAL(</span><span class="Special">%d</span><span class="Constant">) precision must not be negative&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tl[<span class="Constant">1</span>])));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tl[<span class="Constant">1</span>] &gt; MAX_INTERVAL_PRECISION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;INTERVAL(</span><span class="Special">%d</span><span class="Constant">) precision reduced to maximum allowed, </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tl[<span class="Constant">1</span>], MAX_INTERVAL_PRECISION)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typmod = INTERVAL_TYPMOD(MAX_INTERVAL_PRECISION, tl[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typmod = INTERVAL_TYPMOD(tl[<span class="Constant">1</span>], tl[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid INTERVAL type modifier&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typmod = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(typmod);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1135">&#x200c;</a><span class="linkable">intervaltypmodout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *res = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Constant">64</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fields;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; precision;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *fieldstr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typmod &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *res = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_CSTRING(res);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fields = INTERVAL_RANGE(typmod);<br/></li>
<li>&nbsp; &nbsp; precision = INTERVAL_PRECISION(typmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (fields)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(YEAR):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldstr = <span class="Constant">&quot; year&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(MONTH):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldstr = <span class="Constant">&quot; month&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(DAY):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldstr = <span class="Constant">&quot; day&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(HOUR):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldstr = <span class="Constant">&quot; hour&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(MINUTE):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldstr = <span class="Constant">&quot; minute&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(SECOND):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldstr = <span class="Constant">&quot; second&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldstr = <span class="Constant">&quot; year to month&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldstr = <span class="Constant">&quot; day to hour&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldstr = <span class="Constant">&quot; day to minute&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldstr = <span class="Constant">&quot; day to second&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldstr = <span class="Constant">&quot; hour to minute&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldstr = <span class="Constant">&quot; hour to second&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldstr = <span class="Constant">&quot; minute to second&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_FULL_RANGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldstr = <span class="Constant">&quot;&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid INTERVAL typmod: 0x</span><span class="Special">%x</span><span class="Constant">&quot;</span>, typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldstr = <span class="Constant">&quot;&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (precision != INTERVAL_FULL_PRECISION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(res, <span class="Constant">64</span>, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">)&quot;</span>, fieldstr, precision);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(res, <span class="Constant">64</span>, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, fieldstr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given an interval typmod value, return a code for the least-significant<br/></li>
<li></span><span class="Comment"> * field that the typmod allows to be nonzero, for instance given<br/></li>
<li></span><span class="Comment"> * INTERVAL DAY TO HOUR we want to identify &quot;hour&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The results should be ordered by field significance, which means<br/></li>
<li></span><span class="Comment"> * we can't use the dt.h macros YEAR etc, because for some odd reason<br/></li>
<li></span><span class="Comment"> * they aren't ordered that way.&nbsp; Instead, arbitrarily represent<br/></li>
<li></span><span class="Comment"> * SECOND = 0, MINUTE = 1, HOUR = 2, DAY = 3, MONTH = 4, YEAR = 5.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1221">&#x200c;</a></span><span class="linkable">intervaltypmodleastfield</span>(int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typmod &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SECOND */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (INTERVAL_RANGE(typmod))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(YEAR):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">5</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* YEAR */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(MONTH):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">4</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* MONTH */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(DAY):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">3</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* DAY */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(HOUR):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">2</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* HOUR */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(MINUTE):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* MINUTE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(SECOND):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SECOND */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">4</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* MONTH */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">2</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* HOUR */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* MINUTE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SECOND */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* MINUTE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SECOND */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SECOND */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_FULL_RANGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SECOND */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid INTERVAL typmod: 0x</span><span class="Special">%x</span><span class="Constant">&quot;</span>, typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't get here, but keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1274" title="utils/adt/timestamp.c:1274">interval_support</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Planner support function for <a href="#L1337" title="utils/adt/timestamp.c:1337">interval_scale</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Flatten superfluous calls to <a href="#L1337" title="utils/adt/timestamp.c:1337">interval_scale</a>().&nbsp; The interval typmod is<br/></li>
<li></span><span class="Comment"> * complex to permit accepting and regurgitating all SQL standard variations.<br/></li>
<li></span><span class="Comment"> * For truncation purposes, it boils down to a single, simple granularity.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1274">&#x200c;</a><span class="linkable">interval_support</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rawreq = (Node *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *ret = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(rawreq, SupportRequestSimplify))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SupportRequestSimplify *req = (SupportRequestSimplify *) rawreq;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FuncExpr&nbsp;&nbsp; *expr = req-&gt;fcall;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *typmod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(expr-&gt;args) &gt;= <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typmod = (Node *) lsecond(expr-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(typmod, Const) &amp;&amp; !((Const *) typmod)-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *source = (Node *) linitial(expr-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; new_typmod = DatumGetInt32(((Const *) typmod)-&gt;constvalue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; noop;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_typmod &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; noop = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; old_typmod = <a href="../../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>(source);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_least_field;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_least_field;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_precis;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_precis;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_least_field = <a href="#L1221" title="utils/adt/timestamp.c:1221">intervaltypmodleastfield</a>(old_typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_least_field = <a href="#L1221" title="utils/adt/timestamp.c:1221">intervaltypmodleastfield</a>(new_typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old_typmod &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_precis = INTERVAL_FULL_PRECISION;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_precis = INTERVAL_PRECISION(old_typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_precis = INTERVAL_PRECISION(new_typmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Cast is a no-op if least field stays the same or decreases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * while precision stays the same or increases.&nbsp; But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * precision, which is to say, sub-second precision, only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * affects ranges that include SECOND.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; noop = (new_least_field &lt;= old_least_field) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (old_least_field &gt; <span class="Constant">0</span> <span class="Comment">/* SECOND */</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_precis &gt;= MAX_INTERVAL_PRECISION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_precis &gt;= old_precis);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (noop)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="../../nodes/nodeFuncs.c.html#L684" title="nodes/nodeFuncs.c:684">relabel_to_typmod</a>(source, new_typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1337" title="utils/adt/timestamp.c:1337">interval_scale</a>()<br/></li>
<li></span><span class="Comment"> * Adjust interval type for specified fields.<br/></li>
<li></span><span class="Comment"> * Used by PostgreSQL type system to stuff columns.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1337">&#x200c;</a><span class="linkable">interval_scale</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typmod = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li>&nbsp; &nbsp; *result = *interval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1359" title="utils/adt/timestamp.c:1359">AdjustIntervalForTypmod</a>(result, typmod, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Adjust interval for specified precision, in both YEAR to SECOND<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> and sub-second precision.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true on success, false on failure (if escontext points to an<br/></li>
<li></span><span class="Comment"> * ErrorSaveContext; otherwise errors are thrown).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1359">&#x200c;</a></span><span class="linkable">AdjustIntervalForTypmod</span>(Interval *interval, int32 typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">const</span> int64 IntervalScales[MAX_INTERVAL_PRECISION + <span class="Constant">1</span>] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">1000000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">100000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">10000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">1000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">100</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">10</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">const</span> int64 IntervalOffsets[MAX_INTERVAL_PRECISION + <span class="Constant">1</span>] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">500000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">50000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">5000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">500</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">50</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">5</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INT64CONST(<span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Typmod has no effect on infinite intervals */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE(interval))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unspecified <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> and precision? Then not necessary to adjust. Setting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * typmod to -1 is the convention for all data types.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (typmod &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = INTERVAL_RANGE(typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; precision = INTERVAL_PRECISION(typmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Our interpretation of intervals with a limited set of fields is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that fields to the right of the last one specified are zeroed out,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but those to the left of it remain valid.&nbsp; Thus for example there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is no operational difference between INTERVAL YEAR TO MONTH and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * INTERVAL MONTH.&nbsp; In some cases we could meaningfully enforce that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * higher-order fields are zero; for example INTERVAL DAY could reject<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nonzero &quot;month&quot; field.&nbsp; However that seems a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> pointless when we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can't do it consistently.&nbsp; (We cannot enforce a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> limit on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * highest expected field, since we do not have <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> equivalent of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * SQL's &lt;interval leading field precision&gt;.)&nbsp; If we ever decide to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * revisit this, <a href="#L1274" title="utils/adt/timestamp.c:1274">interval_support</a> will likely require adjusting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> PG 8.4 we interpreted a limited set of fields as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * actually causing a &quot;modulo&quot; operation on a given value, potentially<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * losing high-order as well as low-order information.&nbsp; But there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no support for such behavior in the standard, and it seems fairly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * undesirable on data consistency grounds anyway.&nbsp; Now we only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * perform truncation or rounding of low-order fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> == INTERVAL_FULL_RANGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do nothing... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> == INTERVAL_MASK(YEAR))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interval-&gt;month = (interval-&gt;month / MONTHS_PER_YEAR) * MONTHS_PER_YEAR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interval-&gt;day = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interval-&gt;time = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> == INTERVAL_MASK(MONTH))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interval-&gt;day = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interval-&gt;time = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* YEAR TO MONTH */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> == (INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interval-&gt;day = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interval-&gt;time = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> == INTERVAL_MASK(DAY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interval-&gt;time = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> == INTERVAL_MASK(HOUR))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interval-&gt;time = (interval-&gt;time / USECS_PER_HOUR) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; USECS_PER_HOUR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> == INTERVAL_MASK(MINUTE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interval-&gt;time = (interval-&gt;time / USECS_PER_MINUTE) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; USECS_PER_MINUTE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> == INTERVAL_MASK(SECOND))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fractional-second rounding will be dealt with below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* DAY TO HOUR */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> == (INTERVAL_MASK(DAY) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INTERVAL_MASK(HOUR)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interval-&gt;time = (interval-&gt;time / USECS_PER_HOUR) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; USECS_PER_HOUR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* DAY TO MINUTE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> == (INTERVAL_MASK(DAY) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INTERVAL_MASK(HOUR) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INTERVAL_MASK(MINUTE)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interval-&gt;time = (interval-&gt;time / USECS_PER_MINUTE) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; USECS_PER_MINUTE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* DAY TO SECOND */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> == (INTERVAL_MASK(DAY) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INTERVAL_MASK(HOUR) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INTERVAL_MASK(MINUTE) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INTERVAL_MASK(SECOND)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fractional-second rounding will be dealt with below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* HOUR TO MINUTE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> == (INTERVAL_MASK(HOUR) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INTERVAL_MASK(MINUTE)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interval-&gt;time = (interval-&gt;time / USECS_PER_MINUTE) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; USECS_PER_MINUTE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* HOUR TO SECOND */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> == (INTERVAL_MASK(HOUR) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INTERVAL_MASK(MINUTE) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INTERVAL_MASK(SECOND)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fractional-second rounding will be dealt with below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* MINUTE TO SECOND */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> == (INTERVAL_MASK(MINUTE) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INTERVAL_MASK(SECOND)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fractional-second rounding will be dealt with below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized interval typmod: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, typmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Need to adjust sub-second precision? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (precision != INTERVAL_FULL_PRECISION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (precision &lt; <span class="Constant">0</span> || precision &gt; MAX_INTERVAL_PRECISION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval(</span><span class="Special">%d</span><span class="Constant">) precision must be between </span><span class="Special">%d</span><span class="Constant"> and </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; precision, <span class="Constant">0</span>, MAX_INTERVAL_PRECISION)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (interval-&gt;time &gt;= INT64CONST(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_add_s64_overflow(interval-&gt;time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IntervalOffsets[precision],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;interval-&gt;time))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interval-&gt;time -= interval-&gt;time % IntervalScales[precision];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_sub_s64_overflow(interval-&gt;time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IntervalOffsets[precision],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;interval-&gt;time))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interval-&gt;time -= interval-&gt;time % IntervalScales[precision];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1539" title="utils/adt/timestamp.c:1539">make_interval</a> - <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> Interval constructor<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1539">&#x200c;</a><span class="linkable">make_interval</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; years = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L81" title="utils/adt/datetime.c:81">months</a> = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; weeks = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> = PG_GETARG_INT32(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; hours = PG_GETARG_INT32(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; mins = PG_GETARG_INT32(<span class="Constant">5</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; secs = PG_GETARG_FLOAT8(<span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reject out-of-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> inputs.&nbsp; We reject <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> input <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that cause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * integer overflow of the corresponding interval fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isinf(secs) || isnan(secs))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Interval *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* years and <a href="datetime.c.html#L81" title="utils/adt/datetime.c:81">months</a> -&gt; <a href="datetime.c.html#L81" title="utils/adt/datetime.c:81">months</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pg_mul_s32_overflow(years, MONTHS_PER_YEAR, &amp;result-&gt;month) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_add_s32_overflow(result-&gt;month, <a href="datetime.c.html#L81" title="utils/adt/datetime.c:81">months</a>, &amp;result-&gt;month))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* weeks and <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> -&gt; <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pg_mul_s32_overflow(weeks, DAYS_PER_WEEK, &amp;result-&gt;day) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_add_s32_overflow(result-&gt;day, <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a>, &amp;result-&gt;day))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* hours and mins -&gt; usecs (cannot overflow 64-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>) */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;time = hours * USECS_PER_HOUR + mins * USECS_PER_MINUTE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* secs -&gt; usecs */<br/></li>
<li></span>&nbsp; &nbsp; secs = rint(float8_mul(secs, USECS_PER_SEC));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!FLOAT8_FITS_IN_INT64(secs) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_add_s64_overflow(result-&gt;time, (int64) secs, &amp;result-&gt;time))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure that the result is finite */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li><br/></li>
<li><span class="Statement">out_of_range</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NULL();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1596" title="utils/adt/timestamp.c:1596">EncodeSpecialTimestamp</a>()<br/></li>
<li></span><span class="Comment"> * Convert reserved timestamp data type to string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1596">&#x200c;</a></span><span class="linkable">EncodeSpecialTimestamp</span>(Timestamp dt, <span class="Type">char</span> *str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_IS_NOBEGIN(dt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcpy(str, EARLY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (TIMESTAMP_IS_NOEND(dt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcpy(str, LATE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid argument for <a href="#L1596" title="utils/adt/timestamp.c:1596">EncodeSpecialTimestamp</a>&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1607">&#x200c;</a></span><span class="linkable">EncodeSpecialInterval</span>(<span class="Type">const</span> Interval *interval, <span class="Type">char</span> *str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_IS_NOBEGIN(interval))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcpy(str, EARLY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (INTERVAL_IS_NOEND(interval))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcpy(str, LATE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid argument for <a href="#L1607" title="utils/adt/timestamp.c:1607">EncodeSpecialInterval</a>&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1618">&#x200c;</a><span class="linkable">now</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMPTZ(<a href="../../access/transam/xact.c.html#L867" title="access/transam/xact.c:867">GetCurrentTransactionStartTimestamp</a>());<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1624">&#x200c;</a><span class="linkable">statement_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMPTZ(<a href="../../access/transam/xact.c.html#L876" title="access/transam/xact.c:876">GetCurrentStatementStartTimestamp</a>());<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1630">&#x200c;</a><span class="linkable">clock_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMPTZ(<a href="#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>());<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1636">&#x200c;</a><span class="linkable">pg_postmaster_start_time</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMPTZ(<a href="#L52" title="utils/adt/timestamp.c:52">PgStartTime</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1642">&#x200c;</a><span class="linkable">pg_conf_load_time</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMPTZ(<a href="#L55" title="utils/adt/timestamp.c:55">PgReloadTime</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a> -- get the current operating system time<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Result is in the form of a TimestampTz value, and is expressed to the<br/></li>
<li></span><span class="Comment"> * full precision of the gettimeofday() syscall<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TimestampTz<br/></li>
<li><a id="L1654">&#x200c;</a><span class="linkable">GetCurrentTimestamp</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> timeval tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; gettimeofday(&amp;tp, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (TimestampTz) tp.tv_sec -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);<br/></li>
<li>&nbsp; &nbsp; result = (result * USECS_PER_SEC) + tp.tv_usec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1672" title="utils/adt/timestamp.c:1672">GetSQLCurrentTimestamp</a> -- implements CURRENT_TIMESTAMP, CURRENT_TIMESTAMP(n)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TimestampTz<br/></li>
<li><a id="L1672">&#x200c;</a><span class="linkable">GetSQLCurrentTimestamp</span>(int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz ts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ts = <a href="../../access/transam/xact.c.html#L867" title="access/transam/xact.c:867">GetCurrentTransactionStartTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typmod &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L366" title="utils/adt/timestamp.c:366">AdjustTimestampForTypmod</a>(&amp;ts, typmod, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ts;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1686" title="utils/adt/timestamp.c:1686">GetSQLLocalTimestamp</a> -- implements LOCALTIMESTAMP, LOCALTIMESTAMP(n)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Timestamp<br/></li>
<li><a id="L1686">&#x200c;</a><span class="linkable">GetSQLLocalTimestamp</span>(int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; ts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ts = <a href="#L6361" title="utils/adt/timestamp.c:6361">timestamptz2timestamp</a>(<a href="../../access/transam/xact.c.html#L867" title="access/transam/xact.c:867">GetCurrentTransactionStartTimestamp</a>());<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typmod &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L366" title="utils/adt/timestamp.c:366">AdjustTimestampForTypmod</a>(&amp;ts, typmod, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ts;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1700" title="utils/adt/timestamp.c:1700">timeofday</a>(*) -- returns the current time as a text.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1700">&#x200c;</a><span class="linkable">timeofday</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> timeval tp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; templ[<span class="Constant">128</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[<span class="Constant">128</span>];<br/></li>
<li>&nbsp; &nbsp; pg_time_t&nbsp; &nbsp; tt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; gettimeofday(&amp;tp, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; tt = (pg_time_t) tp.tv_sec;<br/></li>
<li>&nbsp; &nbsp; pg_strftime(templ, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(templ), <span class="Constant">&quot;</span><span class="Special">%a</span><span class="Constant"> </span><span class="Special">%b</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant"> %H:%M:</span><span class="Special">%S</span><span class="Constant">.</span><span class="Special">%%</span><span class="Constant">06d %Y %Z&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_localtime(&amp;tt, session_timezone));<br/></li>
<li>&nbsp; &nbsp; snprintf(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buf), templ, tp.tv_usec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1730" title="utils/adt/timestamp.c:1730">TimestampDifference</a> -- convert the difference between two timestamps<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; into integer seconds and microseconds<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is typically used to calculate a wait timeout for <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a>(2),<br/></li>
<li></span><span class="Comment"> * which explains the otherwise-odd choice of output format.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Both inputs must be ordinary finite timestamps (in current usage,<br/></li>
<li></span><span class="Comment"> * they'll be results from <a href="#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>()).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We expect start_time &lt;= stop_time.&nbsp; If not, we return zeros,<br/></li>
<li></span><span class="Comment"> * since then we're already past the previously determined stop_time.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1730">&#x200c;</a></span><span class="linkable">TimestampDifference</span>(TimestampTz start_time, TimestampTz stop_time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span> *secs, <span class="Type">int</span> *microsecs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz diff = stop_time - start_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (diff &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *secs = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *microsecs = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *secs = (<span class="Type">long</span>) (diff / USECS_PER_SEC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *microsecs = (<span class="Type">int</span>) (diff % USECS_PER_SEC);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1766" title="utils/adt/timestamp.c:1766">TimestampDifferenceMilliseconds</a> -- convert the difference between two<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; timestamps into integer milliseconds<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is typically used to calculate a wait timeout for <a href="../../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>()<br/></li>
<li></span><span class="Comment"> * or a related function.&nbsp; The choice of &quot;long&quot; as the result type<br/></li>
<li></span><span class="Comment"> * is to harmonize with that; furthermore, we clamp the result to at most<br/></li>
<li></span><span class="Comment"> * INT_MAX milliseconds, because that's all that <a href="../../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>() allows.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We expect start_time &lt;= stop_time.&nbsp; If not, we return zero,<br/></li>
<li></span><span class="Comment"> * since then we're already past the previously determined stop_time.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Subtracting finite and infinite timestamps works correctly, returning<br/></li>
<li></span><span class="Comment"> * zero or INT_MAX as appropriate.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note we round up <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fractional millisecond, since <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for just<br/></li>
<li></span><span class="Comment"> * less than the intended timeout is undesirable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">long<br/></li>
<li><a id="L1766">&#x200c;</a></span><span class="linkable">TimestampDifferenceMilliseconds</span>(TimestampTz start_time, TimestampTz stop_time)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz diff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Deal with zero or negative elapsed time quickly. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (start_time &gt;= stop_time)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* To not fail with timestamp infinities, we must detect overflow. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pg_sub_s64_overflow(stop_time, start_time, &amp;diff))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">long</span>) <span class="Constant">INT_MAX</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (diff &gt;= (<span class="Constant">INT_MAX</span> * INT64CONST(<span class="Constant">1000</span>) - <span class="Constant">999</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">long</span>) <span class="Constant">INT_MAX</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">long</span>) ((diff + <span class="Constant">999</span>) / <span class="Constant">1000</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1790" title="utils/adt/timestamp.c:1790">TimestampDifferenceExceeds</a> -- report whether the difference between two<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; timestamps is &gt;= a threshold (expressed in milliseconds)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Both inputs must be ordinary finite timestamps (in current usage,<br/></li>
<li></span><span class="Comment"> * they'll be results from <a href="#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>()).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1790">&#x200c;</a></span><span class="linkable">TimestampDifferenceExceeds</span>(TimestampTz start_time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimestampTz stop_time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> msec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz diff = stop_time - start_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (diff &gt;= msec * INT64CONST(<span class="Constant">1000</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert a time_t to TimestampTz.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We do not use time_t internally in Postgres, but this is provided for use<br/></li>
<li></span><span class="Comment"> * by <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that need to interpret, say, a stat(2) result.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To avoid having the function's ABI vary depending on the width of time_t,<br/></li>
<li></span><span class="Comment"> * we declare the argument as pg_time_t, which is cast-compatible with<br/></li>
<li></span><span class="Comment"> * time_t but always 64 bits wide (unless the platform has no 64-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> type).<br/></li>
<li></span><span class="Comment"> * This detail should be invisible to callers, at least at source code level.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TimestampTz<br/></li>
<li><a id="L1811">&#x200c;</a><span class="linkable">time_t_to_timestamptz</span>(pg_time_t tm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (TimestampTz) tm -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);<br/></li>
<li>&nbsp; &nbsp; result *= USECS_PER_SEC;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert a TimestampTz to time_t.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This too is just marginally useful, but some places need it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To avoid having the function's ABI vary depending on the width of time_t,<br/></li>
<li></span><span class="Comment"> * we declare the result as pg_time_t, which is cast-compatible with<br/></li>
<li></span><span class="Comment"> * time_t but always 64 bits wide (unless the platform has no 64-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> type).<br/></li>
<li></span><span class="Comment"> * This detail should be invisible to callers, at least at source code level.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>pg_time_t<br/></li>
<li><a id="L1833">&#x200c;</a><span class="linkable">timestamptz_to_time_t</span>(TimestampTz t)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_time_t&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (pg_time_t) (t / USECS_PER_SEC +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Produce a C-string representation of a TimestampTz.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is mostly for use in emitting messages.&nbsp; The primary difference<br/></li>
<li></span><span class="Comment"> * from <a href="#L785" title="utils/adt/timestamp.c:785">timestamptz_out</a> is that we force the output format to ISO.&nbsp; Note<br/></li>
<li></span><span class="Comment"> * also that the result is in a static buffer, not <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>'d.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See also pg_strftime.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1853">&#x200c;</a><span class="linkable">timestamptz_to_str</span>(TimestampTz t)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">char</span> buf[MAXDATELEN + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *tzn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(t))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1596" title="utils/adt/timestamp.c:1596">EncodeSpecialTimestamp</a>(t, buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(t, &amp;tz, tm, &amp;fsec, &amp;tzn, <span class="Constant">NULL</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L4331" title="utils/adt/datetime.c:4331">EncodeDateTime</a>(tm, fsec, <span class="Constant">true</span>, tz, tzn, USE_ISO_DATES, buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; strlcpy(buf, <span class="Constant">&quot;(timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>)&quot;</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buf));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1874">&#x200c;</a></span><span class="linkable">dt2time</span>(Timestamp jd, <span class="Type">int</span> *hour, <span class="Type">int</span> *min, <span class="Type">int</span> *sec, fsec_t *fsec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeOffset&nbsp; &nbsp; time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; time = jd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *hour = time / USECS_PER_HOUR;<br/></li>
<li>&nbsp; &nbsp; time -= (*hour) * USECS_PER_HOUR;<br/></li>
<li>&nbsp; &nbsp; *min = time / USECS_PER_MINUTE;<br/></li>
<li>&nbsp; &nbsp; time -= (*min) * USECS_PER_MINUTE;<br/></li>
<li>&nbsp; &nbsp; *sec = time / USECS_PER_SEC;<br/></li>
<li>&nbsp; &nbsp; *fsec = time - (*sec * USECS_PER_SEC);<br/></li>
<li>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L1874" title="utils/adt/timestamp.c:1874">dt2time</a>() */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>() - Convert timestamp data type to POSIX time structure.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that year is _not_ 1900-based, but is an explicit full value.<br/></li>
<li></span><span class="Comment"> * Also, month is one-based, _not_ zero-based.<br/></li>
<li></span><span class="Comment"> * Returns:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; 0 on success<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; -1 on out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If attimezone is NULL, the global timezone setting will be used.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1901">&#x200c;</a></span><span class="linkable">timestamp2tm</span>(Timestamp dt, <span class="Type">int</span> *tzp, <span class="Type">struct</span> pg_tm *tm, fsec_t *fsec, <span class="Type">const</span> <span class="Type">char</span> **tzn, pg_tz *attimezone)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; date;<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; time;<br/></li>
<li>&nbsp; &nbsp; pg_time_t&nbsp; &nbsp; utime;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use session timezone if caller asks for default */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attimezone == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attimezone = session_timezone;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; time = dt;<br/></li>
<li>&nbsp; &nbsp; TMODULO(time, date, USECS_PER_DAY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (time &lt; INT64CONST(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; time += USECS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; date -= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* add offset to go from J2000 back to standard Julian date */<br/></li>
<li></span>&nbsp; &nbsp; date += POSTGRES_EPOCH_JDATE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Julian day routine does not work for negative Julian <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (date &lt; <span class="Constant">0</span> || date &gt; (Timestamp) <span class="Constant">INT_MAX</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="datetime.c.html#L311" title="utils/adt/datetime.c:311">j2date</a>((<span class="Type">int</span>) date, &amp;tm-&gt;tm_year, &amp;tm-&gt;tm_mon, &amp;tm-&gt;tm_mday);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1874" title="utils/adt/timestamp.c:1874">dt2time</a>(time, &amp;tm-&gt;tm_hour, &amp;tm-&gt;tm_min, &amp;tm-&gt;tm_sec, fsec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done if no TZ conversion wanted */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tzp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_isdst = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_gmtoff = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_zone = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzn != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tzn = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the time falls within the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of pg_time_t, use pg_localtime() to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rotate to the local time zone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, convert to an integral timestamp, avoiding possibly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * platform-specific roundoff-in-wrong-direction errors, and adjust to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unix epoch.&nbsp; Then see if we can convert to pg_time_t without loss. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * coding avoids hardwiring <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> assumptions about the width of pg_time_t,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so it should behave sanely on machines without int64.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dt = (dt - *fsec) / USECS_PER_SEC +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; utime = (pg_time_t) dt;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((Timestamp) utime == dt)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_tm *tx = pg_localtime(&amp;utime, attimezone);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = tx-&gt;tm_year + <span class="Constant">1900</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon = tx-&gt;tm_mon + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday = tx-&gt;tm_mday;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour = tx-&gt;tm_hour;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_min = tx-&gt;tm_min;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_sec = tx-&gt;tm_sec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_isdst = tx-&gt;tm_isdst;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_gmtoff = tx-&gt;tm_gmtoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_zone = tx-&gt;tm_zone;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *tzp = -tm-&gt;tm_gmtoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzn != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tzn = tm-&gt;tm_zone;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of pg_time_t, treat as GMT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *tzp = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark this as *no* time zone available */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_isdst = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_gmtoff = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_zone = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzn != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tzn = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1997" title="utils/adt/timestamp.c:1997">tm2timestamp</a>()<br/></li>
<li></span><span class="Comment"> * Convert a tm structure to a timestamp data type.<br/></li>
<li></span><span class="Comment"> * Note that year is _not_ 1900-based, but is an explicit full value.<br/></li>
<li></span><span class="Comment"> * Also, month is one-based, _not_ zero-based.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns -1 on failure (value out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1997">&#x200c;</a></span><span class="linkable">tm2timestamp</span>(<span class="Type">struct</span> pg_tm *tm, fsec_t fsec, <span class="Type">int</span> *tzp, Timestamp *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeOffset&nbsp; &nbsp; date;<br/></li>
<li>&nbsp; &nbsp; TimeOffset&nbsp; &nbsp; time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prevent overflow in Julian-day routines */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IS_VALID_JULIAN(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *result = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; date = <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday) - POSTGRES_EPOCH_JDATE;<br/></li>
<li>&nbsp; &nbsp; time = <a href="#L2128" title="utils/adt/timestamp.c:2128">time2t</a>(tm-&gt;tm_hour, tm-&gt;tm_min, tm-&gt;tm_sec, fsec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *result = date * USECS_PER_DAY + time;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for major overflow */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((*result - time) / USECS_PER_DAY != date)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *result = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for just-barely overflow (okay except time-of-day wraps) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* caution: we want to allow 1999-12-31 24:00:00 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((*result &lt; <span class="Constant">0</span> &amp;&amp; date &gt; <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*result &gt; <span class="Constant">0</span> &amp;&amp; date &lt; -<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *result = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tzp != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *result = <a href="#L2134" title="utils/adt/timestamp.c:2134">dt2local</a>(*result, -(*tzp));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* final <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> check catches just-out-of-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> timestamps */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IS_VALID_TIMESTAMP(*result))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *result = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2047" title="utils/adt/timestamp.c:2047">interval2itm</a>()<br/></li>
<li></span><span class="Comment"> * Convert an Interval to a pg_itm structure.<br/></li>
<li></span><span class="Comment"> * Note: overflow is not possible, because the pg_itm fields are<br/></li>
<li></span><span class="Comment"> * wide enough for all possible conversion results.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2047">&#x200c;</a></span><span class="linkable">interval2itm</span>(Interval span, <span class="Type">struct</span> pg_itm *itm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeOffset&nbsp; &nbsp; time;<br/></li>
<li>&nbsp; &nbsp; TimeOffset&nbsp; &nbsp; tfrac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itm-&gt;tm_year = span.month / MONTHS_PER_YEAR;<br/></li>
<li>&nbsp; &nbsp; itm-&gt;tm_mon = span.month % MONTHS_PER_YEAR;<br/></li>
<li>&nbsp; &nbsp; itm-&gt;tm_mday = span.day;<br/></li>
<li>&nbsp; &nbsp; time = span.time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tfrac = time / USECS_PER_HOUR;<br/></li>
<li>&nbsp; &nbsp; time -= tfrac * USECS_PER_HOUR;<br/></li>
<li>&nbsp; &nbsp; itm-&gt;tm_hour = tfrac;<br/></li>
<li>&nbsp; &nbsp; tfrac = time / USECS_PER_MINUTE;<br/></li>
<li>&nbsp; &nbsp; time -= tfrac * USECS_PER_MINUTE;<br/></li>
<li>&nbsp; &nbsp; itm-&gt;tm_min = (<span class="Type">int</span>) tfrac;<br/></li>
<li>&nbsp; &nbsp; tfrac = time / USECS_PER_SEC;<br/></li>
<li>&nbsp; &nbsp; time -= tfrac * USECS_PER_SEC;<br/></li>
<li>&nbsp; &nbsp; itm-&gt;tm_sec = (<span class="Type">int</span>) tfrac;<br/></li>
<li>&nbsp; &nbsp; itm-&gt;tm_usec = (<span class="Type">int</span>) time;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2077" title="utils/adt/timestamp.c:2077">itm2interval</a>()<br/></li>
<li></span><span class="Comment"> * Convert a pg_itm structure to an Interval.<br/></li>
<li></span><span class="Comment"> * Returns 0 if OK, -1 on overflow.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is for use in computations expected to produce finite results.&nbsp; Any<br/></li>
<li></span><span class="Comment"> * inputs that lead to infinite results are treated as overflows.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2077">&#x200c;</a></span><span class="linkable">itm2interval</span>(<span class="Type">struct</span> pg_itm *itm, Interval *span)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; total_months = (int64) itm-&gt;tm_year * MONTHS_PER_YEAR + itm-&gt;tm_mon;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (total_months &gt; <span class="Constant">INT_MAX</span> || total_months &lt; <span class="Constant">INT_MIN</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; span-&gt;month = (int32) total_months;<br/></li>
<li>&nbsp; &nbsp; span-&gt;day = itm-&gt;tm_mday;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_mul_s64_overflow(itm-&gt;tm_hour, USECS_PER_HOUR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;span-&gt;time))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* tm_min, tm_sec are 32 bits, so intermediate products can't overflow */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pg_add_s64_overflow(span-&gt;time, itm-&gt;tm_min * USECS_PER_MINUTE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;span-&gt;time))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_add_s64_overflow(span-&gt;time, itm-&gt;tm_sec * USECS_PER_SEC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;span-&gt;time))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_add_s64_overflow(span-&gt;time, itm-&gt;tm_usec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;span-&gt;time))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE(span))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2115" title="utils/adt/timestamp.c:2115">itmin2interval</a>()<br/></li>
<li></span><span class="Comment"> * Convert a pg_itm_in structure to an Interval.<br/></li>
<li></span><span class="Comment"> * Returns 0 if OK, -1 on overflow.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: if the result is infinite, it is not treated as an overflow.&nbsp; This<br/></li>
<li></span><span class="Comment"> * avoids <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a>/reload hazards from pre-17 databases that do not support<br/></li>
<li></span><span class="Comment"> * infinite intervals, but do allow finite intervals with all fields set to<br/></li>
<li></span><span class="Comment"> * INT_MIN/INT_MAX (outside the documented <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>).&nbsp; Such intervals will be<br/></li>
<li></span><span class="Comment"> * silently converted to +/-infinity.&nbsp; This may not be ideal, but seems<br/></li>
<li></span><span class="Comment"> * preferable to failure, and ought to be pretty unlikely in practice.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2115">&#x200c;</a></span><span class="linkable">itmin2interval</span>(<span class="Type">struct</span> pg_itm_in *itm_in, Interval *span)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; total_months = (int64) itm_in-&gt;tm_year * MONTHS_PER_YEAR + itm_in-&gt;tm_mon;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (total_months &gt; <span class="Constant">INT_MAX</span> || total_months &lt; <span class="Constant">INT_MIN</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; span-&gt;month = (int32) total_months;<br/></li>
<li>&nbsp; &nbsp; span-&gt;day = itm_in-&gt;tm_mday;<br/></li>
<li>&nbsp; &nbsp; span-&gt;time = itm_in-&gt;tm_usec;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> TimeOffset<br/></li>
<li><a id="L2128">&#x200c;</a><span class="linkable">time2t</span>(<span class="Type">const</span> <span class="Type">int</span> hour, <span class="Type">const</span> <span class="Type">int</span> min, <span class="Type">const</span> <span class="Type">int</span> sec, <span class="Type">const</span> fsec_t fsec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (((((hour * MINS_PER_HOUR) + min) * SECS_PER_MINUTE) + sec) * USECS_PER_SEC) + fsec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Timestamp<br/></li>
<li><a id="L2134">&#x200c;</a><span class="linkable">dt2local</span>(Timestamp dt, <span class="Type">int</span> timezone)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dt -= (timezone * USECS_PER_SEC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> dt;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; PUBLIC ROUTINES&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2147">&#x200c;</a><span class="linkable">timestamp_finite</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestamp = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(!TIMESTAMP_NOT_FINITE(timestamp));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2155">&#x200c;</a><span class="linkable">interval_finite</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(!INTERVAL_NOT_FINITE(interval));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Relational operators for timestamp.<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L2168">&#x200c;</a></span><span class="linkable">GetEpochTime</span>(<span class="Type">struct</span> pg_tm *tm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm *t0;<br/></li>
<li>&nbsp; &nbsp; pg_time_t&nbsp; &nbsp; epoch = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; t0 = pg_gmtime(&amp;epoch);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (t0 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not convert epoch to timestamp: %m&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tm-&gt;tm_year = t0-&gt;tm_year;<br/></li>
<li>&nbsp; &nbsp; tm-&gt;tm_mon = t0-&gt;tm_mon;<br/></li>
<li>&nbsp; &nbsp; tm-&gt;tm_mday = t0-&gt;tm_mday;<br/></li>
<li>&nbsp; &nbsp; tm-&gt;tm_hour = t0-&gt;tm_hour;<br/></li>
<li>&nbsp; &nbsp; tm-&gt;tm_min = t0-&gt;tm_min;<br/></li>
<li>&nbsp; &nbsp; tm-&gt;tm_sec = t0-&gt;tm_sec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tm-&gt;tm_year += <span class="Constant">1900</span>;<br/></li>
<li>&nbsp; &nbsp; tm-&gt;tm_mon++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Timestamp<br/></li>
<li><a id="L2190">&#x200c;</a><span class="linkable">SetEpochTimestamp</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2168" title="utils/adt/timestamp.c:2168">GetEpochTime</a>(tm);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we don't bother to test for failure ... */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1997" title="utils/adt/timestamp.c:1997">tm2timestamp</a>(tm, <span class="Constant">0</span>, <span class="Constant">NULL</span>, &amp;dt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> dt;<br/></li>
<li>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L2190" title="utils/adt/timestamp.c:2190">SetEpochTimestamp</a>() */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We are currently sharing some code between timestamp and timestamptz.<br/></li>
<li></span><span class="Comment"> * The comparison <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are among them. - thomas 2001-09-25<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; timestamp_relop - is timestamp1 relop timestamp2<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2210">&#x200c;</a></span><span class="linkable">timestamp_cmp_internal</span>(Timestamp dt1, Timestamp dt2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (dt1 &lt; dt2) ? -<span class="Constant">1</span> : ((dt1 &gt; dt2) ? <span class="Constant">1</span> : <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2216">&#x200c;</a><span class="linkable">timestamp_eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt1 = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt2 = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2210" title="utils/adt/timestamp.c:2210">timestamp_cmp_internal</a>(dt1, dt2) == <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2225">&#x200c;</a><span class="linkable">timestamp_ne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt1 = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt2 = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2210" title="utils/adt/timestamp.c:2210">timestamp_cmp_internal</a>(dt1, dt2) != <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2234">&#x200c;</a><span class="linkable">timestamp_lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt1 = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt2 = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2210" title="utils/adt/timestamp.c:2210">timestamp_cmp_internal</a>(dt1, dt2) &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2243">&#x200c;</a><span class="linkable">timestamp_gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt1 = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt2 = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2210" title="utils/adt/timestamp.c:2210">timestamp_cmp_internal</a>(dt1, dt2) &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2252">&#x200c;</a><span class="linkable">timestamp_le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt1 = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt2 = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2210" title="utils/adt/timestamp.c:2210">timestamp_cmp_internal</a>(dt1, dt2) &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2261">&#x200c;</a><span class="linkable">timestamp_ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt1 = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt2 = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2210" title="utils/adt/timestamp.c:2210">timestamp_cmp_internal</a>(dt1, dt2) &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2270">&#x200c;</a><span class="linkable">timestamp_cmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt1 = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt2 = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L2210" title="utils/adt/timestamp.c:2210">timestamp_cmp_internal</a>(dt1, dt2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#if SIZEOF_DATUM &lt; </span><span class="Constant">8<br/></li>
<li></span><span class="Comment">/* note: this is used for timestamptz also */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2281">&#x200c;</a></span><span class="linkable">timestamp_fastcmp</span>(Datum x, Datum y, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; a = DatumGetTimestamp(x);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; b = DatumGetTimestamp(y);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2210" title="utils/adt/timestamp.c:2210">timestamp_cmp_internal</a>(a, b);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L2291">&#x200c;</a><span class="linkable">timestamp_sortsupport</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortSupport ssup = (SortSupport) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#if SIZEOF_DATUM &gt;= </span><span class="Constant">8<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this build has pass-by-value timestamps, then we can use a standard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comparator function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ssup-&gt;comparator = <a href="../sort/tuplesort.c.html#L3189" title="utils/sort/tuplesort.c:3189">ssup_datum_signed_cmp</a>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; ssup-&gt;comparator = <a href="#L2281" title="utils/adt/timestamp.c:2281">timestamp_fastcmp</a>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2309">&#x200c;</a><span class="linkable">timestamp_hash</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../access/hash/hashfunc.c.html#L83" title="access/hash/hashfunc.c:83">hashint8</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2315">&#x200c;</a><span class="linkable">timestamp_hash_extended</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../access/hash/hashfunc.c.html#L103" title="access/hash/hashfunc.c:103">hashint8extended</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cross-type comparison <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for timestamp vs timestamptz<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>int32<br/></li>
<li><a id="L2325">&#x200c;</a><span class="linkable">timestamp_cmp_timestamptz_internal</span>(Timestamp timestampVal, TimestampTz dt2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overflow;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dt1 = <a href="#L6292" title="utils/adt/timestamp.c:6292">timestamp2timestamptz_opt_overflow</a>(timestampVal, &amp;overflow);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (overflow &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dt1 is larger than <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> finite timestamp, but less than infinity */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TIMESTAMP_IS_NOEND(dt2) ? -<span class="Constant">1</span> : +<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (overflow &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dt1 is less than <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> finite timestamp, but more than -infinity */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TIMESTAMP_IS_NOBEGIN(dt2) ? +<span class="Constant">1</span> : -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> timestamptz_cmp_internal(dt1, dt2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2346">&#x200c;</a><span class="linkable">timestamp_eq_timestamptz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestampVal = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2325" title="utils/adt/timestamp.c:2325">timestamp_cmp_timestamptz_internal</a>(timestampVal, dt2) == <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2355">&#x200c;</a><span class="linkable">timestamp_ne_timestamptz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestampVal = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2325" title="utils/adt/timestamp.c:2325">timestamp_cmp_timestamptz_internal</a>(timestampVal, dt2) != <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2364">&#x200c;</a><span class="linkable">timestamp_lt_timestamptz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestampVal = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2325" title="utils/adt/timestamp.c:2325">timestamp_cmp_timestamptz_internal</a>(timestampVal, dt2) &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2373">&#x200c;</a><span class="linkable">timestamp_gt_timestamptz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestampVal = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2325" title="utils/adt/timestamp.c:2325">timestamp_cmp_timestamptz_internal</a>(timestampVal, dt2) &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2382">&#x200c;</a><span class="linkable">timestamp_le_timestamptz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestampVal = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2325" title="utils/adt/timestamp.c:2325">timestamp_cmp_timestamptz_internal</a>(timestampVal, dt2) &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2391">&#x200c;</a><span class="linkable">timestamp_ge_timestamptz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestampVal = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2325" title="utils/adt/timestamp.c:2325">timestamp_cmp_timestamptz_internal</a>(timestampVal, dt2) &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2400">&#x200c;</a><span class="linkable">timestamp_cmp_timestamptz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestampVal = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L2325" title="utils/adt/timestamp.c:2325">timestamp_cmp_timestamptz_internal</a>(timestampVal, dt2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2409">&#x200c;</a><span class="linkable">timestamptz_eq_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestampVal = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2325" title="utils/adt/timestamp.c:2325">timestamp_cmp_timestamptz_internal</a>(timestampVal, dt1) == <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2418">&#x200c;</a><span class="linkable">timestamptz_ne_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestampVal = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2325" title="utils/adt/timestamp.c:2325">timestamp_cmp_timestamptz_internal</a>(timestampVal, dt1) != <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2427">&#x200c;</a><span class="linkable">timestamptz_lt_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestampVal = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2325" title="utils/adt/timestamp.c:2325">timestamp_cmp_timestamptz_internal</a>(timestampVal, dt1) &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2436">&#x200c;</a><span class="linkable">timestamptz_gt_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestampVal = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2325" title="utils/adt/timestamp.c:2325">timestamp_cmp_timestamptz_internal</a>(timestampVal, dt1) &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2445">&#x200c;</a><span class="linkable">timestamptz_le_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestampVal = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2325" title="utils/adt/timestamp.c:2325">timestamp_cmp_timestamptz_internal</a>(timestampVal, dt1) &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2454">&#x200c;</a><span class="linkable">timestamptz_ge_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestampVal = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2325" title="utils/adt/timestamp.c:2325">timestamp_cmp_timestamptz_internal</a>(timestampVal, dt1) &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2463">&#x200c;</a><span class="linkable">timestamptz_cmp_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestampVal = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(-<a href="#L2325" title="utils/adt/timestamp.c:2325">timestamp_cmp_timestamptz_internal</a>(timestampVal, dt1));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; interval_relop&nbsp; &nbsp; - is interval1 relop interval2<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Interval comparison is based on converting interval <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to a linear<br/></li>
<li></span><span class="Comment"> * representation expressed in the units of the time field (microseconds,<br/></li>
<li></span><span class="Comment"> * in the case of integer timestamps) with <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> assumed to be always 24 hours<br/></li>
<li></span><span class="Comment"> * and <a href="datetime.c.html#L81" title="utils/adt/datetime.c:81">months</a> assumed to be always 30 <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a>.&nbsp; To avoid overflow, we need a<br/></li>
<li></span><span class="Comment"> * wider-than-int64 datatype for the linear representation, so use INT128.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> INT128<br/></li>
<li><a id="L2483">&#x200c;</a><span class="linkable">interval_cmp_value</span>(<span class="Type">const</span> Interval *interval)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; INT128&nbsp; &nbsp; &nbsp; &nbsp; span;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Combine the month and day fields into an integral number of <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because the inputs are int32, int64 arithmetic suffices here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> = interval-&gt;month * INT64CONST(<span class="Constant">30</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> += interval-&gt;day;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Widen time field to 128 bits */<br/></li>
<li></span>&nbsp; &nbsp; span = int64_to_int128(interval-&gt;time);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scale up <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> to microseconds, forming a 128-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> product */<br/></li>
<li></span>&nbsp; &nbsp; int128_add_int64_mul_int64(&amp;span, <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a>, USECS_PER_DAY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> span;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2505">&#x200c;</a></span><span class="linkable">interval_cmp_internal</span>(<span class="Type">const</span> Interval *interval1, <span class="Type">const</span> Interval *interval2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; INT128&nbsp; &nbsp; &nbsp; &nbsp; span1 = <a href="#L2483" title="utils/adt/timestamp.c:2483">interval_cmp_value</a>(interval1);<br/></li>
<li>&nbsp; &nbsp; INT128&nbsp; &nbsp; &nbsp; &nbsp; span2 = <a href="#L2483" title="utils/adt/timestamp.c:2483">interval_cmp_value</a>(interval2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> int128_compare(span1, span2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2514">&#x200c;</a></span><span class="linkable">interval_sign</span>(<span class="Type">const</span> Interval *interval)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; INT128&nbsp; &nbsp; &nbsp; &nbsp; span = <a href="#L2483" title="utils/adt/timestamp.c:2483">interval_cmp_value</a>(interval);<br/></li>
<li>&nbsp; &nbsp; INT128&nbsp; &nbsp; &nbsp; &nbsp; zero = int64_to_int128(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> int128_compare(span, zero);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2523">&#x200c;</a><span class="linkable">interval_eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval1 = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval2 = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2505" title="utils/adt/timestamp.c:2505">interval_cmp_internal</a>(interval1, interval2) == <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2532">&#x200c;</a><span class="linkable">interval_ne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval1 = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval2 = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2505" title="utils/adt/timestamp.c:2505">interval_cmp_internal</a>(interval1, interval2) != <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2541">&#x200c;</a><span class="linkable">interval_lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval1 = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval2 = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2505" title="utils/adt/timestamp.c:2505">interval_cmp_internal</a>(interval1, interval2) &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2550">&#x200c;</a><span class="linkable">interval_gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval1 = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval2 = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2505" title="utils/adt/timestamp.c:2505">interval_cmp_internal</a>(interval1, interval2) &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2559">&#x200c;</a><span class="linkable">interval_le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval1 = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval2 = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2505" title="utils/adt/timestamp.c:2505">interval_cmp_internal</a>(interval1, interval2) &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2568">&#x200c;</a><span class="linkable">interval_ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval1 = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval2 = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2505" title="utils/adt/timestamp.c:2505">interval_cmp_internal</a>(interval1, interval2) &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2577">&#x200c;</a><span class="linkable">interval_cmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval1 = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval2 = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L2505" title="utils/adt/timestamp.c:2505">interval_cmp_internal</a>(interval1, interval2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Hashing for intervals<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We must produce <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> hashvals for <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that <a href="#L2505" title="utils/adt/timestamp.c:2505">interval_cmp_internal</a>()<br/></li>
<li></span><span class="Comment"> * considers <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.&nbsp; So, compute the net span the same way it does,<br/></li>
<li></span><span class="Comment"> * and then <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2593">&#x200c;</a><span class="linkable">interval_hash</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; INT128&nbsp; &nbsp; &nbsp; &nbsp; span = <a href="#L2483" title="utils/adt/timestamp.c:2483">interval_cmp_value</a>(interval);<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; span64;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use only the least significant 64 bits for hashing.&nbsp; The <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> 64 bits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seldom add <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> useful information, and besides we must do it like this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for compatibility with hashes calculated <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> use of INT128 was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * introduced.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; span64 = int128_to_int64(span);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall1(<a href="../../access/hash/hashfunc.c.html#L83" title="access/hash/hashfunc.c:83">hashint8</a>, Int64GetDatumFast(span64));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2611">&#x200c;</a><span class="linkable">interval_hash_extended</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; INT128&nbsp; &nbsp; &nbsp; &nbsp; span = <a href="#L2483" title="utils/adt/timestamp.c:2483">interval_cmp_value</a>(interval);<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; span64;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Same approach as <a href="#L2593" title="utils/adt/timestamp.c:2593">interval_hash</a> */<br/></li>
<li></span>&nbsp; &nbsp; span64 = int128_to_int64(span);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall2(<a href="../../access/hash/hashfunc.c.html#L103" title="access/hash/hashfunc.c:103">hashint8extended</a>, Int64GetDatumFast(span64),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_GETARG_DATUM(<span class="Constant">1</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2631" title="utils/adt/timestamp.c:2631">overlaps_timestamp</a>() --- implements the SQL OVERLAPS operator.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Algorithm is per SQL spec.&nbsp; This is much harder than you'd think<br/></li>
<li></span><span class="Comment"> * because the spec requires us to deliver a non-null answer in some cases<br/></li>
<li></span><span class="Comment"> * where some of the inputs are null.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2631">&#x200c;</a><span class="linkable">overlaps_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The arguments are Timestamps, but we leave them as generic Datums to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoid unnecessary conversions between value and reference forms --- not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to mention possible dereferences of null pointers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; ts1 = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; te1 = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; ts2 = PG_GETARG_DATUM(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; te2 = PG_GETARG_DATUM(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ts1IsNull = PG_ARGISNULL(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; te1IsNull = PG_ARGISNULL(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ts2IsNull = PG_ARGISNULL(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; te2IsNull = PG_ARGISNULL(<span class="Constant">3</span>);<br/></li>
<li><br/></li>
<li><a id="L2647">&#x200c;</a><span class="PreProc">#define <span class="linkable">TIMESTAMP_GT</span>(t1,t2) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; DatumGetBool(DirectFunctionCall2(<a href="#L2243" title="utils/adt/timestamp.c:2243">timestamp_gt</a>,t1,t2))<br/></li>
<li><a id="L2649">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TIMESTAMP_LT</span>(t1,t2) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; DatumGetBool(DirectFunctionCall2(<a href="#L2234" title="utils/adt/timestamp.c:2234">timestamp_lt</a>,t1,t2))<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If both endpoints of interval 1 are null, the result is null (unknown).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If just one endpoint is null, take ts1 as the non-null one. Otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * take ts1 as the lesser endpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ts1IsNull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (te1IsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* swap null for non-null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ts1 = te1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; te1IsNull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!te1IsNull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2647" title="utils/adt/timestamp.c:2647">TIMESTAMP_GT</a>(ts1, te1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; tt = ts1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ts1 = te1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; te1 = tt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Likewise for interval 2. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ts2IsNull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (te2IsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* swap null for non-null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ts2 = te2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; te2IsNull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!te2IsNull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2647" title="utils/adt/timestamp.c:2647">TIMESTAMP_GT</a>(ts2, te2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; tt = ts2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ts2 = te2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; te2 = tt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At this point neither ts1 nor ts2 is null, so we can consider three<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases: ts1 &gt; ts2, ts1 &lt; ts2, ts1 = ts2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2647" title="utils/adt/timestamp.c:2647">TIMESTAMP_GT</a>(ts1, ts2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This case is ts1 &lt; te2 OR te1 &lt; te2, which may look redundant but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the presence of nulls it's not quite completely so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (te2IsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2649" title="utils/adt/timestamp.c:2649">TIMESTAMP_LT</a>(ts1, te2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (te1IsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If te1 is not null then we had ts1 &lt;= te1 above, and we just found<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ts1 &gt;= te2, hence te1 &gt;= te2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L2649" title="utils/adt/timestamp.c:2649">TIMESTAMP_LT</a>(ts1, ts2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This case is ts2 &lt; te1 OR te2 &lt; te1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (te1IsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2649" title="utils/adt/timestamp.c:2649">TIMESTAMP_LT</a>(ts2, te1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (te2IsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If te2 is not null then we had ts2 &lt;= te2 above, and we just found<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ts2 &gt;= te1, hence te2 &gt;= te1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For ts1 = ts2 the spec says te1 &lt;&gt; te2 OR te1 = te2, which is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rather silly way of saying &quot;true if both are non-null, else null&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (te1IsNull || te2IsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><a id="L2746">&#x200c;</a><span class="PreProc">#undef <span class="linkable">TIMESTAMP_GT</span><br/></li>
<li><a id="L2747">&#x200c;</a></span><span class="PreProc">#undef <span class="linkable">TIMESTAMP_LT</span><br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &quot;Arithmetic&quot; operators on date/times.<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L2756">&#x200c;</a><span class="linkable">timestamp_smaller</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt1 = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt2 = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use <a href="#L2210" title="utils/adt/timestamp.c:2210">timestamp_cmp_internal</a> to be sure this agrees with comparisons */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2210" title="utils/adt/timestamp.c:2210">timestamp_cmp_internal</a>(dt1, dt2) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = dt1;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = dt2;<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMP(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2771">&#x200c;</a><span class="linkable">timestamp_larger</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt1 = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt2 = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2210" title="utils/adt/timestamp.c:2210">timestamp_cmp_internal</a>(dt1, dt2) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = dt1;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = dt2;<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMP(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2786">&#x200c;</a><span class="linkable">timestamp_mi</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt1 = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt2 = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Interval *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle infinities.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We treat anything that amounts to &quot;infinity - infinity&quot; as an error,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since the interval type has nothing equivalent to NaN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(dt1) || TIMESTAMP_NOT_FINITE(dt2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_IS_NOBEGIN(dt1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_IS_NOBEGIN(dt2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOBEGIN(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (TIMESTAMP_IS_NOEND(dt1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_IS_NOEND(dt2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (TIMESTAMP_IS_NOBEGIN(dt2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* TIMESTAMP_IS_NOEND(dt2) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOBEGIN(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(pg_sub_s64_overflow(dt1, dt2, &amp;result-&gt;time)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;month = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;day = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; This is wrong, but removing it breaks a lot of regression tests.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; For example:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; test=&gt; <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> timezone = 'EST5EDT';<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; test=&gt; SELECT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; test-&gt; ('2005-10-30 13:22:00-05'::timestamptz -<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; test(&gt;&nbsp; &nbsp; '2005-10-29 13:22:00-04'::timestamptz);<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; ?column?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; ----------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp;&nbsp; 1 day 01:00:00<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp;&nbsp; (1 row)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; so adding that to the first timestamp gets:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp;&nbsp; test=&gt; SELECT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp;&nbsp; test-&gt; ('2005-10-29 13:22:00-04'::timestamptz +<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp;&nbsp; test(&gt; ('2005-10-30 13:22:00-05'::timestamptz -<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp;&nbsp; test(&gt;&nbsp; '2005-10-29 13:22:00-04'::timestamptz)) at time zone 'EST';<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; timezone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; --------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; 2005-10-30 14:22:00<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; (1 row)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = DatumGetIntervalP(DirectFunctionCall1(<a href="#L2960" title="utils/adt/timestamp.c:2960">interval_justify_hours</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IntervalPGetDatum(result)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2880" title="utils/adt/timestamp.c:2880">interval_justify_interval</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Adjust interval so 'month', 'day', and 'time' portions are within<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; customary bounds.&nbsp; Specifically:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 0 &lt;= abs(time) &lt; 24 hours<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 0 &lt;= abs(day)&nbsp; &lt; 30 <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Also, the sign <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> on all three fields is made <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, so either<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; all three fields are negative or all are positive.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2880">&#x200c;</a><span class="linkable">interval_justify_interval</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *span = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; TimeOffset&nbsp; &nbsp; wholeday;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; wholemonth;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Interval *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li>&nbsp; &nbsp; result-&gt;month = span-&gt;month;<br/></li>
<li>&nbsp; &nbsp; result-&gt;day = span-&gt;day;<br/></li>
<li>&nbsp; &nbsp; result-&gt;time = span-&gt;time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do nothing for infinite intervals */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pre-justify <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> if it might prevent overflow */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((result-&gt;day &gt; <span class="Constant">0</span> &amp;&amp; result-&gt;time &gt; <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (result-&gt;day &lt; <span class="Constant">0</span> &amp;&amp; result-&gt;time &lt; <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wholemonth = result-&gt;day / DAYS_PER_MONTH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;day -= wholemonth * DAYS_PER_MONTH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_add_s32_overflow(result-&gt;month, wholemonth, &amp;result-&gt;month))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since TimeOffset is int64, abs(wholeday) can't exceed about 1.07e8.&nbsp; If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we pre-justified then abs(result-&gt;day) is less than DAYS_PER_MONTH, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this addition can't overflow.&nbsp; If we didn't pre-justify, then day and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * time are of different signs, so it still can't overflow.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; TMODULO(result-&gt;time, wholeday, USECS_PER_DAY);<br/></li>
<li>&nbsp; &nbsp; result-&gt;day += wholeday;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; wholemonth = result-&gt;day / DAYS_PER_MONTH;<br/></li>
<li>&nbsp; &nbsp; result-&gt;day -= wholemonth * DAYS_PER_MONTH;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_add_s32_overflow(result-&gt;month, wholemonth, &amp;result-&gt;month))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result-&gt;month &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (result-&gt;day &lt; <span class="Constant">0</span> || (result-&gt;day == <span class="Constant">0</span> &amp;&amp; result-&gt;time &lt; <span class="Constant">0</span>)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;day += DAYS_PER_MONTH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;month--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (result-&gt;month &lt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (result-&gt;day &gt; <span class="Constant">0</span> || (result-&gt;day == <span class="Constant">0</span> &amp;&amp; result-&gt;time &gt; <span class="Constant">0</span>)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;day -= DAYS_PER_MONTH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;month++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result-&gt;day &gt; <span class="Constant">0</span> &amp;&amp; result-&gt;time &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;time += USECS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;day--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (result-&gt;day &lt; <span class="Constant">0</span> &amp;&amp; result-&gt;time &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;time -= USECS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;day++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2960" title="utils/adt/timestamp.c:2960">interval_justify_hours</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Adjust interval so 'time' contains less than a whole day, adding<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the excess to 'day'.&nbsp; This is useful for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; situations (such as non-TZ) where '1 day' = '24 hours' is valid,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; e.g. interval subtraction and division.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2960">&#x200c;</a><span class="linkable">interval_justify_hours</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *span = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; TimeOffset&nbsp; &nbsp; wholeday;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Interval *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li>&nbsp; &nbsp; result-&gt;month = span-&gt;month;<br/></li>
<li>&nbsp; &nbsp; result-&gt;day = span-&gt;day;<br/></li>
<li>&nbsp; &nbsp; result-&gt;time = span-&gt;time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do nothing for infinite intervals */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TMODULO(result-&gt;time, wholeday, USECS_PER_DAY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_add_s32_overflow(result-&gt;day, wholeday, &amp;result-&gt;day))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result-&gt;day &gt; <span class="Constant">0</span> &amp;&amp; result-&gt;time &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;time += USECS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;day--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (result-&gt;day &lt; <span class="Constant">0</span> &amp;&amp; result-&gt;time &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;time -= USECS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;day++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L3002" title="utils/adt/timestamp.c:3002">interval_justify_days</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Adjust interval so 'day' contains less than 30 <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a>, adding<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the excess to 'month'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3002">&#x200c;</a><span class="linkable">interval_justify_days</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *span = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; wholemonth;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Interval *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li>&nbsp; &nbsp; result-&gt;month = span-&gt;month;<br/></li>
<li>&nbsp; &nbsp; result-&gt;day = span-&gt;day;<br/></li>
<li>&nbsp; &nbsp; result-&gt;time = span-&gt;time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do nothing for infinite intervals */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; wholemonth = result-&gt;day / DAYS_PER_MONTH;<br/></li>
<li>&nbsp; &nbsp; result-&gt;day -= wholemonth * DAYS_PER_MONTH;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_add_s32_overflow(result-&gt;month, wholemonth, &amp;result-&gt;month))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result-&gt;month &gt; <span class="Constant">0</span> &amp;&amp; result-&gt;day &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;day += DAYS_PER_MONTH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;month--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (result-&gt;month &lt; <span class="Constant">0</span> &amp;&amp; result-&gt;day &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;day -= DAYS_PER_MONTH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;month++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L3049" title="utils/adt/timestamp.c:3049">timestamp_pl_interval</a>()<br/></li>
<li></span><span class="Comment"> * Add an interval to a timestamp data type.<br/></li>
<li></span><span class="Comment"> * Note that interval has provisions for qualitative year/month and day<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; units, so try to do the right thing with them.<br/></li>
<li></span><span class="Comment"> * To add a month, increment the month, and use the same day of month.<br/></li>
<li></span><span class="Comment"> * Then, if the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> month has fewer <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a>, set the day of month<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; to the last day of month.<br/></li>
<li></span><span class="Comment"> * To add a day, increment the mday, and use the same time of day.<br/></li>
<li></span><span class="Comment"> * Lastly, add in the &quot;quantitative time&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3049">&#x200c;</a><span class="linkable">timestamp_pl_interval</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestamp = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *span = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle infinities.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We treat anything that amounts to &quot;infinity - infinity&quot; as an error,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since the timestamp type has nothing equivalent to NaN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_IS_NOBEGIN(span))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_IS_NOEND(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TIMESTAMP_NOBEGIN(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (INTERVAL_IS_NOEND(span))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_IS_NOBEGIN(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TIMESTAMP_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = timestamp;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (span-&gt;month != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, <span class="Constant">NULL</span>, tm, &amp;fsec, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon += span-&gt;month;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_mon &gt; MONTHS_PER_YEAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year += (tm-&gt;tm_mon - <span class="Constant">1</span>) / MONTHS_PER_YEAR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon = ((tm-&gt;tm_mon - <span class="Constant">1</span>) % MONTHS_PER_YEAR) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (tm-&gt;tm_mon &lt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year += tm-&gt;tm_mon / MONTHS_PER_YEAR - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon = tm-&gt;tm_mon % MONTHS_PER_YEAR + MONTHS_PER_YEAR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* adjust for end of month boundary problems... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_mday &gt; <a href="datetime.c.html#L75" title="utils/adt/datetime.c:75">day_tab</a>[isleap(tm-&gt;tm_year)][tm-&gt;tm_mon - <span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday = (<a href="datetime.c.html#L75" title="utils/adt/datetime.c:75">day_tab</a>[isleap(tm-&gt;tm_year)][tm-&gt;tm_mon - <span class="Constant">1</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1997" title="utils/adt/timestamp.c:1997">tm2timestamp</a>(tm, fsec, <span class="Constant">NULL</span>, &amp;timestamp) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (span-&gt;day != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; julian;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, <span class="Constant">NULL</span>, tm, &amp;fsec, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> by converting to and from Julian.&nbsp; We need an overflow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check here since <a href="datetime.c.html#L311" title="utils/adt/datetime.c:311">j2date</a> expects a non-negative integer input.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; julian = <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_add_s32_overflow(julian, span-&gt;day, &amp;julian) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; julian &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L311" title="utils/adt/datetime.c:311">j2date</a>(julian, &amp;tm-&gt;tm_year, &amp;tm-&gt;tm_mon, &amp;tm-&gt;tm_mday);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1997" title="utils/adt/timestamp.c:1997">tm2timestamp</a>(tm, fsec, <span class="Constant">NULL</span>, &amp;timestamp) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; timestamp += span-&gt;time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IS_VALID_TIMESTAMP(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = timestamp;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMP(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3160">&#x200c;</a><span class="linkable">timestamp_mi_interval</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestamp = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *span = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp; &nbsp; tspan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3373" title="utils/adt/timestamp.c:3373">interval_um_internal</a>(span, &amp;tspan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall2(<a href="#L3049" title="utils/adt/timestamp.c:3049">timestamp_pl_interval</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimestampGetDatum(timestamp),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(&amp;tspan));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L3186" title="utils/adt/timestamp.c:3186">timestamptz_pl_interval_internal</a>()<br/></li>
<li></span><span class="Comment"> * Add an interval to a timestamptz, in the given (or session) timezone.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that interval has provisions for qualitative year/month and day<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; units, so try to do the right thing with them.<br/></li>
<li></span><span class="Comment"> * To add a month, increment the month, and use the same day of month.<br/></li>
<li></span><span class="Comment"> * Then, if the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> month has fewer <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a>, set the day of month<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; to the last day of month.<br/></li>
<li></span><span class="Comment"> * To add a day, increment the mday, and use the same time of day.<br/></li>
<li></span><span class="Comment"> * Lastly, add in the &quot;quantitative time&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TimestampTz<br/></li>
<li><a id="L3186">&#x200c;</a><span class="linkable">timestamptz_pl_interval_internal</span>(TimestampTz timestamp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Interval *span,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_tz *attimezone)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle infinities.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We treat anything that amounts to &quot;infinity - infinity&quot; as an error,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since the timestamptz type has nothing equivalent to NaN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_IS_NOBEGIN(span))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_IS_NOEND(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TIMESTAMP_NOBEGIN(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (INTERVAL_IS_NOEND(span))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_IS_NOBEGIN(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TIMESTAMP_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = timestamp;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use session timezone if caller asks for default */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attimezone == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attimezone = session_timezone;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (span-&gt;month != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, &amp;tz, tm, &amp;fsec, <span class="Constant">NULL</span>, attimezone) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon += span-&gt;month;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_mon &gt; MONTHS_PER_YEAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year += (tm-&gt;tm_mon - <span class="Constant">1</span>) / MONTHS_PER_YEAR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon = ((tm-&gt;tm_mon - <span class="Constant">1</span>) % MONTHS_PER_YEAR) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (tm-&gt;tm_mon &lt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year += tm-&gt;tm_mon / MONTHS_PER_YEAR - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon = tm-&gt;tm_mon % MONTHS_PER_YEAR + MONTHS_PER_YEAR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* adjust for end of month boundary problems... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_mday &gt; <a href="datetime.c.html#L75" title="utils/adt/datetime.c:75">day_tab</a>[isleap(tm-&gt;tm_year)][tm-&gt;tm_mon - <span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday = (<a href="datetime.c.html#L75" title="utils/adt/datetime.c:75">day_tab</a>[isleap(tm-&gt;tm_year)][tm-&gt;tm_mon - <span class="Constant">1</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz = <a href="datetime.c.html#L1585" title="utils/adt/datetime.c:1585">DetermineTimeZoneOffset</a>(tm, attimezone);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1997" title="utils/adt/timestamp.c:1997">tm2timestamp</a>(tm, fsec, &amp;tz, &amp;timestamp) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (span-&gt;day != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; julian;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, &amp;tz, tm, &amp;fsec, <span class="Constant">NULL</span>, attimezone) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> by converting to and from Julian.&nbsp; We need an overflow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check here since <a href="datetime.c.html#L311" title="utils/adt/datetime.c:311">j2date</a> expects a non-negative integer input.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In practice though, it will give correct answers for small<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * negative Julian dates; we should allow -1 to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * timezone-dependent failures, as discussed in timestamp.h.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; julian = <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_add_s32_overflow(julian, span-&gt;day, &amp;julian) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; julian &lt; -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="datetime.c.html#L311" title="utils/adt/datetime.c:311">j2date</a>(julian, &amp;tm-&gt;tm_year, &amp;tm-&gt;tm_mon, &amp;tm-&gt;tm_mday);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz = <a href="datetime.c.html#L1585" title="utils/adt/datetime.c:1585">DetermineTimeZoneOffset</a>(tm, attimezone);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1997" title="utils/adt/timestamp.c:1997">tm2timestamp</a>(tm, fsec, &amp;tz, &amp;timestamp) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; timestamp += span-&gt;time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IS_VALID_TIMESTAMP(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = timestamp;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L3312" title="utils/adt/timestamp.c:3312">timestamptz_mi_interval_internal</a>()<br/></li>
<li></span><span class="Comment"> * As above, but subtract the interval.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TimestampTz<br/></li>
<li><a id="L3312">&#x200c;</a><span class="linkable">timestamptz_mi_interval_internal</span>(TimestampTz timestamp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Interval *span,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_tz *attimezone)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp; &nbsp; tspan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3373" title="utils/adt/timestamp.c:3373">interval_um_internal</a>(span, &amp;tspan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3186" title="utils/adt/timestamp.c:3186">timestamptz_pl_interval_internal</a>(timestamp, &amp;tspan, attimezone);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L3327" title="utils/adt/timestamp.c:3327">timestamptz_pl_interval</a>()<br/></li>
<li></span><span class="Comment"> * Add an interval to a timestamptz, in the session timezone.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3327">&#x200c;</a><span class="linkable">timestamptz_pl_interval</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *span = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMP(<a href="#L3186" title="utils/adt/timestamp.c:3186">timestamptz_pl_interval_internal</a>(timestamp, span, <span class="Constant">NULL</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3336">&#x200c;</a><span class="linkable">timestamptz_mi_interval</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *span = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMP(<a href="#L3312" title="utils/adt/timestamp.c:3312">timestamptz_mi_interval_internal</a>(timestamp, span, <span class="Constant">NULL</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L3348" title="utils/adt/timestamp.c:3348">timestamptz_pl_interval_at_zone</a>()<br/></li>
<li></span><span class="Comment"> * Add an interval to a timestamptz, in the specified timezone.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3348">&#x200c;</a><span class="linkable">timestamptz_pl_interval_at_zone</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *span = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *zone = PG_GETARG_TEXT_PP(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; pg_tz&nbsp; &nbsp; &nbsp;&nbsp; *attimezone = <a href="#L558" title="utils/adt/timestamp.c:558">lookup_timezone</a>(zone);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMP(<a href="#L3186" title="utils/adt/timestamp.c:3186">timestamptz_pl_interval_internal</a>(timestamp, span, attimezone));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3359">&#x200c;</a><span class="linkable">timestamptz_mi_interval_at_zone</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *span = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *zone = PG_GETARG_TEXT_PP(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; pg_tz&nbsp; &nbsp; &nbsp;&nbsp; *attimezone = <a href="#L558" title="utils/adt/timestamp.c:558">lookup_timezone</a>(zone);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMP(<a href="#L3312" title="utils/adt/timestamp.c:3312">timestamptz_mi_interval_internal</a>(timestamp, span, attimezone));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L3373" title="utils/adt/timestamp.c:3373">interval_um_internal</a>()<br/></li>
<li></span><span class="Comment"> * Negate an interval.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3373">&#x200c;</a></span><span class="linkable">interval_um_internal</span>(<span class="Type">const</span> Interval *interval, Interval *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_IS_NOBEGIN(interval))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (INTERVAL_IS_NOEND(interval))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOBEGIN(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Negate each field, guarding against overflow */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_sub_s64_overflow(INT64CONST(<span class="Constant">0</span>), interval-&gt;time, &amp;result-&gt;time) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_sub_s32_overflow(<span class="Constant">0</span>, interval-&gt;day, &amp;result-&gt;day) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_sub_s32_overflow(<span class="Constant">0</span>, interval-&gt;month, &amp;result-&gt;month) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOT_FINITE(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3393">&#x200c;</a><span class="linkable">interval_um</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Interval *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li>&nbsp; &nbsp; <a href="#L3373" title="utils/adt/timestamp.c:3373">interval_um_internal</a>(interval, result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3406">&#x200c;</a><span class="linkable">interval_smaller</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval1 = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval2 = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use <a href="#L2505" title="utils/adt/timestamp.c:2505">interval_cmp_internal</a> to be sure this agrees with comparisons */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2505" title="utils/adt/timestamp.c:2505">interval_cmp_internal</a>(interval1, interval2) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = interval1;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = interval2;<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3421">&#x200c;</a><span class="linkable">interval_larger</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval1 = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval2 = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2505" title="utils/adt/timestamp.c:2505">interval_cmp_internal</a>(interval1, interval2) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = interval1;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = interval2;<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3435">&#x200c;</a></span><span class="linkable">finite_interval_pl</span>(<span class="Type">const</span> Interval *span1, <span class="Type">const</span> Interval *span2, Interval *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!INTERVAL_NOT_FINITE(span1));<br/></li>
<li>&nbsp; &nbsp; Assert(!INTERVAL_NOT_FINITE(span2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_add_s32_overflow(span1-&gt;month, span2-&gt;month, &amp;result-&gt;month) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_add_s32_overflow(span1-&gt;day, span2-&gt;day, &amp;result-&gt;day) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_add_s64_overflow(span1-&gt;time, span2-&gt;time, &amp;result-&gt;time) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOT_FINITE(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3450">&#x200c;</a><span class="linkable">interval_pl</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *span1 = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *span2 = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Interval *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle infinities.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We treat anything that amounts to &quot;infinity - infinity&quot; as an error,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since the interval type has nothing equivalent to NaN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_IS_NOBEGIN(span1))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_IS_NOEND(span2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOBEGIN(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (INTERVAL_IS_NOEND(span1))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_IS_NOBEGIN(span2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (INTERVAL_NOT_FINITE(span2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(result, span2, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3435" title="utils/adt/timestamp.c:3435">finite_interval_pl</a>(span1, span2, result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3491">&#x200c;</a></span><span class="linkable">finite_interval_mi</span>(<span class="Type">const</span> Interval *span1, <span class="Type">const</span> Interval *span2, Interval *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!INTERVAL_NOT_FINITE(span1));<br/></li>
<li>&nbsp; &nbsp; Assert(!INTERVAL_NOT_FINITE(span2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_sub_s32_overflow(span1-&gt;month, span2-&gt;month, &amp;result-&gt;month) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_sub_s32_overflow(span1-&gt;day, span2-&gt;day, &amp;result-&gt;day) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_sub_s64_overflow(span1-&gt;time, span2-&gt;time, &amp;result-&gt;time) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOT_FINITE(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3506">&#x200c;</a><span class="linkable">interval_mi</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *span1 = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *span2 = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Interval *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle infinities.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We treat anything that amounts to &quot;infinity - infinity&quot; as an error,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since the interval type has nothing equivalent to NaN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_IS_NOBEGIN(span1))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_IS_NOBEGIN(span2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOBEGIN(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (INTERVAL_IS_NOEND(span1))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_IS_NOEND(span2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (INTERVAL_IS_NOBEGIN(span2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (INTERVAL_IS_NOEND(span2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOBEGIN(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3491" title="utils/adt/timestamp.c:3491">finite_interval_mi</a>(span1, span2, result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; There is no interval_abs():&nbsp; it is unclear what value to return:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; http://archives.postgresql.org/pgsql-general/2009-10/msg01031.php<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; http://archives.postgresql.org/pgsql-general/2009-11/msg00041.php<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L3555">&#x200c;</a><span class="linkable">interval_mul</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *span = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; factor = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; month_remainder_days,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sec_remainder,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_double;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; orig_month = span-&gt;month,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_day = span-&gt;day;<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Interval *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and infinities.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We treat &quot;0 * infinity&quot; and &quot;infinity * 0&quot; as errors, since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interval type has nothing equivalent to NaN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(factor))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE(span))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (factor == <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (factor &lt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3373" title="utils/adt/timestamp.c:3373">interval_um_internal</a>(span, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(result, span, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isinf(factor))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isign = <a href="#L2514" title="utils/adt/timestamp.c:2514">interval_sign</a>(span);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isign == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (factor * isign &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOBEGIN(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOEND(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result_double = span-&gt;month * factor;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(result_double) || !FLOAT8_FITS_IN_INT32(result_double))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li>&nbsp; &nbsp; result-&gt;month = (int32) result_double;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result_double = span-&gt;day * factor;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(result_double) || !FLOAT8_FITS_IN_INT32(result_double))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li>&nbsp; &nbsp; result-&gt;day = (int32) result_double;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The above correctly handles the whole-number part of the month and day<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * products, but we have to do something with <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fractional part<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * resulting when the factor is non-integral.&nbsp; We cascade the fractions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * down to <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> units using the conversion factors DAYS_PER_MONTH and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SECS_PER_DAY.&nbsp; Note we do NOT cascade up, since we are not forced to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so by the representation.&nbsp; The user can choose to cascade up later,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using justify_hours and/or justify_days.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fractional <a href="datetime.c.html#L81" title="utils/adt/datetime.c:81">months</a> full <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> into <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Floating point calculation are inherently imprecise, so these<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calculations are crafted to produce the most reliable result possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TSROUND() is needed to more accurately produce whole numbers where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; month_remainder_days = (orig_month * factor - result-&gt;month) * DAYS_PER_MONTH;<br/></li>
<li>&nbsp; &nbsp; month_remainder_days = TSROUND(month_remainder_days);<br/></li>
<li>&nbsp; &nbsp; sec_remainder = (orig_day * factor - result-&gt;day +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; month_remainder_days - (<span class="Type">int</span>) month_remainder_days) * SECS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; sec_remainder = TSROUND(sec_remainder);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Might have 24:00:00 hours due to rounding, or &gt;24 hours because of time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cascade from <a href="datetime.c.html#L81" title="utils/adt/datetime.c:81">months</a> and <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a>.&nbsp; It might still be &gt;24 if the combination<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of cascade and the seconds factor operation itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fabs(sec_remainder) &gt;= SECS_PER_DAY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_add_s32_overflow(result-&gt;day,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) (sec_remainder / SECS_PER_DAY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;result-&gt;day))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sec_remainder -= (<span class="Type">int</span>) (sec_remainder / SECS_PER_DAY) * SECS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cascade units down */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pg_add_s32_overflow(result-&gt;day, (int32) month_remainder_days,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;result-&gt;day))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li>&nbsp; &nbsp; result_double = rint(span-&gt;time * factor + sec_remainder * USECS_PER_SEC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(result_double) || !FLOAT8_FITS_IN_INT64(result_double))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li>&nbsp; &nbsp; result-&gt;time = (int64) result_double;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li><br/></li>
<li><span class="Statement">out_of_range</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NULL();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3675">&#x200c;</a><span class="linkable">mul_d_interval</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Args are float8 and Interval *, but leave them as generic Datum */<br/></li>
<li></span>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; factor = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; span = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall2(<a href="#L3555" title="utils/adt/timestamp.c:3555">interval_mul</a>, span, factor);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3685">&#x200c;</a><span class="linkable">interval_div</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *span = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; factor = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; month_remainder_days,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sec_remainder,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_double;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; orig_month = span-&gt;month,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_day = span-&gt;day;<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Interval *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (factor == <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DIVISION_BY_ZERO),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;division by zero&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle NaN and infinities.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We treat &quot;infinity / infinity&quot; as an error, since the interval type has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nothing equivalent to NaN.&nbsp; Otherwise, dividing by infinity is handled<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by the regular division code, causing all fields to be set to zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(factor))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE(span))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isinf(factor))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (factor &lt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3373" title="utils/adt/timestamp.c:3373">interval_um_internal</a>(span, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(result, span, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result_double = span-&gt;month / factor;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(result_double) || !FLOAT8_FITS_IN_INT32(result_double))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li>&nbsp; &nbsp; result-&gt;month = (int32) result_double;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result_double = span-&gt;day / factor;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(result_double) || !FLOAT8_FITS_IN_INT32(result_double))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li>&nbsp; &nbsp; result-&gt;day = (int32) result_double;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fractional <a href="datetime.c.html#L81" title="utils/adt/datetime.c:81">months</a> full <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> into <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a>.&nbsp; See comment in <a href="#L3555" title="utils/adt/timestamp.c:3555">interval_mul</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; month_remainder_days = (orig_month / factor - result-&gt;month) * DAYS_PER_MONTH;<br/></li>
<li>&nbsp; &nbsp; month_remainder_days = TSROUND(month_remainder_days);<br/></li>
<li>&nbsp; &nbsp; sec_remainder = (orig_day / factor - result-&gt;day +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; month_remainder_days - (<span class="Type">int</span>) month_remainder_days) * SECS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; sec_remainder = TSROUND(sec_remainder);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fabs(sec_remainder) &gt;= SECS_PER_DAY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_add_s32_overflow(result-&gt;day,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) (sec_remainder / SECS_PER_DAY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;result-&gt;day))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sec_remainder -= (<span class="Type">int</span>) (sec_remainder / SECS_PER_DAY) * SECS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cascade units down */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pg_add_s32_overflow(result-&gt;day, (int32) month_remainder_days,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;result-&gt;day))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li>&nbsp; &nbsp; result_double = rint(span-&gt;time / factor + sec_remainder * USECS_PER_SEC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(result_double) || !FLOAT8_FITS_IN_INT64(result_double))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li>&nbsp; &nbsp; result-&gt;time = (int64) result_double;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_of_range;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li><br/></li>
<li><span class="Statement">out_of_range</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NULL();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * in_range support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for timestamps and intervals.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Per SQL spec, we support these with interval as the offset type.<br/></li>
<li></span><span class="Comment"> * The spec's restriction that the offset not be negative is a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> hard to<br/></li>
<li></span><span class="Comment"> * decipher for intervals, but we choose to interpret it the same as our<br/></li>
<li></span><span class="Comment"> * interval comparison operators would.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L3786">&#x200c;</a><span class="linkable">in_range_timestamptz_interval</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz val = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz base = PG_GETARG_TIMESTAMPTZ(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *offset = PG_GETARG_INTERVAL_P(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sub = PG_GETARG_BOOL(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; less = PG_GETARG_BOOL(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz sum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2514" title="utils/adt/timestamp.c:2514">interval_sign</a>(offset) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid preceding or following size in window function&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Deal with cases where both base and offset are infinite, and computing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * base +/- offset would cause an error.&nbsp; As for float and <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> types,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we assume that all <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> infinitely precede +infinity and infinitely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * follow -infinity.&nbsp; See <a href="float.c.html#L1020" title="utils/adt/float.c:1020">in_range_float8_float8</a>() for reasoning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_IS_NOEND(offset) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (sub ? TIMESTAMP_IS_NOEND(base) : TIMESTAMP_IS_NOBEGIN(base)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We don't currently bother to avoid overflow hazards here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sub)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sum = <a href="#L3312" title="utils/adt/timestamp.c:3312">timestamptz_mi_interval_internal</a>(base, offset, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sum = <a href="#L3186" title="utils/adt/timestamp.c:3186">timestamptz_pl_interval_internal</a>(base, offset, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (less)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(val &lt;= sum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(val &gt;= sum);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3823">&#x200c;</a><span class="linkable">in_range_timestamp_interval</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; val = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; base = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *offset = PG_GETARG_INTERVAL_P(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sub = PG_GETARG_BOOL(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; less = PG_GETARG_BOOL(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; sum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2514" title="utils/adt/timestamp.c:2514">interval_sign</a>(offset) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid preceding or following size in window function&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Deal with cases where both base and offset are infinite, and computing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * base +/- offset would cause an error.&nbsp; As for float and <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> types,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we assume that all <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> infinitely precede +infinity and infinitely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * follow -infinity.&nbsp; See <a href="float.c.html#L1020" title="utils/adt/float.c:1020">in_range_float8_float8</a>() for reasoning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_IS_NOEND(offset) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (sub ? TIMESTAMP_IS_NOEND(base) : TIMESTAMP_IS_NOBEGIN(base)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We don't currently bother to avoid overflow hazards here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sub)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sum = DatumGetTimestamp(DirectFunctionCall2(<a href="#L3160" title="utils/adt/timestamp.c:3160">timestamp_mi_interval</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampGetDatum(base),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IntervalPGetDatum(offset)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sum = DatumGetTimestamp(DirectFunctionCall2(<a href="#L3049" title="utils/adt/timestamp.c:3049">timestamp_pl_interval</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampGetDatum(base),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IntervalPGetDatum(offset)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (less)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(val &lt;= sum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(val &gt;= sum);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3864">&#x200c;</a><span class="linkable">in_range_interval_interval</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *val = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *base = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *offset = PG_GETARG_INTERVAL_P(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sub = PG_GETARG_BOOL(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; less = PG_GETARG_BOOL(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *sum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2514" title="utils/adt/timestamp.c:2514">interval_sign</a>(offset) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid preceding or following size in window function&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Deal with cases where both base and offset are infinite, and computing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * base +/- offset would cause an error.&nbsp; As for float and <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> types,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we assume that all <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> infinitely precede +infinity and infinitely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * follow -infinity.&nbsp; See <a href="float.c.html#L1020" title="utils/adt/float.c:1020">in_range_float8_float8</a>() for reasoning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_IS_NOEND(offset) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (sub ? INTERVAL_IS_NOEND(base) : INTERVAL_IS_NOBEGIN(base)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We don't currently bother to avoid overflow hazards here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sub)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sum = DatumGetIntervalP(DirectFunctionCall2(<a href="#L3506" title="utils/adt/timestamp.c:3506">interval_mi</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IntervalPGetDatum(base),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IntervalPGetDatum(offset)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sum = DatumGetIntervalP(DirectFunctionCall2(<a href="#L3450" title="utils/adt/timestamp.c:3450">interval_pl</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IntervalPGetDatum(base),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IntervalPGetDatum(offset)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (less)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2505" title="utils/adt/timestamp.c:2505">interval_cmp_internal</a>(val, sum) &lt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2505" title="utils/adt/timestamp.c:2505">interval_cmp_internal</a>(val, sum) &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare state data for an interval aggregate function, that needs to compute<br/></li>
<li></span><span class="Comment"> * sum and count, in the aggregate's memory context.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The function is used when the state data needs to be allocated in aggregate's<br/></li>
<li></span><span class="Comment"> * context. When the state data needs to be allocated in the current memory<br/></li>
<li></span><span class="Comment"> * context, we use <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a> directly e.g. <a href="#L4094" title="utils/adt/timestamp.c:4094">interval_avg_deserialize</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a> *<br/></li>
<li><a id="L3914">&#x200c;</a><span class="linkable">makeIntervalAggState</span>(FunctionCallInfo fcinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a> *state;<br/></li>
<li>&nbsp; &nbsp; MemoryContext agg_context;<br/></li>
<li>&nbsp; &nbsp; MemoryContext old_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, &amp;agg_context))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;aggregate function called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; old_context = MemoryContextSwitchTo(agg_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = (<a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a> *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Accumulate a new input value for interval aggregate <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3936">&#x200c;</a></span><span class="linkable">do_interval_accum</span>(<a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a> *state, Interval *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Infinite inputs are counted separately, and do not affect &quot;N&quot; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_IS_NOBEGIN(<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nInfcount++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_IS_NOEND(<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;pInfcount++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3435" title="utils/adt/timestamp.c:3435">finite_interval_pl</a>(&amp;state-&gt;sumX, <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, &amp;state-&gt;sumX);<br/></li>
<li>&nbsp; &nbsp; state-&gt;N++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove the given interval value from the aggregated state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3959">&#x200c;</a></span><span class="linkable">do_interval_discard</span>(<a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a> *state, Interval *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Infinite inputs are counted separately, and do not affect &quot;N&quot; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_IS_NOBEGIN(<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nInfcount--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_IS_NOEND(<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;pInfcount--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle the to-be-discarded finite value. */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;N--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;N &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3491" title="utils/adt/timestamp.c:3491">finite_interval_mi</a>(&amp;state-&gt;sumX, <a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, &amp;state-&gt;sumX);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* All <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> discarded, reset the state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;N == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;state-&gt;sumX, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(state-&gt;sumX));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Transition function for sum() and avg() interval aggregates.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3990">&#x200c;</a><span class="linkable">interval_avg_accum</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the state data on the first call */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state = <a href="#L3914" title="utils/adt/timestamp.c:3914">makeIntervalAggState</a>(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3936" title="utils/adt/timestamp.c:3936">do_interval_accum</a>(state, PG_GETARG_INTERVAL_P(<span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Combine function for sum() and avg() interval aggregates.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Combine the given <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> aggregate states and place the combination in<br/></li>
<li></span><span class="Comment"> * the first argument.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4013">&#x200c;</a><span class="linkable">interval_avg_combine</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a> *state1;<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a> *state2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state1 = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; state2 = PG_ARGISNULL(<span class="Constant">1</span>) ? <span class="Constant">NULL</span> : (<a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a> *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state2 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(state1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state1 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* manually copy all fields from state2 to state1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state1 = <a href="#L3914" title="utils/adt/timestamp.c:3914">makeIntervalAggState</a>(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;N = state2-&gt;N;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;pInfcount = state2-&gt;pInfcount;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;nInfcount = state2-&gt;nInfcount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;sumX.day = state2-&gt;sumX.day;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;sumX.month = state2-&gt;sumX.month;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;sumX.time = state2-&gt;sumX.time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(state1);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state1-&gt;N += state2-&gt;N;<br/></li>
<li>&nbsp; &nbsp; state1-&gt;pInfcount += state2-&gt;pInfcount;<br/></li>
<li>&nbsp; &nbsp; state1-&gt;nInfcount += state2-&gt;nInfcount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Accumulate finite interval <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state2-&gt;N &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3435" title="utils/adt/timestamp.c:3435">finite_interval_pl</a>(&amp;state1-&gt;sumX, &amp;state2-&gt;sumX, &amp;state1-&gt;sumX);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(state1);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4056" title="utils/adt/timestamp.c:4056">interval_avg_serialize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Serialize <a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a> for interval aggregates.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4056">&#x200c;</a><span class="linkable">interval_avg_serialize</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a> *state;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure we disallow calling when not in aggregate context */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;aggregate function called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = (<a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* N */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(&amp;buf, state-&gt;N);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sumX */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(&amp;buf, state-&gt;sumX.time);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(&amp;buf, state-&gt;sumX.day);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(&amp;buf, state-&gt;sumX.month);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pInfcount */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(&amp;buf, state-&gt;pInfcount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* nInfcount */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(&amp;buf, state-&gt;nInfcount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4094" title="utils/adt/timestamp.c:4094">interval_avg_deserialize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Deserialize bytea into <a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a> for interval aggregates.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4094">&#x200c;</a><span class="linkable">interval_avg_deserialize</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *sstate;<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a> *result;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;aggregate function called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sstate = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize a StringInfo so that we can &quot;receive&quot; it using the standard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../port/win32/socket.c.html#L37" title="port/win32/socket.c:37">recv</a>-function infrastructure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; initReadOnlyStringInfo(&amp;buf, VARDATA_ANY(sstate),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(sstate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (<a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a> *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* N */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;N = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sumX */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;sumX.time = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; result-&gt;sumX.day = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(&amp;buf, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; result-&gt;sumX.month = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(&amp;buf, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* pInfcount */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;pInfcount = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* nInfcount */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;nInfcount = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L635" title="libpq/pqformat.c:635">pq_getmsgend</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Inverse transition function for sum() and avg() interval aggregates.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4137">&#x200c;</a><span class="linkable">interval_avg_accum_inv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should not get here with no state */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L4137" title="utils/adt/timestamp.c:4137">interval_avg_accum_inv</a> called with NULL state&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3959" title="utils/adt/timestamp.c:3959">do_interval_discard</a>(state, PG_GETARG_INTERVAL_P(<span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* avg(interval) aggregate final function */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4155">&#x200c;</a><span class="linkable">interval_avg</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there were no non-null inputs, return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span> || <a href="#L87" title="utils/adt/timestamp.c:87">IA_TOTAL_COUNT</a>(state) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Aggregating infinities that all have the same sign produces infinity<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with that sign.&nbsp; Aggregating infinities with different signs results in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;pInfcount &gt; <span class="Constant">0</span> || state-&gt;nInfcount &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Interval&nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;pInfcount &gt; <span class="Constant">0</span> &amp;&amp; state-&gt;nInfcount &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (Interval *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;pInfcount &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOBEGIN(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall2(<a href="#L3685" title="utils/adt/timestamp.c:3685">interval_div</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IntervalPGetDatum(&amp;state-&gt;sumX),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../fmgr/fmgr.c.html#L1816" title="utils/fmgr/fmgr.c:1816">Float8GetDatum</a>((<span class="Type">double</span>) state-&gt;N));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* sum(interval) aggregate final function */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4195">&#x200c;</a><span class="linkable">interval_sum</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a> *state;<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (<a href="#L78" title="utils/adt/timestamp.c:78">IntervalAggState</a> *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there were no non-null inputs, return NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span> || <a href="#L87" title="utils/adt/timestamp.c:87">IA_TOTAL_COUNT</a>(state) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Aggregating infinities that all have the same sign produces infinity<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with that sign.&nbsp; Aggregating infinities with different signs results in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;pInfcount &gt; <span class="Constant">0</span> &amp;&amp; state-&gt;nInfcount &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Interval *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;pInfcount &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (state-&gt;nInfcount &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOBEGIN(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(result, &amp;state-&gt;sumX, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L4235" title="utils/adt/timestamp.c:4235">timestamp_age</a>()<br/></li>
<li></span><span class="Comment"> * Calculate time difference while retaining year/month fields.<br/></li>
<li></span><span class="Comment"> * Note that this does not result in an accurate absolute time span<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; since year and month are out of context once the arithmetic<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; is done.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4235">&#x200c;</a><span class="linkable">timestamp_age</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt1 = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt2 = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_itm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm1 = &amp;tt1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm2 = &amp;tt2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Interval *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle infinities.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We treat anything that amounts to &quot;infinity - infinity&quot; as an error,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since the interval type has nothing equivalent to NaN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_IS_NOBEGIN(dt1))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_IS_NOBEGIN(dt2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOBEGIN(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (TIMESTAMP_IS_NOEND(dt1))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_IS_NOEND(dt2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (TIMESTAMP_IS_NOBEGIN(dt2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (TIMESTAMP_IS_NOEND(dt2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOBEGIN(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(dt1, <span class="Constant">NULL</span>, tm1, &amp;fsec1, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(dt2, <span class="Constant">NULL</span>, tm2, &amp;fsec2, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* form the symbolic difference */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_usec = fsec1 - fsec2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_sec = tm1-&gt;tm_sec - tm2-&gt;tm_sec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_min = tm1-&gt;tm_min - tm2-&gt;tm_min;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour = tm1-&gt;tm_hour - tm2-&gt;tm_hour;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday = tm1-&gt;tm_mday - tm2-&gt;tm_mday;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon = tm1-&gt;tm_mon - tm2-&gt;tm_mon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = tm1-&gt;tm_year - tm2-&gt;tm_year;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* flip sign if necessary... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dt1 &lt; dt2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_usec = -tm-&gt;tm_usec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_sec = -tm-&gt;tm_sec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_min = -tm-&gt;tm_min;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour = -tm-&gt;tm_hour;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday = -tm-&gt;tm_mday;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon = -tm-&gt;tm_mon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = -tm-&gt;tm_year;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* propagate <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> negative fields into the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> higher field */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (tm-&gt;tm_usec &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_usec += USECS_PER_SEC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_sec--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (tm-&gt;tm_sec &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_sec += SECS_PER_MINUTE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_min--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (tm-&gt;tm_min &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_min += MINS_PER_HOUR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (tm-&gt;tm_hour &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour += HOURS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (tm-&gt;tm_mday &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dt1 &lt; dt2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday += <a href="datetime.c.html#L75" title="utils/adt/datetime.c:75">day_tab</a>[isleap(tm1-&gt;tm_year)][tm1-&gt;tm_mon - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday += <a href="datetime.c.html#L75" title="utils/adt/datetime.c:75">day_tab</a>[isleap(tm2-&gt;tm_year)][tm2-&gt;tm_mon - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (tm-&gt;tm_mon &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon += MONTHS_PER_YEAR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recover sign if necessary... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dt1 &lt; dt2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_usec = -tm-&gt;tm_usec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_sec = -tm-&gt;tm_sec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_min = -tm-&gt;tm_min;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour = -tm-&gt;tm_hour;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday = -tm-&gt;tm_mday;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon = -tm-&gt;tm_mon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = -tm-&gt;tm_year;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2077" title="utils/adt/timestamp.c:2077">itm2interval</a>(tm, result) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L4381" title="utils/adt/timestamp.c:4381">timestamptz_age</a>()<br/></li>
<li></span><span class="Comment"> * Calculate time difference while retaining year/month fields.<br/></li>
<li></span><span class="Comment"> * Note that this does not result in an accurate absolute time span<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; since year and month are out of context once the arithmetic<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; is done.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4381">&#x200c;</a><span class="linkable">timestamptz_age</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_itm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm1 = &amp;tt1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm2 = &amp;tt2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Interval *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle infinities.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We treat anything that amounts to &quot;infinity - infinity&quot; as an error,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since the interval type has nothing equivalent to NaN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_IS_NOBEGIN(dt1))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_IS_NOBEGIN(dt2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOBEGIN(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (TIMESTAMP_IS_NOEND(dt1))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_IS_NOEND(dt2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (TIMESTAMP_IS_NOBEGIN(dt2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (TIMESTAMP_IS_NOEND(dt2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_NOBEGIN(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(dt1, &amp;tz1, tm1, &amp;fsec1, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(dt2, &amp;tz2, tm2, &amp;fsec2, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* form the symbolic difference */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_usec = fsec1 - fsec2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_sec = tm1-&gt;tm_sec - tm2-&gt;tm_sec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_min = tm1-&gt;tm_min - tm2-&gt;tm_min;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour = tm1-&gt;tm_hour - tm2-&gt;tm_hour;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday = tm1-&gt;tm_mday - tm2-&gt;tm_mday;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon = tm1-&gt;tm_mon - tm2-&gt;tm_mon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = tm1-&gt;tm_year - tm2-&gt;tm_year;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* flip sign if necessary... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dt1 &lt; dt2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_usec = -tm-&gt;tm_usec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_sec = -tm-&gt;tm_sec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_min = -tm-&gt;tm_min;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour = -tm-&gt;tm_hour;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday = -tm-&gt;tm_mday;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon = -tm-&gt;tm_mon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = -tm-&gt;tm_year;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* propagate <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> negative fields into the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> higher field */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (tm-&gt;tm_usec &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_usec += USECS_PER_SEC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_sec--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (tm-&gt;tm_sec &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_sec += SECS_PER_MINUTE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_min--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (tm-&gt;tm_min &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_min += MINS_PER_HOUR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (tm-&gt;tm_hour &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour += HOURS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (tm-&gt;tm_mday &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dt1 &lt; dt2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday += <a href="datetime.c.html#L75" title="utils/adt/datetime.c:75">day_tab</a>[isleap(tm1-&gt;tm_year)][tm1-&gt;tm_mon - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday += <a href="datetime.c.html#L75" title="utils/adt/datetime.c:75">day_tab</a>[isleap(tm2-&gt;tm_year)][tm2-&gt;tm_mon - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (tm-&gt;tm_mon &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon += MONTHS_PER_YEAR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: we deliberately ignore <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> difference between tz1 and tz2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recover sign if necessary... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dt1 &lt; dt2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_usec = -tm-&gt;tm_usec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_sec = -tm-&gt;tm_sec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_min = -tm-&gt;tm_min;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour = -tm-&gt;tm_hour;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday = -tm-&gt;tm_mday;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon = -tm-&gt;tm_mon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = -tm-&gt;tm_year;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2077" title="utils/adt/timestamp.c:2077">itm2interval</a>(tm, result) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Conversion operators.<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------*/<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L4535" title="utils/adt/timestamp.c:4535">timestamp_bin</a>()<br/></li>
<li></span><span class="Comment"> * Bin timestamp into specified interval.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4535">&#x200c;</a><span class="linkable">timestamp_bin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *stride = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestamp = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; origin = PG_GETARG_TIMESTAMP(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stride_usecs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm_diff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm_modulo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm_delta;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TIMESTAMP(timestamp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(origin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;origin out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE(stride))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamps cannot be binned into infinite intervals&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stride-&gt;month != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamps cannot be binned into intervals containing <a href="datetime.c.html#L81" title="utils/adt/datetime.c:81">months</a> or years&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(pg_mul_s64_overflow(stride-&gt;day, USECS_PER_DAY, &amp;stride_usecs)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unlikely(pg_add_s64_overflow(stride_usecs, stride-&gt;time, &amp;stride_usecs)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stride_usecs &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;stride must be greater than zero&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(pg_sub_s64_overflow(timestamp, origin, &amp;tm_diff)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* These calculations cannot overflow */<br/></li>
<li></span>&nbsp; &nbsp; tm_modulo = tm_diff % stride_usecs;<br/></li>
<li>&nbsp; &nbsp; tm_delta = tm_diff - tm_modulo;<br/></li>
<li>&nbsp; &nbsp; result = origin + tm_delta;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We want to round towards -infinity, not 0, when tm_diff is negative and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not a multiple of stride_usecs.&nbsp; This adjustment *can* cause overflow,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since the result might <a href="#L1618" title="utils/adt/timestamp.c:1618">now</a> be out of the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> origin .. timestamp.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tm_modulo &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(pg_sub_s64_overflow(result, stride_usecs, &amp;result)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !IS_VALID_TIMESTAMP(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMP(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L4606" title="utils/adt/timestamp.c:4606">timestamp_trunc</a>()<br/></li>
<li></span><span class="Comment"> * Truncate timestamp to specified units.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4606">&#x200c;</a><span class="linkable">timestamp_trunc</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *units = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestamp = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *lowunits;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TIMESTAMP(timestamp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lowunits = <a href="../../parser/scansup.c.html#L37" title="parser/scansup.c:37">downcase_truncate_identifier</a>(VARDATA_ANY(units),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARSIZE_ANY_EXHDR(units),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; type = <a href="datetime.c.html#L4036" title="utils/adt/datetime.c:4036">DecodeUnits</a>(<span class="Constant">0</span>, lowunits, &amp;val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type == UNITS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, <span class="Constant">NULL</span>, tm, &amp;fsec, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (val)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_WEEK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; woy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; woy = <a href="#L5155" title="utils/adt/timestamp.c:5155">date2isoweek</a>(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it is week 52/53 and the month is January, then the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * week must belong to the previous year. Also, some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * December dates belong to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> year.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (woy &gt;= <span class="Constant">52</span> &amp;&amp; tm-&gt;tm_mon == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --tm-&gt;tm_year;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (woy &lt;= <span class="Constant">1</span> &amp;&amp; tm-&gt;tm_mon == MONTHS_PER_YEAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++tm-&gt;tm_year;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5124" title="utils/adt/timestamp.c:5124">isoweek2date</a>(woy, &amp;(tm-&gt;tm_year), &amp;(tm-&gt;tm_mon), &amp;(tm-&gt;tm_mday));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_min = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_sec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MILLENNIUM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see comments in <a href="#L4958" title="utils/adt/timestamp.c:4958">timestamptz_trunc</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_year &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = ((tm-&gt;tm_year + <span class="Constant">999</span>) / <span class="Constant">1000</span>) * <span class="Constant">1000</span> - <span class="Constant">999</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = -((<span class="Constant">999</span> - (tm-&gt;tm_year - <span class="Constant">1</span>)) / <span class="Constant">1000</span>) * <span class="Constant">1000</span> + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_CENTURY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see comments in <a href="#L4958" title="utils/adt/timestamp.c:4958">timestamptz_trunc</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_year &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = ((tm-&gt;tm_year + <span class="Constant">99</span>) / <span class="Constant">100</span>) * <span class="Constant">100</span> - <span class="Constant">99</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = -((<span class="Constant">99</span> - (tm-&gt;tm_year - <span class="Constant">1</span>)) / <span class="Constant">100</span>) * <span class="Constant">100</span> + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DECADE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see comments in <a href="#L4958" title="utils/adt/timestamp.c:4958">timestamptz_trunc</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (val != DTK_MILLENNIUM &amp;&amp; val != DTK_CENTURY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_year &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = (tm-&gt;tm_year / <span class="Constant">10</span>) * <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = -((<span class="Constant">8</span> - (tm-&gt;tm_year - <span class="Constant">1</span>)) / <span class="Constant">10</span>) * <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_YEAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_QUARTER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon = (<span class="Constant">3</span> * ((tm-&gt;tm_mon - <span class="Constant">1</span>) / <span class="Constant">3</span>)) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MONTH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_HOUR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_min = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MINUTE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_sec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_SECOND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MILLISEC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec = (fsec / <span class="Constant">1000</span>) * <span class="Constant">1000</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MICROSEC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not supported for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(TIMESTAMPOID))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1997" title="utils/adt/timestamp.c:1997">tm2timestamp</a>(tm, fsec, <span class="Constant">NULL</span>, &amp;result) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not recognized for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(TIMESTAMPOID))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMP(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L4740" title="utils/adt/timestamp.c:4740">timestamptz_bin</a>()<br/></li>
<li></span><span class="Comment"> * Bin timestamptz into specified interval using specified origin.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4740">&#x200c;</a><span class="linkable">timestamptz_bin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *stride = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz origin = PG_GETARG_TIMESTAMPTZ(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stride_usecs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm_diff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm_modulo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm_delta;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TIMESTAMPTZ(timestamp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(origin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;origin out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE(stride))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamps cannot be binned into infinite intervals&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stride-&gt;month != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamps cannot be binned into intervals containing <a href="datetime.c.html#L81" title="utils/adt/datetime.c:81">months</a> or years&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(pg_mul_s64_overflow(stride-&gt;day, USECS_PER_DAY, &amp;stride_usecs)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unlikely(pg_add_s64_overflow(stride_usecs, stride-&gt;time, &amp;stride_usecs)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stride_usecs &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;stride must be greater than zero&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(pg_sub_s64_overflow(timestamp, origin, &amp;tm_diff)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* These calculations cannot overflow */<br/></li>
<li></span>&nbsp; &nbsp; tm_modulo = tm_diff % stride_usecs;<br/></li>
<li>&nbsp; &nbsp; tm_delta = tm_diff - tm_modulo;<br/></li>
<li>&nbsp; &nbsp; result = origin + tm_delta;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We want to round towards -infinity, not 0, when tm_diff is negative and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not a multiple of stride_usecs.&nbsp; This adjustment *can* cause overflow,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since the result might <a href="#L1618" title="utils/adt/timestamp.c:1618">now</a> be out of the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> origin .. timestamp.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tm_modulo &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(pg_sub_s64_overflow(result, stride_usecs, &amp;result)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !IS_VALID_TIMESTAMP(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMPTZ(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Common code for <a href="#L4958" title="utils/adt/timestamp.c:4958">timestamptz_trunc</a>() and <a href="#L4976" title="utils/adt/timestamp.c:4976">timestamptz_trunc_zone</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tzp identifies the zone to truncate with respect to.&nbsp; We assume<br/></li>
<li></span><span class="Comment"> * infinite timestamps have already been rejected.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TimestampTz<br/></li>
<li><a id="L4814">&#x200c;</a><span class="linkable">timestamptz_trunc_internal</span>(text *units, TimestampTz timestamp, pg_tz *tzp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; redotz = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *lowunits;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lowunits = <a href="../../parser/scansup.c.html#L37" title="parser/scansup.c:37">downcase_truncate_identifier</a>(VARDATA_ANY(units),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARSIZE_ANY_EXHDR(units),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; type = <a href="datetime.c.html#L4036" title="utils/adt/datetime.c:4036">DecodeUnits</a>(<span class="Constant">0</span>, lowunits, &amp;val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type == UNITS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, &amp;tz, tm, &amp;fsec, <span class="Constant">NULL</span>, tzp) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (val)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_WEEK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; woy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; woy = <a href="#L5155" title="utils/adt/timestamp.c:5155">date2isoweek</a>(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it is week 52/53 and the month is January, then the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * week must belong to the previous year. Also, some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * December dates belong to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> year.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (woy &gt;= <span class="Constant">52</span> &amp;&amp; tm-&gt;tm_mon == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --tm-&gt;tm_year;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (woy &lt;= <span class="Constant">1</span> &amp;&amp; tm-&gt;tm_mon == MONTHS_PER_YEAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++tm-&gt;tm_year;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5124" title="utils/adt/timestamp.c:5124">isoweek2date</a>(woy, &amp;(tm-&gt;tm_year), &amp;(tm-&gt;tm_mon), &amp;(tm-&gt;tm_mday));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_min = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_sec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; redotz = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* one may consider DTK_THOUSAND and DTK_HUNDRED... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MILLENNIUM:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * truncating to the millennium? what is this supposed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mean? let us put the first year of the millennium... i.e.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * -1000, 1, 1001, 2001...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_year &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = ((tm-&gt;tm_year + <span class="Constant">999</span>) / <span class="Constant">1000</span>) * <span class="Constant">1000</span> - <span class="Constant">999</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = -((<span class="Constant">999</span> - (tm-&gt;tm_year - <span class="Constant">1</span>)) / <span class="Constant">1000</span>) * <span class="Constant">1000</span> + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_CENTURY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* truncating to the century? as above: -100, 1, 101... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_year &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = ((tm-&gt;tm_year + <span class="Constant">99</span>) / <span class="Constant">100</span>) * <span class="Constant">100</span> - <span class="Constant">99</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = -((<span class="Constant">99</span> - (tm-&gt;tm_year - <span class="Constant">1</span>)) / <span class="Constant">100</span>) * <span class="Constant">100</span> + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DECADE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * truncating to the decade? first year of the decade. must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not be applied if year was truncated <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (val != DTK_MILLENNIUM &amp;&amp; val != DTK_CENTURY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_year &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = (tm-&gt;tm_year / <span class="Constant">10</span>) * <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = -((<span class="Constant">8</span> - (tm-&gt;tm_year - <span class="Constant">1</span>)) / <span class="Constant">10</span>) * <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_YEAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_QUARTER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon = (<span class="Constant">3</span> * ((tm-&gt;tm_mon - <span class="Constant">1</span>) / <span class="Constant">3</span>)) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MONTH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; redotz = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* for all cases &gt;= DAY */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_HOUR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_min = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MINUTE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_sec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_SECOND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MILLISEC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec = (fsec / <span class="Constant">1000</span>) * <span class="Constant">1000</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MICROSEC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not supported for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(TIMESTAMPTZOID))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (redotz)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz = <a href="datetime.c.html#L1585" title="utils/adt/datetime.c:1585">DetermineTimeZoneOffset</a>(tm, tzp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1997" title="utils/adt/timestamp.c:1997">tm2timestamp</a>(tm, fsec, &amp;tz, &amp;result) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not recognized for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(TIMESTAMPTZOID))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L4958" title="utils/adt/timestamp.c:4958">timestamptz_trunc</a>()<br/></li>
<li></span><span class="Comment"> * Truncate timestamptz to specified units in session timezone.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4958">&#x200c;</a><span class="linkable">timestamptz_trunc</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *units = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TIMESTAMPTZ(timestamp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L4814" title="utils/adt/timestamp.c:4814">timestamptz_trunc_internal</a>(units, timestamp, session_timezone);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMPTZ(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L4976" title="utils/adt/timestamp.c:4976">timestamptz_trunc_zone</a>()<br/></li>
<li></span><span class="Comment"> * Truncate timestamptz to specified units in specified timezone.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4976">&#x200c;</a><span class="linkable">timestamptz_trunc_zone</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *units = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *zone = PG_GETARG_TEXT_PP(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz result;<br/></li>
<li>&nbsp; &nbsp; pg_tz&nbsp; &nbsp; &nbsp;&nbsp; *tzp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L6390" title="utils/adt/timestamp.c:6390">timestamptz_zone</a>() doesn't look up the zone for infinite inputs, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't do so here either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TIMESTAMP(timestamp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up the requested timezone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tzp = <a href="#L558" title="utils/adt/timestamp.c:558">lookup_timezone</a>(zone);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L4814" title="utils/adt/timestamp.c:4814">timestamptz_trunc_internal</a>(units, timestamp, tzp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMPTZ(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L5005" title="utils/adt/timestamp.c:5005">interval_trunc</a>()<br/></li>
<li></span><span class="Comment"> * Extract specified field from interval.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5005">&#x200c;</a><span class="linkable">interval_trunc</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *units = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *lowunits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_itm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (Interval *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE(interval))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(result, interval, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lowunits = <a href="../../parser/scansup.c.html#L37" title="parser/scansup.c:37">downcase_truncate_identifier</a>(VARDATA_ANY(units),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARSIZE_ANY_EXHDR(units),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; type = <a href="datetime.c.html#L4036" title="utils/adt/datetime.c:4036">DecodeUnits</a>(<span class="Constant">0</span>, lowunits, &amp;val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type == UNITS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2047" title="utils/adt/timestamp.c:2047">interval2itm</a>(*interval, tm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (val)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MILLENNIUM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* caution: C division may have negative remainder */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = (tm-&gt;tm_year / <span class="Constant">1000</span>) * <span class="Constant">1000</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_CENTURY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* caution: C division may have negative remainder */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = (tm-&gt;tm_year / <span class="Constant">100</span>) * <span class="Constant">100</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DECADE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* caution: C division may have negative remainder */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = (tm-&gt;tm_year / <span class="Constant">10</span>) * <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_YEAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_QUARTER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon = <span class="Constant">3</span> * (tm-&gt;tm_mon / <span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MONTH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_HOUR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_min = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MINUTE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_sec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_SECOND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_usec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MILLISEC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_usec = (tm-&gt;tm_usec / <span class="Constant">1000</span>) * <span class="Constant">1000</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MICROSEC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not supported for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(INTERVALOID)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (val == DTK_WEEK) ? <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Months usually have fractional weeks.&quot;</span>) : <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2077" title="utils/adt/timestamp.c:2077">itm2interval</a>(tm, result) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not recognized for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(INTERVALOID))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INTERVAL_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L5104" title="utils/adt/timestamp.c:5104">isoweek2j</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Return the Julian day which corresponds to the first day (Monday) of the given ISO 8601 year and week.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Julian <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> are used to convert between ISO week dates and Gregorian dates.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L5104">&#x200c;</a></span><span class="linkable">isoweek2j</span>(<span class="Type">int</span> year, <span class="Type">int</span> week)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; day0,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; day4;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fourth day of current year */<br/></li>
<li></span>&nbsp; &nbsp; day4 = <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(year, <span class="Constant">1</span>, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* day0 == offset to first day of week (Monday) */<br/></li>
<li></span>&nbsp; &nbsp; day0 = <a href="datetime.c.html#L344" title="utils/adt/datetime.c:344">j2day</a>(day4 - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ((week - <span class="Constant">1</span>) * <span class="Constant">7</span>) + (day4 - day0);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L5124" title="utils/adt/timestamp.c:5124">isoweek2date</a>()<br/></li>
<li></span><span class="Comment"> * Convert ISO week of year number to date.<br/></li>
<li></span><span class="Comment"> * The year field must be specified with the ISO year!<br/></li>
<li></span><span class="Comment"> * karel 2000/08/07<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5124">&#x200c;</a></span><span class="linkable">isoweek2date</span>(<span class="Type">int</span> woy, <span class="Type">int</span> *year, <span class="Type">int</span> *mon, <span class="Type">int</span> *mday)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="datetime.c.html#L311" title="utils/adt/datetime.c:311">j2date</a>(<a href="#L5104" title="utils/adt/timestamp.c:5104">isoweek2j</a>(*year, woy), year, mon, mday);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L5137" title="utils/adt/timestamp.c:5137">isoweekdate2date</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Convert an ISO 8601 week date (ISO year, ISO week) into a Gregorian date.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Gregorian day of week sent so weekday strings can be supplied.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Populates year, mon, and mday with the correct Gregorian <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; year must be passed in as the ISO year.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5137">&#x200c;</a></span><span class="linkable">isoweekdate2date</span>(<span class="Type">int</span> isoweek, <span class="Type">int</span> wday, <span class="Type">int</span> *year, <span class="Type">int</span> *mon, <span class="Type">int</span> *mday)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jday;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; jday = <a href="#L5104" title="utils/adt/timestamp.c:5104">isoweek2j</a>(*year, isoweek);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* convert Gregorian week start (Sunday=1) to ISO week start (Monday=1) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (wday &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jday += wday - <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; jday += <span class="Constant">6</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="datetime.c.html#L311" title="utils/adt/datetime.c:311">j2date</a>(jday, year, mon, mday);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L5155" title="utils/adt/timestamp.c:5155">date2isoweek</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Returns ISO week number of year.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L5155">&#x200c;</a></span><span class="linkable">date2isoweek</span>(<span class="Type">int</span> year, <span class="Type">int</span> mon, <span class="Type">int</span> mday)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; day0,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; day4,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dayn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* current day */<br/></li>
<li></span>&nbsp; &nbsp; dayn = <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(year, mon, mday);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fourth day of current year */<br/></li>
<li></span>&nbsp; &nbsp; day4 = <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(year, <span class="Constant">1</span>, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* day0 == offset to first day of week (Monday) */<br/></li>
<li></span>&nbsp; &nbsp; day0 = <a href="datetime.c.html#L344" title="utils/adt/datetime.c:344">j2day</a>(day4 - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need the first week containing a Thursday, otherwise this day falls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into the previous year for purposes of counting weeks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dayn &lt; day4 - day0)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; day4 = <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(year - <span class="Constant">1</span>, <span class="Constant">1</span>, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* day0 == offset to first day of week (Monday) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; day0 = <a href="datetime.c.html#L344" title="utils/adt/datetime.c:344">j2day</a>(day4 - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (dayn - (day4 - day0)) / <span class="Constant">7</span> + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sometimes the last few <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> in a year will fall into the first week of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> year, so check for this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result &gt;= <span class="Constant">52</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; day4 = <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(year + <span class="Constant">1</span>, <span class="Constant">1</span>, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* day0 == offset to first day of week (Monday) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; day0 = <a href="datetime.c.html#L344" title="utils/adt/datetime.c:344">j2day</a>(day4 - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dayn &gt;= day4 - day0)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (dayn - (day4 - day0)) / <span class="Constant">7</span> + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">int</span>) result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L5210" title="utils/adt/timestamp.c:5210">date2isoyear</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Returns ISO 8601 year number.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Note: zero or negative results follow the year-zero-exists convention.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L5210">&#x200c;</a></span><span class="linkable">date2isoyear</span>(<span class="Type">int</span> year, <span class="Type">int</span> mon, <span class="Type">int</span> mday)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; day0,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; day4,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dayn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* current day */<br/></li>
<li></span>&nbsp; &nbsp; dayn = <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(year, mon, mday);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fourth day of current year */<br/></li>
<li></span>&nbsp; &nbsp; day4 = <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(year, <span class="Constant">1</span>, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* day0 == offset to first day of week (Monday) */<br/></li>
<li></span>&nbsp; &nbsp; day0 = <a href="datetime.c.html#L344" title="utils/adt/datetime.c:344">j2day</a>(day4 - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need the first week containing a Thursday, otherwise this day falls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into the previous year for purposes of counting weeks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dayn &lt; day4 - day0)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; day4 = <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(year - <span class="Constant">1</span>, <span class="Constant">1</span>, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* day0 == offset to first day of week (Monday) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; day0 = <a href="datetime.c.html#L344" title="utils/adt/datetime.c:344">j2day</a>(day4 - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; year--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (dayn - (day4 - day0)) / <span class="Constant">7</span> + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sometimes the last few <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> in a year will fall into the first week of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> year, so check for this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result &gt;= <span class="Constant">52</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; day4 = <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(year + <span class="Constant">1</span>, <span class="Constant">1</span>, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* day0 == offset to first day of week (Monday) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; day0 = <a href="datetime.c.html#L344" title="utils/adt/datetime.c:344">j2day</a>(day4 - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dayn &gt;= day4 - day0)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; year++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> year;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L5267" title="utils/adt/timestamp.c:5267">date2isoyearday</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Returns the ISO 8601 day-of-year, given a Gregorian year, month and day.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Possible return <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are 1 through 371 (364 in non-leap years).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L5267">&#x200c;</a></span><span class="linkable">date2isoyearday</span>(<span class="Type">int</span> year, <span class="Type">int</span> mon, <span class="Type">int</span> mday)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(year, mon, mday) - <a href="#L5104" title="utils/adt/timestamp.c:5104">isoweek2j</a>(<a href="#L5210" title="utils/adt/timestamp.c:5210">date2isoyear</a>(year, mon, mday), <span class="Constant">1</span>) + <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5284" title="utils/adt/timestamp.c:5284">NonFiniteTimestampTzPart</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Used by <a href="#L5599" title="utils/adt/timestamp.c:5599">timestamp_part</a> and <a href="#L5871" title="utils/adt/timestamp.c:5871">timestamptz_part</a> when extracting from infinite<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; timestamp[tz].&nbsp; Returns +/-Infinity if that is the appropriate result,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; otherwise returns zero (which should be taken as meaning to return NULL).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Errors thrown here for invalid units should exactly match those that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; would be thrown in the calling <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, else there will be unexpected<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; discrepancies between finite- and infinite-input cases.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> float8<br/></li>
<li><a id="L5284">&#x200c;</a><span class="linkable">NonFiniteTimestampTzPart</span>(<span class="Type">int</span> type, <span class="Type">int</span> unit, <span class="Type">char</span> *lowunits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isNegative, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isTz)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((type != UNITS) &amp;&amp; (type != RESERV))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not recognized for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(isTz ? TIMESTAMPTZOID : TIMESTAMPOID))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (unit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Oscillating units */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MICROSEC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MILLISEC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_SECOND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MINUTE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_HOUR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MONTH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_QUARTER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_WEEK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DOW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_ISODOW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DOY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TZ:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TZ_MINUTE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TZ_HOUR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Monotonically-increasing units */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_YEAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DECADE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_CENTURY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MILLENNIUM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_JULIAN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_ISOYEAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_EPOCH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isNegative)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -get_float8_infinity();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> get_float8_infinity();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not supported for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(isTz ? TIMESTAMPTZOID : TIMESTAMPOID))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L5599" title="utils/adt/timestamp.c:5599">timestamp_part</a>() and <a href="#L5605" title="utils/adt/timestamp.c:5605">extract_timestamp</a>()<br/></li>
<li></span><span class="Comment"> * Extract specified field from timestamp.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L5341">&#x200c;</a><span class="linkable">timestamp_part_common</span>(PG_FUNCTION_ARGS, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> retnumeric)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *units = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestamp = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; intresult;<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; epoch;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *lowunits;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lowunits = <a href="../../parser/scansup.c.html#L37" title="parser/scansup.c:37">downcase_truncate_identifier</a>(VARDATA_ANY(units),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARSIZE_ANY_EXHDR(units),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; type = <a href="datetime.c.html#L4036" title="utils/adt/datetime.c:4036">DecodeUnits</a>(<span class="Constant">0</span>, lowunits, &amp;val);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type == UNKNOWN_FIELD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; type = <a href="datetime.c.html#L3137" title="utils/adt/datetime.c:3137">DecodeSpecial</a>(<span class="Constant">0</span>, lowunits, &amp;val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; r = <a href="#L5284" title="utils/adt/timestamp.c:5284">NonFiniteTimestampTzPart</a>(type, val, lowunits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TIMESTAMP_IS_NOBEGIN(timestamp),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r != <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall3(<a href="numeric.c.html#L628" title="utils/adt/numeric.c:628">numeric_in</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CStringGetDatum(<span class="Constant">&quot;-Infinity&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(InvalidOid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int32GetDatum(-<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (r &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall3(<a href="numeric.c.html#L628" title="utils/adt/numeric.c:628">numeric_in</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CStringGetDatum(<span class="Constant">&quot;Infinity&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(InvalidOid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int32GetDatum(-<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(r);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type == UNITS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, <span class="Constant">NULL</span>, tm, &amp;fsec, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (val)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MICROSEC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_sec * INT64CONST(<span class="Constant">1000000</span>) + fsec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MILLISEC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tm-&gt;tm_sec * 1000 + fsec / 1000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * = (tm-&gt;tm_sec * 1'000'000 + fsec) / 1000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="numeric.c.html#L4304" title="utils/adt/numeric.c:4304">int64_div_fast_to_numeric</a>(tm-&gt;tm_sec * INT64CONST(<span class="Constant">1000000</span>) + fsec, <span class="Constant">3</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(tm-&gt;tm_sec * <span class="Constant">1000.0</span> + fsec / <span class="Constant">1000.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_SECOND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tm-&gt;tm_sec + fsec / 1'000'000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * = (tm-&gt;tm_sec * 1'000'000 + fsec) / 1'000'000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="numeric.c.html#L4304" title="utils/adt/numeric.c:4304">int64_div_fast_to_numeric</a>(tm-&gt;tm_sec * INT64CONST(<span class="Constant">1000000</span>) + fsec, <span class="Constant">6</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(tm-&gt;tm_sec + fsec / <span class="Constant">1000000.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MINUTE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_min;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_HOUR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_hour;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_mday;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MONTH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_mon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_QUARTER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = (tm-&gt;tm_mon - <span class="Constant">1</span>) / <span class="Constant">3</span> + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_WEEK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = <a href="#L5155" title="utils/adt/timestamp.c:5155">date2isoweek</a>(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_YEAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_year &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_year;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there is no year 0, just 1 BC and 1 AD */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_year - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DECADE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * what is a decade wrt dates? let us assume that decade 199<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is 1990 thru 1999... decade 0 starts on year 1 BC, and -1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is 11 BC thru 2 BC...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_year &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_year / <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = -((<span class="Constant">8</span> - (tm-&gt;tm_year - <span class="Constant">1</span>)) / <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_CENTURY:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ----<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * centuries AD, c&gt;0: year in [ (c-1)* 100 + 1 : c*100 ]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * centuries BC, c&lt;0: year in [ c*100 : (c+1) * 100 - 1]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there is no number 0 century.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ----<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_year &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = (tm-&gt;tm_year + <span class="Constant">99</span>) / <span class="Constant">100</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* caution: C division may have negative remainder */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = -((<span class="Constant">99</span> - (tm-&gt;tm_year - <span class="Constant">1</span>)) / <span class="Constant">100</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MILLENNIUM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see comments above. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_year &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = (tm-&gt;tm_year + <span class="Constant">999</span>) / <span class="Constant">1000</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = -((<span class="Constant">999</span> - (tm-&gt;tm_year - <span class="Constant">1</span>)) / <span class="Constant">1000</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_JULIAN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="numeric.c.html#L2867" title="utils/adt/numeric.c:2867">numeric_add_opt_error</a>(<a href="numeric.c.html#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(<a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="numeric.c.html#L3144" title="utils/adt/numeric.c:3144">numeric_div_opt_error</a>(<a href="numeric.c.html#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(((((tm-&gt;tm_hour * MINS_PER_HOUR) + tm-&gt;tm_min) * SECS_PER_MINUTE) + tm-&gt;tm_sec) * INT64CONST(<span class="Constant">1000000</span>) + fsec),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="numeric.c.html#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(SECS_PER_DAY * INT64CONST(<span class="Constant">1000000</span>)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((((tm-&gt;tm_hour * MINS_PER_HOUR) + tm-&gt;tm_min) * SECS_PER_MINUTE) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_sec + (fsec / <span class="Constant">1000000.0</span>)) / (<span class="Type">double</span>) SECS_PER_DAY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_ISOYEAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = <a href="#L5210" title="utils/adt/timestamp.c:5210">date2isoyear</a>(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust BC years */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (intresult &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult -= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DOW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_ISODOW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = <a href="datetime.c.html#L344" title="utils/adt/datetime.c:344">j2day</a>(<a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (val == DTK_ISODOW &amp;&amp; intresult == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = <span class="Constant">7</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DOY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = (<a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; - <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(tm-&gt;tm_year, <span class="Constant">1</span>, <span class="Constant">1</span>) + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TZ:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TZ_MINUTE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TZ_HOUR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not supported for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(TIMESTAMPOID))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (type == RESERV)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (val)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_EPOCH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; epoch = <a href="#L2190" title="utils/adt/timestamp.c:2190">SetEpochTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* (timestamp - epoch) / 1000000 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (timestamp &lt; (PG_INT64_MAX + epoch))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="numeric.c.html#L4304" title="utils/adt/numeric.c:4304">int64_div_fast_to_numeric</a>(timestamp - epoch, <span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="numeric.c.html#L3144" title="utils/adt/numeric.c:3144">numeric_div_opt_error</a>(<a href="numeric.c.html#L2945" title="utils/adt/numeric.c:2945">numeric_sub_opt_error</a>(<a href="numeric.c.html#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(timestamp),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="numeric.c.html#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(epoch),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="numeric.c.html#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(<span class="Constant">1000000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = DatumGetNumeric(DirectFunctionCall2(<a href="numeric.c.html#L1534" title="utils/adt/numeric.c:1534">numeric_round</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NumericGetDatum(result),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int32GetDatum(<span class="Constant">6</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* try to avoid precision loss in subtraction */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (timestamp &lt; (PG_INT64_MAX + epoch))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (timestamp - epoch) / <span class="Constant">1000000.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = ((float8) timestamp - epoch) / <span class="Constant">1000000.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not supported for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(TIMESTAMPOID))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not recognized for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(TIMESTAMPOID))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; intresult = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="numeric.c.html#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(intresult));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(intresult);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L5599">&#x200c;</a><span class="linkable">timestamp_part</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L5341" title="utils/adt/timestamp.c:5341">timestamp_part_common</a>(fcinfo, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L5605">&#x200c;</a><span class="linkable">extract_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L5341" title="utils/adt/timestamp.c:5341">timestamp_part_common</a>(fcinfo, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L5871" title="utils/adt/timestamp.c:5871">timestamptz_part</a>() and <a href="#L5877" title="utils/adt/timestamp.c:5877">extract_timestamptz</a>()<br/></li>
<li></span><span class="Comment"> * Extract specified field from timestamp with time zone.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L5614">&#x200c;</a><span class="linkable">timestamptz_part_common</span>(PG_FUNCTION_ARGS, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> retnumeric)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *units = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; intresult;<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; epoch;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *lowunits;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lowunits = <a href="../../parser/scansup.c.html#L37" title="parser/scansup.c:37">downcase_truncate_identifier</a>(VARDATA_ANY(units),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARSIZE_ANY_EXHDR(units),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; type = <a href="datetime.c.html#L4036" title="utils/adt/datetime.c:4036">DecodeUnits</a>(<span class="Constant">0</span>, lowunits, &amp;val);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type == UNKNOWN_FIELD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; type = <a href="datetime.c.html#L3137" title="utils/adt/datetime.c:3137">DecodeSpecial</a>(<span class="Constant">0</span>, lowunits, &amp;val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; r = <a href="#L5284" title="utils/adt/timestamp.c:5284">NonFiniteTimestampTzPart</a>(type, val, lowunits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TIMESTAMP_IS_NOBEGIN(timestamp),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r != <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall3(<a href="numeric.c.html#L628" title="utils/adt/numeric.c:628">numeric_in</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CStringGetDatum(<span class="Constant">&quot;-Infinity&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(InvalidOid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int32GetDatum(-<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (r &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall3(<a href="numeric.c.html#L628" title="utils/adt/numeric.c:628">numeric_in</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CStringGetDatum(<span class="Constant">&quot;Infinity&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(InvalidOid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int32GetDatum(-<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(r);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type == UNITS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, &amp;tz, tm, &amp;fsec, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (val)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TZ:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = -tz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TZ_MINUTE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = (-tz / SECS_PER_MINUTE) % MINS_PER_HOUR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TZ_HOUR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = -tz / SECS_PER_HOUR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MICROSEC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_sec * INT64CONST(<span class="Constant">1000000</span>) + fsec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MILLISEC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tm-&gt;tm_sec * 1000 + fsec / 1000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * = (tm-&gt;tm_sec * 1'000'000 + fsec) / 1000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="numeric.c.html#L4304" title="utils/adt/numeric.c:4304">int64_div_fast_to_numeric</a>(tm-&gt;tm_sec * INT64CONST(<span class="Constant">1000000</span>) + fsec, <span class="Constant">3</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(tm-&gt;tm_sec * <span class="Constant">1000.0</span> + fsec / <span class="Constant">1000.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_SECOND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tm-&gt;tm_sec + fsec / 1'000'000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * = (tm-&gt;tm_sec * 1'000'000 + fsec) / 1'000'000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="numeric.c.html#L4304" title="utils/adt/numeric.c:4304">int64_div_fast_to_numeric</a>(tm-&gt;tm_sec * INT64CONST(<span class="Constant">1000000</span>) + fsec, <span class="Constant">6</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(tm-&gt;tm_sec + fsec / <span class="Constant">1000000.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MINUTE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_min;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_HOUR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_hour;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_mday;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MONTH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_mon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_QUARTER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = (tm-&gt;tm_mon - <span class="Constant">1</span>) / <span class="Constant">3</span> + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_WEEK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = <a href="#L5155" title="utils/adt/timestamp.c:5155">date2isoweek</a>(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_YEAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_year &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_year;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there is no year 0, just 1 BC and 1 AD */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_year - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DECADE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see comments in <a href="#L5599" title="utils/adt/timestamp.c:5599">timestamp_part</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_year &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_year / <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = -((<span class="Constant">8</span> - (tm-&gt;tm_year - <span class="Constant">1</span>)) / <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_CENTURY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see comments in <a href="#L5599" title="utils/adt/timestamp.c:5599">timestamp_part</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_year &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = (tm-&gt;tm_year + <span class="Constant">99</span>) / <span class="Constant">100</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = -((<span class="Constant">99</span> - (tm-&gt;tm_year - <span class="Constant">1</span>)) / <span class="Constant">100</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MILLENNIUM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see comments in <a href="#L5599" title="utils/adt/timestamp.c:5599">timestamp_part</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_year &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = (tm-&gt;tm_year + <span class="Constant">999</span>) / <span class="Constant">1000</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = -((<span class="Constant">999</span> - (tm-&gt;tm_year - <span class="Constant">1</span>)) / <span class="Constant">1000</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_JULIAN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="numeric.c.html#L2867" title="utils/adt/numeric.c:2867">numeric_add_opt_error</a>(<a href="numeric.c.html#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(<a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="numeric.c.html#L3144" title="utils/adt/numeric.c:3144">numeric_div_opt_error</a>(<a href="numeric.c.html#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(((((tm-&gt;tm_hour * MINS_PER_HOUR) + tm-&gt;tm_min) * SECS_PER_MINUTE) + tm-&gt;tm_sec) * INT64CONST(<span class="Constant">1000000</span>) + fsec),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="numeric.c.html#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(SECS_PER_DAY * INT64CONST(<span class="Constant">1000000</span>)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((((tm-&gt;tm_hour * MINS_PER_HOUR) + tm-&gt;tm_min) * SECS_PER_MINUTE) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_sec + (fsec / <span class="Constant">1000000.0</span>)) / (<span class="Type">double</span>) SECS_PER_DAY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_ISOYEAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = <a href="#L5210" title="utils/adt/timestamp.c:5210">date2isoyear</a>(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust BC years */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (intresult &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult -= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DOW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_ISODOW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = <a href="datetime.c.html#L344" title="utils/adt/datetime.c:344">j2day</a>(<a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (val == DTK_ISODOW &amp;&amp; intresult == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = <span class="Constant">7</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DOY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = (<a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; - <a href="datetime.c.html#L286" title="utils/adt/datetime.c:286">date2j</a>(tm-&gt;tm_year, <span class="Constant">1</span>, <span class="Constant">1</span>) + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not supported for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(TIMESTAMPTZOID))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (type == RESERV)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (val)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_EPOCH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; epoch = <a href="#L2190" title="utils/adt/timestamp.c:2190">SetEpochTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* (timestamp - epoch) / 1000000 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (timestamp &lt; (PG_INT64_MAX + epoch))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="numeric.c.html#L4304" title="utils/adt/numeric.c:4304">int64_div_fast_to_numeric</a>(timestamp - epoch, <span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="numeric.c.html#L3144" title="utils/adt/numeric.c:3144">numeric_div_opt_error</a>(<a href="numeric.c.html#L2945" title="utils/adt/numeric.c:2945">numeric_sub_opt_error</a>(<a href="numeric.c.html#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(timestamp),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="numeric.c.html#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(epoch),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="numeric.c.html#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(<span class="Constant">1000000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = DatumGetNumeric(DirectFunctionCall2(<a href="numeric.c.html#L1534" title="utils/adt/numeric.c:1534">numeric_round</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NumericGetDatum(result),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int32GetDatum(<span class="Constant">6</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* try to avoid precision loss in subtraction */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (timestamp &lt; (PG_INT64_MAX + epoch))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (timestamp - epoch) / <span class="Constant">1000000.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = ((float8) timestamp - epoch) / <span class="Constant">1000000.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not supported for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(TIMESTAMPTZOID))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not recognized for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(TIMESTAMPTZOID))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; intresult = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="numeric.c.html#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(intresult));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(intresult);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L5871">&#x200c;</a><span class="linkable">timestamptz_part</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L5614" title="utils/adt/timestamp.c:5614">timestamptz_part_common</a>(fcinfo, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L5877">&#x200c;</a><span class="linkable">extract_timestamptz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L5614" title="utils/adt/timestamp.c:5614">timestamptz_part_common</a>(fcinfo, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5894" title="utils/adt/timestamp.c:5894">NonFiniteIntervalPart</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Used by <a href="#L6131" title="utils/adt/timestamp.c:6131">interval_part</a> when extracting from infinite interval.&nbsp; Returns<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; +/-Infinity if that is the appropriate result, otherwise returns zero<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (which should be taken as meaning to return NULL).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Errors thrown here for invalid units should exactly match those that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; would be thrown in the calling <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, else there will be unexpected<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; discrepancies between finite- and infinite-input cases.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> float8<br/></li>
<li><a id="L5894">&#x200c;</a><span class="linkable">NonFiniteIntervalPart</span>(<span class="Type">int</span> type, <span class="Type">int</span> unit, <span class="Type">char</span> *lowunits, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isNegative)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((type != UNITS) &amp;&amp; (type != RESERV))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not recognized for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(INTERVALOID))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (unit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Oscillating units */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MICROSEC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MILLISEC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_SECOND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MINUTE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MONTH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_QUARTER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Monotonically-increasing units */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_HOUR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_YEAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DECADE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_CENTURY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MILLENNIUM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_EPOCH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isNegative)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -get_float8_infinity();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> get_float8_infinity();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not supported for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(INTERVALOID))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L6131" title="utils/adt/timestamp.c:6131">interval_part</a>() and <a href="#L6137" title="utils/adt/timestamp.c:6137">extract_interval</a>()<br/></li>
<li></span><span class="Comment"> * Extract specified field from interval.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L5939">&#x200c;</a><span class="linkable">interval_part_common</span>(PG_FUNCTION_ARGS, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> retnumeric)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *units = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *interval = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; intresult;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *lowunits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_itm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lowunits = <a href="../../parser/scansup.c.html#L37" title="parser/scansup.c:37">downcase_truncate_identifier</a>(VARDATA_ANY(units),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARSIZE_ANY_EXHDR(units),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; type = <a href="datetime.c.html#L4036" title="utils/adt/datetime.c:4036">DecodeUnits</a>(<span class="Constant">0</span>, lowunits, &amp;val);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type == UNKNOWN_FIELD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; type = <a href="datetime.c.html#L3137" title="utils/adt/datetime.c:3137">DecodeSpecial</a>(<span class="Constant">0</span>, lowunits, &amp;val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE(interval))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; r = <a href="#L5894" title="utils/adt/timestamp.c:5894">NonFiniteIntervalPart</a>(type, val, lowunits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INTERVAL_IS_NOBEGIN(interval));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r != <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall3(<a href="numeric.c.html#L628" title="utils/adt/numeric.c:628">numeric_in</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CStringGetDatum(<span class="Constant">&quot;-Infinity&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(InvalidOid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int32GetDatum(-<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (r &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall3(<a href="numeric.c.html#L628" title="utils/adt/numeric.c:628">numeric_in</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CStringGetDatum(<span class="Constant">&quot;Infinity&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(InvalidOid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int32GetDatum(-<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(r);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type == UNITS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2047" title="utils/adt/timestamp.c:2047">interval2itm</a>(*interval, tm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (val)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MICROSEC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_sec * INT64CONST(<span class="Constant">1000000</span>) + tm-&gt;tm_usec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MILLISEC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tm-&gt;tm_sec * 1000 + fsec / 1000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * = (tm-&gt;tm_sec * 1'000'000 + fsec) / 1000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="numeric.c.html#L4304" title="utils/adt/numeric.c:4304">int64_div_fast_to_numeric</a>(tm-&gt;tm_sec * INT64CONST(<span class="Constant">1000000</span>) + tm-&gt;tm_usec, <span class="Constant">3</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(tm-&gt;tm_sec * <span class="Constant">1000.0</span> + tm-&gt;tm_usec / <span class="Constant">1000.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_SECOND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tm-&gt;tm_sec + fsec / 1'000'000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * = (tm-&gt;tm_sec * 1'000'000 + fsec) / 1'000'000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="numeric.c.html#L4304" title="utils/adt/numeric.c:4304">int64_div_fast_to_numeric</a>(tm-&gt;tm_sec * INT64CONST(<span class="Constant">1000000</span>) + tm-&gt;tm_usec, <span class="Constant">6</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(tm-&gt;tm_sec + tm-&gt;tm_usec / <span class="Constant">1000000.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MINUTE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_min;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_HOUR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_hour;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_mday;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MONTH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_mon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_QUARTER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = (tm-&gt;tm_mon / <span class="Constant">3</span>) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_YEAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_year;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DECADE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* caution: C division may have negative remainder */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_year / <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_CENTURY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* caution: C division may have negative remainder */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_year / <span class="Constant">100</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MILLENNIUM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* caution: C division may have negative remainder */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = tm-&gt;tm_year / <span class="Constant">1000</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not supported for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(INTERVALOID))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intresult = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (type == RESERV &amp;&amp; val == DTK_EPOCH)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Numeric&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; secs_from_day_month;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To do this calculation in integer arithmetic even though<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * DAYS_PER_YEAR is fractional, multiply everything by 4 and then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * divide by 4 again at the end.&nbsp; This relies on DAYS_PER_YEAR<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * being a multiple of 0.25 and on SECS_PER_DAY being a multiple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of 4.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; secs_from_day_month = ((int64) (<span class="Constant">4</span> * DAYS_PER_YEAR) * (interval-&gt;month / MONTHS_PER_YEAR) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (int64) (<span class="Constant">4</span> * DAYS_PER_MONTH) * (interval-&gt;month % MONTHS_PER_YEAR) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (int64) <span class="Constant">4</span> * interval-&gt;day) * (SECS_PER_DAY / <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result = secs_from_day_month + interval-&gt;time / 1'000'000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * = (secs_from_day_month * 1'000'000 + interval-&gt;time) / 1'000'000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try the computation inside int64; if it overflows, do it in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> (slower).&nbsp; This overflow happens around 10^9 <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a>, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not common in practice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pg_mul_s64_overflow(secs_from_day_month, <span class="Constant">1000000</span>, &amp;val) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !pg_add_s64_overflow(val, interval-&gt;time, &amp;val))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="numeric.c.html#L4304" title="utils/adt/numeric.c:4304">int64_div_fast_to_numeric</a>(val, <span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="numeric.c.html#L2867" title="utils/adt/numeric.c:2867">numeric_add_opt_error</a>(<a href="numeric.c.html#L4304" title="utils/adt/numeric.c:4304">int64_div_fast_to_numeric</a>(interval-&gt;time, <span class="Constant">6</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="numeric.c.html#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(secs_from_day_month),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = interval-&gt;time / <span class="Constant">1000000.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result += ((<span class="Type">double</span>) DAYS_PER_YEAR * SECS_PER_DAY) * (interval-&gt;month / MONTHS_PER_YEAR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result += ((<span class="Type">double</span>) DAYS_PER_MONTH * SECS_PER_DAY) * (interval-&gt;month % MONTHS_PER_YEAR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result += ((<span class="Type">double</span>) SECS_PER_DAY) * interval-&gt;day;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unit </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not recognized for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowunits, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(INTERVALOID))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; intresult = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (retnumeric)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NUMERIC(<a href="numeric.c.html#L4283" title="utils/adt/numeric.c:4283">int64_to_numeric</a>(intresult));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(intresult);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6131">&#x200c;</a><span class="linkable">interval_part</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L5939" title="utils/adt/timestamp.c:5939">interval_part_common</a>(fcinfo, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6137">&#x200c;</a><span class="linkable">extract_interval</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L5939" title="utils/adt/timestamp.c:5939">interval_part_common</a>(fcinfo, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*&nbsp; &nbsp; <a href="#L6152" title="utils/adt/timestamp.c:6152">timestamp_zone</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Encode timestamp type with specified time zone.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This function is just <a href="#L6344" title="utils/adt/timestamp.c:6344">timestamp2timestamptz</a>() except instead of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; shifting to the global timezone, we shift to the specified timezone.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This is different from the other AT TIME ZONE cases because instead<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; of shifting _to_ a new time zone, it sets the time to _be_ the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; specified timezone.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L6152">&#x200c;</a><span class="linkable">timestamp_zone</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *zone = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestamp = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; tzname[TZ_STRLEN_MAX + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; pg_tz&nbsp; &nbsp; &nbsp;&nbsp; *tzp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tm;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TIMESTAMPTZ(timestamp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up the requested timezone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="varlena.c.html#L248" title="utils/adt/varlena.c:248">text_to_cstring_buffer</a>(zone, tzname, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tzname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; type = <a href="datetime.c.html#L3179" title="utils/adt/datetime.c:3179">DecodeTimezoneName</a>(tzname, &amp;val, &amp;tzp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type == TZNAME_FIXED_OFFSET)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fixed-offset abbreviation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tz = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2134" title="utils/adt/timestamp.c:2134">dt2local</a>(timestamp, tz);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (type == TZNAME_DYNTZ)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dynamic-offset abbreviation, resolve using specified time */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, <span class="Constant">NULL</span>, &amp;tm, &amp;fsec, <span class="Constant">NULL</span>, tzp) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tz = -<a href="datetime.c.html#L1746" title="utils/adt/datetime.c:1746">DetermineTimeZoneAbbrevOffset</a>(&amp;tm, tzname, tzp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2134" title="utils/adt/timestamp.c:2134">dt2local</a>(timestamp, tz);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* full zone name, rotate to that zone */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, <span class="Constant">NULL</span>, &amp;tm, &amp;fsec, <span class="Constant">NULL</span>, tzp) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tz = <a href="datetime.c.html#L1585" title="utils/adt/datetime.c:1585">DetermineTimeZoneOffset</a>(&amp;tm, tzp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1997" title="utils/adt/timestamp.c:1997">tm2timestamp</a>(&amp;tm, fsec, &amp;tz, &amp;result) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!IS_VALID_TIMESTAMP(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMPTZ(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L6217" title="utils/adt/timestamp.c:6217">timestamp_izone</a>()<br/></li>
<li></span><span class="Comment"> * Encode timestamp type with specified time interval as time zone.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L6217">&#x200c;</a><span class="linkable">timestamp_izone</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *zone = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestamp = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TIMESTAMPTZ(timestamp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE(zone))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval time zone </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> must be finite&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetCString(DirectFunctionCall1(<a href="#L982" title="utils/adt/timestamp.c:982">interval_out</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(zone))))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (zone-&gt;month != <span class="Constant">0</span> || zone-&gt;day != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval time zone </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> must not include <a href="datetime.c.html#L81" title="utils/adt/datetime.c:81">months</a> or <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetCString(DirectFunctionCall1(<a href="#L982" title="utils/adt/timestamp.c:982">interval_out</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(zone))))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tz = zone-&gt;time / USECS_PER_SEC;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L2134" title="utils/adt/timestamp.c:2134">dt2local</a>(timestamp, tz);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!IS_VALID_TIMESTAMP(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMPTZ(result);<br/></li>
<li>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L6217" title="utils/adt/timestamp.c:6217">timestamp_izone</a>() */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* <a href="#L6261" title="utils/adt/timestamp.c:6261">TimestampTimestampTzRequiresRewrite</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns false if the TimeZone GUC setting causes <a href="#L6274" title="utils/adt/timestamp.c:6274">timestamp_timestamptz</a> and<br/></li>
<li></span><span class="Comment"> * <a href="#L6353" title="utils/adt/timestamp.c:6353">timestamptz_timestamp</a> to be no-ops, where the return value has the same<br/></li>
<li></span><span class="Comment"> * bits as the argument.&nbsp; Since project convention is to assume a GUC changes<br/></li>
<li></span><span class="Comment"> * no more often than STABLE <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> change, the answer is valid that long.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L6261">&#x200c;</a></span><span class="linkable">TimestampTimestampTzRequiresRewrite</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_get_timezone_offset(session_timezone, &amp;offset) &amp;&amp; offset == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L6274" title="utils/adt/timestamp.c:6274">timestamp_timestamptz</a>()<br/></li>
<li></span><span class="Comment"> * Convert local timestamp to timestamp at GMT<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L6274">&#x200c;</a><span class="linkable">timestamp_timestamptz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; timestamp = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMPTZ(<a href="#L6344" title="utils/adt/timestamp.c:6344">timestamp2timestamptz</a>(timestamp));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert timestamp to timestamp with time zone.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On successful conversion, *overflow is set to zero if it's not NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the timestamp is finite but out of the valid <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> for timestamptz, then:<br/></li>
<li></span><span class="Comment"> * if overflow is NULL, we throw an out-of-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> error.<br/></li>
<li></span><span class="Comment"> * if overflow is not NULL, we store +1 or -1 there to indicate the sign<br/></li>
<li></span><span class="Comment"> * of the overflow, and return the appropriate timestamptz infinity.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TimestampTz<br/></li>
<li><a id="L6292">&#x200c;</a><span class="linkable">timestamp2timestamptz_opt_overflow</span>(Timestamp timestamp, <span class="Type">int</span> *overflow)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (overflow)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *overflow = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> timestamp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We don't expect this to fail, but check it pro forma */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, <span class="Constant">NULL</span>, tm, &amp;fsec, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tz = <a href="datetime.c.html#L1585" title="utils/adt/datetime.c:1585">DetermineTimeZoneOffset</a>(tm, session_timezone);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2134" title="utils/adt/timestamp.c:2134">dt2local</a>(timestamp, -tz);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IS_VALID_TIMESTAMP(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (overflow)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result &lt; MIN_TIMESTAMP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *overflow = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TIMESTAMP_NOBEGIN(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *overflow = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TIMESTAMP_NOEND(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Promote timestamp to timestamptz, throwing error for overflow.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TimestampTz<br/></li>
<li><a id="L6344">&#x200c;</a><span class="linkable">timestamp2timestamptz</span>(Timestamp timestamp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L6292" title="utils/adt/timestamp.c:6292">timestamp2timestamptz_opt_overflow</a>(timestamp, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L6353" title="utils/adt/timestamp.c:6353">timestamptz_timestamp</a>()<br/></li>
<li></span><span class="Comment"> * Convert timestamp at GMT to local timestamp<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L6353">&#x200c;</a><span class="linkable">timestamptz_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMP(<a href="#L6361" title="utils/adt/timestamp.c:6361">timestamptz2timestamp</a>(timestamp));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Timestamp<br/></li>
<li><a id="L6361">&#x200c;</a><span class="linkable">timestamptz2timestamp</span>(TimestampTz timestamp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = timestamp;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, &amp;tz, tm, &amp;fsec, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1997" title="utils/adt/timestamp.c:1997">tm2timestamp</a>(tm, fsec, <span class="Constant">NULL</span>, &amp;result) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L6390" title="utils/adt/timestamp.c:6390">timestamptz_zone</a>()<br/></li>
<li></span><span class="Comment"> * Evaluate timestamp with time zone type at the specified time zone.<br/></li>
<li></span><span class="Comment"> * Returns a timestamp without time zone.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L6390">&#x200c;</a><span class="linkable">timestamptz_zone</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *zone = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; tzname[TZ_STRLEN_MAX + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; pg_tz&nbsp; &nbsp; &nbsp;&nbsp; *tzp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TIMESTAMP(timestamp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up the requested timezone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="varlena.c.html#L248" title="utils/adt/varlena.c:248">text_to_cstring_buffer</a>(zone, tzname, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tzname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; type = <a href="datetime.c.html#L3179" title="utils/adt/datetime.c:3179">DecodeTimezoneName</a>(tzname, &amp;val, &amp;tzp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type == TZNAME_FIXED_OFFSET)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fixed-offset abbreviation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tz = -val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2134" title="utils/adt/timestamp.c:2134">dt2local</a>(timestamp, tz);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (type == TZNAME_DYNTZ)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dynamic-offset abbreviation, resolve using specified time */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isdst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tz = <a href="datetime.c.html#L1784" title="utils/adt/datetime.c:1784">DetermineTimeZoneAbbrevOffsetTS</a>(timestamp, tzname, tzp, &amp;isdst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2134" title="utils/adt/timestamp.c:2134">dt2local</a>(timestamp, tz);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* full zone name, rotate from that zone */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_tm tm;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(timestamp, &amp;tz, &amp;tm, &amp;fsec, <span class="Constant">NULL</span>, tzp) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1997" title="utils/adt/timestamp.c:1997">tm2timestamp</a>(&amp;tm, fsec, <span class="Constant">NULL</span>, &amp;result) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!IS_VALID_TIMESTAMP(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMP(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L6454" title="utils/adt/timestamp.c:6454">timestamptz_izone</a>()<br/></li>
<li></span><span class="Comment"> * Encode timestamp with time zone type with specified time interval as time zone.<br/></li>
<li></span><span class="Comment"> * Returns a timestamp without time zone.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L6454">&#x200c;</a><span class="linkable">timestamptz_izone</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *zone = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimestampTz timestamp = PG_GETARG_TIMESTAMPTZ(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TIMESTAMP_NOT_FINITE(timestamp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TIMESTAMP(timestamp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE(zone))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval time zone </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> must be finite&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetCString(DirectFunctionCall1(<a href="#L982" title="utils/adt/timestamp.c:982">interval_out</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(zone))))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (zone-&gt;month != <span class="Constant">0</span> || zone-&gt;day != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval time zone </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> must not include <a href="datetime.c.html#L81" title="utils/adt/datetime.c:81">months</a> or <a href="datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetCString(DirectFunctionCall1(<a href="#L982" title="utils/adt/timestamp.c:982">interval_out</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(zone))))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tz = -(zone-&gt;time / USECS_PER_SEC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L2134" title="utils/adt/timestamp.c:2134">dt2local</a>(timestamp, tz);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!IS_VALID_TIMESTAMP(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TIMESTAMP(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L6494" title="utils/adt/timestamp.c:6494">generate_series_timestamp</a>()<br/></li>
<li></span><span class="Comment"> * Generate the set of timestamps from start to finish by step<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L6494">&#x200c;</a><span class="linkable">generate_series_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FuncCallContext *funcctx;<br/></li>
<li>&nbsp; &nbsp; <a href="#L63" title="utils/adt/timestamp.c:63">generate_series_timestamp_fctx</a> *fctx;<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* stuff done only on the first call of the function */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (SRF_IS_FIRSTCALL())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Timestamp&nbsp; &nbsp; start = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Timestamp&nbsp; &nbsp; finish = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Interval&nbsp;&nbsp; *step = PG_GETARG_INTERVAL_P(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* create a function context for cross-call persistence */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; funcctx = SRF_FIRSTCALL_INIT();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * switch to memory context appropriate for multiple function calls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocate memory for user context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fctx = (<a href="#L63" title="utils/adt/timestamp.c:63">generate_series_timestamp_fctx</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L63" title="utils/adt/timestamp.c:63">generate_series_timestamp_fctx</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use fctx to keep state from call to call. Seed current with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * original start value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fctx-&gt;current = start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fctx-&gt;finish = finish;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fctx-&gt;step = *step;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Determine sign of the interval */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fctx-&gt;step_sign = <a href="#L2514" title="utils/adt/timestamp.c:2514">interval_sign</a>(&amp;fctx-&gt;step);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fctx-&gt;step_sign == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;step size cannot <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> zero&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE((&amp;fctx-&gt;step)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;step size cannot be infinite&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcctx-&gt;user_fctx = fctx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* stuff done on every call of the function */<br/></li>
<li></span>&nbsp; &nbsp; funcctx = SRF_PERCALL_SETUP();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get the saved state and use current as the result for this iteration<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fctx = funcctx-&gt;user_fctx;<br/></li>
<li>&nbsp; &nbsp; result = fctx-&gt;current;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fctx-&gt;step_sign &gt; <span class="Constant">0</span> ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2210" title="utils/adt/timestamp.c:2210">timestamp_cmp_internal</a>(result, fctx-&gt;finish) &lt;= <span class="Constant">0</span> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2210" title="utils/adt/timestamp.c:2210">timestamp_cmp_internal</a>(result, fctx-&gt;finish) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* increment current in preparation for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> iteration */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fctx-&gt;current = DatumGetTimestamp(DirectFunctionCall2(<a href="#L3049" title="utils/adt/timestamp.c:3049">timestamp_pl_interval</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampGetDatum(fctx-&gt;current),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(&amp;fctx-&gt;step)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do when there is more left to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_NEXT(funcctx, TimestampGetDatum(result));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do when there is no more left */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_DONE(funcctx);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L6660" title="utils/adt/timestamp.c:6660">generate_series_timestamptz</a>()<br/></li>
<li></span><span class="Comment"> * Generate the set of timestamps from start to finish by step,<br/></li>
<li></span><span class="Comment"> * doing arithmetic in the specified or session timezone.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L6578">&#x200c;</a><span class="linkable">generate_series_timestamptz_internal</span>(FunctionCallInfo fcinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FuncCallContext *funcctx;<br/></li>
<li>&nbsp; &nbsp; <a href="#L72" title="utils/adt/timestamp.c:72">generate_series_timestamptz_fctx</a> *fctx;<br/></li>
<li>&nbsp; &nbsp; TimestampTz result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* stuff done only on the first call of the function */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (SRF_IS_FIRSTCALL())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz start = PG_GETARG_TIMESTAMPTZ(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz finish = PG_GETARG_TIMESTAMPTZ(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Interval&nbsp;&nbsp; *step = PG_GETARG_INTERVAL_P(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *zone = (PG_NARGS() == <span class="Constant">4</span>) ? PG_GETARG_TEXT_PP(<span class="Constant">3</span>) : <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* create a function context for cross-call persistence */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; funcctx = SRF_FIRSTCALL_INIT();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * switch to memory context appropriate for multiple function calls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocate memory for user context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fctx = (<a href="#L72" title="utils/adt/timestamp.c:72">generate_series_timestamptz_fctx</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L72" title="utils/adt/timestamp.c:72">generate_series_timestamptz_fctx</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use fctx to keep state from call to call. Seed current with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * original start value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fctx-&gt;current = start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fctx-&gt;finish = finish;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fctx-&gt;step = *step;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fctx-&gt;attimezone = zone ? <a href="#L558" title="utils/adt/timestamp.c:558">lookup_timezone</a>(zone) : session_timezone;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Determine sign of the interval */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fctx-&gt;step_sign = <a href="#L2514" title="utils/adt/timestamp.c:2514">interval_sign</a>(&amp;fctx-&gt;step);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fctx-&gt;step_sign == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;step size cannot <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> zero&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (INTERVAL_NOT_FINITE((&amp;fctx-&gt;step)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;step size cannot be infinite&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcctx-&gt;user_fctx = fctx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* stuff done on every call of the function */<br/></li>
<li></span>&nbsp; &nbsp; funcctx = SRF_PERCALL_SETUP();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get the saved state and use current as the result for this iteration<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fctx = funcctx-&gt;user_fctx;<br/></li>
<li>&nbsp; &nbsp; result = fctx-&gt;current;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fctx-&gt;step_sign &gt; <span class="Constant">0</span> ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2210" title="utils/adt/timestamp.c:2210">timestamp_cmp_internal</a>(result, fctx-&gt;finish) &lt;= <span class="Constant">0</span> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2210" title="utils/adt/timestamp.c:2210">timestamp_cmp_internal</a>(result, fctx-&gt;finish) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* increment current in preparation for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> iteration */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fctx-&gt;current = <a href="#L3186" title="utils/adt/timestamp.c:3186">timestamptz_pl_interval_internal</a>(fctx-&gt;current,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;fctx-&gt;step,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fctx-&gt;attimezone);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do when there is more left to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_NEXT(funcctx, TimestampTzGetDatum(result));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do when there is no more left */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_DONE(funcctx);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6660">&#x200c;</a><span class="linkable">generate_series_timestamptz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L6578" title="utils/adt/timestamp.c:6578">generate_series_timestamptz_internal</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6666">&#x200c;</a><span class="linkable">generate_series_timestamptz_at_zone</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L6578" title="utils/adt/timestamp.c:6578">generate_series_timestamptz_internal</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L6680" title="utils/adt/timestamp.c:6680">timestamp_at_local</a>()<br/></li>
<li></span><span class="Comment"> * <a href="#L6686" title="utils/adt/timestamp.c:6686">timestamptz_at_local</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The regression tests do not like two <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> with the same proargs and<br/></li>
<li></span><span class="Comment"> * prosrc but different proname, but the grammar for AT LOCAL needs an<br/></li>
<li></span><span class="Comment"> * overloaded name to handle both types of timestamp, so we make simple<br/></li>
<li></span><span class="Comment"> * wrappers for it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L6680">&#x200c;</a><span class="linkable">timestamp_at_local</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L6274" title="utils/adt/timestamp.c:6274">timestamp_timestamptz</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6686">&#x200c;</a><span class="linkable">timestamptz_at_local</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L6353" title="utils/adt/timestamp.c:6353">timestamptz_timestamp</a>(fcinfo);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
