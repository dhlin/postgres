<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/varlena.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/varlena.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L48">bytea_output</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L108">SplitTextOutputData</a></li>
<li><a href="#L78">TextPositionState</a></li>
<li><a href="#L50">VarString</a></li>
<li><a href="#L97">VarStringSortSupport</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L3584">SplitDirectoriesString</a></li>
<li><a href="#L3705">SplitGUCList</a></li>
<li><a href="#L3457">SplitIdentifierString</a></li>
<li><a href="#L4106">appendStringInfoRegexpSubstr</a></li>
<li><a href="#L3982">appendStringInfoText</a></li>
<li><a href="#L4766">array_to_text</a></li>
<li><a href="#L4808">array_to_text_internal</a></li>
<li><a href="#L4782">array_to_text_null</a></li>
<li><a href="#L2049">bpcharfastcmp_c</a></li>
<li><a href="#L2700">btnametextcmp</a></li>
<li><a href="#L2883">bttext_pattern_cmp</a></li>
<li><a href="#L2899">bttext_pattern_sortsupport</a></li>
<li><a href="#L1831">bttextcmp</a></li>
<li><a href="#L2716">bttextnamecmp</a></li>
<li><a href="#L1846">bttextsortsupport</a></li>
<li><a href="#L2555">btvarstrequalimage</a></li>
<li><a href="#L5384">build_concat_foutcache</a></li>
<li><a href="#L3238">byteaGetBit</a></li>
<li><a href="#L3209">byteaGetByte</a></li>
<li><a href="#L3308">byteaSetBit</a></li>
<li><a href="#L3276">byteaSetByte</a></li>
<li><a href="#L3151">bytea_bit_count</a></li>
<li><a href="#L2953">bytea_catenate</a></li>
<li><a href="#L3118">bytea_overlay</a></li>
<li><a href="#L3960">bytea_sortsupport</a></li>
<li><a href="#L551">bytea_string_agg_finalfn</a></li>
<li><a href="#L498">bytea_string_agg_transfn</a></li>
<li><a href="#L3005">bytea_substr</a></li>
<li><a href="#L3019">bytea_substr_no_len</a></li>
<li><a href="#L3028">bytea_substring</a></li>
<li><a href="#L2938">byteacat</a></li>
<li><a href="#L3938">byteacmp</a></li>
<li><a href="#L3794">byteaeq</a></li>
<li><a href="#L3918">byteage</a></li>
<li><a href="#L3898">byteagt</a></li>
<li><a href="#L290">byteain</a></li>
<li><a href="#L3878">byteale</a></li>
<li><a href="#L3858">bytealt</a></li>
<li><a href="#L3826">byteane</a></li>
<li><a href="#L2922">byteaoctetlen</a></li>
<li><a href="#L388">byteaout</a></li>
<li><a href="#L3095">byteaoverlay</a></li>
<li><a href="#L3106">byteaoverlay_no_len</a></li>
<li><a href="#L3165">byteapos</a></li>
<li><a href="#L471">bytearecv</a></li>
<li><a href="#L490">byteasend</a></li>
<li><a href="#L806">charlen_to_bytelen</a></li>
<li><a href="#L1510">check_collation_set</a></li>
<li><a href="#L4073">check_replace_text_has_escape</a></li>
<li><a href="#L5422">concat_internal</a></li>
<li><a href="#L4930">convert_to_base</a></li>
<li><a href="#L184">cstring_to_text</a></li>
<li><a href="#L196">cstring_to_text_with_len</a></li>
<li><a href="#L6243">getClosestMatch</a></li>
<li><a href="#L6472">hexval</a></li>
<li><a href="#L6488">hexval_n</a></li>
<li><a href="#L6302">icu_unicode_version</a></li>
<li><a href="#L6188">initClosestMatch</a></li>
<li><a href="#L2797">internal_text_pattern_compare</a></li>
<li><a href="#L6462">isxdigits_n</a></li>
<li><a href="#L5162">makeStringAggState</a></li>
<li><a href="#L3382">name_text</a></li>
<li><a href="#L2600">nameeqtext</a></li>
<li><a href="#L2082">namefastcmp_c</a></li>
<li><a href="#L2125">namefastcmp_locale</a></li>
<li><a href="#L2756">namegetext</a></li>
<li><a href="#L2750">namegttext</a></li>
<li><a href="#L2744">nameletext</a></li>
<li><a href="#L2738">namelttext</a></li>
<li><a href="#L2650">namenetext</a></li>
<li><a href="#L5061">pg_column_compression</a></li>
<li><a href="#L5014">pg_column_size</a></li>
<li><a href="#L5114">pg_column_toast_chunk_id</a></li>
<li><a href="#L3996">replace_text</a></li>
<li><a href="#L4206">replace_text_regexp</a></li>
<li><a href="#L6152">rest_of_char_same</a></li>
<li><a href="#L4368">split_part</a></li>
<li><a href="#L4591">split_text</a></li>
<li><a href="#L4727">split_text_accum_result</a></li>
<li><a href="#L5241">string_agg_combine</a></li>
<li><a href="#L5322">string_agg_deserialize</a></li>
<li><a href="#L5358">string_agg_finalfn</a></li>
<li><a href="#L5291">string_agg_serialize</a></li>
<li><a href="#L5186">string_agg_transfn</a></li>
<li><a href="#L3399">textToQualifiedNameList</a></li>
<li><a href="#L765">text_catenate</a></li>
<li><a href="#L1594">text_cmp</a></li>
<li><a href="#L5502">text_concat</a></li>
<li><a href="#L5517">text_concat_ws</a></li>
<li><a href="#L5638">text_format</a></li>
<li><a href="#L6090">text_format_append_string</a></li>
<li><a href="#L6142">text_format_nv</a></li>
<li><a href="#L5915">text_format_parse_digits</a></li>
<li><a href="#L5964">text_format_parse_format</a></li>
<li><a href="#L6041">text_format_string_conversion</a></li>
<li><a href="#L1776">text_ge</a></li>
<li><a href="#L1761">text_gt</a></li>
<li><a href="#L4500">text_isequal</a></li>
<li><a href="#L2571">text_larger</a></li>
<li><a href="#L1746">text_le</a></li>
<li><a href="#L5538">text_left</a></li>
<li><a href="#L711">text_length</a></li>
<li><a href="#L1731">text_lt</a></li>
<li><a href="#L3359">text_name</a></li>
<li><a href="#L1116">text_overlay</a></li>
<li><a href="#L2851">text_pattern_ge</a></li>
<li><a href="#L2867">text_pattern_gt</a></li>
<li><a href="#L2835">text_pattern_le</a></li>
<li><a href="#L2819">text_pattern_lt</a></li>
<li><a href="#L1176">text_position</a></li>
<li><a href="#L1503">text_position_cleanup</a></li>
<li><a href="#L1479">text_position_get_match_pos</a></li>
<li><a href="#L1468">text_position_get_match_ptr</a></li>
<li><a href="#L1336">text_position_next</a></li>
<li><a href="#L1400">text_position_next_internal</a></li>
<li><a href="#L1495">text_position_reset</a></li>
<li><a href="#L1216">text_position_setup</a></li>
<li><a href="#L5583">text_reverse</a></li>
<li><a href="#L5562">text_right</a></li>
<li><a href="#L2583">text_smaller</a></li>
<li><a href="#L1791">text_starts_with</a></li>
<li><a href="#L852">text_substr</a></li>
<li><a href="#L866">text_substr_no_len</a></li>
<li><a href="#L885">text_substring</a></li>
<li><a href="#L4514">text_to_array</a></li>
<li><a href="#L4540">text_to_array_null</a></li>
<li><a href="#L217">text_to_cstring</a></li>
<li><a href="#L248">text_to_cstring_buffer</a></li>
<li><a href="#L4551">text_to_table</a></li>
<li><a href="#L4575">text_to_table_null</a></li>
<li><a href="#L750">textcat</a></li>
<li><a href="#L1619">texteq</a></li>
<li><a href="#L2625">texteqname</a></li>
<li><a href="#L2780">textgename</a></li>
<li><a href="#L2774">textgtname</a></li>
<li><a href="#L579">textin</a></li>
<li><a href="#L693">textlen</a></li>
<li><a href="#L2768">textlename</a></li>
<li><a href="#L2762">textltname</a></li>
<li><a href="#L1678">textne</a></li>
<li><a href="#L2675">textnename</a></li>
<li><a href="#L731">textoctetlen</a></li>
<li><a href="#L590">textout</a></li>
<li><a href="#L1093">textoverlay</a></li>
<li><a href="#L1104">textoverlay_no_len</a></li>
<li><a href="#L1153">textpos</a></li>
<li><a href="#L601">textrecv</a></li>
<li><a href="#L619">textsend</a></li>
<li><a href="#L4956">to_bin32</a></li>
<li><a href="#L4963">to_bin64</a></li>
<li><a href="#L4994">to_hex32</a></li>
<li><a href="#L5001">to_hex64</a></li>
<li><a href="#L4975">to_oct32</a></li>
<li><a href="#L4982">to_oct64</a></li>
<li><a href="#L6316">unicode_assigned</a></li>
<li><a href="#L6410">unicode_is_normalized</a></li>
<li><a href="#L6256">unicode_norm_form_from_string</a></li>
<li><a href="#L6344">unicode_normalize_func</a></li>
<li><a href="#L6293">unicode_version</a></li>
<li><a href="#L6502">unistr</a></li>
<li><a href="#L634">unknownin</a></li>
<li><a href="#L646">unknownout</a></li>
<li><a href="#L658">unknownrecv</a></li>
<li><a href="#L673">unknownsend</a></li>
<li><a href="#L6208">updateClosestMatch</a></li>
<li><a href="#L2094">varlenafastcmp_locale</a></li>
<li><a href="#L2437">varstr_abbrev_abort</a></li>
<li><a href="#L2239">varstr_abbrev_convert</a></li>
<li><a href="#L1539">varstr_cmp</a></li>
<li><a href="#L1873">varstr_sortsupport</a></li>
<li><a href="#L2012">varstrfastcmp_c</a></li>
<li><a href="#L2139">varstrfastcmp_locale</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L5625">ADVANCE_PARSE_POINTER</a></li>
<li><a href="#L2731">CmpCall</a></li>
<li><a href="#L2785">CmpCall</a></li>
<li><a href="#L276">DIG</a></li>
<li><a href="#L116">DatumGetVarStringP</a></li>
<li><a href="#L117">DatumGetVarStringPP</a></li>
<li><a href="#L6165">LEVENSHTEIN_LESS_EQUAL</a></li>
<li><a href="#L2986">PG_STR_GET_BYTEA</a></li>
<li><a href="#L114">TEXTBUFLEN</a></li>
<li><a href="#L5623">TEXT_FORMAT_FLAG_MINUS</a></li>
<li><a href="#L275">VAL</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * varlena.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Functions for the variable-length built-in types.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/varlena.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;ctype.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/detoast.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/toast_compression.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_collation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/hashfn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/int.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/unicode_category.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/unicode_norm.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/<a href="#L6293" title="utils/adt/varlena.c:6293">unicode_version</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/hyperloglog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/execnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/scansup.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bswap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;regex/regex.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/bytea.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pg_locale.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/sortsupport.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/varlena.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* GUC variable */<br/></li>
<li><a id="L48">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">bytea_output</span> = BYTEA_OUTPUT_HEX;<br/></li>
<li><br/></li>
<li><a id="L50">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> varlena <span class="linkable">VarString</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * State for text_position_* <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_multibyte_char_in_char;&nbsp; &nbsp; <span class="Comment">/* need to check char boundaries? */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str1;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* haystack string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str2;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* needle string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* string lengths in bytes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Skip table for Boyer-Moore-Horspool search algorithm: */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skiptablemask;&nbsp; &nbsp; <span class="Comment">/* mask for ANDing with skiptable subscripts */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skiptable[<span class="Constant">256</span>]; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> distance for given mismatched char */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *last_match;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pointer to last match in 'str1' */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sometimes we need to convert the byte position of a match to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * character position.&nbsp; These store the last position that was converted,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so that on the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call, we can continue from that point, rather than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * count characters from the very beginning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *refpoint;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pointer within original haystack string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; refpos;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* 0-based character offset of the same point */<br/></li>
<li><a id="L78">&#x200c;</a></span>} <span class="linkable">TextPositionState</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf1;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* 1st string, or abbreviation original string<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buf */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf2;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* 2nd string, or abbreviation strxfrm() buf */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buflen1;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allocated length of buf1 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buflen2;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allocated length of buf2 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_len1;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Length of last buf1 string/strxfrm() input */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_len2;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Length of last buf2 string/strxfrm() blob */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_returned;&nbsp; &nbsp; <span class="Comment">/* Last comparison result (cache) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; cache_blob;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Does buf2 contain strxfrm() blob, etc? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; collate_c;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Actual datatype (text/<a href="varchar.c.html#L271" title="utils/adt/varchar.c:271">bpchar</a>/bytea/name) */<br/></li>
<li></span>&nbsp; &nbsp; hyperLogLogState abbr_card; <span class="Comment">/* Abbreviated key cardinality state */<br/></li>
<li></span>&nbsp; &nbsp; hyperLogLogState full_card; <span class="Comment">/* Full key cardinality state */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; prop_card;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Required cardinality proportion */<br/></li>
<li></span>&nbsp; &nbsp; pg_locale_t locale;<br/></li>
<li><a id="L97">&#x200c;</a>} <span class="linkable">VarStringSortSupport</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Output data for <a href="#L4591" title="utils/adt/varlena.c:4591">split_text</a>(): we output either to an array or a table.<br/></li>
<li></span><span class="Comment"> * tupstore and tupdesc must be set up in advance to output to a table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; ArrayBuildState *astate;<br/></li>
<li>&nbsp; &nbsp; <a href="../sort/tuplestore.c.html#L103" title="utils/sort/tuplestore.c:103">Tuplestorestate</a> *tupstore;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li><a id="L108">&#x200c;</a>} <span class="linkable">SplitTextOutputData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This should be large enough that most strings will fit, but small enough<br/></li>
<li></span><span class="Comment"> * that we feel comfortable putting it on the stack<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L114">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TEXTBUFLEN</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">1024<br/></li>
<li></span><br/></li>
<li><a id="L116">&#x200c;</a><span class="PreProc">#define <span class="linkable">DatumGetVarStringP</span>(X)&nbsp; &nbsp; &nbsp; &nbsp; ((<a href="#L50" title="utils/adt/varlena.c:50">VarString</a> *) PG_DETOAST_DATUM(X))<br/></li>
<li><a id="L117">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DatumGetVarStringPP</span>(X)&nbsp; &nbsp; &nbsp; &nbsp; ((<a href="#L50" title="utils/adt/varlena.c:50">VarString</a> *) PG_DETOAST_DATUM_PACKED(X))<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2012" title="utils/adt/varlena.c:2012">varstrfastcmp_c</a>(Datum x, Datum y, SortSupport ssup);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2049" title="utils/adt/varlena.c:2049">bpcharfastcmp_c</a>(Datum x, Datum y, SortSupport ssup);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2082" title="utils/adt/varlena.c:2082">namefastcmp_c</a>(Datum x, Datum y, SortSupport ssup);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2094" title="utils/adt/varlena.c:2094">varlenafastcmp_locale</a>(Datum x, Datum y, SortSupport ssup);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2125" title="utils/adt/varlena.c:2125">namefastcmp_locale</a>(Datum x, Datum y, SortSupport ssup);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2139" title="utils/adt/varlena.c:2139">varstrfastcmp_locale</a>(<span class="Type">char</span> *a1p, <span class="Type">int</span> len1, <span class="Type">char</span> *a2p, <span class="Type">int</span> len2, SortSupport ssup);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L2239" title="utils/adt/varlena.c:2239">varstr_abbrev_convert</a>(Datum original, SortSupport ssup);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2437" title="utils/adt/varlena.c:2437">varstr_abbrev_abort</a>(<span class="Type">int</span> memtupcount, SortSupport ssup);<br/></li>
<li><span class="Type">static</span> int32 <a href="#L711" title="utils/adt/varlena.c:711">text_length</a>(Datum str);<br/></li>
<li><span class="Type">static</span> text *<a href="#L765" title="utils/adt/varlena.c:765">text_catenate</a>(text *t1, text *t2);<br/></li>
<li><span class="Type">static</span> text *<a href="#L885" title="utils/adt/varlena.c:885">text_substring</a>(Datum str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32 start,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32 length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> length_not_specified);<br/></li>
<li><span class="Type">static</span> text *<a href="#L1116" title="utils/adt/varlena.c:1116">text_overlay</a>(text *t1, text *t2, <span class="Type">int</span> sp, <span class="Type">int</span> sl);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1176" title="utils/adt/varlena.c:1176">text_position</a>(text *t1, text *t2, Oid collid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1216" title="utils/adt/varlena.c:1216">text_position_setup</a>(text *t1, text *t2, Oid collid, <a href="#L78" title="utils/adt/varlena.c:78">TextPositionState</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1336" title="utils/adt/varlena.c:1336">text_position_next</a>(<a href="#L78" title="utils/adt/varlena.c:78">TextPositionState</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L1400" title="utils/adt/varlena.c:1400">text_position_next_internal</a>(<span class="Type">char</span> *start_ptr, <a href="#L78" title="utils/adt/varlena.c:78">TextPositionState</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L1468" title="utils/adt/varlena.c:1468">text_position_get_match_ptr</a>(<a href="#L78" title="utils/adt/varlena.c:78">TextPositionState</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1479" title="utils/adt/varlena.c:1479">text_position_get_match_pos</a>(<a href="#L78" title="utils/adt/varlena.c:78">TextPositionState</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1503" title="utils/adt/varlena.c:1503">text_position_cleanup</a>(<a href="#L78" title="utils/adt/varlena.c:78">TextPositionState</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="varchar.c.html#L727" title="utils/adt/varchar.c:727">check_collation_set</a>(Oid collid);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1594" title="utils/adt/varlena.c:1594">text_cmp</a>(text *arg1, text *arg2, Oid collid);<br/></li>
<li><span class="Type">static</span> bytea *<a href="#L2953" title="utils/adt/varlena.c:2953">bytea_catenate</a>(bytea *t1, bytea *t2);<br/></li>
<li><span class="Type">static</span> bytea *<a href="#L3028" title="utils/adt/varlena.c:3028">bytea_substring</a>(Datum str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> S,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> L,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> length_not_specified);<br/></li>
<li><span class="Type">static</span> bytea *<a href="#L3118" title="utils/adt/varlena.c:3118">bytea_overlay</a>(bytea *t1, bytea *t2, <span class="Type">int</span> sp, <span class="Type">int</span> sl);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="xml.c.html#L459" title="utils/adt/xml.c:459">appendStringInfoText</a>(StringInfo str, <span class="Type">const</span> text *t);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L4591" title="utils/adt/varlena.c:4591">split_text</a>(FunctionCallInfo fcinfo, <a href="#L108" title="utils/adt/varlena.c:108">SplitTextOutputData</a> *tstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4727" title="utils/adt/varlena.c:4727">split_text_accum_result</a>(<a href="#L108" title="utils/adt/varlena.c:108">SplitTextOutputData</a> *tstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text *field_value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text *null_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid collation);<br/></li>
<li><span class="Type">static</span> text *<a href="#L4808" title="utils/adt/varlena.c:4808">array_to_text_internal</a>(FunctionCallInfo fcinfo, ArrayType *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *fldsep, <span class="Type">const</span> <span class="Type">char</span> *null_string);<br/></li>
<li><span class="Type">static</span> StringInfo <a href="#L5162" title="utils/adt/varlena.c:5162">makeStringAggState</a>(FunctionCallInfo fcinfo);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L5915" title="utils/adt/varlena.c:5915">text_format_parse_digits</a>(<span class="Type">const</span> <span class="Type">char</span> **ptr, <span class="Type">const</span> <span class="Type">char</span> *end_ptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *value);<br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<a href="#L5964" title="utils/adt/varlena.c:5964">text_format_parse_format</a>(<span class="Type">const</span> <span class="Type">char</span> *start_ptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *end_ptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *argpos, <span class="Type">int</span> *widthpos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *flags, <span class="Type">int</span> *width);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L6041" title="utils/adt/varlena.c:6041">text_format_string_conversion</a>(StringInfo buf, <span class="Type">char</span> conversion,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo *typOutputInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum value, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isNull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> flags, <span class="Type">int</span> width);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L6090" title="utils/adt/varlena.c:6090">text_format_append_string</a>(StringInfo buf, <span class="Type">const</span> <span class="Type">char</span> *str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> flags, <span class="Type">int</span> width);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; CONVERSION ROUTINES EXPORTED FOR USE BY C CODE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L184" title="utils/adt/varlena.c:184">cstring_to_text</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Create a text value from a null-terminated C string.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The new text value is freshly <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d with a full-size VARHDR.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>text *<br/></li>
<li><a id="L184">&#x200c;</a><span class="linkable">cstring_to_text</span>(<span class="Type">const</span> <span class="Type">char</span> *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(s, strlen(s));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Same as <a href="#L184" title="utils/adt/varlena.c:184">cstring_to_text</a> except the caller specifies the string length;<br/></li>
<li></span><span class="Comment"> * the string need not be null_terminated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>text *<br/></li>
<li><a id="L196">&#x200c;</a><span class="linkable">cstring_to_text_with_len</span>(<span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result = (text *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len + VARHDRSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, len + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; memcpy(VARDATA(result), s, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L217" title="utils/adt/varlena.c:217">text_to_cstring</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Create a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d, null-terminated C string from a text value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We support being passed a compressed or toasted text value.<br/></li>
<li></span><span class="Comment"> * This is a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> bogus since such <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> shouldn't really be referred to as<br/></li>
<li></span><span class="Comment"> * &quot;text *&quot;, but it seems useful for robustness.&nbsp; If we didn't handle that<br/></li>
<li></span><span class="Comment"> * case here, we'd need another routine that did, anyway.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L217">&#x200c;</a><span class="linkable">text_to_cstring</span>(<span class="Type">const</span> text *t)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* must cast away the const, unfortunately */<br/></li>
<li></span>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *tunpacked = <a href="../fmgr/fmgr.c.html#L1864" title="utils/fmgr/fmgr.c:1864">pg_detoast_datum_packed</a>(unconstify(text *, t));<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = VARSIZE_ANY_EXHDR(tunpacked);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; memcpy(result, VARDATA_ANY(tunpacked), len);<br/></li>
<li>&nbsp; &nbsp; result[len] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tunpacked != t)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tunpacked);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L248" title="utils/adt/varlena.c:248">text_to_cstring_buffer</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copy a text value into a caller-supplied buffer of size dst_len.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The text string is truncated if necessary to fit.&nbsp; The result is<br/></li>
<li></span><span class="Comment"> * guaranteed null-terminated (unless dst_len == 0).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We support being passed a compressed or toasted text value.<br/></li>
<li></span><span class="Comment"> * This is a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> bogus since such <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> shouldn't really be referred to as<br/></li>
<li></span><span class="Comment"> * &quot;text *&quot;, but it seems useful for robustness.&nbsp; If we didn't handle that<br/></li>
<li></span><span class="Comment"> * case here, we'd need another routine that did, anyway.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L248">&#x200c;</a></span><span class="linkable">text_to_cstring_buffer</span>(<span class="Type">const</span> text *src, <span class="Type">char</span> *dst, <span class="Type">size_t</span> dst_len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* must cast away the const, unfortunately */<br/></li>
<li></span>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *srcunpacked = <a href="../fmgr/fmgr.c.html#L1864" title="utils/fmgr/fmgr.c:1864">pg_detoast_datum_packed</a>(unconstify(text *, src));<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; src_len = VARSIZE_ANY_EXHDR(srcunpacked);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dst_len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dst_len--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dst_len &gt;= src_len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dst_len = src_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ensure truncation is encoding-safe */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dst_len = <a href="../mb/mbutils.c.html#L1083" title="utils/mb/mbutils.c:1083">pg_mbcliplen</a>(VARDATA_ANY(srcunpacked), src_len, dst_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(dst, VARDATA_ANY(srcunpacked), dst_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dst[dst_len] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (srcunpacked != src)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(srcunpacked);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; USER I/O ROUTINES&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L275">&#x200c;</a><span class="PreProc">#define <span class="linkable">VAL</span>(CH)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((CH) - </span><span class="Constant">'0'</span><span class="PreProc">)<br/></li>
<li><a id="L276">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DIG</span>(<a href="encode.c.html#L411" title="utils/adt/encode.c:411">VAL</a>)&nbsp; &nbsp; &nbsp; &nbsp; ((<a href="encode.c.html#L411" title="utils/adt/encode.c:411">VAL</a>) + </span><span class="Constant">'0'</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L290" title="utils/adt/varlena.c:290">byteain</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts from printable representation of byte array<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Non-printable characters must be passed as '\nnn' (octal) and are<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; converted to <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> form.&nbsp; '\' must be passed as '\\'.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR, ...) if bad form.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; BUGS:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The input is scanned twice.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The error checking of input is minimal.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L290">&#x200c;</a><span class="linkable">byteain</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *inputText = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *rp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bc;<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Recognize hex input */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (inputText[<span class="Constant">0</span>] == <span class="Special">'\\'</span> &amp;&amp; inputText[<span class="Constant">1</span>] == <span class="Constant">'x'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len = strlen(inputText);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bc = (len - <span class="Constant">2</span>) / <span class="Constant">2</span> + VARHDRSZ;&nbsp; &nbsp; <span class="Comment">/* maximum possible length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(bc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bc = <a href="encode.c.html#L196" title="utils/adt/encode.c:196">hex_decode_safe</a>(inputText + <span class="Constant">2</span>, len - <span class="Constant">2</span>, VARDATA(result),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; escontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(result, bc + VARHDRSZ); <span class="Comment">/* actual length */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BYTEA_P(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else, it's the traditional escaped style */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (bc = <span class="Constant">0</span>, tp = inputText; *tp != <span class="Special">'\0'</span>; bc++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tp[<span class="Constant">0</span>] != <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((tp[<span class="Constant">0</span>] == <span class="Special">'\\'</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (tp[<span class="Constant">1</span>] &gt;= <span class="Constant">'0'</span> &amp;&amp; tp[<span class="Constant">1</span>] &lt;= <span class="Constant">'3'</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (tp[<span class="Constant">2</span>] &gt;= <span class="Constant">'0'</span> &amp;&amp; tp[<span class="Constant">2</span>] &lt;= <span class="Constant">'7'</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (tp[<span class="Constant">3</span>] &gt;= <span class="Constant">'0'</span> &amp;&amp; tp[<span class="Constant">3</span>] &lt;= <span class="Constant">'7'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tp += <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((tp[<span class="Constant">0</span>] == <span class="Special">'\\'</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (tp[<span class="Constant">1</span>] == <span class="Special">'\\'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tp += <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one backslash, not followed by another or ### valid octal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;bytea&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bc += VARHDRSZ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (bytea *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(bc);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, bc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = inputText;<br/></li>
<li>&nbsp; &nbsp; rp = VARDATA(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (*tp != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tp[<span class="Constant">0</span>] != <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rp++ = *tp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((tp[<span class="Constant">0</span>] == <span class="Special">'\\'</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (tp[<span class="Constant">1</span>] &gt;= <span class="Constant">'0'</span> &amp;&amp; tp[<span class="Constant">1</span>] &lt;= <span class="Constant">'3'</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (tp[<span class="Constant">2</span>] &gt;= <span class="Constant">'0'</span> &amp;&amp; tp[<span class="Constant">2</span>] &lt;= <span class="Constant">'7'</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (tp[<span class="Constant">3</span>] &gt;= <span class="Constant">'0'</span> &amp;&amp; tp[<span class="Constant">3</span>] &lt;= <span class="Constant">'7'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bc = <a href="encode.c.html#L411" title="utils/adt/encode.c:411">VAL</a>(tp[<span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bc &lt;&lt;= <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bc += <a href="encode.c.html#L411" title="utils/adt/encode.c:411">VAL</a>(tp[<span class="Constant">2</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bc &lt;&lt;= <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rp++ = bc + <a href="encode.c.html#L411" title="utils/adt/encode.c:411">VAL</a>(tp[<span class="Constant">3</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tp += <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((tp[<span class="Constant">0</span>] == <span class="Special">'\\'</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (tp[<span class="Constant">1</span>] == <span class="Special">'\\'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rp++ = <span class="Special">'\\'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tp += <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should never get here. The first pass should not allow it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;bytea&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L388" title="utils/adt/varlena.c:388">byteaout</a>&nbsp; &nbsp; &nbsp; &nbsp; - converts to printable representation of byte array<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; In the traditional escaped format, non-printable characters are<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; printed as '\nnn' (octal) and '\' as '\\'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L388">&#x200c;</a><span class="linkable">byteaout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *vlena = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *rp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L48" title="utils/adt/varlena.c:48">bytea_output</a> == BYTEA_OUTPUT_HEX)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Print hex format */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rp = result = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(VARSIZE_ANY_EXHDR(vlena) * <span class="Constant">2</span> + <span class="Constant">2</span> + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *rp++ = <span class="Special">'\\'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *rp++ = <span class="Constant">'x'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rp += <a href="encode.c.html#L162" title="utils/adt/encode.c:162">hex_encode</a>(VARDATA_ANY(vlena), VARSIZE_ANY_EXHDR(vlena), rp);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L48" title="utils/adt/varlena.c:48">bytea_output</a> == BYTEA_OUTPUT_ESCAPE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Print traditional escaped format */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *vp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* empty string has 1 char */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; vp = VARDATA_ANY(vlena);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = VARSIZE_ANY_EXHDR(vlena); i != <span class="Constant">0</span>; i--, vp++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*vp == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len += <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((<span class="Type">unsigned</span> <span class="Type">char</span>) *vp &lt; <span class="Constant">0x20</span> || (<span class="Type">unsigned</span> <span class="Type">char</span>) *vp &gt; <span class="Constant">0x7e</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len += <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In principle len can't overflow uint32 if the input fit in 1GB, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for safety let's check rather than relying on <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'s <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len &gt; MaxAllocSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;result of bytea output conversion is too large&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rp = result = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vp = VARDATA_ANY(vlena);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = VARSIZE_ANY_EXHDR(vlena); i != <span class="Constant">0</span>; i--, vp++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*vp == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rp++ = <span class="Special">'\\'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rp++ = <span class="Special">'\\'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((<span class="Type">unsigned</span> <span class="Type">char</span>) *vp &lt; <span class="Constant">0x20</span> || (<span class="Type">unsigned</span> <span class="Type">char</span>) *vp &gt; <span class="Constant">0x7e</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;&nbsp; &nbsp; <span class="Comment">/* holds unprintable chars */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = *vp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rp[<span class="Constant">0</span>] = <span class="Special">'\\'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rp[<span class="Constant">3</span>] = <a href="encode.c.html#L412" title="utils/adt/encode.c:412">DIG</a>(val &amp; <span class="PreProc">0</span><span class="Constant">7</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val &gt;&gt;= <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rp[<span class="Constant">2</span>] = <a href="encode.c.html#L412" title="utils/adt/encode.c:412">DIG</a>(val &amp; <span class="PreProc">0</span><span class="Constant">7</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val &gt;&gt;= <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rp[<span class="Constant">1</span>] = <a href="encode.c.html#L412" title="utils/adt/encode.c:412">DIG</a>(val &amp; <span class="PreProc">0</span><span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rp += <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rp++ = *vp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized <a href="#L48" title="utils/adt/varlena.c:48">bytea_output</a> setting: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L48" title="utils/adt/varlena.c:48">bytea_output</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rp = result = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *rp = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L471" title="utils/adt/varlena.c:471">bytearecv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to bytea<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L471">&#x200c;</a><span class="linkable">bytearecv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nbytes = buf-&gt;len - buf-&gt;cursor;<br/></li>
<li>&nbsp; &nbsp; result = (bytea *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nbytes + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, nbytes + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L528" title="libpq/pqformat.c:528">pq_copymsgbytes</a>(buf, VARDATA(result), nbytes);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L490" title="utils/adt/varlena.c:490">byteasend</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts bytea to binary format<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a special case: just copy the input...<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L490">&#x200c;</a><span class="linkable">byteasend</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *vlena = PG_GETARG_BYTEA_P_COPY(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(vlena);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L498">&#x200c;</a><span class="linkable">bytea_string_agg_transfn</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Append the value unless null, preceding it with the delimiter. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *value = PG_GETARG_BYTEA_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isfirst = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * You might think we can just throw away the first delimiter, however<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we must keep it as we may be a parallel worker doing partial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aggregation building a state to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> to the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> process.&nbsp; We need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to keep the delimiter of every aggregation so that the <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function can properly join up the strings of two separately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partially aggregated results.&nbsp; The first delimiter is only stripped<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * off in the final function.&nbsp; To know how much to strip off the front<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the string, we store the length of the first delimiter in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * StringInfo's cursor field, which we don't otherwise need here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state = <a href="#L5162" title="utils/adt/varlena.c:5162">makeStringAggState</a>(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isfirst = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">2</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *delim = PG_GETARG_BYTEA_PP(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(state, VARDATA_ANY(delim),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(delim));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isfirst)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;cursor = VARSIZE_ANY_EXHDR(delim);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(state, VARDATA_ANY(value),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(value));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The transition type for string_agg() is declared to be &quot;<a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>&quot;,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which is a pass-by-value type the same size as a pointer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(state);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L551">&#x200c;</a><span class="linkable">bytea_string_agg_finalfn</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cannot be called directly because of <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>-type argument */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* As per comment in transfn, strip data <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the cursor position */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strippedlen = state-&gt;len - state-&gt;cursor;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (bytea *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(strippedlen + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(result, strippedlen + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(VARDATA(result), &amp;state-&gt;data[state-&gt;cursor], strippedlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BYTEA_P(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L579" title="utils/adt/varlena.c:579">textin</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts cstring to <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> representation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L579">&#x200c;</a><span class="linkable">textin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *inputText = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(inputText));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L590" title="utils/adt/varlena.c:590">textout</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> representation to cstring<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L590">&#x200c;</a><span class="linkable">textout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; txt = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(TextDatumGetCString(txt));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L601" title="utils/adt/varlena.c:601">textrecv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to text<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L601">&#x200c;</a><span class="linkable">textrecv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; str = <a href="../../libpq/pqformat.c.html#L546" title="libpq/pqformat.c:546">pq_getmsgtext</a>(buf, buf-&gt;len - buf-&gt;cursor, &amp;nbytes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(str, nbytes);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(str);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L619" title="utils/adt/varlena.c:619">textsend</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts text to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L619">&#x200c;</a><span class="linkable">textsend</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *t = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L172" title="libpq/pqformat.c:172">pq_sendtext</a>(&amp;buf, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L634" title="utils/adt/varlena.c:634">unknownin</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts cstring to <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> representation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L634">&#x200c;</a><span class="linkable">unknownin</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* representation is same as cstring */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_CSTRING(<a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(str));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L646" title="utils/adt/varlena.c:646">unknownout</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> representation to cstring<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L646">&#x200c;</a><span class="linkable">unknownout</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* representation is same as cstring */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(<a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(str));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L658" title="utils/adt/varlena.c:658">unknownrecv</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts external binary format to unknown<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L658">&#x200c;</a><span class="linkable">unknownrecv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; str = <a href="../../libpq/pqformat.c.html#L546" title="libpq/pqformat.c:546">pq_getmsgtext</a>(buf, buf-&gt;len - buf-&gt;cursor, &amp;nbytes);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* representation is same as cstring */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_CSTRING(str);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L673" title="utils/adt/varlena.c:673">unknownsend</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts unknown to binary format<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L673">&#x200c;</a><span class="linkable">unknownsend</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* representation is same as cstring */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L172" title="libpq/pqformat.c:172">pq_sendtext</a>(&amp;buf, str, strlen(str));<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ========== PUBLIC ROUTINES ========== */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L693" title="utils/adt/varlena.c:693">textlen</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; returns the logical length of a text*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; (which is less than the VARSIZE of the text*)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L693">&#x200c;</a><span class="linkable">textlen</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; str = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* try to avoid decompressing argument */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L711" title="utils/adt/varlena.c:711">text_length</a>(str));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L711" title="utils/adt/varlena.c:711">text_length</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Does the real work for <a href="#L693" title="utils/adt/varlena.c:693">textlen</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This is broken out so it can be called directly by other string processing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; Note that the argument is passed as a Datum, to indicate that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; it may still be in compressed form.&nbsp; We can avoid decompressing it at all<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; in some cases.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> int32<br/></li>
<li><a id="L711">&#x200c;</a><span class="linkable">text_length</span>(Datum str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fastpath when max encoding length is one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../mb/mbutils.c.html#L1546" title="utils/mb/mbutils.c:1546">pg_database_encoding_max_length</a>() == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32(<a href="../../access/common/detoast.c.html#L545" title="access/common/detoast.c:545">toast_raw_datum_size</a>(str) - VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *t = DatumGetTextPP(str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32(<a href="../mb/mbutils.c.html#L1057" title="utils/mb/mbutils.c:1057">pg_mbstrlen_with_len</a>(VARDATA_ANY(t),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(t)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L731" title="utils/adt/varlena.c:731">textoctetlen</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; returns the physical length of a text*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; (which is less than the VARSIZE of the text*)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L731">&#x200c;</a><span class="linkable">textoctetlen</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; str = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We need not detoast the input at all */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_INT32(<a href="../../access/common/detoast.c.html#L545" title="access/common/detoast.c:545">toast_raw_datum_size</a>(str) - VARHDRSZ);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L750" title="utils/adt/varlena.c:750">textcat</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; takes two text* and returns a text* that is the concatenation of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the two.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Rewritten by Sapa, sapa@hq.icb.chel.su. 8-Jul-96.<br/></li>
<li></span><span class="Comment"> * Updated by Thomas, Thomas.Lockhart@jpl.nasa.gov 1997-07-10.<br/></li>
<li></span><span class="Comment"> * Allocate space for output in all cases.<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> - thomas 1997-07-10<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L750">&#x200c;</a><span class="linkable">textcat</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *t1 = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *t2 = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L765" title="utils/adt/varlena.c:765">text_catenate</a>(t1, t2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L765" title="utils/adt/varlena.c:765">text_catenate</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Guts of <a href="#L750" title="utils/adt/varlena.c:750">textcat</a>(), broken out so it can be used by other <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Arguments can be in short-header form, but not compressed or out-of-line<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> text *<br/></li>
<li><a id="L765">&#x200c;</a><span class="linkable">text_catenate</span>(text *t1, text *t2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = VARSIZE_ANY_EXHDR(t1);<br/></li>
<li>&nbsp; &nbsp; len2 = VARSIZE_ANY_EXHDR(t2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* paranoia ... probably should throw error instead? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (len1 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len1 = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len2 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len2 = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = len1 + len2 + VARHDRSZ;<br/></li>
<li>&nbsp; &nbsp; result = (text *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set size of result string... */<br/></li>
<li></span>&nbsp; &nbsp; SET_VARSIZE(result, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fill data field of result string... */<br/></li>
<li></span>&nbsp; &nbsp; ptr = VARDATA(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len1 &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, VARDATA_ANY(t1), len1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len2 &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr + len1, VARDATA_ANY(t2), len2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L806" title="utils/adt/varlena.c:806">charlen_to_bytelen</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Compute the number of bytes occupied by n characters starting at *p<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is caller's responsibility that there actually are n characters;<br/></li>
<li></span><span class="Comment"> * the string need not be null-terminated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L806">&#x200c;</a></span><span class="linkable">charlen_to_bytelen</span>(<span class="Type">const</span> <span class="Type">char</span> *p, <span class="Type">int</span> n)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../mb/mbutils.c.html#L1546" title="utils/mb/mbutils.c:1546">pg_database_encoding_max_length</a>() == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Optimization for single-byte encodings */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> n;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (s = p; n &gt; <span class="Constant">0</span>; n--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s += <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(s);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> s - p;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L852" title="utils/adt/varlena.c:852">text_substr</a>()<br/></li>
<li></span><span class="Comment"> * Return a substring starting at the specified position.<br/></li>
<li></span><span class="Comment"> * - thomas 1997-12-31<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Input:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; - string<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; - starting position (is one-based)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; - string length<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the starting position is zero or less, then return from the start of the string<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; adjusting the length to be consistent with the &quot;negative start&quot; per SQL.<br/></li>
<li></span><span class="Comment"> * If the length is less than zero, return the remaining string.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Added multibyte support.<br/></li>
<li></span><span class="Comment"> * - Tatsuo Ishii 1998-4-21<br/></li>
<li></span><span class="Comment"> * Changed behavior if starting position is less than one to conform to SQL behavior.<br/></li>
<li></span><span class="Comment"> * Formerly returned the entire string; <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> returns a portion.<br/></li>
<li></span><span class="Comment"> * - Thomas Lockhart 1998-12-10<br/></li>
<li></span><span class="Comment"> * Now uses faster TOAST-slicing interface<br/></li>
<li></span><span class="Comment"> * - John Gray 2002-02-22<br/></li>
<li></span><span class="Comment"> * Remove &quot;#ifdef MULTIBYTE&quot; and test for encoding_max_length instead. Change<br/></li>
<li></span><span class="Comment"> * behaviors conflicting with SQL to meet SQL (if E = S + L &lt; S throw<br/></li>
<li></span><span class="Comment"> * error; if E &lt; 1, return '', not entire string). Fixed MB related bug when<br/></li>
<li></span><span class="Comment"> * S &gt; LC and &lt; LC + 4 sometimes garbage characters are returned.<br/></li>
<li></span><span class="Comment"> * - Joe Conway 2002-08-10<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L852">&#x200c;</a><span class="linkable">text_substr</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L885" title="utils/adt/varlena.c:885">text_substring</a>(PG_GETARG_DATUM(<span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GETARG_INT32(<span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GETARG_INT32(<span class="Constant">2</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L866" title="utils/adt/varlena.c:866">text_substr_no_len</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Wrapper to avoid opr_sanity failure due to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; one function accepting a different number of args.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L866">&#x200c;</a><span class="linkable">text_substr_no_len</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L885" title="utils/adt/varlena.c:885">text_substring</a>(PG_GETARG_DATUM(<span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GETARG_INT32(<span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>, <span class="Constant">true</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L885" title="utils/adt/varlena.c:885">text_substring</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Does the real work for <a href="#L852" title="utils/adt/varlena.c:852">text_substr</a>() and <a href="#L866" title="utils/adt/varlena.c:866">text_substr_no_len</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This is broken out so it can be called directly by other string processing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; Note that the argument is passed as a Datum, to indicate that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; it may still be in compressed/toasted form.&nbsp; We can avoid detoasting all<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; of it in some cases.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The result is always a freshly <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d datum.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> text *<br/></li>
<li><a id="L885">&#x200c;</a><span class="linkable">text_substring</span>(Datum str, int32 start, int32 length, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> length_not_specified)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; eml = <a href="../mb/mbutils.c.html#L1546" title="utils/mb/mbutils.c:1546">pg_database_encoding_max_length</a>();<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; S = start;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* start position */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; S1;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* adjusted start position */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; L1;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* adjusted substring length */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; E;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end position */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SQL99 says S can be zero or negative (which we don't document), but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * still must fetch from the start of the string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * https://www.postgresql.org/message-id/170905442373.643.11536838320909376197%40wrigleys.postgresql.org<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; S1 = Max(S, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* life is easy if the encoding max length is 1 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (eml == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (length_not_specified)&nbsp; &nbsp; <span class="Comment">/* special case - get length to end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L1 = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (length &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SQL99 says to throw an error for E &lt; S, i.e., negative length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SUBSTRING_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;negative substring length not allowed&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L1 = -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* silence stupider compilers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_add_s32_overflow(S, length, &amp;E))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * L could be large enough for S + L to overflow, in which case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the substring must run to end of string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L1 = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A zero or negative value for the end position can happen if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * start was negative or one. SQL99 says to return a zero-length<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (E &lt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(<span class="Constant">&quot;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L1 = E - S1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the start position is past the end of the string, SQL99 says to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * return a zero-length string -- DatumGetTextPSlice() will do that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for us.&nbsp; We need only convert S1 to zero-based starting position.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DatumGetTextPSlice(str, S1 - <span class="Constant">1</span>, L1);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (eml &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When encoding max length is &gt; 1, we can't get LC without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * detoasting, so we'll grab a conservatively large slice <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> and go<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * back later to do the right thing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; slice_start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; slice_size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; slice_strlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *slice;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; E1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to start at position zero because there is no way to know<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in advance which byte offset corresponds to the supplied start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * position.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; slice_start = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (length_not_specified)&nbsp; &nbsp; <span class="Comment">/* special case - get length to end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slice_size = L1 = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (length &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SQL99 says to throw an error for E &lt; S, i.e., negative length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SUBSTRING_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;negative substring length not allowed&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slice_size = L1 = -<span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* silence stupider compilers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_add_s32_overflow(S, length, &amp;E))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * L could be large enough for S + L to overflow, in which case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the substring must run to end of string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slice_size = L1 = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A zero or negative value for the end position can happen if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * start was negative or one. SQL99 says to return a zero-length<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (E &lt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(<span class="Constant">&quot;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if E is past the end of the string, the tuple toaster will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * truncate the length for us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L1 = E - S1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Total slice size in bytes can't be <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> longer than the start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * position plus substring length times the encoding max length.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If that overflows, we can just use -1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_mul_s32_overflow(E, eml, &amp;slice_size))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slice_size = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're working with an untoasted source, no need to do an extra<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * copying step.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_COMPRESSED(DatumGetPointer(str)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARATT_IS_EXTERNAL(DatumGetPointer(str)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slice = DatumGetTextPSlice(str, slice_start, slice_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slice = (text *) DatumGetPointer(str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see if we got back an empty string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VARSIZE_ANY_EXHDR(slice) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slice != (text *) DatumGetPointer(str))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(slice);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(<span class="Constant">&quot;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now we can get the actual length of the slice in MB characters */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; slice_strlen = <a href="../mb/mbutils.c.html#L1057" title="utils/mb/mbutils.c:1057">pg_mbstrlen_with_len</a>(VARDATA_ANY(slice),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARSIZE_ANY_EXHDR(slice));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check that the start position wasn't &gt; slice_strlen. If so, SQL99<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * says to return a zero-length string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (S1 &gt; slice_strlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slice != (text *) DatumGetPointer(str))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(slice);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(<span class="Constant">&quot;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Adjust L1 and E1 <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that we know the slice string length. Again<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remember that S1 is one based, and slice_start is zero based.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (L1 &gt; -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; E1 = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(S1 + L1, slice_start + <span class="Constant">1</span> + slice_strlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; E1 = slice_start + <span class="Constant">1</span> + slice_strlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find the start position in the slice; remember S1 is not zero based<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; p = VARDATA_ANY(slice);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; S1 - <span class="Constant">1</span>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p += <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* hang onto a pointer to our start position */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; s = p;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Count the actual bytes used by the substring of the requested<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * length.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = S1; i &lt; E1; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p += <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ret = (text *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(VARHDRSZ + (p - s));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(ret, VARHDRSZ + (p - s));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(VARDATA(ret), s, (p - s));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slice != (text *) DatumGetPointer(str))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(slice);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid backend encoding: encoding max length &lt; 1&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* not reached: suppress compiler warning */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1093" title="utils/adt/varlena.c:1093">textoverlay</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Replace specified substring of first string with second<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The SQL standard defines OVERLAY() in terms of substring and concatenation.<br/></li>
<li></span><span class="Comment"> * This code is a direct implementation of what the standard says.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1093">&#x200c;</a><span class="linkable">textoverlay</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *t1 = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *t2 = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sp = PG_GETARG_INT32(<span class="Constant">2</span>);&nbsp; &nbsp; <span class="Comment">/* substring start position */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sl = PG_GETARG_INT32(<span class="Constant">3</span>);&nbsp; &nbsp; <span class="Comment">/* substring length */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L1116" title="utils/adt/varlena.c:1116">text_overlay</a>(t1, t2, sp, sl));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1104">&#x200c;</a><span class="linkable">textoverlay_no_len</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *t1 = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *t2 = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sp = PG_GETARG_INT32(<span class="Constant">2</span>);&nbsp; &nbsp; <span class="Comment">/* substring start position */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sl = <a href="#L711" title="utils/adt/varlena.c:711">text_length</a>(PointerGetDatum(t2));&nbsp; &nbsp; <span class="Comment">/* defaults to length(t2) */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L1116" title="utils/adt/varlena.c:1116">text_overlay</a>(t1, t2, sp, sl));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> text *<br/></li>
<li><a id="L1116">&#x200c;</a><span class="linkable">text_overlay</span>(text *t1, text *t2, <span class="Type">int</span> sp, <span class="Type">int</span> sl)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *s1;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *s2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sp_pl_sl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for possible integer-overflow cases.&nbsp; For negative sp, throw a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;substring length&quot; error because that's what should be expected<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * according to the spec's definition of OVERLAY().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sp &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SUBSTRING_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;negative substring length not allowed&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_add_s32_overflow(sp, sl, &amp;sp_pl_sl))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;integer out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s1 = <a href="#L885" title="utils/adt/varlena.c:885">text_substring</a>(PointerGetDatum(t1), <span class="Constant">1</span>, sp - <span class="Constant">1</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; s2 = <a href="#L885" title="utils/adt/varlena.c:885">text_substring</a>(PointerGetDatum(t1), sp_pl_sl, -<span class="Constant">1</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; result = <a href="#L765" title="utils/adt/varlena.c:765">text_catenate</a>(s1, t2);<br/></li>
<li>&nbsp; &nbsp; result = <a href="#L765" title="utils/adt/varlena.c:765">text_catenate</a>(result, s2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1153" title="utils/adt/varlena.c:1153">textpos</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Return the position of the specified substring.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Implements the SQL POSITION() function.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Ref: A Guide To The SQL Standard, Date &amp; Darwen, 1997<br/></li>
<li></span><span class="Comment"> * - thomas 1997-07-27<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1153">&#x200c;</a><span class="linkable">textpos</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *search_str = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32((int32) <a href="#L1176" title="utils/adt/varlena.c:1176">text_position</a>(str, search_str, PG_GET_COLLATION()));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1176" title="utils/adt/varlena.c:1176">text_position</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Does the real work for <a href="#L1153" title="utils/adt/varlena.c:1153">textpos</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Inputs:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; t1 - string to be searched<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; t2 - pattern to match within t1<br/></li>
<li></span><span class="Comment"> * Result:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Character index of the first matched char, starting from 1,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; or 0 if no match.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This is broken out so it can be called directly by other string processing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1176">&#x200c;</a></span><span class="linkable">text_position</span>(text *t1, text *t2, Oid collid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="utils/adt/varlena.c:78">TextPositionState</a> state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Empty needle always matches at position 1 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (VARSIZE_ANY_EXHDR(t2) &lt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise, can't match if haystack is shorter than needle */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (VARSIZE_ANY_EXHDR(t1) &lt; VARSIZE_ANY_EXHDR(t2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1216" title="utils/adt/varlena.c:1216">text_position_setup</a>(t1, t2, collid, &amp;state);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1336" title="utils/adt/varlena.c:1336">text_position_next</a>(&amp;state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1479" title="utils/adt/varlena.c:1479">text_position_get_match_pos</a>(&amp;state);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1503" title="utils/adt/varlena.c:1503">text_position_cleanup</a>(&amp;state);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1216" title="utils/adt/varlena.c:1216">text_position_setup</a>, <a href="#L1336" title="utils/adt/varlena.c:1336">text_position_next</a>, <a href="#L1503" title="utils/adt/varlena.c:1503">text_position_cleanup</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Component steps of <a href="#L1176" title="utils/adt/varlena.c:1176">text_position</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These are broken out so that a string can be efficiently searched for<br/></li>
<li></span><span class="Comment"> * multiple occurrences of the same pattern.&nbsp; <a href="#L1336" title="utils/adt/varlena.c:1336">text_position_next</a> may be<br/></li>
<li></span><span class="Comment"> * called multiple times, and it advances to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> match on each call.<br/></li>
<li></span><span class="Comment"> * <a href="#L1468" title="utils/adt/varlena.c:1468">text_position_get_match_ptr</a>() and <a href="#L1479" title="utils/adt/varlena.c:1479">text_position_get_match_pos</a>() return<br/></li>
<li></span><span class="Comment"> * a pointer or 1-based character position of the last match, respectively.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The &quot;state&quot; variable is normally just a local variable in the caller.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: <a href="#L1336" title="utils/adt/varlena.c:1336">text_position_next</a> skips over the matched portion.&nbsp; For example,<br/></li>
<li></span><span class="Comment"> * searching for &quot;xx&quot; in &quot;xxx&quot; returns only one match, not two.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1216">&#x200c;</a></span><span class="linkable">text_position_setup</span>(text *t1, text *t2, Oid collid, <a href="#L78" title="utils/adt/varlena.c:78">TextPositionState</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1 = VARSIZE_ANY_EXHDR(t1);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2 = VARSIZE_ANY_EXHDR(t2);<br/></li>
<li>&nbsp; &nbsp; pg_locale_t mylocale = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="varchar.c.html#L727" title="utils/adt/varchar.c:727">check_collation_set</a>(collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="pg_locale.c.html#L1317" title="utils/adt/pg_locale.c:1317">lc_collate_is_c</a>(collid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mylocale = <a href="pg_locale.c.html#L1551" title="utils/adt/pg_locale.c:1551">pg_newlocale_from_collation</a>(collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="pg_locale.c.html#L1531" title="utils/adt/pg_locale.c:1531">pg_locale_deterministic</a>(mylocale))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;nondeterministic collations are not supported for substring searches&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(len1 &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(len2 &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Even with a multi-byte encoding, we perform the search using the raw<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * byte sequence, ignoring multibyte issues.&nbsp; For UTF-8, that works fine,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because in UTF-8 the byte sequence of one character cannot contain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * another character.&nbsp; For other multi-byte encodings, we do the search<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initially as a simple byte search, ignoring multibyte issues, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * verify afterwards that the match we found is at a character boundary,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and continue the search if it was a false match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../mb/mbutils.c.html#L1546" title="utils/mb/mbutils.c:1546">pg_database_encoding_max_length</a>() == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;is_multibyte_char_in_char = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>() == PG_UTF8)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;is_multibyte_char_in_char = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;is_multibyte_char_in_char = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;str1 = VARDATA_ANY(t1);<br/></li>
<li>&nbsp; &nbsp; state-&gt;str2 = VARDATA_ANY(t2);<br/></li>
<li>&nbsp; &nbsp; state-&gt;len1 = len1;<br/></li>
<li>&nbsp; &nbsp; state-&gt;len2 = len2;<br/></li>
<li>&nbsp; &nbsp; state-&gt;last_match = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;refpoint = state-&gt;str1;<br/></li>
<li>&nbsp; &nbsp; state-&gt;refpos = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare the <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> table for Boyer-Moore-Horspool searching.&nbsp; In these<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * notes we use the terminology that the &quot;haystack&quot; is the string to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * searched (t1) and the &quot;needle&quot; is the pattern being sought (t2).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the needle is empty or bigger than the haystack then there is no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * point in wasting cycles initializing the table.&nbsp; We also choose not to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use B-M-H for needles of length 1, since the <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> table can't possibly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * save anything in that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (len1 &gt;= len2 &amp;&amp; len2 &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; searchlength = len1 - len2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skiptablemask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *str2 = state-&gt;str2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First we must determine how much of the <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> table to use.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * declaration of <a href="#L78" title="utils/adt/varlena.c:78">TextPositionState</a> allows up to 256 elements, but for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * short search problems we don't really want to have to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * many elements --- it would take too long in comparison to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * actual search time.&nbsp; So we choose a useful <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> table size based on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the haystack length minus the needle length.&nbsp; The closer the needle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * length is to the haystack length the less useful skipping becomes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: since we use <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>-masking to <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> table elements, the <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * table size MUST be a power of 2, and so the mask must be 2^N-1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (searchlength &lt; <span class="Constant">16</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skiptablemask = <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (searchlength &lt; <span class="Constant">64</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skiptablemask = <span class="Constant">7</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (searchlength &lt; <span class="Constant">128</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skiptablemask = <span class="Constant">15</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (searchlength &lt; <span class="Constant">512</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skiptablemask = <span class="Constant">31</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (searchlength &lt; <span class="Constant">2048</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skiptablemask = <span class="Constant">63</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (searchlength &lt; <span class="Constant">4096</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skiptablemask = <span class="Constant">127</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skiptablemask = <span class="Constant">255</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;skiptablemask = skiptablemask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Initialize the <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> table.&nbsp; We set all elements to the needle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * length, since this is the correct <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> distance for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> character<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not found in the needle.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt;= skiptablemask; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;skiptable[i] = len2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now examine the needle.&nbsp; For each character except the last one,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set the corresponding table <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> to the appropriate <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * distance.&nbsp; Note that when two characters share the same <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry, the one later in the needle must determine the <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * distance.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; last = len2 - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; last; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;skiptable[(<span class="Type">unsigned</span> <span class="Type">char</span>) str2[i] &amp; skiptablemask] = last - i;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Advance to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> match, starting from the end of the previous match<br/></li>
<li></span><span class="Comment"> * (or the beginning of the string, on first call).&nbsp; Returns true if a match<br/></li>
<li></span><span class="Comment"> * is found.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this refuses to match an empty-string needle.&nbsp; Most callers<br/></li>
<li></span><span class="Comment"> * will have handled that case specially and we'll never see it here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1336">&#x200c;</a></span><span class="linkable">text_position_next</span>(<a href="#L78" title="utils/adt/varlena.c:78">TextPositionState</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needle_len = state-&gt;len2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *start_ptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *matchptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (needle_len &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* result for empty pattern */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Start from the point right after the previous match. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;last_match)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; start_ptr = state-&gt;last_match + needle_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; start_ptr = state-&gt;str1;<br/></li>
<li><br/></li>
<li><span class="Statement">retry</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; matchptr = <a href="#L1400" title="utils/adt/varlena.c:1400">text_position_next_internal</a>(start_ptr, state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!matchptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Found a match for the byte sequence.&nbsp; If this is a multibyte encoding,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where one character's byte sequence can appear inside a longer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multi-byte character, we need to verify that the match was at a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * character boundary, not in the middle of a multi-byte character.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;is_multibyte_char_in_char)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Walk one character at a time, until we reach the match. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the search should never move backwards. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;refpoint &lt;= matchptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (state-&gt;refpoint &lt; matchptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* step to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> character. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;refpoint += <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(state-&gt;refpoint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;refpos++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we stepped over the match's start position, then it was a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * false positive, where the byte sequence appeared in the middle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of a multi-byte character.&nbsp; Skip it, and continue the search at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> character boundary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;refpoint &gt; matchptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start_ptr = state-&gt;refpoint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> retry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;last_match = matchptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine of <a href="#L1336" title="utils/adt/varlena.c:1336">text_position_next</a>().&nbsp; This searches for the raw byte<br/></li>
<li></span><span class="Comment"> * sequence, ignoring <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> multi-byte encoding issues.&nbsp; Returns the first<br/></li>
<li></span><span class="Comment"> * match starting at 'start_ptr', or NULL if no match is found.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1400">&#x200c;</a><span class="linkable">text_position_next_internal</span>(<span class="Type">char</span> *start_ptr, <a href="#L78" title="utils/adt/varlena.c:78">TextPositionState</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; haystack_len = state-&gt;len1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needle_len = state-&gt;len2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skiptablemask = state-&gt;skiptablemask;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *haystack = state-&gt;str1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *needle = state-&gt;str2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *haystack_end = &amp;haystack[haystack_len];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *hptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(start_ptr &gt;= haystack &amp;&amp; start_ptr &lt;= haystack_end);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (needle_len == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No point in using B-M-H for a one-character needle */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; nchar = *needle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hptr = start_ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (hptr &lt; haystack_end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*hptr == nchar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">char</span> *) hptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hptr++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *needle_last = &amp;needle[needle_len - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Start at startpos plus the length of the needle */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hptr = start_ptr + needle_len - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (hptr &lt; haystack_end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Match the needle scanning *backward* */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *nptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *p;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nptr = needle_last;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = hptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (*nptr == *p)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Matched it all?&nbsp; &nbsp; If so, return 1-based position */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nptr == needle)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">char</span> *) p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nptr--, p--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No match, so use the haystack char at hptr to decide how far to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * advance.&nbsp; If the needle had <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> occurrence of that character<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (or more precisely, one sharing the same skiptable entry)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> its last character, then we advance far enough to align<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the last such needle character with that haystack position.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise we can advance by the whole needle length.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hptr += state-&gt;skiptable[(<span class="Type">unsigned</span> <span class="Type">char</span>) *hptr &amp; skiptablemask];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not found */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return a pointer to the current match.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned pointer points into the original haystack string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1468">&#x200c;</a><span class="linkable">text_position_get_match_ptr</span>(<a href="#L78" title="utils/adt/varlena.c:78">TextPositionState</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state-&gt;last_match;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the offset of the current match.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The offset is in characters, 1-based.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1479">&#x200c;</a></span><span class="linkable">text_position_get_match_pos</span>(<a href="#L78" title="utils/adt/varlena.c:78">TextPositionState</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert the byte position to char position. */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;refpos += <a href="../mb/mbutils.c.html#L1057" title="utils/mb/mbutils.c:1057">pg_mbstrlen_with_len</a>(state-&gt;refpoint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;last_match - state-&gt;refpoint);<br/></li>
<li>&nbsp; &nbsp; state-&gt;refpoint = state-&gt;last_match;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state-&gt;refpos + <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reset search state to the initial state installed by <a href="#L1216" title="utils/adt/varlena.c:1216">text_position_setup</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call to <a href="#L1336" title="utils/adt/varlena.c:1336">text_position_next</a> will search from the beginning<br/></li>
<li></span><span class="Comment"> * of the string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1495">&#x200c;</a></span><span class="linkable">text_position_reset</span>(<a href="#L78" title="utils/adt/varlena.c:78">TextPositionState</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; state-&gt;last_match = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;refpoint = state-&gt;str1;<br/></li>
<li>&nbsp; &nbsp; state-&gt;refpos = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1503">&#x200c;</a></span><span class="linkable">text_position_cleanup</span>(<a href="#L78" title="utils/adt/varlena.c:78">TextPositionState</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> needed */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1510">&#x200c;</a></span><span class="linkable">check_collation_set</span>(Oid collid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(collid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This typically means that the parser could not resolve a conflict<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of implicit collations, so report it that way.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDETERMINATE_COLLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not determine which collation to use for string comparison&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use the COLLATE clause to set the collation explicitly.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1539" title="utils/adt/varlena.c:1539">varstr_cmp</a>()<br/></li>
<li></span><span class="Comment"> * Comparison function for text strings with given lengths.<br/></li>
<li></span><span class="Comment"> * Includes locale support, but must copy strings to temporary memory<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; to allow null-termination for inputs to strcoll().<br/></li>
<li></span><span class="Comment"> * Returns an integer less than, <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to, or greater than zero, indicating<br/></li>
<li></span><span class="Comment"> * whether arg1 is less than, <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to, or greater than arg2.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: many <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that depend on this are marked leakproof; therefore,<br/></li>
<li></span><span class="Comment"> * avoid reporting the actual contents of the input when throwing errors.<br/></li>
<li></span><span class="Comment"> * All errors herein should be things that can't happen except on corrupt<br/></li>
<li></span><span class="Comment"> * data, anyway; otherwise we will have trouble with indexing strings that<br/></li>
<li></span><span class="Comment"> * would cause them.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1539">&#x200c;</a></span><span class="linkable">varstr_cmp</span>(<span class="Type">const</span> <span class="Type">char</span> *arg1, <span class="Type">int</span> len1, <span class="Type">const</span> <span class="Type">char</span> *arg2, <span class="Type">int</span> len2, Oid collid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="varchar.c.html#L727" title="utils/adt/varchar.c:727">check_collation_set</a>(collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unfortunately, there is no strncoll(), so in the non-C locale case we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have to do some memory copying.&nbsp; This turns out to be significantly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slower, so we <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> the case where LC_COLLATE is C.&nbsp; We also try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> relatively-short strings by avoiding <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>/<a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> overhead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="pg_locale.c.html#L1317" title="utils/adt/pg_locale.c:1317">lc_collate_is_c</a>(collid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = memcmp(arg1, arg2, <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(len1, len2));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((result == <span class="Constant">0</span>) &amp;&amp; (len1 != len2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (len1 &lt; len2) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_locale_t mylocale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mylocale = <a href="pg_locale.c.html#L1551" title="utils/adt/pg_locale.c:1551">pg_newlocale_from_collation</a>(collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memcmp() can't tell us which of two unequal strings sorts first,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but it's a cheap way to tell if they're <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.&nbsp; Testing shows that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memcmp() followed by strcoll() is only trivially slower than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * strcoll() by itself, so we don't lose much if this doesn't work out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * very often, and if it does - for example, because there are many<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> strings in the input - then we win big by avoiding expensive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * collation-aware comparisons.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len1 == len2 &amp;&amp; memcmp(arg1, arg2, len1) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="pg_locale.c.html#L2133" title="utils/adt/pg_locale.c:2133">pg_strncoll</a>(arg1, len1, arg2, len2, mylocale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Break tie if necessary. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">0</span> &amp;&amp; <a href="pg_locale.c.html#L1531" title="utils/adt/pg_locale.c:1531">pg_locale_deterministic</a>(mylocale))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = memcmp(arg1, arg2, <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(len1, len2));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((result == <span class="Constant">0</span>) &amp;&amp; (len1 != len2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (len1 &lt; len2) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1594" title="utils/adt/varlena.c:1594">text_cmp</a>()<br/></li>
<li></span><span class="Comment"> * Internal comparison function for text strings.<br/></li>
<li></span><span class="Comment"> * Returns -1, 0 or 1<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1594">&#x200c;</a></span><span class="linkable">text_cmp</span>(text *arg1, text *arg2, Oid collid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *a1p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *a2p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; a1p = VARDATA_ANY(arg1);<br/></li>
<li>&nbsp; &nbsp; a2p = VARDATA_ANY(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = VARSIZE_ANY_EXHDR(arg1);<br/></li>
<li>&nbsp; &nbsp; len2 = VARSIZE_ANY_EXHDR(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1539" title="utils/adt/varlena.c:1539">varstr_cmp</a>(a1p, len1, a2p, len2, collid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Comparison <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for text strings.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: btree indexes need these routines not to leak memory; therefore,<br/></li>
<li></span><span class="Comment"> * be careful to free working copies of toasted datums.&nbsp; Most places don't<br/></li>
<li></span><span class="Comment"> * need to be so careful.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L1619">&#x200c;</a><span class="linkable">texteq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collid = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; locale_is_c = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pg_locale_t mylocale = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="varchar.c.html#L727" title="utils/adt/varchar.c:727">check_collation_set</a>(collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="pg_locale.c.html#L1317" title="utils/adt/pg_locale.c:1317">lc_collate_is_c</a>(collid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locale_is_c = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mylocale = <a href="pg_locale.c.html#L1551" title="utils/adt/pg_locale.c:1551">pg_newlocale_from_collation</a>(collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (locale_is_c || <a href="pg_locale.c.html#L1531" title="utils/adt/pg_locale.c:1531">pg_locale_deterministic</a>(mylocale))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since we only care about equality or not-equality, we can avoid all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the expense of strcoll() here, and just do bitwise comparison.&nbsp; In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fact, we don't even have to do a bitwise comparison if we can show<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the lengths of the strings are unequal; which might save us from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * having to detoast one or both <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; len1 = <a href="../../access/common/detoast.c.html#L545" title="access/common/detoast.c:545">toast_raw_datum_size</a>(arg1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len2 = <a href="../../access/common/detoast.c.html#L545" title="access/common/detoast.c:545">toast_raw_datum_size</a>(arg2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len1 != len2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *targ1 = DatumGetTextPP(arg1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *targ2 = DatumGetTextPP(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (memcmp(VARDATA_ANY(targ1), VARDATA_ANY(targ2),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; len1 - VARHDRSZ) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_FREE_IF_COPY(targ1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_FREE_IF_COPY(targ2, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (<a href="#L1594" title="utils/adt/varlena.c:1594">text_cmp</a>(arg1, arg2, collid) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1678">&#x200c;</a><span class="linkable">textne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collid = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; locale_is_c = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pg_locale_t mylocale = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="varchar.c.html#L727" title="utils/adt/varchar.c:727">check_collation_set</a>(collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="pg_locale.c.html#L1317" title="utils/adt/pg_locale.c:1317">lc_collate_is_c</a>(collid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; locale_is_c = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mylocale = <a href="pg_locale.c.html#L1551" title="utils/adt/pg_locale.c:1551">pg_newlocale_from_collation</a>(collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (locale_is_c || <a href="pg_locale.c.html#L1531" title="utils/adt/pg_locale.c:1531">pg_locale_deterministic</a>(mylocale))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See comment in <a href="#L1619" title="utils/adt/varlena.c:1619">texteq</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; len1 = <a href="../../access/common/detoast.c.html#L545" title="access/common/detoast.c:545">toast_raw_datum_size</a>(arg1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len2 = <a href="../../access/common/detoast.c.html#L545" title="access/common/detoast.c:545">toast_raw_datum_size</a>(arg2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len1 != len2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *targ1 = DatumGetTextPP(arg1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *targ2 = DatumGetTextPP(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (memcmp(VARDATA_ANY(targ1), VARDATA_ANY(targ2),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; len1 - VARHDRSZ) != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_FREE_IF_COPY(targ1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_FREE_IF_COPY(targ2, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (<a href="#L1594" title="utils/adt/varlena.c:1594">text_cmp</a>(arg1, arg2, collid) != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1731">&#x200c;</a><span class="linkable">text_lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (<a href="#L1594" title="utils/adt/varlena.c:1594">text_cmp</a>(arg1, arg2, PG_GET_COLLATION()) &lt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1746">&#x200c;</a><span class="linkable">text_le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (<a href="#L1594" title="utils/adt/varlena.c:1594">text_cmp</a>(arg1, arg2, PG_GET_COLLATION()) &lt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1761">&#x200c;</a><span class="linkable">text_gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (<a href="#L1594" title="utils/adt/varlena.c:1594">text_cmp</a>(arg1, arg2, PG_GET_COLLATION()) &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1776">&#x200c;</a><span class="linkable">text_ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (<a href="#L1594" title="utils/adt/varlena.c:1594">text_cmp</a>(arg1, arg2, PG_GET_COLLATION()) &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1791">&#x200c;</a><span class="linkable">text_starts_with</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collid = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; pg_locale_t mylocale = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="varchar.c.html#L727" title="utils/adt/varchar.c:727">check_collation_set</a>(collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="pg_locale.c.html#L1317" title="utils/adt/pg_locale.c:1317">lc_collate_is_c</a>(collid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mylocale = <a href="pg_locale.c.html#L1551" title="utils/adt/pg_locale.c:1551">pg_newlocale_from_collation</a>(collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="pg_locale.c.html#L1531" title="utils/adt/pg_locale.c:1531">pg_locale_deterministic</a>(mylocale))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;nondeterministic collations are not supported for substring searches&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = <a href="../../access/common/detoast.c.html#L545" title="access/common/detoast.c:545">toast_raw_datum_size</a>(arg1);<br/></li>
<li>&nbsp; &nbsp; len2 = <a href="../../access/common/detoast.c.html#L545" title="access/common/detoast.c:545">toast_raw_datum_size</a>(arg2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len2 &gt; len1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *targ1 = <a href="#L885" title="utils/adt/varlena.c:885">text_substring</a>(arg1, <span class="Constant">1</span>, len2, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *targ2 = DatumGetTextPP(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (memcmp(VARDATA_ANY(targ1), VARDATA_ANY(targ2),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(targ2)) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_FREE_IF_COPY(targ1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_FREE_IF_COPY(targ2, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1831">&#x200c;</a><span class="linkable">bttextcmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1594" title="utils/adt/varlena.c:1594">text_cmp</a>(arg1, arg2, PG_GET_COLLATION());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1846">&#x200c;</a><span class="linkable">bttextsortsupport</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortSupport ssup = (SortSupport) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collid = ssup-&gt;ssup_collation;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(ssup-&gt;ssup_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use generic string SortSupport */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1873" title="utils/adt/varlena.c:1873">varstr_sortsupport</a>(ssup, TEXTOID, collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generic sortsupport interface for character type's operator classes.<br/></li>
<li></span><span class="Comment"> * Includes locale support, and support for BpChar semantics (i.e. removing<br/></li>
<li></span><span class="Comment"> * trailing spaces <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> comparison).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Relies on the assumption that text, VarChar, BpChar, and bytea all have the<br/></li>
<li></span><span class="Comment"> * same representation.&nbsp; Callers that always use the C collation (e.g.<br/></li>
<li></span><span class="Comment"> * non-collatable type callers like bytea) may have NUL bytes in their strings;<br/></li>
<li></span><span class="Comment"> * this will not work with <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other collation, though.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1873">&#x200c;</a></span><span class="linkable">varstr_sortsupport</span>(SortSupport ssup, Oid typid, Oid collid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; abbreviate = ssup-&gt;abbreviate;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; collate_c = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="utils/adt/varlena.c:97">VarStringSortSupport</a> *sss;<br/></li>
<li>&nbsp; &nbsp; pg_locale_t locale = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="varchar.c.html#L727" title="utils/adt/varchar.c:727">check_collation_set</a>(collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If possible, set ssup-&gt;comparator to a function which can be used to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * directly <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> two datums.&nbsp; If we can do this, we'll avoid the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overhead of a trip through the fmgr layer for every comparison, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can be substantial.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Most typically, we'll set the comparator to <a href="#L2094" title="utils/adt/varlena.c:2094">varlenafastcmp_locale</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which uses strcoll() to perform comparisons.&nbsp; We use that for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * BpChar case too, but type NAME uses <a href="#L2125" title="utils/adt/varlena.c:2125">namefastcmp_locale</a>. However, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LC_COLLATE = C, we can make things quite a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> faster with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2012" title="utils/adt/varlena.c:2012">varstrfastcmp_c</a>, <a href="#L2049" title="utils/adt/varlena.c:2049">bpcharfastcmp_c</a>, or <a href="#L2082" title="utils/adt/varlena.c:2082">namefastcmp_c</a>, all of which use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memcmp() rather than strcoll().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="pg_locale.c.html#L1317" title="utils/adt/pg_locale.c:1317">lc_collate_is_c</a>(collid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typid == BPCHAROID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;comparator = <a href="#L2049" title="utils/adt/varlena.c:2049">bpcharfastcmp_c</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (typid == NAMEOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;comparator = <a href="#L2082" title="utils/adt/varlena.c:2082">namefastcmp_c</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not supporting abbreviation with type NAME, for <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abbreviate = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;comparator = <a href="#L2012" title="utils/adt/varlena.c:2012">varstrfastcmp_c</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collate_c = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need a collation-sensitive comparison.&nbsp; To make things faster,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll figure out the collation based on the locale id and cache the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; locale = <a href="pg_locale.c.html#L1551" title="utils/adt/pg_locale.c:1551">pg_newlocale_from_collation</a>(collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We use <a href="#L2094" title="utils/adt/varlena.c:2094">varlenafastcmp_locale</a> except for type NAME.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typid == NAMEOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;comparator = <a href="#L2125" title="utils/adt/varlena.c:2125">namefastcmp_locale</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not supporting abbreviation with type NAME, for <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abbreviate = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;comparator = <a href="#L2094" title="utils/adt/varlena.c:2094">varlenafastcmp_locale</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unfortunately, it seems that abbreviation for non-C collations is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * broken on many common platforms; see <a href="pg_locale.c.html#L2349" title="utils/adt/pg_locale.c:2349">pg_strxfrm_enabled</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Even apart from the risk of broken locales, it's possible that there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are platforms where the use of abbreviated keys should be disabled at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compile time.&nbsp; Having only 4 byte datums could make worst-case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * performance drastically more likely, for example.&nbsp; Moreover, macOS's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * strxfrm() implementation is known to not effectively concentrate a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * significant amount of entropy from the original string in earlier<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transformed blobs.&nbsp; It's possible that other supported platforms are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * similarly encumbered.&nbsp; So, if we ever get past disabling this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * categorically, we may still want or need to disable it for particular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * platforms.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!collate_c &amp;&amp; !<a href="pg_locale.c.html#L2349" title="utils/adt/pg_locale.c:2349">pg_strxfrm_enabled</a>(locale))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; abbreviate = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're using abbreviated keys, or if we're using a locale-aware<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comparison, we need to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> a <a href="#L97" title="utils/adt/varlena.c:97">VarStringSortSupport</a> object. Both<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases will make use of the temporary buffers we <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> here for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scratch space (and to detect requirement for BpChar semantics from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * caller), and the abbreviation case requires additional state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (abbreviate || !collate_c)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sss = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L97" title="utils/adt/varlena.c:97">VarStringSortSupport</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;buf1 = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<a href="pg_locale.c.html#L91" title="utils/adt/pg_locale.c:91">TEXTBUFLEN</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;buflen1 = <a href="pg_locale.c.html#L91" title="utils/adt/pg_locale.c:91">TEXTBUFLEN</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;buf2 = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<a href="pg_locale.c.html#L91" title="utils/adt/pg_locale.c:91">TEXTBUFLEN</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;buflen2 = <a href="pg_locale.c.html#L91" title="utils/adt/pg_locale.c:91">TEXTBUFLEN</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Start with invalid <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;last_len1 = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;last_len2 = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;last_returned = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;locale = locale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To avoid somehow confusing a strxfrm() blob and an original string,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constantly keep track of the variety of data that buf1 and buf2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * currently contain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Comparisons may be interleaved with conversion calls.&nbsp; Frequently,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * conversions and comparisons are batched into two distinct phases,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but the correctness of caching cannot hinge upon this.&nbsp; For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comparison caching, buffer state is only trusted if cache_blob is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * found set to false, whereas strxfrm() caching only trusts the state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when cache_blob is found set to true.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Arbitrarily <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> cache_blob to true.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;cache_blob = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;collate_c = collate_c;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;typid = typid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;ssup_extra = sss;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If possible, plan to use the abbreviated keys optimization.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * core code may switch back to authoritative comparator should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * abbreviation be aborted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (abbreviate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;prop_card = <span class="Constant">0.20</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/hyperloglog.c.html#L66" title="lib/hyperloglog.c:66">initHyperLogLog</a>(&amp;sss-&gt;abbr_card, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/hyperloglog.c.html#L66" title="lib/hyperloglog.c:66">initHyperLogLog</a>(&amp;sss-&gt;full_card, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;abbrev_full_comparator = ssup-&gt;comparator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;comparator = <a href="../sort/tuplesort.c.html#L3177" title="utils/sort/tuplesort.c:3177">ssup_datum_unsigned_cmp</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;abbrev_converter = <a href="#L2239" title="utils/adt/varlena.c:2239">varstr_abbrev_convert</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;abbrev_abort = <a href="#L2437" title="utils/adt/varlena.c:2437">varstr_abbrev_abort</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * sortsupport comparison func (for C locale case)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2012">&#x200c;</a></span><span class="linkable">varstrfastcmp_c</span>(Datum x, Datum y, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="utils/adt/varlena.c:50">VarString</a>&nbsp; *arg1 = <a href="#L117" title="utils/adt/varlena.c:117">DatumGetVarStringPP</a>(x);<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="utils/adt/varlena.c:50">VarString</a>&nbsp; *arg2 = <a href="#L117" title="utils/adt/varlena.c:117">DatumGetVarStringPP</a>(y);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *a1p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *a2p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; a1p = VARDATA_ANY(arg1);<br/></li>
<li>&nbsp; &nbsp; a2p = VARDATA_ANY(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = VARSIZE_ANY_EXHDR(arg1);<br/></li>
<li>&nbsp; &nbsp; len2 = VARSIZE_ANY_EXHDR(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = memcmp(a1p, a2p, <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(len1, len2));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((result == <span class="Constant">0</span>) &amp;&amp; (len1 != len2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (len1 &lt; len2) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can't afford to leak memory here. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PointerGetDatum(arg1) != x)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(arg1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PointerGetDatum(arg2) != y)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * sortsupport comparison func (for BpChar C locale case)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * BpChar outsources its sortsupport to this module.&nbsp; Specialization for the<br/></li>
<li></span><span class="Comment"> * <a href="#L1873" title="utils/adt/varlena.c:1873">varstr_sortsupport</a> BpChar case, modeled on<br/></li>
<li></span><span class="Comment"> * <a href="varchar.c.html#L1115" title="utils/adt/varchar.c:1115">internal_bpchar_pattern_compare</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2049">&#x200c;</a></span><span class="linkable">bpcharfastcmp_c</span>(Datum x, Datum y, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = DatumGetBpCharPP(x);<br/></li>
<li>&nbsp; &nbsp; BpChar&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = DatumGetBpCharPP(y);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *a1p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *a2p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; a1p = VARDATA_ANY(arg1);<br/></li>
<li>&nbsp; &nbsp; a2p = VARDATA_ANY(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = <a href="varchar.c.html#L676" title="utils/adt/varchar.c:676">bpchartruelen</a>(a1p, VARSIZE_ANY_EXHDR(arg1));<br/></li>
<li>&nbsp; &nbsp; len2 = <a href="varchar.c.html#L676" title="utils/adt/varchar.c:676">bpchartruelen</a>(a2p, VARSIZE_ANY_EXHDR(arg2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = memcmp(a1p, a2p, <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(len1, len2));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((result == <span class="Constant">0</span>) &amp;&amp; (len1 != len2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (len1 &lt; len2) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can't afford to leak memory here. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PointerGetDatum(arg1) != x)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(arg1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PointerGetDatum(arg2) != y)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * sortsupport comparison func (for NAME C locale case)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2082">&#x200c;</a></span><span class="linkable">namefastcmp_c</span>(Datum x, Datum y, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; arg1 = DatumGetName(x);<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; arg2 = DatumGetName(y);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> strncmp(NameStr(*arg1), NameStr(*arg2), NAMEDATALEN);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * sortsupport comparison func (for locale case with all varlena types)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2094">&#x200c;</a></span><span class="linkable">varlenafastcmp_locale</span>(Datum x, Datum y, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="utils/adt/varlena.c:50">VarString</a>&nbsp; *arg1 = <a href="#L117" title="utils/adt/varlena.c:117">DatumGetVarStringPP</a>(x);<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="utils/adt/varlena.c:50">VarString</a>&nbsp; *arg2 = <a href="#L117" title="utils/adt/varlena.c:117">DatumGetVarStringPP</a>(y);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *a1p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *a2p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; a1p = VARDATA_ANY(arg1);<br/></li>
<li>&nbsp; &nbsp; a2p = VARDATA_ANY(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = VARSIZE_ANY_EXHDR(arg1);<br/></li>
<li>&nbsp; &nbsp; len2 = VARSIZE_ANY_EXHDR(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L2139" title="utils/adt/varlena.c:2139">varstrfastcmp_locale</a>(a1p, len1, a2p, len2, ssup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can't afford to leak memory here. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PointerGetDatum(arg1) != x)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(arg1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PointerGetDatum(arg2) != y)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * sortsupport comparison func (for locale case with NAME type)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2125">&#x200c;</a></span><span class="linkable">namefastcmp_locale</span>(Datum x, Datum y, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; arg1 = DatumGetName(x);<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; arg2 = DatumGetName(y);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2139" title="utils/adt/varlena.c:2139">varstrfastcmp_locale</a>(NameStr(*arg1), strlen(NameStr(*arg1)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(*arg2), strlen(NameStr(*arg2)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ssup);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * sortsupport comparison func for locale cases<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2139">&#x200c;</a></span><span class="linkable">varstrfastcmp_locale</span>(<span class="Type">char</span> *a1p, <span class="Type">int</span> len1, <span class="Type">char</span> *a2p, <span class="Type">int</span> len2, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="utils/adt/varlena.c:97">VarStringSortSupport</a> *sss = (<a href="#L97" title="utils/adt/varlena.c:97">VarStringSortSupport</a> *) ssup-&gt;ssup_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; arg1_match;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fast pre-check for equality, as discussed in <a href="#L1539" title="utils/adt/varlena.c:1539">varstr_cmp</a>() */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (len1 == len2 &amp;&amp; memcmp(a1p, a2p, len1) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No change in buf1 or buf2 contents, so avoid changing last_len1 or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * last_len2.&nbsp; Existing contents of buffers might still be used by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's fine to allow the comparison of BpChar padding bytes here,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * even though that implies that the memcmp() will usually be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * performed for BpChar callers (though multibyte characters could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still prevent that from occurring).&nbsp; The memcmp() is still very<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cheap, and BpChar's funny semantics have us remove trailing spaces<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (not limited to padding), so we need make no distinction between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * padding space characters and &quot;real&quot; space characters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sss-&gt;typid == BPCHAROID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get true number of bytes, ignoring trailing spaces */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; len1 = <a href="varchar.c.html#L676" title="utils/adt/varchar.c:676">bpchartruelen</a>(a1p, len1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len2 = <a href="varchar.c.html#L676" title="utils/adt/varchar.c:676">bpchartruelen</a>(a2p, len2);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len1 &gt;= sss-&gt;buflen1)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;buflen1 = Max(len1 + <span class="Constant">1</span>, <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(sss-&gt;buflen1 * <span class="Constant">2</span>, MaxAllocSize));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;buf1 = <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(sss-&gt;buf1, sss-&gt;buflen1);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len2 &gt;= sss-&gt;buflen2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;buflen2 = Max(len2 + <span class="Constant">1</span>, <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(sss-&gt;buflen2 * <span class="Constant">2</span>, MaxAllocSize));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;buf2 = <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(sss-&gt;buf2, sss-&gt;buflen2);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We're likely to be asked to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the same strings repeatedly, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memcmp() is so much cheaper than strcoll() that it pays to try to cache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comparisons, even though in general there is no reason to think that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that will work out (every string datum may be unique).&nbsp; Caching does<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not slow things down measurably when it doesn't work out, and can speed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * things up by rather a lot when it does.&nbsp; In part, this is because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memcmp() compares data from cachelines that are needed in L1 cache even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when the last comparison's result cannot be reused.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; arg1_match = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len1 != sss-&gt;last_len1 || memcmp(sss-&gt;buf1, a1p, len1) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arg1_match = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(sss-&gt;buf1, a1p, len1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;buf1[len1] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;last_len1 = len1;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're comparing the same two strings as last time, we can return the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same answer without calling strcoll() again.&nbsp; This is more likely than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it seems (at least with moderate to low cardinality sets), because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * quicksort compares the same pivot against many <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (len2 != sss-&gt;last_len2 || memcmp(sss-&gt;buf2, a2p, len2) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(sss-&gt;buf2, a2p, len2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;buf2[len2] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;last_len2 = len2;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (arg1_match &amp;&amp; !sss-&gt;cache_blob)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use result cached following last actual strcoll() call */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> sss-&gt;last_returned;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="pg_locale.c.html#L2098" title="utils/adt/pg_locale.c:2098">pg_strcoll</a>(sss-&gt;buf1, sss-&gt;buf2, sss-&gt;locale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Break tie if necessary. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">0</span> &amp;&amp; <a href="pg_locale.c.html#L1531" title="utils/adt/pg_locale.c:1531">pg_locale_deterministic</a>(sss-&gt;locale))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = strcmp(sss-&gt;buf1, sss-&gt;buf2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cache result, perhaps saving an expensive strcoll() call <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time */<br/></li>
<li></span>&nbsp; &nbsp; sss-&gt;cache_blob = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; sss-&gt;last_returned = result;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Conversion routine for sortsupport.&nbsp; Converts original to abbreviated key<br/></li>
<li></span><span class="Comment"> * representation.&nbsp; Our encoding strategy is simple -- pack the first 8 bytes<br/></li>
<li></span><span class="Comment"> * of a strxfrm() blob into a Datum (on little-endian machines, the 8 bytes are<br/></li>
<li></span><span class="Comment"> * stored in reverse order), and treat it as an unsigned integer.&nbsp; When the &quot;C&quot;<br/></li>
<li></span><span class="Comment"> * locale is used, or in case of bytea, just memcpy() from original instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L2239">&#x200c;</a><span class="linkable">varstr_abbrev_convert</span>(Datum original, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">size_t</span> max_prefix_bytes = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum);<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="utils/adt/varlena.c:97">VarStringSortSupport</a> *sss = (<a href="#L97" title="utils/adt/varlena.c:97">VarStringSortSupport</a> *) ssup-&gt;ssup_extra;<br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="utils/adt/varlena.c:50">VarString</a>&nbsp; *authoritative = <a href="#L117" title="utils/adt/varlena.c:117">DatumGetVarStringPP</a>(original);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *authoritative_data = VARDATA_ANY(authoritative);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* working state */<br/></li>
<li></span>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *pres;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pres = (<span class="Type">char</span> *) &amp;res;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* memset(), so <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-overwritten bytes are NUL */<br/></li>
<li></span>&nbsp; &nbsp; memset(pres, <span class="Constant">0</span>, max_prefix_bytes);<br/></li>
<li>&nbsp; &nbsp; len = VARSIZE_ANY_EXHDR(authoritative);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get number of bytes, ignoring trailing spaces */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sss-&gt;typid == BPCHAROID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = <a href="varchar.c.html#L676" title="utils/adt/varchar.c:676">bpchartruelen</a>(authoritative_data, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're using the C collation, use memcpy(), rather than strxfrm(), to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * abbreviate keys.&nbsp; The full comparator for the C locale is always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memcmp().&nbsp; It would be incorrect to allow bytea callers (callers that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * always force the C collation -- bytea isn't a collatable type, but this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * approach is convenient) to use strxfrm().&nbsp; This is because bytea<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * strings may contain NUL bytes.&nbsp; Besides, this should be faster, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * More generally, it's okay that bytea callers can have NUL bytes in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * strings because abbreviated <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> need not make a distinction between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * terminating NUL bytes, and NUL bytes representing actual NULs in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * authoritative representation.&nbsp; Hopefully a comparison at or past one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * abbreviated key's terminating NUL byte will resolve the comparison<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * without consulting the authoritative representation; specifically, some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * later non-NUL byte in the longer string can resolve the comparison<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * against a subsequent terminating NUL in the shorter string.&nbsp; There will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * usually be what is effectively a &quot;length-wise&quot; resolution there and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If that doesn't work out -- if all bytes in the longer string<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * positioned at or past the offset of the smaller string's (first)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * terminating NUL are actually representative of NUL bytes in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * authoritative binary string (perhaps with some *terminating* NUL bytes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * towards the end of the longer string iff it happens to still be small)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * -- then an authoritative tie-breaker will happen, and do the right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * thing: explicitly consider string length.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sss-&gt;collate_c)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(pres, authoritative_data, <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(len, max_prefix_bytes));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; bsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're not using the C collation, so fall back on strxfrm or ICU<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * analogs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* By convention, we use buffer 1 to store and NUL-terminate */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len &gt;= sss-&gt;buflen1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;buflen1 = Max(len + <span class="Constant">1</span>, <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(sss-&gt;buflen1 * <span class="Constant">2</span>, MaxAllocSize));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;buf1 = <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(sss-&gt;buf1, sss-&gt;buflen1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Might be able to reuse strxfrm() blob from last call */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sss-&gt;last_len1 == len &amp;&amp; sss-&gt;cache_blob &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcmp(sss-&gt;buf1, authoritative_data, len) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(pres, sss-&gt;buf2, <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(max_prefix_bytes, sss-&gt;last_len2));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No change affecting cardinality, so no hashing required */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> done;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(sss-&gt;buf1, authoritative_data, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="pg_locale.c.html#L2381" title="utils/adt/pg_locale.c:2381">pg_strxfrm</a>() and <a href="pg_locale.c.html#L2467" title="utils/adt/pg_locale.c:2467">pg_strxfrm_prefix</a> expect NUL-terminated strings.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;buf1[len] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;last_len1 = len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="pg_locale.c.html#L2440" title="utils/adt/pg_locale.c:2440">pg_strxfrm_prefix_enabled</a>(sss-&gt;locale))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sss-&gt;buflen2 &lt; max_prefix_bytes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;buflen2 = Max(max_prefix_bytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(sss-&gt;buflen2 * <span class="Constant">2</span>, MaxAllocSize));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;buf2 = <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(sss-&gt;buf2, sss-&gt;buflen2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bsize = <a href="pg_locale.c.html#L2467" title="utils/adt/pg_locale.c:2467">pg_strxfrm_prefix</a>(sss-&gt;buf2, sss-&gt;buf1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_prefix_bytes, sss-&gt;locale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;last_len2 = bsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Loop: Call <a href="pg_locale.c.html#L2381" title="utils/adt/pg_locale.c:2381">pg_strxfrm</a>(), possibly enlarge buffer, and try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * again.&nbsp; The <a href="pg_locale.c.html#L2381" title="utils/adt/pg_locale.c:2381">pg_strxfrm</a>() function leaves the result buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * content undefined if the result did not fit, so we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * retry until everything fits, even though we only need the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * few bytes in the end.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bsize = <a href="pg_locale.c.html#L2381" title="utils/adt/pg_locale.c:2381">pg_strxfrm</a>(sss-&gt;buf2, sss-&gt;buf1, sss-&gt;buflen2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sss-&gt;locale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;last_len2 = bsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bsize &lt; sss-&gt;buflen2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Grow buffer and retry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;buflen2 = Max(bsize + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(sss-&gt;buflen2 * <span class="Constant">2</span>, MaxAllocSize));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;buf2 = <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(sss-&gt;buf2, sss-&gt;buflen2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Every Datum byte is always compared.&nbsp; This is safe because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * strxfrm() blob is itself NUL terminated, leaving no danger of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * misinterpreting <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> NUL bytes not intended to be interpreted as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * logically representing termination.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Actually, even if there were NUL bytes in the blob it would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * okay.&nbsp; See remarks on bytea case above.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(pres, sss-&gt;buf2, <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(max_prefix_bytes, bsize));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Maintain approximate cardinality of both abbreviated keys and original,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * authoritative keys using HyperLogLog.&nbsp; Used as cheap insurance against<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the worst case, where we do many string transformations for no saving<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in full strcoll()-based comparisons.&nbsp; These statistics are used by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2437" title="utils/adt/varlena.c:2437">varstr_abbrev_abort</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, Hash key proper, or a significant fraction of it.&nbsp; Mix in length<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in order to compensate for cases where differences are past<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PG_CACHE_LINE_SIZE bytes, so as to limit the overhead of hashing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = DatumGetUInt32(hash_any((<span class="Type">unsigned</span> <span class="Type">char</span> *) authoritative_data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(len, PG_CACHE_LINE_SIZE)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len &gt; PG_CACHE_LINE_SIZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> ^= DatumGetUInt32(hash_uint32((uint32) len));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/hyperloglog.c.html#L167" title="lib/hyperloglog.c:167">addHyperLogLog</a>(&amp;sss-&gt;full_card, <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Hash abbreviated key */<br/></li>
<li></span><span class="PreProc">#if SIZEOF_DATUM == </span><span class="Constant">8<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; lohalf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hihalf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lohalf = (uint32) res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hihalf = (uint32) (res &gt;&gt; <span class="Constant">32</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = DatumGetUInt32(hash_uint32(lohalf ^ hihalf));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SIZEOF_DATUM != 8 */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = DatumGetUInt32(hash_uint32((uint32) res));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/hyperloglog.c.html#L167" title="lib/hyperloglog.c:167">addHyperLogLog</a>(&amp;sss-&gt;abbr_card, <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cache result, perhaps saving an expensive strxfrm() call <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time */<br/></li>
<li></span>&nbsp; &nbsp; sss-&gt;cache_blob = <span class="Constant">true</span>;<br/></li>
<li><span class="Statement">done</span><span class="cUserCont">:<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Byteswap on little-endian machines.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is needed so that <a href="../sort/tuplesort.c.html#L3177" title="utils/sort/tuplesort.c:3177">ssup_datum_unsigned_cmp</a>() (an unsigned integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 3-way comparator) works correctly on all platforms.&nbsp; If we didn't do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this, the comparator would have to call memcmp() with a pair of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pointers to the first byte of each abbreviated key, which is slower.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; res = DatumBigEndianToNative(res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't leak memory here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PointerGetDatum(authoritative) != original)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(authoritative);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Callback for estimating effectiveness of abbreviated key optimization, using<br/></li>
<li></span><span class="Comment"> * heuristic rules.&nbsp; Returns value indicating if the abbreviation optimization<br/></li>
<li></span><span class="Comment"> * should be aborted, based on its projected effectiveness.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2437">&#x200c;</a></span><span class="linkable">varstr_abbrev_abort</span>(<span class="Type">int</span> memtupcount, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="utils/adt/varlena.c:97">VarStringSortSupport</a> *sss = (<a href="#L97" title="utils/adt/varlena.c:97">VarStringSortSupport</a> *) ssup-&gt;ssup_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; abbrev_distinct,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key_distinct;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(ssup-&gt;abbreviate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Have a little patience */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (memtupcount &lt; <span class="Constant">100</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; abbrev_distinct = <a href="../../lib/hyperloglog.c.html#L186" title="lib/hyperloglog.c:186">estimateHyperLogLog</a>(&amp;sss-&gt;abbr_card);<br/></li>
<li>&nbsp; &nbsp; key_distinct = <a href="../../lib/hyperloglog.c.html#L186" title="lib/hyperloglog.c:186">estimateHyperLogLog</a>(&amp;sss-&gt;full_card);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clamp cardinality estimates to at least one distinct value.&nbsp; While<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NULLs are generally disregarded, if only NULL <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> were seen so far,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that might misrepresent costs if we failed to clamp.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (abbrev_distinct &lt;= <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; abbrev_distinct = <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (key_distinct &lt;= <span class="Constant">1.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key_distinct = <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In the worst case all abbreviated keys are identical, while at the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * time there are differences within full key strings not captured in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * abbreviations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../sort/tuplesort.c.html#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; norm_abbrev_card = abbrev_distinct / (<span class="Type">double</span>) memtupcount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;varstr_abbrev: abbrev_distinct after </span><span class="Special">%d</span><span class="Constant">: </span><span class="Special">%f</span><span class="Constant"> &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;(key_distinct: </span><span class="Special">%f</span><span class="Constant">, norm_abbrev_card: </span><span class="Special">%f</span><span class="Constant">, prop_card: </span><span class="Special">%f</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; memtupcount, abbrev_distinct, key_distinct, norm_abbrev_card,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sss-&gt;prop_card);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the number of distinct abbreviated keys approximately matches the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number of distinct authoritative original keys, that's reason enough to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * proceed.&nbsp; We can win even with a very low cardinality set if most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tie-breakers only memcmp().&nbsp; This is by far the most important<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consideration.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * While comparisons that are resolved at the abbreviated key level are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * considerably cheaper than tie-breakers resolved with memcmp(), both of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those two outcomes are so much cheaper than a full strcoll() once<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sorting is underway that it doesn't seem worth it to weigh abbreviated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cardinality against the overall size of the set in order to more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * accurately model costs.&nbsp; Assume that an abbreviated comparison, and an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * abbreviated comparison with a cheap memcmp()-based authoritative<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * resolution are equivalent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (abbrev_distinct &gt; key_distinct * sss-&gt;prop_card)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When we have exceeded 10,000 tuples, decay required cardinality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aggressively for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is useful because the number of comparisons required on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * average increases at a linearithmic rate, and at roughly 10,000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples that factor will start to dominate over the linear costs of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * string transformation (this is a conservative estimate).&nbsp; The decay<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rate is chosen to be a little less aggressive than halving -- which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (since we're called at points at which memtupcount has doubled)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would never see the cost model actually abort past the first call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * following a decay.&nbsp; This decay rate is mostly a precaution against<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a sudden, violent swing in how well abbreviated cardinality tracks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * full key cardinality.&nbsp; The decay also serves to prevent a marginal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case from being aborted too late, when too much has already been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * invested in string transformation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's possible for sets of several million distinct strings with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mere tens of thousands of distinct abbreviated keys to still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * benefit very significantly.&nbsp; This will generally occur provided<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * each abbreviated key is a proxy for a roughly uniform number of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set's full keys. If it isn't so, we hope to catch that early and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * abort.&nbsp; If it isn't caught early, by the time the problem is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * apparent it's probably not worth aborting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (memtupcount &gt; <span class="Constant">10000</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sss-&gt;prop_card *= <span class="Constant">0.65</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Abort abbreviation strategy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The worst case, where all abbreviated keys are identical while all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * original strings differ will typically only see a regression of about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 10% in execution time for small to medium sized lists of strings.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Whereas on modern CPUs where cache stalls are the dominant cost, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * often expect very large improvements, particularly with sets of strings<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of moderately high to high abbreviated cardinality.&nbsp; There is little to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lose but much to gain, which our strategy reflects.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef TRACE_SORT<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../sort/tuplesort.c.html#L124" title="utils/sort/tuplesort.c:124">trace_sort</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;varstr_abbrev: aborted abbreviation at </span><span class="Special">%d</span><span class="Constant"> &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;(abbrev_distinct: </span><span class="Special">%f</span><span class="Constant">, key_distinct: </span><span class="Special">%f</span><span class="Constant">, prop_card: </span><span class="Special">%f</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; memtupcount, abbrev_distinct, key_distinct, sss-&gt;prop_card);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generic equalimage support function for character type's operator classes.<br/></li>
<li></span><span class="Comment"> * Disables the use of deduplication with nondeterministic collations.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2555">&#x200c;</a><span class="linkable">btvarstrequalimage</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Oid&nbsp; &nbsp; &nbsp; &nbsp; opcintype = PG_GETARG_OID(0); */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collid = PG_GET_COLLATION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="varchar.c.html#L727" title="utils/adt/varchar.c:727">check_collation_set</a>(collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="pg_locale.c.html#L1317" title="utils/adt/pg_locale.c:1317">lc_collate_is_c</a>(collid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collid == DEFAULT_COLLATION_OID ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L1054" title="utils/cache/lsyscache.c:1054">get_collation_isdeterministic</a>(collid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2571">&#x200c;</a><span class="linkable">text_larger</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = ((<a href="#L1594" title="utils/adt/varlena.c:1594">text_cmp</a>(arg1, arg2, PG_GET_COLLATION()) &gt; <span class="Constant">0</span>) ? arg1 : arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2583">&#x200c;</a><span class="linkable">text_smaller</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = ((<a href="#L1594" title="utils/adt/varlena.c:1594">text_cmp</a>(arg1, arg2, PG_GET_COLLATION()) &lt; <span class="Constant">0</span>) ? arg1 : arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cross-type comparison <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for types text and name.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L2600">&#x200c;</a><span class="linkable">nameeqtext</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_NAME(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len1 = strlen(NameStr(*arg1));<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len2 = VARSIZE_ANY_EXHDR(arg2);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collid = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="varchar.c.html#L727" title="utils/adt/varchar.c:727">check_collation_set</a>(collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (collid == C_COLLATION_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (len1 == len2 &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcmp(NameStr(*arg1), VARDATA_ANY(arg2), len1) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = (<a href="#L1539" title="utils/adt/varlena.c:1539">varstr_cmp</a>(NameStr(*arg1), len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARDATA_ANY(arg2), len2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collid) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2625">&#x200c;</a><span class="linkable">texteqname</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_NAME(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len1 = VARSIZE_ANY_EXHDR(arg1);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len2 = strlen(NameStr(*arg2));<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collid = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="varchar.c.html#L727" title="utils/adt/varchar.c:727">check_collation_set</a>(collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (collid == C_COLLATION_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (len1 == len2 &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcmp(VARDATA_ANY(arg1), NameStr(*arg2), len1) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = (<a href="#L1539" title="utils/adt/varlena.c:1539">varstr_cmp</a>(VARDATA_ANY(arg1), len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(*arg2), len2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collid) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2650">&#x200c;</a><span class="linkable">namenetext</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_NAME(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len1 = strlen(NameStr(*arg1));<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len2 = VARSIZE_ANY_EXHDR(arg2);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collid = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="varchar.c.html#L727" title="utils/adt/varchar.c:727">check_collation_set</a>(collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (collid == C_COLLATION_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = !(len1 == len2 &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; memcmp(NameStr(*arg1), VARDATA_ANY(arg2), len1) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = !(<a href="#L1539" title="utils/adt/varlena.c:1539">varstr_cmp</a>(NameStr(*arg1), len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARDATA_ANY(arg2), len2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collid) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2675">&#x200c;</a><span class="linkable">textnename</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_NAME(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len1 = VARSIZE_ANY_EXHDR(arg1);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len2 = strlen(NameStr(*arg2));<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collid = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="varchar.c.html#L727" title="utils/adt/varchar.c:727">check_collation_set</a>(collid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (collid == C_COLLATION_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = !(len1 == len2 &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; memcmp(VARDATA_ANY(arg1), NameStr(*arg2), len1) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = !(<a href="#L1539" title="utils/adt/varlena.c:1539">varstr_cmp</a>(VARDATA_ANY(arg1), len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(*arg2), len2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collid) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2700">&#x200c;</a><span class="linkable">btnametextcmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_NAME(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1539" title="utils/adt/varlena.c:1539">varstr_cmp</a>(NameStr(*arg1), strlen(NameStr(*arg1)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARDATA_ANY(arg2), VARSIZE_ANY_EXHDR(arg2),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GET_COLLATION());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2716">&#x200c;</a><span class="linkable">bttextnamecmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_NAME(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L1539" title="utils/adt/varlena.c:1539">varstr_cmp</a>(VARDATA_ANY(arg1), VARSIZE_ANY_EXHDR(arg1),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(*arg2), strlen(NameStr(*arg2)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GET_COLLATION());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L2731">&#x200c;</a><span class="PreProc">#define <span class="linkable">CmpCall</span>(cmpfunc) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; DatumGetInt32(<a href="../fmgr/fmgr.c.html#L812" title="utils/fmgr/fmgr.c:812">DirectFunctionCall2Coll</a>(cmpfunc, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GET_COLLATION(), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GETARG_DATUM(</span><span class="Constant">0</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GETARG_DATUM(</span><span class="Constant">1</span><span class="PreProc">)))<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L2738">&#x200c;</a><span class="linkable">namelttext</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2731" title="utils/adt/varlena.c:2731">CmpCall</a>(<a href="#L2700" title="utils/adt/varlena.c:2700">btnametextcmp</a>) &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2744">&#x200c;</a><span class="linkable">nameletext</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2731" title="utils/adt/varlena.c:2731">CmpCall</a>(<a href="#L2700" title="utils/adt/varlena.c:2700">btnametextcmp</a>) &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2750">&#x200c;</a><span class="linkable">namegttext</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2731" title="utils/adt/varlena.c:2731">CmpCall</a>(<a href="#L2700" title="utils/adt/varlena.c:2700">btnametextcmp</a>) &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2756">&#x200c;</a><span class="linkable">namegetext</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2731" title="utils/adt/varlena.c:2731">CmpCall</a>(<a href="#L2700" title="utils/adt/varlena.c:2700">btnametextcmp</a>) &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2762">&#x200c;</a><span class="linkable">textltname</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2731" title="utils/adt/varlena.c:2731">CmpCall</a>(<a href="#L2716" title="utils/adt/varlena.c:2716">bttextnamecmp</a>) &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2768">&#x200c;</a><span class="linkable">textlename</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2731" title="utils/adt/varlena.c:2731">CmpCall</a>(<a href="#L2716" title="utils/adt/varlena.c:2716">bttextnamecmp</a>) &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2774">&#x200c;</a><span class="linkable">textgtname</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2731" title="utils/adt/varlena.c:2731">CmpCall</a>(<a href="#L2716" title="utils/adt/varlena.c:2716">bttextnamecmp</a>) &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2780">&#x200c;</a><span class="linkable">textgename</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L2731" title="utils/adt/varlena.c:2731">CmpCall</a>(<a href="#L2716" title="utils/adt/varlena.c:2716">bttextnamecmp</a>) &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L2785">&#x200c;</a><span class="PreProc">#undef <span class="linkable">CmpCall</span><br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The following operators support character-by-character comparison<br/></li>
<li></span><span class="Comment"> * of text datums, to allow building indexes suitable for LIKE clauses.<br/></li>
<li></span><span class="Comment"> * Note that the regular <a href="#L1619" title="utils/adt/varlena.c:1619">texteq</a>/<a href="#L1678" title="utils/adt/varlena.c:1678">textne</a> comparison operators, and regular<br/></li>
<li></span><span class="Comment"> * support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> 1 and 2 with &quot;C&quot; collation are assumed to be<br/></li>
<li></span><span class="Comment"> * compatible with these!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2797">&#x200c;</a></span><span class="linkable">internal_text_pattern_compare</span>(text *arg1, text *arg2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = VARSIZE_ANY_EXHDR(arg1);<br/></li>
<li>&nbsp; &nbsp; len2 = VARSIZE_ANY_EXHDR(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(len1, len2));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (len1 &lt; len2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (len1 &gt; len2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2819">&#x200c;</a><span class="linkable">text_pattern_lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L2797" title="utils/adt/varlena.c:2797">internal_text_pattern_compare</a>(arg1, arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2835">&#x200c;</a><span class="linkable">text_pattern_le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L2797" title="utils/adt/varlena.c:2797">internal_text_pattern_compare</a>(arg1, arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2851">&#x200c;</a><span class="linkable">text_pattern_ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L2797" title="utils/adt/varlena.c:2797">internal_text_pattern_compare</a>(arg1, arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2867">&#x200c;</a><span class="linkable">text_pattern_gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L2797" title="utils/adt/varlena.c:2797">internal_text_pattern_compare</a>(arg1, arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2883">&#x200c;</a><span class="linkable">bttext_pattern_cmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L2797" title="utils/adt/varlena.c:2797">internal_text_pattern_compare</a>(arg1, arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2899">&#x200c;</a><span class="linkable">bttext_pattern_sortsupport</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortSupport ssup = (SortSupport) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(ssup-&gt;ssup_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use generic string SortSupport, forcing &quot;C&quot; collation */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1873" title="utils/adt/varlena.c:1873">varstr_sortsupport</a>(ssup, TEXTOID, C_COLLATION_OID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * <a href="#L2922" title="utils/adt/varlena.c:2922">byteaoctetlen</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * get the number of bytes contained in an instance of type 'bytea'<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2922">&#x200c;</a><span class="linkable">byteaoctetlen</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; str = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We need not detoast the input at all */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_INT32(<a href="../../access/common/detoast.c.html#L545" title="access/common/detoast.c:545">toast_raw_datum_size</a>(str) - VARHDRSZ);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2938" title="utils/adt/varlena.c:2938">byteacat</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; takes two bytea* and returns a bytea* that is the concatenation of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the two.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Cloned from <a href="#L750" title="utils/adt/varlena.c:750">textcat</a> and modified as required.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2938">&#x200c;</a><span class="linkable">byteacat</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *t1 = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *t2 = PG_GETARG_BYTEA_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="#L2953" title="utils/adt/varlena.c:2953">bytea_catenate</a>(t1, t2));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2953" title="utils/adt/varlena.c:2953">bytea_catenate</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Guts of <a href="#L2938" title="utils/adt/varlena.c:2938">byteacat</a>(), broken out so it can be used by other <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Arguments can be in short-header form, but not compressed or out-of-line<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> bytea *<br/></li>
<li><a id="L2953">&#x200c;</a><span class="linkable">bytea_catenate</span>(bytea *t1, bytea *t2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = VARSIZE_ANY_EXHDR(t1);<br/></li>
<li>&nbsp; &nbsp; len2 = VARSIZE_ANY_EXHDR(t2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* paranoia ... probably should throw error instead? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (len1 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len1 = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len2 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len2 = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = len1 + len2 + VARHDRSZ;<br/></li>
<li>&nbsp; &nbsp; result = (bytea *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set size of result string... */<br/></li>
<li></span>&nbsp; &nbsp; SET_VARSIZE(result, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fill data field of result string... */<br/></li>
<li></span>&nbsp; &nbsp; ptr = VARDATA(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len1 &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, VARDATA_ANY(t1), len1);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len2 &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr + len1, VARDATA_ANY(t2), len2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L2986">&#x200c;</a><span class="PreProc">#define <span class="linkable">PG_STR_GET_BYTEA</span>(str_) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; DatumGetByteaPP(DirectFunctionCall1(<a href="#L290" title="utils/adt/varlena.c:290">byteain</a>, CStringGetDatum(str_)))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3005" title="utils/adt/varlena.c:3005">bytea_substr</a>()<br/></li>
<li></span><span class="Comment"> * Return a substring starting at the specified position.<br/></li>
<li></span><span class="Comment"> * Cloned from <a href="#L852" title="utils/adt/varlena.c:852">text_substr</a> and modified as required.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Input:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; - string<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; - starting position (is one-based)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; - string length (optional)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the starting position is zero or less, then return from the start of the string<br/></li>
<li></span><span class="Comment"> * adjusting the length to be consistent with the &quot;negative start&quot; per SQL.<br/></li>
<li></span><span class="Comment"> * If the length is less than zero, an ERROR is thrown. If no third argument<br/></li>
<li></span><span class="Comment"> * (length) is provided, the length to the end of the string is assumed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3005">&#x200c;</a><span class="linkable">bytea_substr</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="#L3028" title="utils/adt/varlena.c:3028">bytea_substring</a>(PG_GETARG_DATUM(<span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GETARG_INT32(<span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GETARG_INT32(<span class="Constant">2</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3019" title="utils/adt/varlena.c:3019">bytea_substr_no_len</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Wrapper to avoid opr_sanity failure due to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; one function accepting a different number of args.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3019">&#x200c;</a><span class="linkable">bytea_substr_no_len</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="#L3028" title="utils/adt/varlena.c:3028">bytea_substring</a>(PG_GETARG_DATUM(<span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GETARG_INT32(<span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> bytea *<br/></li>
<li><a id="L3028">&#x200c;</a><span class="linkable">bytea_substring</span>(Datum str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> S,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> L,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> length_not_specified)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; S1;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* adjusted start position */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; L1;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* adjusted substring length */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; E;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end position */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The logic here should generally match <a href="#L885" title="utils/adt/varlena.c:885">text_substring</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; S1 = Max(S, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (length_not_specified)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Not passed a length - DatumGetByteaPSlice() grabs everything to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end of the string if we pass it a negative value for length.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; L1 = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (L &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SQL99 says to throw an error for E &lt; S, i.e., negative length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SUBSTRING_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;negative substring length not allowed&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; L1 = -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* silence stupider compilers */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_add_s32_overflow(S, L, &amp;E))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * L could be large enough for S + L to overflow, in which case the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * substring must run to end of string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; L1 = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A zero or negative value for the end position can happen if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * start was negative or one. SQL99 says to return a zero-length<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (E &lt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2986" title="utils/adt/varlena.c:2986">PG_STR_GET_BYTEA</a>(<span class="Constant">&quot;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; L1 = E - S1;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the start position is past the end of the string, SQL99 says to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * return a zero-length string -- DatumGetByteaPSlice() will do that for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * us.&nbsp; We need only convert S1 to zero-based starting position.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetByteaPSlice(str, S1 - <span class="Constant">1</span>, L1);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3095" title="utils/adt/varlena.c:3095">byteaoverlay</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Replace specified substring of first string with second<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The SQL standard defines OVERLAY() in terms of substring and concatenation.<br/></li>
<li></span><span class="Comment"> * This code is a direct implementation of what the standard says.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3095">&#x200c;</a><span class="linkable">byteaoverlay</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *t1 = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *t2 = PG_GETARG_BYTEA_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sp = PG_GETARG_INT32(<span class="Constant">2</span>);&nbsp; &nbsp; <span class="Comment">/* substring start position */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sl = PG_GETARG_INT32(<span class="Constant">3</span>);&nbsp; &nbsp; <span class="Comment">/* substring length */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="#L3118" title="utils/adt/varlena.c:3118">bytea_overlay</a>(t1, t2, sp, sl));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3106">&#x200c;</a><span class="linkable">byteaoverlay_no_len</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *t1 = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *t2 = PG_GETARG_BYTEA_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sp = PG_GETARG_INT32(<span class="Constant">2</span>);&nbsp; &nbsp; <span class="Comment">/* substring start position */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sl = VARSIZE_ANY_EXHDR(t2); <span class="Comment">/* defaults to length(t2) */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="#L3118" title="utils/adt/varlena.c:3118">bytea_overlay</a>(t1, t2, sp, sl));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> bytea *<br/></li>
<li><a id="L3118">&#x200c;</a><span class="linkable">bytea_overlay</span>(bytea *t1, bytea *t2, <span class="Type">int</span> sp, <span class="Type">int</span> sl)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *s1;<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *s2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sp_pl_sl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for possible integer-overflow cases.&nbsp; For negative sp, throw a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;substring length&quot; error because that's what should be expected<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * according to the spec's definition of OVERLAY().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sp &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SUBSTRING_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;negative substring length not allowed&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_add_s32_overflow(sp, sl, &amp;sp_pl_sl))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;integer out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s1 = <a href="#L3028" title="utils/adt/varlena.c:3028">bytea_substring</a>(PointerGetDatum(t1), <span class="Constant">1</span>, sp - <span class="Constant">1</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; s2 = <a href="#L3028" title="utils/adt/varlena.c:3028">bytea_substring</a>(PointerGetDatum(t1), sp_pl_sl, -<span class="Constant">1</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; result = <a href="#L2953" title="utils/adt/varlena.c:2953">bytea_catenate</a>(s1, t2);<br/></li>
<li>&nbsp; &nbsp; result = <a href="#L2953" title="utils/adt/varlena.c:2953">bytea_catenate</a>(result, s2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * bit_count<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3151">&#x200c;</a><span class="linkable">bytea_bit_count</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *t1 = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT64(pg_popcount(VARDATA_ANY(t1), VARSIZE_ANY_EXHDR(t1)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3165" title="utils/adt/varlena.c:3165">byteapos</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Return the position of the specified substring.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Implements the SQL POSITION() function.<br/></li>
<li></span><span class="Comment"> * Cloned from <a href="#L1153" title="utils/adt/varlena.c:1153">textpos</a> and modified as required.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3165">&#x200c;</a><span class="linkable">byteapos</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *t1 = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *t2 = PG_GETARG_BYTEA_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_px.c.html#L49" title="optimizer/geqo/geqo_px.c:49">px</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *p2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = VARSIZE_ANY_EXHDR(t1);<br/></li>
<li>&nbsp; &nbsp; len2 = VARSIZE_ANY_EXHDR(t2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len2 &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32(<span class="Constant">1</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* result for empty pattern */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; p1 = VARDATA_ANY(t1);<br/></li>
<li>&nbsp; &nbsp; p2 = VARDATA_ANY(t2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_px.c.html#L49" title="optimizer/geqo/geqo_px.c:49">px</a> = (len1 - len2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (p = <span class="Constant">0</span>; p &lt;= <a href="../../optimizer/geqo/geqo_px.c.html#L49" title="optimizer/geqo/geqo_px.c:49">px</a>; p++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((*p2 == *p1) &amp;&amp; (memcmp(p1, p2, len2) == <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos = p + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; };<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p1++;<br/></li>
<li>&nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(pos);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * <a href="#L3209" title="utils/adt/varlena.c:3209">byteaGetByte</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * this routine treats &quot;bytea&quot; as an array of bytes.<br/></li>
<li></span><span class="Comment"> * It returns the Nth byte (a number between 0 and 255).<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3209">&#x200c;</a><span class="linkable">byteaGetByte</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *v = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; n = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byte;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = VARSIZE_ANY_EXHDR(v);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n &lt; <span class="Constant">0</span> || n &gt;= len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">%d</span><span class="Constant"> out of valid <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, 0..</span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n, len - <span class="Constant">1</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; byte = ((<span class="Type">unsigned</span> <span class="Type">char</span> *) VARDATA_ANY(v))[n];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(byte);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * <a href="#L3238" title="utils/adt/varlena.c:3238">byteaGetBit</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine treats a &quot;bytea&quot; type like an array of bits.<br/></li>
<li></span><span class="Comment"> * It returns the value of the Nth <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> (0 or 1).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3238">&#x200c;</a><span class="linkable">byteaGetBit</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *v = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; n = PG_GETARG_INT64(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byteNo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitNo;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byte;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = VARSIZE_ANY_EXHDR(v);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n &lt; <span class="Constant">0</span> || n &gt;= (int64) len * <span class="Constant">8</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">%lld</span><span class="Constant"> out of valid <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, 0..</span><span class="Special">%lld</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) n, (<span class="Type">long</span> <span class="Type">long</span>) len * <span class="Constant">8</span> - <span class="Constant">1</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* n/8 is <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> known &lt; len, so safe to cast to int */<br/></li>
<li></span>&nbsp; &nbsp; byteNo = (<span class="Type">int</span>) (n / <span class="Constant">8</span>);<br/></li>
<li>&nbsp; &nbsp; bitNo = (<span class="Type">int</span>) (n % <span class="Constant">8</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; byte = ((<span class="Type">unsigned</span> <span class="Type">char</span> *) VARDATA_ANY(v))[byteNo];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (byte &amp; (<span class="Constant">1</span> &lt;&lt; bitNo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_INT32(<span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * <a href="#L3276" title="utils/adt/varlena.c:3276">byteaSetByte</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given an instance of type 'bytea' creates a new one with<br/></li>
<li></span><span class="Comment"> * the Nth byte set to the given value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3276">&#x200c;</a><span class="linkable">byteaSetByte</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *res = PG_GETARG_BYTEA_P_COPY(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; n = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; newByte = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = VARSIZE(res) - VARHDRSZ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n &lt; <span class="Constant">0</span> || n &gt;= len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">%d</span><span class="Constant"> out of valid <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, 0..</span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n, len - <span class="Constant">1</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now set the byte.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ((<span class="Type">unsigned</span> <span class="Type">char</span> *) VARDATA(res))[n] = newByte;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * <a href="#L3308" title="utils/adt/varlena.c:3308">byteaSetBit</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given an instance of type 'bytea' creates a new one with<br/></li>
<li></span><span class="Comment"> * the Nth <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> set to the given value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3308">&#x200c;</a><span class="linkable">byteaSetBit</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *res = PG_GETARG_BYTEA_P_COPY(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; n = PG_GETARG_INT64(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; newBit = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldByte,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newByte;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byteNo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitNo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = VARSIZE(res) - VARHDRSZ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n &lt; <span class="Constant">0</span> || n &gt;= (int64) len * <span class="Constant">8</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ARRAY_SUBSCRIPT_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">%lld</span><span class="Constant"> out of valid <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, 0..</span><span class="Special">%lld</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) n, (<span class="Type">long</span> <span class="Type">long</span>) len * <span class="Constant">8</span> - <span class="Constant">1</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* n/8 is <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> known &lt; len, so safe to cast to int */<br/></li>
<li></span>&nbsp; &nbsp; byteNo = (<span class="Type">int</span>) (n / <span class="Constant">8</span>);<br/></li>
<li>&nbsp; &nbsp; bitNo = (<span class="Type">int</span>) (n % <span class="Constant">8</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sanity check!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newBit != <span class="Constant">0</span> &amp;&amp; newBit != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;new <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> must be 0 or 1&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update the byte.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldByte = ((<span class="Type">unsigned</span> <span class="Type">char</span> *) VARDATA(res))[byteNo];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newBit == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newByte = oldByte &amp; (~(<span class="Constant">1</span> &lt;&lt; bitNo));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newByte = oldByte | (<span class="Constant">1</span> &lt;&lt; bitNo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ((<span class="Type">unsigned</span> <span class="Type">char</span> *) VARDATA(res))[byteNo] = newByte;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L3359" title="utils/adt/varlena.c:3359">text_name</a>()<br/></li>
<li></span><span class="Comment"> * Converts a text type to a Name type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3359">&#x200c;</a><span class="linkable">text_name</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *s = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = VARSIZE_ANY_EXHDR(s);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Truncate oversize input */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (len &gt;= NAMEDATALEN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = <a href="../mb/mbutils.c.html#L1083" title="utils/mb/mbutils.c:1083">pg_mbcliplen</a>(VARDATA_ANY(s), len, NAMEDATALEN - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We use <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a> here to ensure result is zero-padded */<br/></li>
<li></span>&nbsp; &nbsp; result = (Name) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(NAMEDATALEN);<br/></li>
<li>&nbsp; &nbsp; memcpy(NameStr(*result), VARDATA_ANY(s), len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NAME(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L3382" title="utils/adt/varlena.c:3382">name_text</a>()<br/></li>
<li></span><span class="Comment"> * Converts a Name type to a text type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3382">&#x200c;</a><span class="linkable">name_text</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; s = PG_GETARG_NAME(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(NameStr(*s)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3399" title="utils/adt/varlena.c:3399">textToQualifiedNameList</a> - convert a text object to list of names<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This implements the input parsing needed by <a href="../../commands/sequence.c.html#L586" title="commands/sequence.c:586">nextval</a>() and other<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that take a text parameter representing a qualified name.<br/></li>
<li></span><span class="Comment"> * We split the name at dots, downcase if not double-quoted, and<br/></li>
<li></span><span class="Comment"> * truncate names if they're too long.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L3399">&#x200c;</a><span class="linkable">textToQualifiedNameList</span>(text *textval)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *rawname;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *namelist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert to C string (handles possible detoasting). */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Note we rely on being able to modify rawname below. */<br/></li>
<li></span>&nbsp; &nbsp; rawname = <a href="#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(textval);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3457" title="utils/adt/varlena.c:3457">SplitIdentifierString</a>(rawname, <span class="Constant">'.'</span>, &amp;namelist))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_NAME),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid name syntax&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (namelist == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_NAME),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid name syntax&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, namelist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *curname = (<span class="Type">char</span> *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, <a href="../../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(<a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(curname)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rawname);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(namelist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3457" title="utils/adt/varlena.c:3457">SplitIdentifierString</a> --- <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> a string containing identifiers<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is the guts of <a href="#L3399" title="utils/adt/varlena.c:3399">textToQualifiedNameList</a>, and is exported for use in<br/></li>
<li></span><span class="Comment"> * other situations such as parsing GUC variables.&nbsp; In the GUC case, it's<br/></li>
<li></span><span class="Comment"> * important to avoid memory leaks, so the API is designed to minimize the<br/></li>
<li></span><span class="Comment"> * amount of stuff that needs to be allocated and freed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Inputs:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rawstring: the input string; must be overwritable!&nbsp; &nbsp; On return, it's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; been modified to contain the separated identifiers.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; separator: the separator punctuation expected between identifiers<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (typically '.' or ',').&nbsp; Whitespace may also appear around<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; identifiers.<br/></li>
<li></span><span class="Comment"> * Outputs:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; namelist: filled with a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d list of pointers to identifiers within<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rawstring.&nbsp; Caller should <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>() this even on error return.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if okay, false if there is a syntax error in the string.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that an empty string is considered okay here, though not in<br/></li>
<li></span><span class="Comment"> * <a href="#L3399" title="utils/adt/varlena.c:3399">textToQualifiedNameList</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3457">&#x200c;</a></span><span class="linkable">SplitIdentifierString</span>(<span class="Type">char</span> *rawstring, <span class="Type">char</span> separator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **namelist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *nextp = rawstring;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; done = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *namelist = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="../../parser/scansup.c.html#L117" title="parser/scansup.c:117">scanner_isspace</a>(*nextp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nextp++;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> leading whitespace */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*nextp == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allow empty string */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* At the top of the loop, we are at start of a new identifier. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *curname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*nextp == <span class="Constant">'&quot;'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Quoted name --- collapse quote-quote pairs, no downcasing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curname = nextp + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endp = strchr(nextp + <span class="Constant">1</span>, <span class="Constant">'&quot;'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* mismatched quotes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endp[<span class="Constant">1</span>] != <span class="Constant">'&quot;'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found end of quoted name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Collapse adjacent quotes into one quote, and look again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memmove(endp, endp + <span class="Constant">1</span>, strlen(endp));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextp = endp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* endp <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> points at the terminating quote */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextp = endp + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unquoted name --- extends to separator or whitespace */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *downname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curname = nextp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (*nextp &amp;&amp; *nextp != separator &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="../../parser/scansup.c.html#L117" title="parser/scansup.c:117">scanner_isspace</a>(*nextp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endp = nextp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curname == nextp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* empty unquoted name not allowed */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Downcase the identifier, using same code as <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> lexer does.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> because we want to overwrite the input in-place, we cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * support a downcasing transformation that increases the string<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * length.&nbsp; This is not a problem given the current implementation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of <a href="../../parser/scansup.c.html#L37" title="parser/scansup.c:37">downcase_truncate_identifier</a>, but we'll probably have to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * something about this someday.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = endp - curname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; downname = <a href="../../parser/scansup.c.html#L37" title="parser/scansup.c:37">downcase_truncate_identifier</a>(curname, len, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(strlen(downname) &lt;= len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strncpy(curname, downname, len);&nbsp; &nbsp; <span class="Comment">/* strncpy is required here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(downname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="../../parser/scansup.c.html#L117" title="parser/scansup.c:117">scanner_isspace</a>(*nextp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextp++;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> trailing whitespace */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*nextp == separator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="../../parser/scansup.c.html#L117" title="parser/scansup.c:117">scanner_isspace</a>(*nextp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextp++;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> leading whitespace for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we expect another name, so done remains false */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*nextp == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; done = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* invalid syntax */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now safe to overwrite separator with a null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *endp = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Truncate name if it's overlength */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../parser/scansup.c.html#L93" title="parser/scansup.c:93">truncate_identifier</a>(curname, strlen(curname), <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Finished isolating current name --- add it to list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *namelist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*namelist, curname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Loop back if we didn't reach end of string */<br/></li>
<li></span>&nbsp; &nbsp; } <span class="Statement">while</span> (!done);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3584" title="utils/adt/varlena.c:3584">SplitDirectoriesString</a> --- <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> a string containing file/directory names<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This works fine on file names too; the function name is historical.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is similar to <a href="#L3457" title="utils/adt/varlena.c:3457">SplitIdentifierString</a>, except that the parsing<br/></li>
<li></span><span class="Comment"> * rules are meant to handle pathnames instead of identifiers: there is<br/></li>
<li></span><span class="Comment"> * no downcasing, embedded spaces are allowed, the max length is MAXPGPATH-1,<br/></li>
<li></span><span class="Comment"> * and we apply canonicalize_path() to each extracted string.&nbsp; Because of the<br/></li>
<li></span><span class="Comment"> * last, the returned strings are separately <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d rather than being<br/></li>
<li></span><span class="Comment"> * pointers into rawstring --- but we still scribble on rawstring.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Inputs:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rawstring: the input string; must be modifiable!<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; separator: the separator punctuation expected between directories<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (typically ',' or ';').&nbsp; Whitespace may also appear around<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; directories.<br/></li>
<li></span><span class="Comment"> * Outputs:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; namelist: filled with a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d list of directory names.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Caller should <a href="../../nodes/list.c.html#L1560" title="nodes/list.c:1560">list_free_deep</a>() this even on error return.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if okay, false if there is a syntax error in the string.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that an empty string is considered okay here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3584">&#x200c;</a></span><span class="linkable">SplitDirectoriesString</span>(<span class="Type">char</span> *rawstring, <span class="Type">char</span> separator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **namelist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *nextp = rawstring;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; done = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *namelist = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="../../parser/scansup.c.html#L117" title="parser/scansup.c:117">scanner_isspace</a>(*nextp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nextp++;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> leading whitespace */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*nextp == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allow empty string */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* At the top of the loop, we are at start of a new directory. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *curname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*nextp == <span class="Constant">'&quot;'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Quoted name --- collapse quote-quote pairs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curname = nextp + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endp = strchr(nextp + <span class="Constant">1</span>, <span class="Constant">'&quot;'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* mismatched quotes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endp[<span class="Constant">1</span>] != <span class="Constant">'&quot;'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found end of quoted name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Collapse adjacent quotes into one quote, and look again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memmove(endp, endp + <span class="Constant">1</span>, strlen(endp));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextp = endp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* endp <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> points at the terminating quote */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextp = endp + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unquoted name --- extends to separator or end of string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curname = endp = nextp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (*nextp &amp;&amp; *nextp != separator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* trailing whitespace should not be included in name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../parser/scansup.c.html#L117" title="parser/scansup.c:117">scanner_isspace</a>(*nextp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endp = nextp + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curname == endp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* empty unquoted name not allowed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="../../parser/scansup.c.html#L117" title="parser/scansup.c:117">scanner_isspace</a>(*nextp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextp++;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> trailing whitespace */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*nextp == separator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="../../parser/scansup.c.html#L117" title="parser/scansup.c:117">scanner_isspace</a>(*nextp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextp++;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> leading whitespace for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we expect another name, so done remains false */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*nextp == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; done = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* invalid syntax */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now safe to overwrite separator with a null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *endp = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Truncate path if it's overlength */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strlen(curname) &gt;= MAXPGPATH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curname[MAXPGPATH - <span class="Constant">1</span>] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Finished isolating current name --- add it to list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; curname = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(curname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; canonicalize_path(curname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *namelist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*namelist, curname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Loop back if we didn't reach end of string */<br/></li>
<li></span>&nbsp; &nbsp; } <span class="Statement">while</span> (!done);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3705" title="utils/adt/varlena.c:3705">SplitGUCList</a> --- <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> a string containing identifiers or file names<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used to split the value of a GUC_LIST_QUOTE GUC variable, without<br/></li>
<li></span><span class="Comment"> * presuming whether the elements will be taken as identifiers or file names.<br/></li>
<li></span><span class="Comment"> * We assume the input has already been through <a href="../misc/guc_funcs.c.html#L192" title="utils/misc/guc_funcs.c:192">flatten_set_variable_args</a>(),<br/></li>
<li></span><span class="Comment"> * so that we need never downcase (if appropriate, that was done already).<br/></li>
<li></span><span class="Comment"> * Nor do we ever truncate, since we don't know the correct max length.<br/></li>
<li></span><span class="Comment"> * We disallow embedded whitespace for simplicity (it shouldn't matter,<br/></li>
<li></span><span class="Comment"> * because <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> embedded whitespace should have led to double-quoting).<br/></li>
<li></span><span class="Comment"> * Otherwise the API is identical to <a href="#L3457" title="utils/adt/varlena.c:3457">SplitIdentifierString</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> it's annoying to have so many copies of this string-splitting logic.<br/></li>
<li></span><span class="Comment"> * However, it's not clear that having one function with a bunch of option<br/></li>
<li></span><span class="Comment"> * flags would be much better.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> there is a version of this function in src/bin/pg_dump/dumputils.c.<br/></li>
<li></span><span class="Comment"> * Be sure to update that if you have to change this.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Inputs:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rawstring: the input string; must be overwritable!&nbsp; &nbsp; On return, it's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; been modified to contain the separated identifiers.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; separator: the separator punctuation expected between identifiers<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (typically '.' or ',').&nbsp; Whitespace may also appear around<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; identifiers.<br/></li>
<li></span><span class="Comment"> * Outputs:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; namelist: filled with a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d list of pointers to identifiers within<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rawstring.&nbsp; Caller should <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>() this even on error return.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if okay, false if there is a syntax error in the string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3705">&#x200c;</a></span><span class="linkable">SplitGUCList</span>(<span class="Type">char</span> *rawstring, <span class="Type">char</span> separator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List **namelist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *nextp = rawstring;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; done = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *namelist = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="../../parser/scansup.c.html#L117" title="parser/scansup.c:117">scanner_isspace</a>(*nextp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nextp++;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> leading whitespace */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*nextp == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allow empty string */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* At the top of the loop, we are at start of a new identifier. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *curname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*nextp == <span class="Constant">'&quot;'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Quoted name --- collapse quote-quote pairs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curname = nextp + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endp = strchr(nextp + <span class="Constant">1</span>, <span class="Constant">'&quot;'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* mismatched quotes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endp[<span class="Constant">1</span>] != <span class="Constant">'&quot;'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found end of quoted name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Collapse adjacent quotes into one quote, and look again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memmove(endp, endp + <span class="Constant">1</span>, strlen(endp));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextp = endp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* endp <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> points at the terminating quote */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextp = endp + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unquoted name --- extends to separator or whitespace */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curname = nextp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (*nextp &amp;&amp; *nextp != separator &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="../../parser/scansup.c.html#L117" title="parser/scansup.c:117">scanner_isspace</a>(*nextp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endp = nextp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curname == nextp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* empty unquoted name not allowed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="../../parser/scansup.c.html#L117" title="parser/scansup.c:117">scanner_isspace</a>(*nextp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextp++;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> trailing whitespace */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*nextp == separator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="../../parser/scansup.c.html#L117" title="parser/scansup.c:117">scanner_isspace</a>(*nextp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextp++;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> leading whitespace for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we expect another name, so done remains false */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*nextp == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; done = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* invalid syntax */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now safe to overwrite separator with a null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *endp = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Finished isolating current name --- add it to list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *namelist = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*namelist, curname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Loop back if we didn't reach end of string */<br/></li>
<li></span>&nbsp; &nbsp; } <span class="Statement">while</span> (!done);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Comparison Functions used for bytea<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: btree indexes need these routines not to leak memory; therefore,<br/></li>
<li></span><span class="Comment"> * be careful to free working copies of toasted datums.&nbsp; Most places don't<br/></li>
<li></span><span class="Comment"> * need to be so careful.<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L3794">&#x200c;</a><span class="linkable">byteaeq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can use a fast path for unequal lengths, which might save us from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * having to detoast one or both <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; len1 = <a href="../../access/common/detoast.c.html#L545" title="access/common/detoast.c:545">toast_raw_datum_size</a>(arg1);<br/></li>
<li>&nbsp; &nbsp; len2 = <a href="../../access/common/detoast.c.html#L545" title="access/common/detoast.c:545">toast_raw_datum_size</a>(arg2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len1 != len2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *barg1 = DatumGetByteaPP(arg1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *barg2 = DatumGetByteaPP(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (memcmp(VARDATA_ANY(barg1), VARDATA_ANY(barg2),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; len1 - VARHDRSZ) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_FREE_IF_COPY(barg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_FREE_IF_COPY(barg2, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3826">&#x200c;</a><span class="linkable">byteane</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arg1 = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arg2 = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can use a fast path for unequal lengths, which might save us from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * having to detoast one or both <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; len1 = <a href="../../access/common/detoast.c.html#L545" title="access/common/detoast.c:545">toast_raw_datum_size</a>(arg1);<br/></li>
<li>&nbsp; &nbsp; len2 = <a href="../../access/common/detoast.c.html#L545" title="access/common/detoast.c:545">toast_raw_datum_size</a>(arg2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len1 != len2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *barg1 = DatumGetByteaPP(arg1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *barg2 = DatumGetByteaPP(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (memcmp(VARDATA_ANY(barg1), VARDATA_ANY(barg2),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; len1 - VARHDRSZ) != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_FREE_IF_COPY(barg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_FREE_IF_COPY(barg2, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3858">&#x200c;</a><span class="linkable">bytealt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_BYTEA_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = VARSIZE_ANY_EXHDR(arg1);<br/></li>
<li>&nbsp; &nbsp; len2 = VARSIZE_ANY_EXHDR(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(len1, len2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL((<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &lt; <span class="Constant">0</span>) || ((<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> == <span class="Constant">0</span>) &amp;&amp; (len1 &lt; len2)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3878">&#x200c;</a><span class="linkable">byteale</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_BYTEA_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = VARSIZE_ANY_EXHDR(arg1);<br/></li>
<li>&nbsp; &nbsp; len2 = VARSIZE_ANY_EXHDR(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(len1, len2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL((<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &lt; <span class="Constant">0</span>) || ((<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> == <span class="Constant">0</span>) &amp;&amp; (len1 &lt;= len2)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3898">&#x200c;</a><span class="linkable">byteagt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_BYTEA_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = VARSIZE_ANY_EXHDR(arg1);<br/></li>
<li>&nbsp; &nbsp; len2 = VARSIZE_ANY_EXHDR(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(len1, len2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL((<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &gt; <span class="Constant">0</span>) || ((<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> == <span class="Constant">0</span>) &amp;&amp; (len1 &gt; len2)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3918">&#x200c;</a><span class="linkable">byteage</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_BYTEA_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = VARSIZE_ANY_EXHDR(arg1);<br/></li>
<li>&nbsp; &nbsp; len2 = VARSIZE_ANY_EXHDR(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(len1, len2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL((<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &gt; <span class="Constant">0</span>) || ((<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> == <span class="Constant">0</span>) &amp;&amp; (len1 &gt;= len2)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3938">&#x200c;</a><span class="linkable">byteacmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *arg1 = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *arg2 = PG_GETARG_BYTEA_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len1 = VARSIZE_ANY_EXHDR(arg1);<br/></li>
<li>&nbsp; &nbsp; len2 = VARSIZE_ANY_EXHDR(arg2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(len1, len2));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> == <span class="Constant">0</span>) &amp;&amp; (len1 != len2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = (len1 &lt; len2) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(arg2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3960">&#x200c;</a><span class="linkable">bytea_sortsupport</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortSupport ssup = (SortSupport) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(ssup-&gt;ssup_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use generic string SortSupport, forcing &quot;C&quot; collation */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1873" title="utils/adt/varlena.c:1873">varstr_sortsupport</a>(ssup, BYTEAOID, C_COLLATION_OID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="xml.c.html#L459" title="utils/adt/xml.c:459">appendStringInfoText</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Append a text to str.<br/></li>
<li></span><span class="Comment"> * Like appendStringInfoString(str, <a href="#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(t)) but faster.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3982">&#x200c;</a></span><span class="linkable">appendStringInfoText</span>(StringInfo str, <span class="Type">const</span> text *t)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; appendBinaryStringInfo(str, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3996" title="utils/adt/varlena.c:3996">replace_text</a><br/></li>
<li></span><span class="Comment"> * replace all occurrences of 'old_sub_str' in 'orig_str'<br/></li>
<li></span><span class="Comment"> * with 'new_sub_str' to form 'new_str'<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * returns 'orig_str' if 'old_sub_str' == '' or 'orig_str' == ''<br/></li>
<li></span><span class="Comment"> * otherwise returns 'new_str'<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3996">&#x200c;</a><span class="linkable">replace_text</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *src_text = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *from_sub_text = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *to_sub_text = PG_GETARG_TEXT_PP(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src_text_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; from_sub_text_len;<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="utils/adt/varlena.c:78">TextPositionState</a> state;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *ret_text;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunk_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *curr_ptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *start_ptr;<br/></li>
<li>&nbsp; &nbsp; StringInfoData str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; src_text_len = VARSIZE_ANY_EXHDR(src_text);<br/></li>
<li>&nbsp; &nbsp; from_sub_text_len = VARSIZE_ANY_EXHDR(from_sub_text);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return unmodified source string if empty source or pattern */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (src_text_len &lt; <span class="Constant">1</span> || from_sub_text_len &lt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(src_text);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1216" title="utils/adt/varlena.c:1216">text_position_setup</a>(src_text, from_sub_text, PG_GET_COLLATION(), &amp;state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; found = <a href="#L1336" title="utils/adt/varlena.c:1336">text_position_next</a>(&amp;state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* When the from_sub_text is not found, there is nothing to do. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1503" title="utils/adt/varlena.c:1503">text_position_cleanup</a>(&amp;state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(src_text);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; curr_ptr = <a href="#L1468" title="utils/adt/varlena.c:1468">text_position_get_match_ptr</a>(&amp;state);<br/></li>
<li>&nbsp; &nbsp; start_ptr = VARDATA_ANY(src_text);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy the data skipped over by last <a href="#L1336" title="utils/adt/varlena.c:1336">text_position_next</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; chunk_len = curr_ptr - start_ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(&amp;str, start_ptr, chunk_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xml.c.html#L459" title="utils/adt/xml.c:459">appendStringInfoText</a>(&amp;str, to_sub_text);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; start_ptr = curr_ptr + from_sub_text_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; found = <a href="#L1336" title="utils/adt/varlena.c:1336">text_position_next</a>(&amp;state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curr_ptr = <a href="#L1468" title="utils/adt/varlena.c:1468">text_position_get_match_ptr</a>(&amp;state);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy trailing data */<br/></li>
<li></span>&nbsp; &nbsp; chunk_len = ((<span class="Type">char</span> *) src_text + VARSIZE_ANY(src_text)) - start_ptr;<br/></li>
<li>&nbsp; &nbsp; appendBinaryStringInfo(&amp;str, start_ptr, chunk_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1503" title="utils/adt/varlena.c:1503">text_position_cleanup</a>(&amp;state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret_text = <a href="#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(str.data, str.len);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(str.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(ret_text);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4073" title="utils/adt/varlena.c:4073">check_replace_text_has_escape</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns 0 if text contains no backslashes that need processing.<br/></li>
<li></span><span class="Comment"> * Returns 1 if text contains backslashes, but not regexp submatch specifiers.<br/></li>
<li></span><span class="Comment"> * Returns 2 if text contains regexp submatch specifiers (\1 .. \9).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L4073">&#x200c;</a></span><span class="linkable">check_replace_text_has_escape</span>(<span class="Type">const</span> text *<a href="#L3996" title="utils/adt/varlena.c:3996">replace_text</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *p = VARDATA_ANY(<a href="#L3996" title="utils/adt/varlena.c:3996">replace_text</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *p_end = p + VARSIZE_ANY_EXHDR(<a href="#L3996" title="utils/adt/varlena.c:3996">replace_text</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (p &lt; p_end)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> escape char, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; p = memchr(p, <span class="Special">'\\'</span>, p_end - p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Note: a backslash at the end doesn't require extra processing. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p &lt; p_end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p &gt;= <span class="Constant">'1'</span> &amp;&amp; *p &lt;= <span class="Constant">'9'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">2</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found a submatch specifier, so done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found some other sequence, keep looking */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4106" title="utils/adt/varlena.c:4106">appendStringInfoRegexpSubstr</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Append <a href="#L3996" title="utils/adt/varlena.c:3996">replace_text</a> to str, substituting regexp back references for<br/></li>
<li></span><span class="Comment"> * \n escapes.&nbsp; start_ptr is the start of the match in the source string,<br/></li>
<li></span><span class="Comment"> * at logical character position data_pos.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4106">&#x200c;</a></span><span class="linkable">appendStringInfoRegexpSubstr</span>(StringInfo str, text *<a href="#L3996" title="utils/adt/varlena.c:3996">replace_text</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; regmatch_t *pmatch,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *start_ptr, <span class="Type">int</span> data_pos)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *p = VARDATA_ANY(<a href="#L3996" title="utils/adt/varlena.c:3996">replace_text</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *p_end = p + VARSIZE_ANY_EXHDR(<a href="#L3996" title="utils/adt/varlena.c:3996">replace_text</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (p &lt; p_end)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *chunk_start = p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> escape char, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; p = memchr(p, <span class="Special">'\\'</span>, p_end - p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = p_end;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy the text we just scanned over, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p &gt; chunk_start)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(str, chunk_start, p - chunk_start);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Done if at end of string, else advance over escape char. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p &gt;= p_end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p &gt;= p_end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Escape at very end of input.&nbsp; Treat same as unexpected char */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(str, <span class="Special">'\\'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*p &gt;= <span class="Constant">'1'</span> &amp;&amp; *p &lt;= <span class="Constant">'9'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use the back reference of regexp. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = *p - <span class="Constant">'0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so = pmatch[idx].rm_so;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eo = pmatch[idx].rm_eo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*p == <span class="Constant">'&amp;'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use the entire matched string. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so = pmatch[<span class="Constant">0</span>].rm_so;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eo = pmatch[<span class="Constant">0</span>].rm_eo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*p == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* \\ means transfer one \ to output. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(str, <span class="Special">'\\'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If escape char is not followed by <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> expected char, just treat<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it as ordinary data to copy.&nbsp; (</span><span class="Todo">XXX</span><span class="Comment"> would it be better to throw<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an error?)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(str, <span class="Special">'\\'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so &gt;= <span class="Constant">0</span> &amp;&amp; eo &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy the text that is back reference of regexp.&nbsp; Note so and eo<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are counted in characters not bytes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *chunk_start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunk_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(so &gt;= data_pos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunk_start = start_ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunk_start += <a href="#L806" title="utils/adt/varlena.c:806">charlen_to_bytelen</a>(chunk_start, so - data_pos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunk_len = <a href="#L806" title="utils/adt/varlena.c:806">charlen_to_bytelen</a>(chunk_start, eo - so);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(str, chunk_start, chunk_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4206" title="utils/adt/varlena.c:4206">replace_text_regexp</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * replace substring(s) in src_text that match pattern with <a href="#L3996" title="utils/adt/varlena.c:3996">replace_text</a>.<br/></li>
<li></span><span class="Comment"> * The <a href="#L3996" title="utils/adt/varlena.c:3996">replace_text</a> can contain backslash markers to substitute<br/></li>
<li></span><span class="Comment"> * (parts of) the matched text.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * cflags: regexp compile flags.<br/></li>
<li></span><span class="Comment"> * collation: collation to use.<br/></li>
<li></span><span class="Comment"> * search_start: the character (not byte) offset in src_text at which to<br/></li>
<li></span><span class="Comment"> * begin searching.<br/></li>
<li></span><span class="Comment"> * n: if 0, replace all matches; if &gt; 0, replace only the N'th match.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>text *<br/></li>
<li><a id="L4206">&#x200c;</a><span class="linkable">replace_text_regexp</span>(text *src_text, text *pattern_text,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text *<a href="#L3996" title="utils/adt/varlena.c:3996">replace_text</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> cflags, Oid collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> search_start, <span class="Type">int</span> n)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *ret_text;<br/></li>
<li>&nbsp; &nbsp; regex_t&nbsp; &nbsp; *re;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src_text_len = VARSIZE_ANY_EXHDR(src_text);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmatches = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; regmatch_t&nbsp; &nbsp; pmatch[<span class="Constant">10</span>];&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> match, plus \1 to \9 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmatch = lengthof(pmatch);<br/></li>
<li>&nbsp; &nbsp; pg_wchar&nbsp;&nbsp; *data;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; data_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_pos;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *start_ptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; escape_status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert data string to wide characters. */<br/></li>
<li></span>&nbsp; &nbsp; data = (pg_wchar *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>((src_text_len + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pg_wchar));<br/></li>
<li>&nbsp; &nbsp; data_len = <a href="../mb/mbutils.c.html#L986" title="utils/mb/mbutils.c:986">pg_mb2wchar_with_len</a>(VARDATA_ANY(src_text), data, src_text_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check whether <a href="#L3996" title="utils/adt/varlena.c:3996">replace_text</a> has escapes, especially regexp submatches. */<br/></li>
<li></span>&nbsp; &nbsp; escape_status = <a href="#L4073" title="utils/adt/varlena.c:4073">check_replace_text_has_escape</a>(<a href="#L3996" title="utils/adt/varlena.c:3996">replace_text</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If no regexp submatches, we can use REG_NOSUB. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (escape_status &lt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cflags |= REG_NOSUB;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Also tell <a href="../../regex/regexec.c.html#L185" title="regex/regexec.c:185">pg_regexec</a> we only want the whole-match location. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nmatch = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare the regexp. */<br/></li>
<li></span>&nbsp; &nbsp; re = <a href="regexp.c.html#L141" title="utils/adt/regexp.c:141">RE_compile_and_cache</a>(pattern_text, cflags, collation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* start_ptr points to the data_pos'th character of src_text */<br/></li>
<li></span>&nbsp; &nbsp; start_ptr = (<span class="Type">char</span> *) VARDATA_ANY(src_text);<br/></li>
<li>&nbsp; &nbsp; data_pos = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (search_start &lt;= data_len)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; regexec_result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; regexec_result = <a href="../../regex/regexec.c.html#L185" title="regex/regexec.c:185">pg_regexec</a>(re,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; search_start,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,&nbsp; &nbsp; <span class="Comment">/* no details */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmatch,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pmatch,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (regexec_result == REG_NOMATCH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (regexec_result != REG_OKAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; errMsg[<span class="Constant">100</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regerror.c.html#L60" title="regex/regerror.c:60">pg_regerror</a>(regexec_result, re, errMsg, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(errMsg));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_REGULAR_EXPRESSION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;regular expression failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, errMsg)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Count matches, and decide whether to replace this match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nmatches++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (n &gt; <span class="Constant">0</span> &amp;&amp; nmatches != n)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No, so advance search_start, but not start_ptr/data_pos. (Thus,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we treat the matched text as if it weren't matched, and copy it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the output later.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; search_start = pmatch[<span class="Constant">0</span>].rm_eo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pmatch[<span class="Constant">0</span>].rm_so == pmatch[<span class="Constant">0</span>].rm_eo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; search_start++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy the text to the left of the match position.&nbsp; Note we are given<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * character not byte indexes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pmatch[<span class="Constant">0</span>].rm_so - data_pos &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunk_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunk_len = <a href="#L806" title="utils/adt/varlena.c:806">charlen_to_bytelen</a>(start_ptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pmatch[<span class="Constant">0</span>].rm_so - data_pos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(&amp;buf, start_ptr, chunk_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Advance start_ptr over that text, to avoid multiple rescans of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it if the <a href="#L3996" title="utils/adt/varlena.c:3996">replace_text</a> contains multiple back-references.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start_ptr += chunk_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_pos = pmatch[<span class="Constant">0</span>].rm_so;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy the <a href="#L3996" title="utils/adt/varlena.c:3996">replace_text</a>, processing escapes if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> are present.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (escape_status &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4106" title="utils/adt/varlena.c:4106">appendStringInfoRegexpSubstr</a>(&amp;buf, <a href="#L3996" title="utils/adt/varlena.c:3996">replace_text</a>, pmatch,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; start_ptr, data_pos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xml.c.html#L459" title="utils/adt/xml.c:459">appendStringInfoText</a>(&amp;buf, <a href="#L3996" title="utils/adt/varlena.c:3996">replace_text</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance start_ptr and data_pos over the matched text. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; start_ptr += <a href="#L806" title="utils/adt/varlena.c:806">charlen_to_bytelen</a>(start_ptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pmatch[<span class="Constant">0</span>].rm_eo - data_pos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data_pos = pmatch[<span class="Constant">0</span>].rm_eo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we only want to replace one occurrence, we're done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (n &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Advance search position.&nbsp; Normally we start the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> search at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end of the previous match; but if the match was of zero length, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have to advance by one character, or we'd just <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the same match<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; search_start = data_pos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pmatch[<span class="Constant">0</span>].rm_so == pmatch[<span class="Constant">0</span>].rm_eo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; search_start++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy the text to the right of the last match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (data_pos &lt; data_len)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunk_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; chunk_len = ((<span class="Type">char</span> *) src_text + VARSIZE_ANY(src_text)) - start_ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(&amp;buf, start_ptr, chunk_len);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret_text = <a href="#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(buf.data, buf.len);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf.data);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret_text;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4368" title="utils/adt/varlena.c:4368">split_part</a><br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> input string based on provided field separator<br/></li>
<li></span><span class="Comment"> * return N'th item (1 based, negative counts from end)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4368">&#x200c;</a><span class="linkable">split_part</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *inputstring = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *fldsep = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fldnum = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inputstring_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fldsep_len;<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="utils/adt/varlena.c:78">TextPositionState</a> state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *start_ptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *end_ptr;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result_text;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* field number is 1 based */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fldnum == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;field position must not be zero&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; inputstring_len = VARSIZE_ANY_EXHDR(inputstring);<br/></li>
<li>&nbsp; &nbsp; fldsep_len = VARSIZE_ANY_EXHDR(fldsep);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* return empty string for empty input string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (inputstring_len &lt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(<span class="Constant">&quot;&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* handle empty field separator */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fldsep_len &lt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if first or last field, return input string, else empty string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fldnum == <span class="Constant">1</span> || fldnum == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(inputstring);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(<span class="Constant">&quot;&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the first field separator */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1216" title="utils/adt/varlena.c:1216">text_position_setup</a>(inputstring, fldsep, PG_GET_COLLATION(), &amp;state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; found = <a href="#L1336" title="utils/adt/varlena.c:1336">text_position_next</a>(&amp;state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* special case if fldsep not found at all */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1503" title="utils/adt/varlena.c:1503">text_position_cleanup</a>(&amp;state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if first or last field, return input string, else empty string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fldnum == <span class="Constant">1</span> || fldnum == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(inputstring);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(<span class="Constant">&quot;&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * take care of a negative field number (i.e. count from the right) by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * converting to a positive field number; we need total number of fields<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fldnum &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we found a fldsep, so there are at least two fields */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfields = <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L1336" title="utils/adt/varlena.c:1336">text_position_next</a>(&amp;state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numfields++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* special case of last field does not require an extra pass */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fldnum == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start_ptr = <a href="#L1468" title="utils/adt/varlena.c:1468">text_position_get_match_ptr</a>(&amp;state) + fldsep_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_ptr = VARDATA_ANY(inputstring) + inputstring_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1503" title="utils/adt/varlena.c:1503">text_position_cleanup</a>(&amp;state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(start_ptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_ptr - start_ptr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else, convert fldnum to positive notation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fldnum += numfields + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if nonexistent field, return empty string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fldnum &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1503" title="utils/adt/varlena.c:1503">text_position_cleanup</a>(&amp;state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(<span class="Constant">&quot;&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reset to pointing at first match, but <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> with positive fldnum */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1495" title="utils/adt/varlena.c:1495">text_position_reset</a>(&amp;state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; found = <a href="#L1336" title="utils/adt/varlena.c:1336">text_position_next</a>(&amp;state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(found);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* identify bounds of first field */<br/></li>
<li></span>&nbsp; &nbsp; start_ptr = VARDATA_ANY(inputstring);<br/></li>
<li>&nbsp; &nbsp; end_ptr = <a href="#L1468" title="utils/adt/varlena.c:1468">text_position_get_match_ptr</a>(&amp;state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (found &amp;&amp; --fldnum &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* identify bounds of <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> field */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; start_ptr = end_ptr + fldsep_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; found = <a href="#L1336" title="utils/adt/varlena.c:1336">text_position_next</a>(&amp;state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_ptr = <a href="#L1468" title="utils/adt/varlena.c:1468">text_position_get_match_ptr</a>(&amp;state);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1503" title="utils/adt/varlena.c:1503">text_position_cleanup</a>(&amp;state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fldnum &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* N'th field separator not found */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if last field requested, return it, else empty string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fldnum == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_len = start_ptr - VARDATA_ANY(inputstring);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_text = <a href="#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(start_ptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inputstring_len - last_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_text = <a href="#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(<span class="Constant">&quot;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* non-last field requested */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result_text = <a href="#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(start_ptr, end_ptr - start_ptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(result_text);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convenience function to return true when two text params are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4500">&#x200c;</a></span><span class="linkable">text_isequal</span>(text *txt1, text *txt2, Oid collid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetBool(<a href="../fmgr/fmgr.c.html#L812" title="utils/fmgr/fmgr.c:812">DirectFunctionCall2Coll</a>(<a href="#L1619" title="utils/adt/varlena.c:1619">texteq</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(txt1),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(txt2)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4514" title="utils/adt/varlena.c:4514">text_to_array</a><br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> input string and return text array of elements,<br/></li>
<li></span><span class="Comment"> * based on provided field separator<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4514">&#x200c;</a><span class="linkable">text_to_array</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="utils/adt/varlena.c:108">SplitTextOutputData</a> tstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For array output, tstate should start as all zeroes */<br/></li>
<li></span>&nbsp; &nbsp; memset(&amp;tstate, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tstate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L4591" title="utils/adt/varlena.c:4591">split_text</a>(fcinfo, &amp;tstate))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tstate.astate == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_ARRAYTYPE_P(<a href="arrayfuncs.c.html#L3561" title="utils/adt/arrayfuncs.c:3561">construct_empty_array</a>(TEXTOID));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(<a href="arrayfuncs.c.html#L5401" title="utils/adt/arrayfuncs.c:5401">makeArrayResult</a>(tstate.astate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4540" title="utils/adt/varlena.c:4540">text_to_array_null</a><br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> input string and return text array of elements,<br/></li>
<li></span><span class="Comment"> * based on provided field separator and null string<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a separate entry point only to prevent the regression tests from<br/></li>
<li></span><span class="Comment"> * complaining about different argument sets for the same <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4540">&#x200c;</a><span class="linkable">text_to_array_null</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L4514" title="utils/adt/varlena.c:4514">text_to_array</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4551" title="utils/adt/varlena.c:4551">text_to_table</a><br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> input string and return table of elements,<br/></li>
<li></span><span class="Comment"> * based on provided field separator<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4551">&#x200c;</a><span class="linkable">text_to_table</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReturnSetInfo *rsi = (ReturnSetInfo *) fcinfo-&gt;resultinfo;<br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="utils/adt/varlena.c:108">SplitTextOutputData</a> tstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tstate.astate = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../fmgr/funcapi.c.html#L76" title="utils/fmgr/funcapi.c:76">InitMaterializedSRF</a>(fcinfo, MAT_SRF_USE_EXPECTED_DESC);<br/></li>
<li>&nbsp; &nbsp; tstate.tupstore = rsi-&gt;setResult;<br/></li>
<li>&nbsp; &nbsp; tstate.tupdesc = rsi-&gt;setDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L4591" title="utils/adt/varlena.c:4591">split_text</a>(fcinfo, &amp;tstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4575" title="utils/adt/varlena.c:4575">text_to_table_null</a><br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> input string and return table of elements,<br/></li>
<li></span><span class="Comment"> * based on provided field separator and null string<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a separate entry point only to prevent the regression tests from<br/></li>
<li></span><span class="Comment"> * complaining about different argument sets for the same <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4575">&#x200c;</a><span class="linkable">text_to_table_null</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L4551" title="utils/adt/varlena.c:4551">text_to_table</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Common code for <a href="#L4514" title="utils/adt/varlena.c:4514">text_to_array</a>, <a href="#L4540" title="utils/adt/varlena.c:4540">text_to_array_null</a>, <a href="#L4551" title="utils/adt/varlena.c:4551">text_to_table</a><br/></li>
<li></span><span class="Comment"> * and <a href="#L4575" title="utils/adt/varlena.c:4575">text_to_table_null</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These are not strict so we have to test for null inputs explicitly.<br/></li>
<li></span><span class="Comment"> * Returns false if result is to be null, else returns true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that if the result is valid but empty (zero elements), we return<br/></li>
<li></span><span class="Comment"> * without changing *tstate --- caller must handle that case, too.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4591">&#x200c;</a></span><span class="linkable">split_text</span>(FunctionCallInfo fcinfo, <a href="#L108" title="utils/adt/varlena.c:108">SplitTextOutputData</a> *tstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *inputstring;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *fldsep;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *null_string;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inputstring_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fldsep_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *start_ptr;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result_text;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* when input string is NULL, then result is NULL too */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; inputstring = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fldsep can be NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fldsep = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fldsep = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* null_string can be NULL or omitted */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_NARGS() &gt; <span class="Constant">2</span> &amp;&amp; !PG_ARGISNULL(<span class="Constant">2</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; null_string = PG_GETARG_TEXT_PP(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; null_string = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fldsep != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Normal case with non-null fldsep.&nbsp; Use the <a href="#L1176" title="utils/adt/varlena.c:1176">text_position</a> machinery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to search for occurrences of fldsep.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="utils/adt/varlena.c:78">TextPositionState</a> state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inputstring_len = VARSIZE_ANY_EXHDR(inputstring);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fldsep_len = VARSIZE_ANY_EXHDR(fldsep);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return empty set for empty input string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (inputstring_len &lt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* empty field separator: return input string as a one-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fldsep_len &lt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4727" title="utils/adt/varlena.c:4727">split_text_accum_result</a>(tstate, inputstring,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; null_string, collation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1216" title="utils/adt/varlena.c:1216">text_position_setup</a>(inputstring, fldsep, collation, &amp;state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; start_ptr = VARDATA_ANY(inputstring);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *end_ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunk_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <a href="#L1336" title="utils/adt/varlena.c:1336">text_position_next</a>(&amp;state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fetch last field */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunk_len = ((<span class="Type">char</span> *) inputstring + VARSIZE_ANY(inputstring)) - start_ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_ptr = <span class="Constant">NULL</span>; <span class="Comment">/* not used, but some compilers complain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fetch non-last field */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_ptr = <a href="#L1468" title="utils/adt/varlena.c:1468">text_position_get_match_ptr</a>(&amp;state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunk_len = end_ptr - start_ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* build a temp text datum to pass to <a href="#L4727" title="utils/adt/varlena.c:4727">split_text_accum_result</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_text = <a href="#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(start_ptr, chunk_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* stash away this field */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4727" title="utils/adt/varlena.c:4727">split_text_accum_result</a>(tstate, result_text,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; null_string, collation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(result_text);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start_ptr = end_ptr + fldsep_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1503" title="utils/adt/varlena.c:1503">text_position_cleanup</a>(&amp;state);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When fldsep is NULL, each character in the input string becomes a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * separate <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> in the result set.&nbsp; The separator is effectively<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the space between characters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; inputstring_len = VARSIZE_ANY_EXHDR(inputstring);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; start_ptr = VARDATA_ANY(inputstring);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (inputstring_len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunk_len = <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(start_ptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* build a temp text datum to pass to <a href="#L4727" title="utils/adt/varlena.c:4727">split_text_accum_result</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_text = <a href="#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(start_ptr, chunk_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* stash away this field */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4727" title="utils/adt/varlena.c:4727">split_text_accum_result</a>(tstate, result_text,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; null_string, collation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(result_text);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start_ptr += chunk_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inputstring_len -= chunk_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add text item to result set (table or array).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is also responsible for checking to see if the item matches<br/></li>
<li></span><span class="Comment"> * the null_string, in which case we should emit NULL instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4727">&#x200c;</a></span><span class="linkable">split_text_accum_result</span>(<a href="#L108" title="utils/adt/varlena.c:108">SplitTextOutputData</a> *tstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text *field_value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text *null_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid collation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_null = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (null_string &amp;&amp; <a href="#L4500" title="utils/adt/varlena.c:4500">text_isequal</a>(field_value, null_string, collation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; is_null = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tstate-&gt;tupstore)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = PointerGetDatum(field_value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">0</span>] = is_null;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../sort/tuplestore.c.html#L750" title="utils/sort/tuplestore.c:750">tuplestore_putvalues</a>(tstate-&gt;tupstore,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tstate-&gt;tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nulls);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tstate-&gt;astate = <a href="arrayfuncs.c.html#L5331" title="utils/adt/arrayfuncs.c:5331">accumArrayResult</a>(tstate-&gt;astate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(field_value),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_null,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TEXTOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4766" title="utils/adt/varlena.c:4766">array_to_text</a><br/></li>
<li></span><span class="Comment"> * concatenate Cstring representation of input array elements<br/></li>
<li></span><span class="Comment"> * using provided field separator<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4766">&#x200c;</a><span class="linkable">array_to_text</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *v = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *fldsep = <a href="#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L4808" title="utils/adt/varlena.c:4808">array_to_text_internal</a>(fcinfo, v, fldsep, <span class="Constant">NULL</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4782" title="utils/adt/varlena.c:4782">array_to_text_null</a><br/></li>
<li></span><span class="Comment"> * concatenate Cstring representation of input array elements<br/></li>
<li></span><span class="Comment"> * using provided field separator and null string<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This version is not strict so we have to test for null inputs explicitly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4782">&#x200c;</a><span class="linkable">array_to_text_null</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *v;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *fldsep;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *null_string;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* returns NULL when first or second parameter is NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>) || PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v = PG_GETARG_ARRAYTYPE_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; fldsep = <a href="#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NULL null string is passed through as a null pointer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">2</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; null_string = <a href="#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">2</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; null_string = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L4808" title="utils/adt/varlena.c:4808">array_to_text_internal</a>(fcinfo, v, fldsep, null_string));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * common code for <a href="#L4766" title="utils/adt/varlena.c:4766">array_to_text</a> and <a href="#L4782" title="utils/adt/varlena.c:4782">array_to_text_null</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> text *<br/></li>
<li><a id="L4808">&#x200c;</a><span class="linkable">array_to_text_internal</span>(FunctionCallInfo fcinfo, ArrayType *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *fldsep, <span class="Type">const</span> <span class="Type">char</span> *null_string)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dims,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndims;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; element_type;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; typalign;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; printed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *bitmap;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; ArrayMetaState *my_extra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ndims = ARR_NDIM(v);<br/></li>
<li>&nbsp; &nbsp; dims = ARR_DIMS(v);<br/></li>
<li>&nbsp; &nbsp; nitems = <a href="arrayutils.c.html#L57" title="utils/adt/arrayutils.c:57">ArrayGetNItems</a>(ndims, dims);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if there are no elements, return an empty string */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nitems == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(<span class="Constant">&quot;&quot;</span>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; element_type = ARR_ELEMTYPE(v);<br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We arrange to look up info about <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type, including its output<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conversion proc, only once per series of calls, assuming the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * type doesn't change underneath us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; my_extra = (ArrayMetaState *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(fcinfo-&gt;flinfo-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ArrayMetaState));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra = (ArrayMetaState *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;element_type = ~element_type;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra-&gt;element_type != element_type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get info about <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type, including its output conversion proc<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2325" title="utils/cache/lsyscache.c:2325">get_type_io_data</a>(element_type, IOFunc_output,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;my_extra-&gt;typlen, &amp;my_extra-&gt;typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;my_extra-&gt;typalign, &amp;my_extra-&gt;typdelim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;my_extra-&gt;typioparam, &amp;my_extra-&gt;typiofunc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(my_extra-&gt;typiofunc, &amp;my_extra-&gt;proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_mcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;element_type = element_type;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; typlen = my_extra-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; typbyval = my_extra-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; typalign = my_extra-&gt;typalign;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; p = ARR_DATA_PTR(v);<br/></li>
<li>&nbsp; &nbsp; bitmap = ARR_NULLBITMAP(v);<br/></li>
<li>&nbsp; &nbsp; bitmask = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; itemvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get source <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, checking for NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bitmap &amp;&amp; (*bitmap &amp; bitmask) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if null_string is NULL, we just ignore null elements */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (null_string != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (printed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">&quot;</span>, fldsep, null_string);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, null_string);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemvalue = fetch_att(p, typbyval, typlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = <a href="../fmgr/fmgr.c.html#L1683" title="utils/fmgr/fmgr.c:1683">OutputFunctionCall</a>(&amp;my_extra-&gt;proc, itemvalue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (printed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">&quot;</span>, fldsep, value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printed = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = att_addlength_pointer(p, typlen, p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = (<span class="Type">char</span> *) att_align_nominal(p, typalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* advance bitmap pointer if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bitmap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask &lt;&lt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bitmask == <span class="Constant">0x100</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmap++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(buf.data, buf.len);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Workhorse for to_bin, to_oct, and to_hex.&nbsp; Note that base must be &gt; 1 and &lt;=<br/></li>
<li></span><span class="Comment"> * 16.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> text *<br/></li>
<li><a id="L4930">&#x200c;</a><span class="linkable">convert_to_base</span>(uint64 value, <span class="Type">int</span> base)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *digits = <span class="Constant">&quot;0123456789abcdef&quot;</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We size the buffer for to_bin's <a href="../../regex/rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a> possible return value. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint64) * BITS_PER_BYTE];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="Type">const</span> end = buf + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr = end;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(base &gt; <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(base &lt;= <span class="Constant">16</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *--ptr = digits[value % base];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; value /= base;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (ptr &gt; buf &amp;&amp; value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(ptr, end - ptr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert an integer to a string containing a base-2 (binary) representation<br/></li>
<li></span><span class="Comment"> * of the number.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4956">&#x200c;</a><span class="linkable">to_bin32</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; value = (uint32) PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L4930" title="utils/adt/varlena.c:4930">convert_to_base</a>(value, <span class="Constant">2</span>));<br/></li>
<li>}<br/></li>
<li>Datum<br/></li>
<li><a id="L4963">&#x200c;</a><span class="linkable">to_bin64</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; value = (uint64) PG_GETARG_INT64(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L4930" title="utils/adt/varlena.c:4930">convert_to_base</a>(value, <span class="Constant">2</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert an integer to a string containing a base-8 (oct) representation of<br/></li>
<li></span><span class="Comment"> * the number.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4975">&#x200c;</a><span class="linkable">to_oct32</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; value = (uint32) PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L4930" title="utils/adt/varlena.c:4930">convert_to_base</a>(value, <span class="Constant">8</span>));<br/></li>
<li>}<br/></li>
<li>Datum<br/></li>
<li><a id="L4982">&#x200c;</a><span class="linkable">to_oct64</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; value = (uint64) PG_GETARG_INT64(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L4930" title="utils/adt/varlena.c:4930">convert_to_base</a>(value, <span class="Constant">8</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert an integer to a string containing a base-16 (hex) representation of<br/></li>
<li></span><span class="Comment"> * the number.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4994">&#x200c;</a><span class="linkable">to_hex32</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; value = (uint32) PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L4930" title="utils/adt/varlena.c:4930">convert_to_base</a>(value, <span class="Constant">16</span>));<br/></li>
<li>}<br/></li>
<li>Datum<br/></li>
<li><a id="L5001">&#x200c;</a><span class="linkable">to_hex64</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; value = (uint64) PG_GETARG_INT64(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L4930" title="utils/adt/varlena.c:4930">convert_to_base</a>(value, <span class="Constant">16</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the size of a datum, possibly compressed<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Works on <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data type<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5014">&#x200c;</a><span class="linkable">pg_column_size</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; value = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* On first call, get the input type's typlen, and save at *fn_extra */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;flinfo-&gt;fn_extra == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Lookup the datatype of the supplied argument */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; argtypeid = <a href="../fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>(fcinfo-&gt;flinfo, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typlen = <a href="../cache/lsyscache.c.html#L2197" title="utils/cache/lsyscache.c:2197">get_typlen</a>(argtypeid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typlen == <span class="Constant">0</span>)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should not happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, argtypeid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(fcinfo-&gt;flinfo-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *((<span class="Type">int</span> *) fcinfo-&gt;flinfo-&gt;fn_extra) = typlen;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typlen = *((<span class="Type">int</span> *) fcinfo-&gt;flinfo-&gt;fn_extra);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* varlena type, possibly toasted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../access/common/detoast.c.html#L601" title="access/common/detoast.c:601">toast_datum_size</a>(value);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (typlen == -<span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cstring */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = strlen(DatumGetCString(value)) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ordinary fixed-width type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = typlen;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the compression method stored in the compressed attribute.&nbsp; Return<br/></li>
<li></span><span class="Comment"> * NULL for non varlena type or uncompressed data.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5061">&#x200c;</a><span class="linkable">pg_column_compression</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; ToastCompressionId cmid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* On first call, get the input type's typlen, and save at *fn_extra */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;flinfo-&gt;fn_extra == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Lookup the datatype of the supplied argument */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; argtypeid = <a href="../fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>(fcinfo-&gt;flinfo, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typlen = <a href="../cache/lsyscache.c.html#L2197" title="utils/cache/lsyscache.c:2197">get_typlen</a>(argtypeid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typlen == <span class="Constant">0</span>)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should not happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, argtypeid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(fcinfo-&gt;flinfo-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *((<span class="Type">int</span> *) fcinfo-&gt;flinfo-&gt;fn_extra) = typlen;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typlen = *((<span class="Type">int</span> *) fcinfo-&gt;flinfo-&gt;fn_extra);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typlen != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* get the compression method id stored in the compressed varlena */<br/></li>
<li></span>&nbsp; &nbsp; cmid = <a href="../../access/common/toast_compression.c.html#L254" title="access/common/toast_compression.c:254">toast_get_compression_id</a>((<span class="Type">struct</span> varlena *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetPointer(PG_GETARG_DATUM(<span class="Constant">0</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cmid == TOAST_INVALID_COMPRESSION_ID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* convert compression method id to compression method name */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (cmid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TOAST_PGLZ_COMPRESSION_ID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">&quot;pglz&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TOAST_LZ4_COMPRESSION_ID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">&quot;lz4&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid compression method id </span><span class="Special">%d</span><span class="Constant">&quot;</span>, cmid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(result));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the chunk_id of the on-disk TOASTed value.&nbsp; Return NULL if the value<br/></li>
<li></span><span class="Comment"> * is un-TOASTed or not on-disk.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5114">&#x200c;</a><span class="linkable">pg_column_toast_chunk_id</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> varlena *attr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> varatt_external toast_pointer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* On first call, get the input type's typlen, and save at *fn_extra */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;flinfo-&gt;fn_extra == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Lookup the datatype of the supplied argument */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; argtypeid = <a href="../fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>(fcinfo-&gt;flinfo, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typlen = <a href="../cache/lsyscache.c.html#L2197" title="utils/cache/lsyscache.c:2197">get_typlen</a>(argtypeid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typlen == <span class="Constant">0</span>)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should not happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, argtypeid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(fcinfo-&gt;flinfo-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *((<span class="Type">int</span> *) fcinfo-&gt;flinfo-&gt;fn_extra) = typlen;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typlen = *((<span class="Type">int</span> *) fcinfo-&gt;flinfo-&gt;fn_extra);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typlen != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attr = (<span class="Type">struct</span> varlena *) DatumGetPointer(PG_GETARG_DATUM(<span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!VARATT_IS_EXTERNAL_ONDISK(attr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; VARATT_EXTERNAL_GET_POINTER(toast_pointer, attr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_OID(toast_pointer.va_valueid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * string_agg - Concatenates <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and returns string.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Syntax: string_agg(value text, delimiter text) RETURNS text<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: Any NULL <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are ignored. The first-call delimiter isn't<br/></li>
<li></span><span class="Comment"> * actually used at all, and on subsequent calls the delimiter precedes<br/></li>
<li></span><span class="Comment"> * the associated value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* subroutine to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> state */<br/></li>
<li></span><span class="Type">static</span> StringInfo<br/></li>
<li><a id="L5162">&#x200c;</a><span class="linkable">makeStringAggState</span>(FunctionCallInfo fcinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; state;<br/></li>
<li>&nbsp; &nbsp; MemoryContext aggcontext;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, &amp;aggcontext))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cannot be called directly because of <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>-type argument */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L5186" title="utils/adt/varlena.c:5186">string_agg_transfn</a> called in non-aggregate context&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create state in aggregate context.&nbsp; It'll stay there across subsequent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calls.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(aggcontext);<br/></li>
<li>&nbsp; &nbsp; state = makeStringInfo();<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L5186">&#x200c;</a><span class="linkable">string_agg_transfn</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Append the value unless null, preceding it with the delimiter. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *value = PG_GETARG_TEXT_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isfirst = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * You might think we can just throw away the first delimiter, however<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we must keep it as we may be a parallel worker doing partial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aggregation building a state to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> to the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> process.&nbsp; We need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to keep the delimiter of every aggregation so that the <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function can properly join up the strings of two separately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partially aggregated results.&nbsp; The first delimiter is only stripped<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * off in the final function.&nbsp; To know how much to strip off the front<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the string, we store the length of the first delimiter in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * StringInfo's cursor field, which we don't otherwise need here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state = <a href="#L5162" title="utils/adt/varlena.c:5162">makeStringAggState</a>(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isfirst = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(<span class="Constant">2</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *delim = PG_GETARG_TEXT_PP(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xml.c.html#L459" title="utils/adt/xml.c:459">appendStringInfoText</a>(state, delim);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isfirst)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;cursor = VARSIZE_ANY_EXHDR(delim);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xml.c.html#L459" title="utils/adt/xml.c:459">appendStringInfoText</a>(state, value);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The transition type for string_agg() is declared to be &quot;<a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>&quot;,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which is a pass-by-value type the same size as a pointer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(state);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5241" title="utils/adt/varlena.c:5241">string_agg_combine</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Aggregate <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> function for string_agg(text) and string_agg(bytea)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5241">&#x200c;</a><span class="linkable">string_agg_combine</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; state1;<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; state2;<br/></li>
<li>&nbsp; &nbsp; MemoryContext agg_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, &amp;agg_context))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;aggregate function called in non-aggregate context&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state1 = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; state2 = PG_ARGISNULL(<span class="Constant">1</span>) ? <span class="Constant">NULL</span> : (StringInfo) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state2 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NULL state2 is easy, just return state1, which we know is already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the agg_context<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state1 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(state1);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state1 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We must copy state2's data into the agg_context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext old_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; old_context = MemoryContextSwitchTo(agg_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1 = <a href="#L5162" title="utils/adt/varlena.c:5162">makeStringAggState</a>(fcinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(state1, state2-&gt;data, state2-&gt;len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state1-&gt;cursor = state2-&gt;cursor;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (state2-&gt;len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Combine ... state1-&gt;cursor does not change in this case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(state1, state2-&gt;data, state2-&gt;len);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(state1);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5291" title="utils/adt/varlena.c:5291">string_agg_serialize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Aggregate serialize function for string_agg(text) and string_agg(bytea)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is strict, so we need not handle NULL input<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5291">&#x200c;</a><span class="linkable">string_agg_serialize</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; state;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cannot be called directly because of <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>-type argument */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cursor */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint(&amp;buf, state-&gt;cursor, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* data */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L126" title="libpq/pqformat.c:126">pq_sendbytes</a>(&amp;buf, state-&gt;data, state-&gt;len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5322" title="utils/adt/varlena.c:5322">string_agg_deserialize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Aggregate deserial function for string_agg(text) and string_agg(bytea)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is strict, so we need not handle NULL input<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5322">&#x200c;</a><span class="linkable">string_agg_deserialize</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *sstate;<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *data;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datalen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cannot be called directly because of <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>-type argument */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sstate = PG_GETARG_BYTEA_PP(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize a StringInfo so that we can &quot;receive&quot; it using the standard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../port/win32/socket.c.html#L37" title="port/win32/socket.c:37">recv</a>-function infrastructure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; initReadOnlyStringInfo(&amp;buf, VARDATA_ANY(sstate),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(sstate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L5162" title="utils/adt/varlena.c:5162">makeStringAggState</a>(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cursor */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;cursor = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(&amp;buf, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* data */<br/></li>
<li></span>&nbsp; &nbsp; datalen = VARSIZE_ANY_EXHDR(sstate) - <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; data = (<span class="Type">char</span> *) <a href="../../libpq/pqformat.c.html#L508" title="libpq/pqformat.c:508">pq_getmsgbytes</a>(&amp;buf, datalen);<br/></li>
<li>&nbsp; &nbsp; appendBinaryStringInfo(result, data, datalen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L635" title="libpq/pqformat.c:635">pq_getmsgend</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L5358">&#x200c;</a><span class="linkable">string_agg_finalfn</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cannot be called directly because of <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>-type argument */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../executor/nodeAgg.c.html#L4511" title="executor/nodeAgg.c:4511">AggCheckCallContext</a>(fcinfo, <span class="Constant">NULL</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = PG_ARGISNULL(<span class="Constant">0</span>) ? <span class="Constant">NULL</span> : (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* As per comment in transfn, strip data <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the cursor position */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(&amp;state-&gt;data[state-&gt;cursor],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;len - state-&gt;cursor));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare cache with fmgr info for the output <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> of the datatypes of<br/></li>
<li></span><span class="Comment"> * the arguments of a concat-like function, beginning with argument &quot;argidx&quot;.<br/></li>
<li></span><span class="Comment"> * (Arguments <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> that will have corresponding slots in the resulting<br/></li>
<li></span><span class="Comment"> * FmgrInfo array, but we don't fill those slots.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> FmgrInfo *<br/></li>
<li><a id="L5384">&#x200c;</a><span class="linkable">build_concat_foutcache</span>(FunctionCallInfo fcinfo, <span class="Type">int</span> argidx)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *foutcache;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We keep the info in fn_mcxt so it survives across calls */<br/></li>
<li></span>&nbsp; &nbsp; foutcache = (FmgrInfo *) <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(fcinfo-&gt;flinfo-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_NARGS() * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FmgrInfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = argidx; i &lt; PG_NARGS(); i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valtype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typOutput;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typIsVarlena;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; valtype = <a href="../fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>(fcinfo-&gt;flinfo, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(valtype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not determine data type of concat() input&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2907" title="utils/cache/lsyscache.c:2907">getTypeOutputInfo</a>(valtype, &amp;typOutput, &amp;typIsVarlena);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(typOutput, &amp;foutcache[i], fcinfo-&gt;flinfo-&gt;fn_mcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = foutcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> foutcache;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Implementation of both concat() and concat_ws().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * sepstr is the separator string to place between <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> * argidx identifies the first argument to concatenate (counting from zero);<br/></li>
<li></span><span class="Comment"> * note that this must be constant across <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one series of calls.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns NULL if result should be NULL, else text value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> text *<br/></li>
<li><a id="L5422">&#x200c;</a><span class="linkable">concat_internal</span>(<span class="Type">const</span> <span class="Type">char</span> *sepstr, <span class="Type">int</span> argidx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FunctionCallInfo fcinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; StringInfoData str;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *foutcache;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; first_arg = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concat(VARIADIC some-array) is essentially equivalent to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L4766" title="utils/adt/varlena.c:4766">array_to_text</a>(), ie concat the array elements with the given separator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * So we just pass the case off to that code.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../fmgr/fmgr.c.html#L2044" title="utils/fmgr/fmgr.c:2044">get_fn_expr_variadic</a>(fcinfo-&gt;flinfo))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *arr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Should have just the one argument */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(argidx == PG_NARGS() - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* concat(VARIADIC NULL) is defined as NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(argidx))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Non-null argument had better be an array.&nbsp; We assume that <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * context that could let <a href="../fmgr/fmgr.c.html#L2044" title="utils/fmgr/fmgr.c:2044">get_fn_expr_variadic</a> return true will have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checked that a VARIADIC-labeled parameter actually is an array.&nbsp; So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it should be okay to just Assert that it's an array rather than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doing a full-fledged error check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(<a href="../cache/lsyscache.c.html#L2832" title="utils/cache/lsyscache.c:2832">get_base_element_type</a>(<a href="../fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>(fcinfo-&gt;flinfo, argidx))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, safe to fetch the array value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; arr = PG_GETARG_ARRAYTYPE_P(argidx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * And serialize the array.&nbsp; We tell <a href="#L4766" title="utils/adt/varlena.c:4766">array_to_text</a> to ignore null<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * elements, which matches the behavior of the loop below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L4808" title="utils/adt/varlena.c:4808">array_to_text_internal</a>(fcinfo, arr, sepstr, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Normal case without explicit VARIADIC marker */<br/></li>
<li></span>&nbsp; &nbsp; initStringInfo(&amp;str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get output function info, building it if first time through */<br/></li>
<li></span>&nbsp; &nbsp; foutcache = (FmgrInfo *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (foutcache == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foutcache = <a href="#L5384" title="utils/adt/varlena.c:5384">build_concat_foutcache</a>(fcinfo, argidx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = argidx; i &lt; PG_NARGS(); i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!PG_ARGISNULL(i))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; value = PG_GETARG_DATUM(i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* add separator if appropriate */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (first_arg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first_arg = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;str, sepstr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* call the appropriate type output function, append the result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../fmgr/fmgr.c.html#L1683" title="utils/fmgr/fmgr.c:1683">OutputFunctionCall</a>(&amp;foutcache[i], value));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(str.data, str.len);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(str.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Concatenate all arguments. NULL arguments are ignored.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5502">&#x200c;</a><span class="linkable">text_concat</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L5422" title="utils/adt/varlena.c:5422">concat_internal</a>(<span class="Constant">&quot;&quot;</span>, <span class="Constant">0</span>, fcinfo);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Concatenate all but first argument value with separators. The first<br/></li>
<li></span><span class="Comment"> * parameter is used as the separator. NULL arguments are ignored.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5517">&#x200c;</a><span class="linkable">text_concat_ws</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *sep;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* return NULL when separator is NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; sep = <a href="#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L5422" title="utils/adt/varlena.c:5422">concat_internal</a>(sep, <span class="Constant">1</span>, fcinfo);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return first n characters in the string. When n is negative,<br/></li>
<li></span><span class="Comment"> * return all but last |n| characters.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5538">&#x200c;</a><span class="linkable">text_left</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *p = VARDATA_ANY(str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = VARSIZE_ANY_EXHDR(str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n = <a href="../mb/mbutils.c.html#L1057" title="utils/mb/mbutils.c:1057">pg_mbstrlen_with_len</a>(p, len) + n;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rlen = <a href="../mb/mbutils.c.html#L1125" title="utils/mb/mbutils.c:1125">pg_mbcharcliplen</a>(p, len, n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(p, rlen));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L885" title="utils/adt/varlena.c:885">text_substring</a>(PG_GETARG_DATUM(<span class="Constant">0</span>), <span class="Constant">1</span>, n, <span class="Constant">false</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return last n characters in the string. When n is negative,<br/></li>
<li></span><span class="Comment"> * return all but first |n| characters.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5562">&#x200c;</a><span class="linkable">text_right</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *p = VARDATA_ANY(str);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = VARSIZE_ANY_EXHDR(str);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n = -n;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; n = <a href="../mb/mbutils.c.html#L1057" title="utils/mb/mbutils.c:1057">pg_mbstrlen_with_len</a>(p, len) - n;<br/></li>
<li>&nbsp; &nbsp; off = <a href="../mb/mbutils.c.html#L1125" title="utils/mb/mbutils.c:1125">pg_mbcharcliplen</a>(p, len, n);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(p + off, len - off));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return reversed string<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5583">&#x200c;</a><span class="linkable">text_reverse</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *str = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *p = VARDATA_ANY(str);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = VARSIZE_ANY_EXHDR(str);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *endp = p + len;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *dst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; dst = (<span class="Type">char</span> *) VARDATA(result) + len;<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, len + VARHDRSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../mb/mbutils.c.html#L1546" title="utils/mb/mbutils.c:1546">pg_database_encoding_max_length</a>() &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* multibyte version */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (p &lt; endp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz = <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dst -= sz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(dst, p, sz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p += sz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* single byte version */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (p &lt; endp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *(--dst) = *p++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Support macros for <a href="#L5638" title="utils/adt/varlena.c:5638">text_format</a>()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L5623">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TEXT_FORMAT_FLAG_MINUS</span>&nbsp; &nbsp; </span><span class="Constant">0x0001</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* is minus flag present? */<br/></li>
<li></span><br/></li>
<li><a id="L5625">&#x200c;</a><span class="PreProc">#define <span class="linkable">ADVANCE_PARSE_POINTER</span>(ptr,end_ptr) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (++(ptr) &gt;= (end_ptr)) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(</span><span class="Constant">&quot;unterminated format() type specifier&quot;</span><span class="PreProc">), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(</span><span class="Constant">&quot;For a single </span><span class="Special">\&quot;%%\&quot;</span><span class="Constant"> use </span><span class="Special">\&quot;%%%%\&quot;</span><span class="Constant">.&quot;</span><span class="PreProc">))); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns a formatted string<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5638">&#x200c;</a><span class="linkable">text_format</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *fmt;<br/></li>
<li>&nbsp; &nbsp; StringInfoData str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *cp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *start_ptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *end_ptr;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; funcvariadic;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nargs;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *elements = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; element_type = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev_type = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev_width_type = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; typoutputfinfo;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; typoutputinfo_width;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* When format string is null, immediately return null */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If argument is marked VARIADIC, expand array into elements */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../fmgr/fmgr.c.html#L2044" title="utils/fmgr/fmgr.c:2044">get_fn_expr_variadic</a>(fcinfo-&gt;flinfo))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *arr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; elmlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; elmbyval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; elmalign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Should have just the one argument */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(PG_NARGS() == <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If argument is NULL, we treat it as zero-length array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Non-null argument had better be an array.&nbsp; We assume that <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * call context that could let <a href="../fmgr/fmgr.c.html#L2044" title="utils/fmgr/fmgr.c:2044">get_fn_expr_variadic</a> return true<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will have checked that a VARIADIC-labeled parameter actually is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an array.&nbsp; So it should be okay to just Assert that it's an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * array rather than doing a full-fledged error check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(<a href="../cache/lsyscache.c.html#L2832" title="utils/cache/lsyscache.c:2832">get_base_element_type</a>(<a href="../fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>(fcinfo-&gt;flinfo, <span class="Constant">1</span>))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, safe to fetch the array value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arr = PG_GETARG_ARRAYTYPE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get info about array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; element_type = ARR_ELEMTYPE(arr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2271" title="utils/cache/lsyscache.c:2271">get_typlenbyvalalign</a>(element_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;elmlen, &amp;elmbyval, &amp;elmalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Extract all array elements */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="arrayfuncs.c.html#L3612" title="utils/adt/arrayfuncs.c:3612">deconstruct_array</a>(arr, element_type, elmlen, elmbyval, elmalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;elements, &amp;nulls, &amp;nitems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nargs = nitems + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcvariadic = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Non-variadic case, we'll process the arguments individually */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nargs = PG_NARGS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcvariadic = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Setup for <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop. */<br/></li>
<li></span>&nbsp; &nbsp; fmt = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; start_ptr = VARDATA_ANY(fmt);<br/></li>
<li>&nbsp; &nbsp; end_ptr = start_ptr + VARSIZE_ANY_EXHDR(fmt);<br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;str);<br/></li>
<li>&nbsp; &nbsp; arg = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> argument position to <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan format string, looking for conversion specifiers. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (cp = start_ptr; cp &lt; end_ptr; cp++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; argpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; widthpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; width;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's not the start of a conversion specifier, just copy it to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the output buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp != <span class="Constant">'%'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoCharMacro(&amp;str, *cp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5625" title="utils/adt/varlena.c:5625">ADVANCE_PARSE_POINTER</a>(cp, end_ptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Easy case: %% outputs a single % */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp == <span class="Constant">'%'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoCharMacro(&amp;str, *cp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Parse the optional portions of the format specifier */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cp = <a href="#L5964" title="utils/adt/varlena.c:5964">text_format_parse_format</a>(cp, end_ptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;argpos, &amp;widthpos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;flags, &amp;width);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Next we should see the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> conversion specifier.&nbsp; Whether or not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an argument position was present, it's known that at least one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * character remains in the string at this point.&nbsp; Experience suggests<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that it's worth checking that that character is one of the expected<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ones <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we try to fetch arguments, so as to produce the least<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * confusing response to a mis-formatted specifier.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strchr(<span class="Constant">&quot;sIL&quot;</span>, *cp) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unrecognized format() type specifier </span><span class="Special">\&quot;%.*s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(cp), cp),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;For a single </span><span class="Special">\&quot;%%\&quot;</span><span class="Constant"> use </span><span class="Special">\&quot;%%%%\&quot;</span><span class="Constant">.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If indirect width was specified, get its value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (widthpos &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Collect the specified or <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> argument position */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (widthpos &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg = widthpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arg &gt;= nargs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;too few arguments for format()&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the value and type of the selected argument */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!funcvariadic)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = PG_GETARG_DATUM(arg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isNull = PG_ARGISNULL(arg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typid = <a href="../fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>(fcinfo-&gt;flinfo, arg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = elements[arg - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isNull = nulls[arg - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typid = element_type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(typid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not determine data type of format() input&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can treat NULL width the same as zero */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; width = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (typid == INT4OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; width = DatumGetInt32(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (typid == INT2OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; width = DatumGetInt16(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* For less-usual datatypes, convert to text then to int */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typid != prev_width_type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typoutputfunc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typIsVarlena;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2907" title="utils/cache/lsyscache.c:2907">getTypeOutputInfo</a>(typid, &amp;typoutputfunc, &amp;typIsVarlena);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(typoutputfunc, &amp;typoutputinfo_width);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev_width_type = typid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="../fmgr/fmgr.c.html#L1683" title="utils/fmgr/fmgr.c:1683">OutputFunctionCall</a>(&amp;typoutputinfo_width, value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="numutils.c.html#L383" title="utils/adt/numutils.c:383">pg_strtoint32</a> will complain about bad data or overflow */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; width = <a href="numutils.c.html#L383" title="utils/adt/numutils.c:383">pg_strtoint32</a>(str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Collect the specified or <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> argument position */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (argpos &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg = argpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arg &gt;= nargs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;too few arguments for format()&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the value and type of the selected argument */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!funcvariadic)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = PG_GETARG_DATUM(arg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isNull = PG_ARGISNULL(arg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typid = <a href="../fmgr/fmgr.c.html#L1910" title="utils/fmgr/fmgr.c:1910">get_fn_expr_argtype</a>(fcinfo-&gt;flinfo, arg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = elements[arg - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isNull = nulls[arg - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typid = element_type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(typid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not determine data type of format() input&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arg++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get the appropriate typOutput function, reusing previous one if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same type as previous argument.&nbsp; That's particularly useful in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * variadic-array case, but often saves work even for ordinary calls.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typid != prev_type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typoutputfunc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typIsVarlena;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2907" title="utils/cache/lsyscache.c:2907">getTypeOutputInfo</a>(typid, &amp;typoutputfunc, &amp;typIsVarlena);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(typoutputfunc, &amp;typoutputfinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev_type = typid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * And <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we can format the value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (*cp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'s'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'I'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'L'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6041" title="utils/adt/varlena.c:6041">text_format_string_conversion</a>(&amp;str, *cp, &amp;typoutputfinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value, isNull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags, width);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should not get here, because of previous check */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unrecognized format() type specifier </span><span class="Special">\&quot;%.*s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mb/mbutils.c.html#L1023" title="utils/mb/mbutils.c:1023">pg_mblen</a>(cp), cp),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;For a single </span><span class="Special">\&quot;%%\&quot;</span><span class="Constant"> use </span><span class="Special">\&quot;%%%%\&quot;</span><span class="Constant">.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't need <a href="arrayfuncs.c.html#L3612" title="utils/adt/arrayfuncs.c:3612">deconstruct_array</a> results anymore. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (elements != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(elements);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nulls != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Generate results. */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(str.data, str.len);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(str.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Parse contiguous digits as a decimal number.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if some digits could be parsed.<br/></li>
<li></span><span class="Comment"> * The value is returned into *value, and *ptr is advanced to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment"> * character to be parsed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note parsing invariant: at least one character is known available <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * string end (end_ptr) at entry, and this is still true at exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L5915">&#x200c;</a></span><span class="linkable">text_format_parse_digits</span>(<span class="Type">const</span> <span class="Type">char</span> **ptr, <span class="Type">const</span> <span class="Type">char</span> *end_ptr, <span class="Type">int</span> *value)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *cp = *ptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (*cp &gt;= <span class="Constant">'0'</span> &amp;&amp; *cp &lt;= <span class="Constant">'9'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int8&nbsp; &nbsp; &nbsp; &nbsp; digit = (*cp - <span class="Constant">'0'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(pg_mul_s32_overflow(val, <span class="Constant">10</span>, &amp;val)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unlikely(pg_add_s32_overflow(val, digit, &amp;val)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;number is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5625" title="utils/adt/varlena.c:5625">ADVANCE_PARSE_POINTER</a>(cp, end_ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *ptr = cp;<br/></li>
<li>&nbsp; &nbsp; *value = val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> found;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Parse a format specifier (generally following the SUS printf spec).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We have already advanced over the initial '%', and we are looking for<br/></li>
<li></span><span class="Comment"> * [argpos][flags][width]type (but the type character is not consumed here).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Inputs are start_ptr (the position after '%') and end_ptr (string end + 1).<br/></li>
<li></span><span class="Comment"> * Output parameters:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; argpos: argument position for value to be printed.&nbsp; -1 means unspecified.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; widthpos: argument position for width.&nbsp; Zero means the argument position<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; was unspecified (ie, take the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> arg) and -1 means no width<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; argument (width was omitted or specified as a constant).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; flags: bitmask of flags.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; width: directly-specified width value.&nbsp; Zero means the width was omitted<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (note it's not necessary to distinguish this case from an explicit<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zero width value).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The function result is the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> character position to be parsed, ie, the<br/></li>
<li></span><span class="Comment"> * location where the type character is/should be.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note parsing invariant: at least one character is known available <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * string end (end_ptr) at entry, and this is still true at exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L5964">&#x200c;</a><span class="linkable">text_format_parse_format</span>(<span class="Type">const</span> <span class="Type">char</span> *start_ptr, <span class="Type">const</span> <span class="Type">char</span> *end_ptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *argpos, <span class="Type">int</span> *widthpos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *flags, <span class="Type">int</span> *width)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *cp = start_ptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set defaults for output parameters */<br/></li>
<li></span>&nbsp; &nbsp; *argpos = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; *widthpos = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; *flags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; *width = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* try to identify first number */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L5915" title="utils/adt/varlena.c:5915">text_format_parse_digits</a>(&amp;cp, end_ptr, &amp;n))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp != <span class="Constant">'$'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must be just a width and a type, so we're done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *width = n;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> cp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The number was argument position */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *argpos = n;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Explicit 0 for argument index is immediately refused */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (n == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;format specifies argument 0, but arguments are numbered from 1&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5625" title="utils/adt/varlena.c:5625">ADVANCE_PARSE_POINTER</a>(cp, end_ptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle flags (only minus is supported <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (*cp == <span class="Constant">'-'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *flags |= <a href="#L5623" title="utils/adt/varlena.c:5623">TEXT_FORMAT_FLAG_MINUS</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5625" title="utils/adt/varlena.c:5625">ADVANCE_PARSE_POINTER</a>(cp, end_ptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*cp == <span class="Constant">'*'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Handle indirect width */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5625" title="utils/adt/varlena.c:5625">ADVANCE_PARSE_POINTER</a>(cp, end_ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L5915" title="utils/adt/varlena.c:5915">text_format_parse_digits</a>(&amp;cp, end_ptr, &amp;n))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number in this position must be closed by $ */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp != <span class="Constant">'$'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;width argument position must be ended by </span><span class="Special">\&quot;</span><span class="Constant">$</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The number was width argument position */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *widthpos = n;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Explicit 0 for argument index is immediately refused */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (n == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;format specifies argument 0, but arguments are numbered from 1&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5625" title="utils/adt/varlena.c:5625">ADVANCE_PARSE_POINTER</a>(cp, end_ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *widthpos = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* width's argument position is unspecified */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for direct width specification */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L5915" title="utils/adt/varlena.c:5915">text_format_parse_digits</a>(&amp;cp, end_ptr, &amp;n))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *width = n;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cp should <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> be pointing at type character */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> cp;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Format a %s, %I, or %L conversion<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6041">&#x200c;</a></span><span class="linkable">text_format_string_conversion</span>(StringInfo buf, <span class="Type">char</span> conversion,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo *typOutputInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum value, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isNull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> flags, <span class="Type">int</span> width)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle NULL arguments <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> trying to stringify the value. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isNull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (conversion == <span class="Constant">'s'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6090" title="utils/adt/varlena.c:6090">text_format_append_string</a>(buf, <span class="Constant">&quot;&quot;</span>, flags, width);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (conversion == <span class="Constant">'L'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6090" title="utils/adt/varlena.c:6090">text_format_append_string</a>(buf, <span class="Constant">&quot;NULL&quot;</span>, flags, width);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (conversion == <span class="Constant">'I'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NULL_VALUE_NOT_ALLOWED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;null <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> cannot be formatted as an SQL identifier&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Stringify. */<br/></li>
<li></span>&nbsp; &nbsp; str = <a href="../fmgr/fmgr.c.html#L1683" title="utils/fmgr/fmgr.c:1683">OutputFunctionCall</a>(typOutputInfo, value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Escape. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (conversion == <span class="Constant">'I'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="ruleutils.c.html#L12623" title="utils/adt/ruleutils.c:12623">quote_identifier</a> may or may not allocate a new string. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6090" title="utils/adt/varlena.c:6090">text_format_append_string</a>(buf, <a href="ruleutils.c.html#L12623" title="utils/adt/ruleutils.c:12623">quote_identifier</a>(str), flags, width);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (conversion == <span class="Constant">'L'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *qstr = <a href="quote.c.html#L103" title="utils/adt/quote.c:103">quote_literal_cstr</a>(str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6090" title="utils/adt/varlena.c:6090">text_format_append_string</a>(buf, qstr, flags, width);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="quote.c.html#L103" title="utils/adt/quote.c:103">quote_literal_cstr</a>() always allocates a new string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(qstr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6090" title="utils/adt/varlena.c:6090">text_format_append_string</a>(buf, str, flags, width);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cleanup. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(str);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Append str to buf, padding as directed by flags/width<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6090">&#x200c;</a></span><span class="linkable">text_format_append_string</span>(StringInfo buf, <span class="Type">const</span> <span class="Type">char</span> *str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> flags, <span class="Type">int</span> width)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; align_to_left = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fast path for typical easy case */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (width == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (width &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Negative width: implicit '-' flag, then take absolute value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; align_to_left = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* -INT_MIN is undefined */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (width &lt;= <span class="Constant">INT_MIN</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;number is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; width = -width;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (flags &amp; <a href="#L5623" title="utils/adt/varlena.c:5623">TEXT_FORMAT_FLAG_MINUS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; align_to_left = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = <a href="../mb/mbutils.c.html#L1037" title="utils/mb/mbutils.c:1037">pg_mbstrlen</a>(str);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (align_to_left)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* left justify */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len &lt; width)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoSpaces(buf, width - len);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* right justify */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len &lt; width)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoSpaces(buf, width - len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, str);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6142" title="utils/adt/varlena.c:6142">text_format_nv</a> - nonvariadic wrapper for <a href="#L5638" title="utils/adt/varlena.c:5638">text_format</a> function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * note: this wrapper is necessary to pass the sanity check in opr_sanity,<br/></li>
<li></span><span class="Comment"> * which checks that all built-in <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that share the implementing C<br/></li>
<li></span><span class="Comment"> * function take the same number of arguments.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L6142">&#x200c;</a><span class="linkable">text_format_nv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L5638" title="utils/adt/varlena.c:5638">text_format</a>(fcinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function for Levenshtein distance <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>. Faster than memcmp(),<br/></li>
<li></span><span class="Comment"> * for this use case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L6152">&#x200c;</a></span><span class="linkable">rest_of_char_same</span>(<span class="Type">const</span> <span class="Type">char</span> *s1, <span class="Type">const</span> <span class="Type">char</span> *s2, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s1[len] != s2[len])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Expand each Levenshtein distance variant */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;levenshtein.c&quot;<br/></li>
<li><a id="L6165">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LEVENSHTEIN_LESS_EQUAL</span><br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;levenshtein.c&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The following *ClosestMatch() <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> can be used to determine whether a<br/></li>
<li></span><span class="Comment"> * user-provided string resembles <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> known valid <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, which is useful for<br/></li>
<li></span><span class="Comment"> * providing hints in log messages, among other things.&nbsp; Use these <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> * like so:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6188" title="utils/adt/varlena.c:6188">initClosestMatch</a>(&amp;state, source_string, max_distance);<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; num_valid_strings; i++)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6208" title="utils/adt/varlena.c:6208">updateClosestMatch</a>(&amp;state, valid_strings[i]);<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; closestMatch = <a href="#L6243" title="utils/adt/varlena.c:6243">getClosestMatch</a>(&amp;state);<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize the given state with the source string and maximum Levenshtein<br/></li>
<li></span><span class="Comment"> * distance to consider.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L6188">&#x200c;</a></span><span class="linkable">initClosestMatch</span>(ClosestMatchState *state, <span class="Type">const</span> <span class="Type">char</span> *source, <span class="Type">int</span> max_d)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(state);<br/></li>
<li>&nbsp; &nbsp; Assert(max_d &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;source = source;<br/></li>
<li>&nbsp; &nbsp; state-&gt;min_d = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;max_d = max_d;<br/></li>
<li>&nbsp; &nbsp; state-&gt;match = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If the candidate string is a closer match than the current one saved (or<br/></li>
<li></span><span class="Comment"> * there is no match saved), save it as the closest match.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the source or candidate string is NULL, empty, or too long, this function<br/></li>
<li></span><span class="Comment"> * takes no action.&nbsp; Likewise, if the Levenshtein distance exceeds the maximum<br/></li>
<li></span><span class="Comment"> * allowed or more than half the characters are different, no action is taken.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L6208">&#x200c;</a></span><span class="linkable">updateClosestMatch</span>(ClosestMatchState *state, <span class="Type">const</span> <span class="Type">char</span> *candidate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;source == <span class="Constant">NULL</span> || state-&gt;source[<span class="Constant">0</span>] == <span class="Special">'\0'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; candidate == <span class="Constant">NULL</span> || candidate[<span class="Constant">0</span>] == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To avoid ERROR-ing, we check the lengths here instead of setting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'trusted' to false in the call to <a href="levenshtein.c.html#L68" title="utils/adt/levenshtein.c:68">varstr_levenshtein_less_equal</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strlen(state-&gt;source) &gt; <a href="levenshtein.c.html#L26" title="utils/adt/levenshtein.c:26">MAX_LEVENSHTEIN_STRLEN</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strlen(candidate) &gt; <a href="levenshtein.c.html#L26" title="utils/adt/levenshtein.c:26">MAX_LEVENSHTEIN_STRLEN</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dist = <a href="levenshtein.c.html#L68" title="utils/adt/levenshtein.c:68">varstr_levenshtein_less_equal</a>(state-&gt;source, strlen(state-&gt;source),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; candidate, strlen(candidate), <span class="Constant">1</span>, <span class="Constant">1</span>, <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;max_d, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dist &lt;= state-&gt;max_d &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dist &lt;= strlen(state-&gt;source) / <span class="Constant">2</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (state-&gt;min_d == -<span class="Constant">1</span> || dist &lt; state-&gt;min_d))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;min_d = dist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;match = candidate;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the closest match.&nbsp; If no suitable candidates were provided via<br/></li>
<li></span><span class="Comment"> * <a href="#L6208" title="utils/adt/varlena.c:6208">updateClosestMatch</a>(), return NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L6243">&#x200c;</a><span class="linkable">getClosestMatch</span>(ClosestMatchState *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state-&gt;match;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Unicode support<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> UnicodeNormalizationForm<br/></li>
<li><a id="L6256">&#x200c;</a><span class="linkable">unicode_norm_form_from_string</span>(<span class="Type">const</span> <span class="Type">char</span> *formstr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; UnicodeNormalizationForm form = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Might as well check this while we're here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>() != PG_UTF8)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;Unicode normalization can only be performed if server encoding is UTF8&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_strcasecmp(formstr, <span class="Constant">&quot;NFC&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; form = UNICODE_NFC;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strcasecmp(formstr, <span class="Constant">&quot;NFD&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; form = UNICODE_NFD;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strcasecmp(formstr, <span class="Constant">&quot;NFKC&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; form = UNICODE_NFKC;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strcasecmp(formstr, <span class="Constant">&quot;NFKD&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; form = UNICODE_NFKD;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid normalization form: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, formstr)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> form;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns version of Unicode used by Postgres in &quot;major.minor&quot; format (the<br/></li>
<li></span><span class="Comment"> * same format as the Unicode version reported by ICU). The third component<br/></li>
<li></span><span class="Comment"> * (&quot;update version&quot;) never involves additions to the character repertiore and<br/></li>
<li></span><span class="Comment"> * is unimportant for most purposes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See: https://unicode.org/versions/<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L6293">&#x200c;</a><span class="linkable">unicode_version</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(PG_UNICODE_VERSION));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns version of Unicode used by ICU, if enabled; otherwise NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L6302">&#x200c;</a><span class="linkable">icu_unicode_version</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_ICU<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(U_UNICODE_VERSION));<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether the string contains only assigned Unicode code<br/></li>
<li></span><span class="Comment"> * points. Requires that the database encoding is UTF-8.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L6316">&#x200c;</a><span class="linkable">unicode_assigned</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *input = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>() != PG_UTF8)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;Unicode categorization can only be performed if server encoding is UTF8&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* convert to pg_wchar */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="../mb/mbutils.c.html#L1057" title="utils/mb/mbutils.c:1057">pg_mbstrlen_with_len</a>(VARDATA_ANY(input), VARSIZE_ANY_EXHDR(input));<br/></li>
<li>&nbsp; &nbsp; p = (<span class="Type">unsigned</span> <span class="Type">char</span> *) VARDATA_ANY(input);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; size; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_wchar&nbsp; &nbsp; uchar = utf8_to_unicode(p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; category = unicode_category(uchar);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (category == PG_U_UNASSIGNED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p += pg_utf_mblen(p);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L6344">&#x200c;</a><span class="linkable">unicode_normalize_func</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *input = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *formstr = <a href="#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; UnicodeNormalizationForm form;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; pg_wchar&nbsp;&nbsp; *input_chars;<br/></li>
<li>&nbsp; &nbsp; pg_wchar&nbsp;&nbsp; *output_chars;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *p;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; form = <a href="#L6256" title="utils/adt/varlena.c:6256">unicode_norm_form_from_string</a>(formstr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* convert to pg_wchar */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="../mb/mbutils.c.html#L1057" title="utils/mb/mbutils.c:1057">pg_mbstrlen_with_len</a>(VARDATA_ANY(input), VARSIZE_ANY_EXHDR(input));<br/></li>
<li>&nbsp; &nbsp; input_chars = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>((size + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pg_wchar));<br/></li>
<li>&nbsp; &nbsp; p = (<span class="Type">unsigned</span> <span class="Type">char</span> *) VARDATA_ANY(input);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; size; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; input_chars[i] = utf8_to_unicode(p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p += pg_utf_mblen(p);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; input_chars[i] = (pg_wchar) <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; Assert((<span class="Type">char</span> *) p == VARDATA_ANY(input) + VARSIZE_ANY_EXHDR(input));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* action */<br/></li>
<li></span>&nbsp; &nbsp; output_chars = unicode_normalize(form, input_chars);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* convert back to UTF-8 string */<br/></li>
<li></span>&nbsp; &nbsp; size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (pg_wchar *wp = output_chars; *wp; wp++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> buf[<span class="Constant">4</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unicode_to_utf8(*wp, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size += pg_utf_mblen(buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(size + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, size + VARHDRSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; p = (<span class="Type">unsigned</span> <span class="Type">char</span> *) VARDATA_ANY(result);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (pg_wchar *wp = output_chars; *wp; wp++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unicode_to_utf8(*wp, p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p += pg_utf_mblen(p);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert((<span class="Type">char</span> *) p == (<span class="Type">char</span> *) result + size + VARHDRSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether the string is in the specified Unicode normalization form.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is done by converting the string to the specified normal form and then<br/></li>
<li></span><span class="Comment"> * comparing that to the original string.&nbsp; To speed that up, we also apply the<br/></li>
<li></span><span class="Comment"> * &quot;quick check&quot; algorithm specified in UAX #15, which can give a yes or no<br/></li>
<li></span><span class="Comment"> * answer for many strings by just scanning the string once.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function should generally be optimized for the case where the string<br/></li>
<li></span><span class="Comment"> * is in fact normalized.&nbsp; In that case, we'll end up looking at the entire<br/></li>
<li></span><span class="Comment"> * string, so it's probably not worth doing <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> incremental conversion etc.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L6410">&#x200c;</a><span class="linkable">unicode_is_normalized</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *input = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *formstr = <a href="#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(PG_GETARG_TEXT_PP(<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; UnicodeNormalizationForm form;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; pg_wchar&nbsp;&nbsp; *input_chars;<br/></li>
<li>&nbsp; &nbsp; pg_wchar&nbsp;&nbsp; *output_chars;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; UnicodeNormalizationQC quickcheck;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; output_size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; form = <a href="#L6256" title="utils/adt/varlena.c:6256">unicode_norm_form_from_string</a>(formstr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* convert to pg_wchar */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="../mb/mbutils.c.html#L1057" title="utils/mb/mbutils.c:1057">pg_mbstrlen_with_len</a>(VARDATA_ANY(input), VARSIZE_ANY_EXHDR(input));<br/></li>
<li>&nbsp; &nbsp; input_chars = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>((size + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pg_wchar));<br/></li>
<li>&nbsp; &nbsp; p = (<span class="Type">unsigned</span> <span class="Type">char</span> *) VARDATA_ANY(input);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; size; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; input_chars[i] = utf8_to_unicode(p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p += pg_utf_mblen(p);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; input_chars[i] = (pg_wchar) <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; Assert((<span class="Type">char</span> *) p == VARDATA_ANY(input) + VARSIZE_ANY_EXHDR(input));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* quick check (see UAX #15) */<br/></li>
<li></span>&nbsp; &nbsp; quickcheck = unicode_is_normalized_quickcheck(form, input_chars);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (quickcheck == UNICODE_NORM_QC_YES)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (quickcheck == UNICODE_NORM_QC_NO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* normalize and <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> with original */<br/></li>
<li></span>&nbsp; &nbsp; output_chars = unicode_normalize(form, input_chars);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; output_size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (pg_wchar *wp = output_chars; *wp; wp++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; output_size++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (size == output_size) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (memcmp(input_chars, output_chars, size * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pg_wchar)) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if first n chars are hexadecimal digits<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L6462">&#x200c;</a></span><span class="linkable">isxdigits_n</span>(<span class="Type">const</span> <span class="Type">char</span> *instr, <span class="Type">size_t</span> n)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">size_t</span> i = <span class="Constant">0</span>; i &lt; n; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isxdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) instr[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">unsigned</span> <span class="Type">int<br/></li>
<li><a id="L6472">&#x200c;</a></span><span class="linkable">hexval</span>(<span class="Type">unsigned</span> <span class="Type">char</span> c)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (c &gt;= <span class="Constant">'0'</span> &amp;&amp; c &lt;= <span class="Constant">'9'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> c - <span class="Constant">'0'</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (c &gt;= <span class="Constant">'a'</span> &amp;&amp; c &lt;= <span class="Constant">'f'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> c - <span class="Constant">'a'</span> + <span class="Constant">0xA</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (c &gt;= <span class="Constant">'A'</span> &amp;&amp; c &lt;= <span class="Constant">'F'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> c - <span class="Constant">'A'</span> + <span class="Constant">0xA</span>;<br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid hexadecimal digit&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not reached */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Translate string with hexadecimal digits to number<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">unsigned</span> <span class="Type">int<br/></li>
<li><a id="L6488">&#x200c;</a></span><span class="linkable">hexval_n</span>(<span class="Type">const</span> <span class="Type">char</span> *instr, <span class="Type">size_t</span> n)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> result = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">size_t</span> i = <span class="Constant">0</span>; i &lt; n; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result += <a href="#L6472" title="utils/adt/varlena.c:6472">hexval</a>(instr[i]) &lt;&lt; (<span class="Constant">4</span> * (n - i - <span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Replaces Unicode escape sequences by Unicode characters<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L6502">&#x200c;</a><span class="linkable">unistr</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *input_text = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *instr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; StringInfoData str;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; pg_wchar&nbsp; &nbsp; pair_first = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; cbuf[MAX_UNICODE_EQUIVALENT_STRING + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; instr = VARDATA_ANY(input_text);<br/></li>
<li>&nbsp; &nbsp; len = VARSIZE_ANY_EXHDR(input_text);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (instr[<span class="Constant">0</span>] == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len &gt;= <span class="Constant">2</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instr[<span class="Constant">1</span>] == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pair_first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_pair;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;str, <span class="Special">'\\'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instr += <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len -= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((len &gt;= <span class="Constant">5</span> &amp;&amp; <a href="#L6462" title="utils/adt/varlena.c:6462">isxdigits_n</a>(instr + <span class="Constant">1</span>, <span class="Constant">4</span>)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (len &gt;= <span class="Constant">6</span> &amp;&amp; instr[<span class="Constant">1</span>] == <span class="Constant">'u'</span> &amp;&amp; <a href="#L6462" title="utils/adt/varlena.c:6462">isxdigits_n</a>(instr + <span class="Constant">2</span>, <span class="Constant">4</span>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_wchar&nbsp; &nbsp; unicode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset = instr[<span class="Constant">1</span>] == <span class="Constant">'u'</span> ? <span class="Constant">2</span> : <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unicode = <a href="#L6488" title="utils/adt/varlena.c:6488">hexval_n</a>(instr + offset, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!is_valid_unicode_codepoint(unicode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid Unicode code point: </span><span class="Special">%04X</span><span class="Constant">&quot;</span>, unicode));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pair_first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_utf16_surrogate_second(unicode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unicode = surrogate_pair_to_codepoint(pair_first, unicode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pair_first = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_pair;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (is_utf16_surrogate_second(unicode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_pair;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_utf16_surrogate_first(unicode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pair_first = unicode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mb/mbutils.c.html#L864" title="utils/mb/mbutils.c:864">pg_unicode_to_server</a>(unicode, (<span class="Type">unsigned</span> <span class="Type">char</span> *) cbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;str, cbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instr += <span class="Constant">4</span> + offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len -= <span class="Constant">4</span> + offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (len &gt;= <span class="Constant">8</span> &amp;&amp; instr[<span class="Constant">1</span>] == <span class="Constant">'+'</span> &amp;&amp; <a href="#L6462" title="utils/adt/varlena.c:6462">isxdigits_n</a>(instr + <span class="Constant">2</span>, <span class="Constant">6</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_wchar&nbsp; &nbsp; unicode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unicode = <a href="#L6488" title="utils/adt/varlena.c:6488">hexval_n</a>(instr + <span class="Constant">2</span>, <span class="Constant">6</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!is_valid_unicode_codepoint(unicode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid Unicode code point: </span><span class="Special">%04X</span><span class="Constant">&quot;</span>, unicode));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pair_first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_utf16_surrogate_second(unicode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unicode = surrogate_pair_to_codepoint(pair_first, unicode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pair_first = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_pair;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (is_utf16_surrogate_second(unicode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_pair;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_utf16_surrogate_first(unicode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pair_first = unicode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mb/mbutils.c.html#L864" title="utils/mb/mbutils.c:864">pg_unicode_to_server</a>(unicode, (<span class="Type">unsigned</span> <span class="Type">char</span> *) cbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;str, cbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instr += <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len -= <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (len &gt;= <span class="Constant">10</span> &amp;&amp; instr[<span class="Constant">1</span>] == <span class="Constant">'U'</span> &amp;&amp; <a href="#L6462" title="utils/adt/varlena.c:6462">isxdigits_n</a>(instr + <span class="Constant">2</span>, <span class="Constant">8</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_wchar&nbsp; &nbsp; unicode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unicode = <a href="#L6488" title="utils/adt/varlena.c:6488">hexval_n</a>(instr + <span class="Constant">2</span>, <span class="Constant">8</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!is_valid_unicode_codepoint(unicode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid Unicode code point: </span><span class="Special">%04X</span><span class="Constant">&quot;</span>, unicode));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pair_first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_utf16_surrogate_second(unicode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unicode = surrogate_pair_to_codepoint(pair_first, unicode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pair_first = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_pair;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (is_utf16_surrogate_second(unicode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_pair;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_utf16_surrogate_first(unicode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pair_first = unicode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mb/mbutils.c.html#L864" title="utils/mb/mbutils.c:864">pg_unicode_to_server</a>(unicode, (<span class="Type">unsigned</span> <span class="Type">char</span> *) cbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;str, cbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instr += <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len -= <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid Unicode escape&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Unicode escapes must be </span><span class="Special">\\</span><span class="Constant">XXXX, </span><span class="Special">\\</span><span class="Constant">+XXXXXX, </span><span class="Special">\\</span><span class="Constant">uXXXX, or </span><span class="Special">\\</span><span class="Constant">UXXXXXXXX.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pair_first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_pair;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;str, *instr++);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* unfinished surrogate pair? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pair_first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> invalid_pair;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(str.data, str.len);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(str.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(result);<br/></li>
<li><br/></li>
<li><span class="Statement">invalid_pair</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid Unicode surrogate pair&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NULL();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
