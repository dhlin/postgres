<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/network_gist.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/network_gist.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L79">GistInetKey</a></li>
<li><a href="#L86">GistInetKey</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L472">build_inet_union_key</a></li>
<li><a href="#L345">calc_inet_union_params</a></li>
<li><a href="#L407">calc_inet_union_params_indexed</a></li>
<li><a href="#L542">inet_gist_compress</a></li>
<li><a href="#L115">inet_gist_consistent</a></li>
<li><a href="#L590">inet_gist_fetch</a></li>
<li><a href="#L620">inet_gist_penalty</a></li>
<li><a href="#L663">inet_gist_picksplit</a></li>
<li><a href="#L797">inet_gist_same</a></li>
<li><a href="#L505">inet_gist_union</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L88">DatumGetInetKeyP</a></li>
<li><a href="#L60">INETSTRAT_EQ</a></li>
<li><a href="#L65">INETSTRAT_GE</a></li>
<li><a href="#L64">INETSTRAT_GT</a></li>
<li><a href="#L63">INETSTRAT_LE</a></li>
<li><a href="#L62">INETSTRAT_LT</a></li>
<li><a href="#L61">INETSTRAT_NE</a></li>
<li><a href="#L59">INETSTRAT_OVERLAPS</a></li>
<li><a href="#L66">INETSTRAT_SUB</a></li>
<li><a href="#L67">INETSTRAT_SUBEQ</a></li>
<li><a href="#L68">INETSTRAT_SUP</a></li>
<li><a href="#L69">INETSTRAT_SUPEQ</a></li>
<li><a href="#L89">InetKeyPGetDatum</a></li>
<li><a href="#L107">SET_GK_VARSIZE</a></li>
<li><a href="#L99">gk_ip_addr</a></li>
<li><a href="#L103">gk_ip_addrsize</a></li>
<li><a href="#L98">gk_ip_commonbits</a></li>
<li><a href="#L96">gk_ip_family</a></li>
<li><a href="#L105">gk_ip_maxbits</a></li>
<li><a href="#L97">gk_ip_minbits</a></li>
<li><a href="#L100">ip_family_maxbits</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * network_gist.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; GiST support for network types.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The key thing to understand about this code is the definition of the<br/></li>
<li></span><span class="Comment"> * &quot;union&quot; of a set of INET/CIDR <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; It works like this:<br/></li>
<li></span><span class="Comment"> * 1. If the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are not all of the same IP address family, the &quot;union&quot;<br/></li>
<li></span><span class="Comment"> * is a dummy value with family number zero, minbits zero, commonbits zero,<br/></li>
<li></span><span class="Comment"> * address all zeroes.&nbsp; Otherwise:<br/></li>
<li></span><span class="Comment"> * 2. The union has the common IP address family number.<br/></li>
<li></span><span class="Comment"> * 3. The union's minbits value is the smallest netmask length (&quot;ip_bits&quot;)<br/></li>
<li></span><span class="Comment"> * of all the input <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> * 4. Let C be the number of leading address bits that are in common among<br/></li>
<li></span><span class="Comment"> * all the input <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (C ranges from 0 to ip_maxbits for the family).<br/></li>
<li></span><span class="Comment"> * 5. The union's commonbits value is C.<br/></li>
<li></span><span class="Comment"> * 6. The union's address value is the same as the common prefix for its<br/></li>
<li></span><span class="Comment"> * first C bits, and is zeroes to the right of that.&nbsp; The physical width<br/></li>
<li></span><span class="Comment"> * of the address value is ip_maxbits for the address family.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In a leaf index entry (representing a single key), commonbits is <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to<br/></li>
<li></span><span class="Comment"> * ip_maxbits for the address family, minbits is the same as the represented<br/></li>
<li></span><span class="Comment"> * value's ip_bits, and the address is <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the represented address.<br/></li>
<li></span><span class="Comment"> * Although it may appear that we're wasting a byte by storing the union<br/></li>
<li></span><span class="Comment"> * format and not just the represented INET/CIDR value in leaf keys, the<br/></li>
<li></span><span class="Comment"> * extra byte is actually &quot;free&quot; because of alignment considerations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this design tracks minbits and commonbits independently; in <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * given union value, either might be smaller than the other.&nbsp; This does not<br/></li>
<li></span><span class="Comment"> * <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> us much when descending the tree, because of the way inet comparison<br/></li>
<li></span><span class="Comment"> * is defined: at non-leaf nodes we can't <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> more than minbits bits<br/></li>
<li></span><span class="Comment"> * even if we know them.&nbsp; However, it greatly improves the quality of split<br/></li>
<li></span><span class="Comment"> * decisions.&nbsp; Preliminary testing suggests that searches are as much as<br/></li>
<li></span><span class="Comment"> * twice as fast as for a simpler design in which a single field doubles as<br/></li>
<li></span><span class="Comment"> * the common prefix length and the minimum ip_bits value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/network_gist.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;sys/<a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/gist.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/stratnum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inet.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;varatt.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Operator strategy numbers used in the GiST inet_ops opclass<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L59">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">INETSTRAT_OVERLAPS</span>&nbsp; &nbsp; &nbsp; &nbsp; RTOverlapStrategyNumber<br/></li>
<li><a id="L60">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">INETSTRAT_EQ</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTEqualStrategyNumber<br/></li>
<li><a id="L61">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">INETSTRAT_NE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTNotEqualStrategyNumber<br/></li>
<li><a id="L62">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">INETSTRAT_LT</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTLessStrategyNumber<br/></li>
<li><a id="L63">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">INETSTRAT_LE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTLessEqualStrategyNumber<br/></li>
<li><a id="L64">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">INETSTRAT_GT</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTGreaterStrategyNumber<br/></li>
<li><a id="L65">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">INETSTRAT_GE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTGreaterEqualStrategyNumber<br/></li>
<li><a id="L66">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">INETSTRAT_SUB</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTSubStrategyNumber<br/></li>
<li><a id="L67">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">INETSTRAT_SUBEQ</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTSubEqualStrategyNumber<br/></li>
<li><a id="L68">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">INETSTRAT_SUP</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTSuperStrategyNumber<br/></li>
<li><a id="L69">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">INETSTRAT_SUPEQ</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTSuperEqualStrategyNumber<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Representation of a GiST INET/CIDR index key.&nbsp; This is not identical to<br/></li>
<li></span><span class="Comment"> * INET/CIDR because we need to keep track of the length of the common address<br/></li>
<li></span><span class="Comment"> * prefix as well as the minimum netmask length.&nbsp; However, as long as it<br/></li>
<li></span><span class="Comment"> * follows varlena header rules, the core GiST code won't know the difference.<br/></li>
<li></span><span class="Comment"> * For simplicity we always use 1-byte-header varlena format.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L79">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">GistInetKey</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; va_header;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* varlena header --- don't touch directly */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> family;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* PGSQL_AF_INET, PGSQL_AF_INET6, or zero */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> minbits;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* minimum number of bits in netmask */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> commonbits;&nbsp; &nbsp; <span class="Comment">/* number of common prefix bits in addresses */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> ipaddr[<span class="Constant">16</span>];&nbsp; &nbsp; <span class="Comment">/* up to 128 bits of common address */<br/></li>
<li><a id="L86">&#x200c;</a></span>} <span class="linkable">GistInetKey</span>;<br/></li>
<li><br/></li>
<li><a id="L88">&#x200c;</a><span class="PreProc">#define <span class="linkable">DatumGetInetKeyP</span>(X) ((<a href="#L79" title="utils/adt/network_gist.c:79">GistInetKey</a> *) DatumGetPointer(X))<br/></li>
<li><a id="L89">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">InetKeyPGetDatum</span>(X) PointerGetDatum(X)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Access macros; not really exciting, but we use these for notational<br/></li>
<li></span><span class="Comment"> * consistency with access to INET/CIDR <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; Note that family-zero <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * are stored with 4 bytes of address, not 16.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L96">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">gk_ip_family</span>(gkptr)&nbsp; &nbsp; &nbsp; &nbsp; ((gkptr)-&gt;family)<br/></li>
<li><a id="L97">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">gk_ip_minbits</span>(gkptr)&nbsp; &nbsp; ((gkptr)-&gt;minbits)<br/></li>
<li><a id="L98">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">gk_ip_commonbits</span>(gkptr) ((gkptr)-&gt;commonbits)<br/></li>
<li><a id="L99">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">gk_ip_addr</span>(gkptr)&nbsp; &nbsp; &nbsp; &nbsp; ((gkptr)-&gt;ipaddr)<br/></li>
<li><a id="L100">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ip_family_maxbits</span>(fam)&nbsp; &nbsp; ((fam) == PGSQL_AF_INET6 ? </span><span class="Constant">128</span><span class="PreProc"> : </span><span class="Constant">32</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* These require that the family field has been set: */<br/></li>
<li><a id="L103">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">gk_ip_addrsize</span>(gkptr) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (<a href="#L96" title="utils/adt/network_gist.c:96">gk_ip_family</a>(gkptr) == PGSQL_AF_INET6 ? </span><span class="Constant">16</span><span class="PreProc"> : </span><span class="Constant">4</span><span class="PreProc">)<br/></li>
<li><a id="L105">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">gk_ip_maxbits</span>(gkptr) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="#L100" title="utils/adt/network_gist.c:100">ip_family_maxbits</a>(<a href="#L96" title="utils/adt/network_gist.c:96">gk_ip_family</a>(gkptr))<br/></li>
<li><a id="L107">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SET_GK_VARSIZE</span>(dst) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; SET_VARSIZE_SHORT(dst, offsetof(<a href="#L79" title="utils/adt/network_gist.c:79">GistInetKey</a>, ipaddr) + <a href="#L103" title="utils/adt/network_gist.c:103">gk_ip_addrsize</a>(dst))<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The GiST query consistency check<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L115">&#x200c;</a><span class="linkable">inet_gist_consistent</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *ent = (GISTENTRY *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *query = PG_GETARG_INET_PP(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Oid&nbsp; &nbsp; &nbsp; &nbsp; subtype = PG_GETARG_OID(3); */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *recheck = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) PG_GETARG_POINTER(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L79" title="utils/adt/network_gist.c:79">GistInetKey</a> *key = <a href="#L88" title="utils/adt/network_gist.c:88">DatumGetInetKeyP</a>(ent-&gt;key);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minbits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; order;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* All operators served by this function are exact. */<br/></li>
<li></span>&nbsp; &nbsp; *recheck = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check 0: different families<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If key represents multiple address families, its children could match<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anything.&nbsp; This can only happen on an inner index page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L96" title="utils/adt/network_gist.c:96">gk_ip_family</a>(key) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!GIST_LEAF(ent));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check 1: different families<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Matching families do not <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the strategies.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L96" title="utils/adt/network_gist.c:96">gk_ip_family</a>(key) != ip_family(query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (strategy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L62" title="utils/adt/network_gist.c:62">INETSTRAT_LT</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L63" title="utils/adt/network_gist.c:63">INETSTRAT_LE</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L96" title="utils/adt/network_gist.c:96">gk_ip_family</a>(key) &lt; ip_family(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L65" title="utils/adt/network_gist.c:65">INETSTRAT_GE</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L64" title="utils/adt/network_gist.c:64">INETSTRAT_GT</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L96" title="utils/adt/network_gist.c:96">gk_ip_family</a>(key) &gt; ip_family(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L61" title="utils/adt/network_gist.c:61">INETSTRAT_NE</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* For all other cases, we can be sure there is no match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check 2: network <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> count<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Network <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> count (ip_bits) helps to check leaves for sub network and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sup network operators.&nbsp; At non-leaf nodes, we know every child value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has ip_bits &gt;= <a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(key), so we can avoid descending in some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (strategy)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L66" title="utils/adt/network_gist.c:66">INETSTRAT_SUB</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GIST_LEAF(ent) &amp;&amp; <a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(key) &lt;= ip_bits(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L67" title="utils/adt/network_gist.c:67">INETSTRAT_SUBEQ</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GIST_LEAF(ent) &amp;&amp; <a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(key) &lt; ip_bits(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L69" title="utils/adt/network_gist.c:69">INETSTRAT_SUPEQ</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L60" title="utils/adt/network_gist.c:60">INETSTRAT_EQ</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(key) &gt; ip_bits(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L68" title="utils/adt/network_gist.c:68">INETSTRAT_SUP</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(key) &gt;= ip_bits(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check 3: common network bits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compare available common prefix bits to the query, but not beyond<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * either the query's netmask or the minimum netmask among the represented<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; If these bits don't match the query, we have our answer (and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * may or may not need to descend, depending on the operator).&nbsp; If they do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * match, and we are not at a leaf, we descend in all cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note this is the final check for operators that only consider the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * network part of the address.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; minbits = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(<a href="#L98" title="utils/adt/network_gist.c:98">gk_ip_commonbits</a>(key), <a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(key));<br/></li>
<li>&nbsp; &nbsp; minbits = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(minbits, ip_bits(query));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; order = <a href="network.c.html#L1569" title="utils/adt/network.c:1569">bitncmp</a>(<a href="#L99" title="utils/adt/network_gist.c:99">gk_ip_addr</a>(key), ip_addr(query), minbits);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (strategy)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L66" title="utils/adt/network_gist.c:66">INETSTRAT_SUB</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L67" title="utils/adt/network_gist.c:67">INETSTRAT_SUBEQ</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L59" title="utils/adt/network_gist.c:59">INETSTRAT_OVERLAPS</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L69" title="utils/adt/network_gist.c:69">INETSTRAT_SUPEQ</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L68" title="utils/adt/network_gist.c:68">INETSTRAT_SUP</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(order == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L62" title="utils/adt/network_gist.c:62">INETSTRAT_LT</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L63" title="utils/adt/network_gist.c:63">INETSTRAT_LE</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (order &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (order &lt; <span class="Constant">0</span> || !GIST_LEAF(ent))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L60" title="utils/adt/network_gist.c:60">INETSTRAT_EQ</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (order != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!GIST_LEAF(ent))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L65" title="utils/adt/network_gist.c:65">INETSTRAT_GE</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L64" title="utils/adt/network_gist.c:64">INETSTRAT_GT</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (order &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (order &gt; <span class="Constant">0</span> || !GIST_LEAF(ent))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L61" title="utils/adt/network_gist.c:61">INETSTRAT_NE</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (order != <span class="Constant">0</span> || !GIST_LEAF(ent))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remaining checks are only for leaves and basic comparison strategies.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See <a href="network.c.html#L405" title="utils/adt/network.c:405">network_cmp_internal</a>() in network.c for the implementation we need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to match.&nbsp; Note that in a leaf key, commonbits should <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> the address<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * length, so we compared the whole network parts above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(GIST_LEAF(ent));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check 4: network <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> count<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Next step is to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> netmask widths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (strategy)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L62" title="utils/adt/network_gist.c:62">INETSTRAT_LT</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L63" title="utils/adt/network_gist.c:63">INETSTRAT_LE</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(key) &lt; ip_bits(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(key) &gt; ip_bits(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L60" title="utils/adt/network_gist.c:60">INETSTRAT_EQ</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(key) != ip_bits(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L65" title="utils/adt/network_gist.c:65">INETSTRAT_GE</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L64" title="utils/adt/network_gist.c:64">INETSTRAT_GT</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(key) &gt; ip_bits(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(key) &lt; ip_bits(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L61" title="utils/adt/network_gist.c:61">INETSTRAT_NE</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(key) != ip_bits(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check 5: whole address<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Netmask <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> counts are the same, so check all the address bits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; order = <a href="network.c.html#L1569" title="utils/adt/network.c:1569">bitncmp</a>(<a href="#L99" title="utils/adt/network_gist.c:99">gk_ip_addr</a>(key), ip_addr(query), <a href="#L105" title="utils/adt/network_gist.c:105">gk_ip_maxbits</a>(key));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (strategy)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L62" title="utils/adt/network_gist.c:62">INETSTRAT_LT</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(order &lt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L63" title="utils/adt/network_gist.c:63">INETSTRAT_LE</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(order &lt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L60" title="utils/adt/network_gist.c:60">INETSTRAT_EQ</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(order == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L65" title="utils/adt/network_gist.c:65">INETSTRAT_GE</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(order &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L64" title="utils/adt/network_gist.c:64">INETSTRAT_GT</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(order &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L61" title="utils/adt/network_gist.c:61">INETSTRAT_NE</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(order != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unknown strategy for inet GiST&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Calculate parameters of the union of some GistInetKeys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Examine the keys in elements m..n inclusive of the GISTENTRY array,<br/></li>
<li></span><span class="Comment"> * and compute these output parameters:<br/></li>
<li></span><span class="Comment"> * *minfamily_p = minimum IP address family number<br/></li>
<li></span><span class="Comment"> * *maxfamily_p = maximum IP address family number<br/></li>
<li></span><span class="Comment"> * *minbits_p = minimum netmask width<br/></li>
<li></span><span class="Comment"> * *commonbits_p = number of leading bits in common among the addresses<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * minbits and commonbits are forced to zero if there's more than one<br/></li>
<li></span><span class="Comment"> * address family.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L345">&#x200c;</a></span><span class="linkable">calc_inet_union_params</span>(GISTENTRY *ent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> m, <span class="Type">int</span> n,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *minfamily_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *maxfamily_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *minbits_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *commonbits_p)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minbits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commonbits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *addr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L79" title="utils/adt/network_gist.c:79">GistInetKey</a> *tmp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must be at least one key. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(m &lt;= n);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize variables using the first key. */<br/></li>
<li></span>&nbsp; &nbsp; tmp = <a href="#L88" title="utils/adt/network_gist.c:88">DatumGetInetKeyP</a>(ent[m].key);<br/></li>
<li>&nbsp; &nbsp; minfamily = maxfamily = <a href="#L96" title="utils/adt/network_gist.c:96">gk_ip_family</a>(tmp);<br/></li>
<li>&nbsp; &nbsp; minbits = <a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(tmp);<br/></li>
<li>&nbsp; &nbsp; commonbits = <a href="#L98" title="utils/adt/network_gist.c:98">gk_ip_commonbits</a>(tmp);<br/></li>
<li>&nbsp; &nbsp; addr = <a href="#L99" title="utils/adt/network_gist.c:99">gk_ip_addr</a>(tmp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan remaining keys. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = m + <span class="Constant">1</span>; i &lt;= n; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmp = <a href="#L88" title="utils/adt/network_gist.c:88">DatumGetInetKeyP</a>(ent[i].key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Determine <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of family numbers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (minfamily &gt; <a href="#L96" title="utils/adt/network_gist.c:96">gk_ip_family</a>(tmp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minfamily = <a href="#L96" title="utils/adt/network_gist.c:96">gk_ip_family</a>(tmp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (maxfamily &lt; <a href="#L96" title="utils/adt/network_gist.c:96">gk_ip_family</a>(tmp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxfamily = <a href="#L96" title="utils/adt/network_gist.c:96">gk_ip_family</a>(tmp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find minimum minbits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (minbits &gt; <a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(tmp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minbits = <a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(tmp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find minimum number of bits in common */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (commonbits &gt; <a href="#L98" title="utils/adt/network_gist.c:98">gk_ip_commonbits</a>(tmp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commonbits = <a href="#L98" title="utils/adt/network_gist.c:98">gk_ip_commonbits</a>(tmp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (commonbits &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commonbits = <a href="network.c.html#L1603" title="utils/adt/network.c:1603">bitncommon</a>(addr, <a href="#L99" title="utils/adt/network_gist.c:99">gk_ip_addr</a>(tmp), commonbits);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Force minbits/commonbits to zero if more than one family. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (minfamily != maxfamily)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; minbits = commonbits = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *minfamily_p = minfamily;<br/></li>
<li>&nbsp; &nbsp; *maxfamily_p = maxfamily;<br/></li>
<li>&nbsp; &nbsp; *minbits_p = minbits;<br/></li>
<li>&nbsp; &nbsp; *commonbits_p = commonbits;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Same as above, but the GISTENTRY elements to examine are those with<br/></li>
<li></span><span class="Comment"> * indices listed in the offsets[] array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L407">&#x200c;</a></span><span class="linkable">calc_inet_union_params_indexed</span>(GISTENTRY *ent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber *offsets, <span class="Type">int</span> noffsets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *minfamily_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *maxfamily_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *minbits_p,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *commonbits_p)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minbits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commonbits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *addr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L79" title="utils/adt/network_gist.c:79">GistInetKey</a> *tmp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must be at least one key. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(noffsets &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize variables using the first key. */<br/></li>
<li></span>&nbsp; &nbsp; tmp = <a href="#L88" title="utils/adt/network_gist.c:88">DatumGetInetKeyP</a>(ent[offsets[<span class="Constant">0</span>]].key);<br/></li>
<li>&nbsp; &nbsp; minfamily = maxfamily = <a href="#L96" title="utils/adt/network_gist.c:96">gk_ip_family</a>(tmp);<br/></li>
<li>&nbsp; &nbsp; minbits = <a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(tmp);<br/></li>
<li>&nbsp; &nbsp; commonbits = <a href="#L98" title="utils/adt/network_gist.c:98">gk_ip_commonbits</a>(tmp);<br/></li>
<li>&nbsp; &nbsp; addr = <a href="#L99" title="utils/adt/network_gist.c:99">gk_ip_addr</a>(tmp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan remaining keys. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; noffsets; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmp = <a href="#L88" title="utils/adt/network_gist.c:88">DatumGetInetKeyP</a>(ent[offsets[i]].key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Determine <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of family numbers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (minfamily &gt; <a href="#L96" title="utils/adt/network_gist.c:96">gk_ip_family</a>(tmp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minfamily = <a href="#L96" title="utils/adt/network_gist.c:96">gk_ip_family</a>(tmp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (maxfamily &lt; <a href="#L96" title="utils/adt/network_gist.c:96">gk_ip_family</a>(tmp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxfamily = <a href="#L96" title="utils/adt/network_gist.c:96">gk_ip_family</a>(tmp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find minimum minbits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (minbits &gt; <a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(tmp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minbits = <a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(tmp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find minimum number of bits in common */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (commonbits &gt; <a href="#L98" title="utils/adt/network_gist.c:98">gk_ip_commonbits</a>(tmp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commonbits = <a href="#L98" title="utils/adt/network_gist.c:98">gk_ip_commonbits</a>(tmp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (commonbits &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commonbits = <a href="network.c.html#L1603" title="utils/adt/network.c:1603">bitncommon</a>(addr, <a href="#L99" title="utils/adt/network_gist.c:99">gk_ip_addr</a>(tmp), commonbits);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Force minbits/commonbits to zero if more than one family. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (minfamily != maxfamily)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; minbits = commonbits = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *minfamily_p = minfamily;<br/></li>
<li>&nbsp; &nbsp; *maxfamily_p = maxfamily;<br/></li>
<li>&nbsp; &nbsp; *minbits_p = minbits;<br/></li>
<li>&nbsp; &nbsp; *commonbits_p = commonbits;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Construct a <a href="#L79" title="utils/adt/network_gist.c:79">GistInetKey</a> representing a union value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Inputs are the family/minbits/commonbits <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to use, plus a pointer to<br/></li>
<li></span><span class="Comment"> * the address field of one of the union inputs.&nbsp; (Since we're going to copy<br/></li>
<li></span><span class="Comment"> * just the bits-in-common, it doesn't matter which one.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L79" title="utils/adt/network_gist.c:79">GistInetKey</a> *<br/></li>
<li><a id="L472">&#x200c;</a><span class="linkable">build_inet_union_key</span>(<span class="Type">int</span> family, <span class="Type">int</span> minbits, <span class="Type">int</span> commonbits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *addr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L79" title="utils/adt/network_gist.c:79">GistInetKey</a> *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unused bits are zeroed. */<br/></li>
<li></span>&nbsp; &nbsp; result = (<a href="#L79" title="utils/adt/network_gist.c:79">GistInetKey</a> *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L79" title="utils/adt/network_gist.c:79">GistInetKey</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L96" title="utils/adt/network_gist.c:96">gk_ip_family</a>(result) = family;<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(result) = minbits;<br/></li>
<li>&nbsp; &nbsp; <a href="#L98" title="utils/adt/network_gist.c:98">gk_ip_commonbits</a>(result) = commonbits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clone appropriate bytes of the address. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (commonbits &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(<a href="#L99" title="utils/adt/network_gist.c:99">gk_ip_addr</a>(result), addr, (commonbits + <span class="Constant">7</span>) / <span class="Constant">8</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unwanted bits in the last partial byte. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (commonbits % <span class="Constant">8</span> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L99" title="utils/adt/network_gist.c:99">gk_ip_addr</a>(result)[commonbits / <span class="Constant">8</span>] &amp;= ~(<span class="Constant">0xFF</span> &gt;&gt; (commonbits % <span class="Constant">8</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set varlena header correctly. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L107" title="utils/adt/network_gist.c:107">SET_GK_VARSIZE</a>(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The GiST union function<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See comments at head of file for the definition of the union.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L505">&#x200c;</a><span class="linkable">inet_gist_union</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *ent = entryvec-&gt;vector;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minbits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commonbits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *addr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L79" title="utils/adt/network_gist.c:79">GistInetKey</a> *tmp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine parameters of the union. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L345" title="utils/adt/network_gist.c:345">calc_inet_union_params</a>(ent, <span class="Constant">0</span>, entryvec-&gt;n - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;minfamily, &amp;maxfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;minbits, &amp;commonbits);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If more than one family, emit family number zero. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (minfamily != maxfamily)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; minfamily = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize address using the first key. */<br/></li>
<li></span>&nbsp; &nbsp; tmp = <a href="#L88" title="utils/adt/network_gist.c:88">DatumGetInetKeyP</a>(ent[<span class="Constant">0</span>].key);<br/></li>
<li>&nbsp; &nbsp; addr = <a href="#L99" title="utils/adt/network_gist.c:99">gk_ip_addr</a>(tmp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Construct the union value. */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="#L472" title="utils/adt/network_gist.c:472">build_inet_union_key</a>(minfamily, minbits, commonbits, addr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The GiST compress function<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Convert an inet value to <a href="#L79" title="utils/adt/network_gist.c:79">GistInetKey</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L542">&#x200c;</a><span class="linkable">inet_gist_compress</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *entry = (GISTENTRY *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *retval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;leafkey)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; retval = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTENTRY));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetPointer(entry-&gt;key) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *in = DatumGetInetPP(entry-&gt;key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/adt/network_gist.c:79">GistInetKey</a> *r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = (<a href="#L79" title="utils/adt/network_gist.c:79">GistInetKey</a> *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L79" title="utils/adt/network_gist.c:79">GistInetKey</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L96" title="utils/adt/network_gist.c:96">gk_ip_family</a>(r) = ip_family(in);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(r) = ip_bits(in);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L98" title="utils/adt/network_gist.c:98">gk_ip_commonbits</a>(r) = <a href="#L105" title="utils/adt/network_gist.c:105">gk_ip_maxbits</a>(r);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(<a href="#L99" title="utils/adt/network_gist.c:99">gk_ip_addr</a>(r), ip_addr(in), <a href="#L103" title="utils/adt/network_gist.c:103">gk_ip_addrsize</a>(r));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="utils/adt/network_gist.c:107">SET_GK_VARSIZE</a>(r);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gistentryinit(*retval, PointerGetDatum(r),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;rel, entry-&gt;page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;offset, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gistentryinit(*retval, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;rel, entry-&gt;page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;offset, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; retval = entry;<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(retval);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We do not need a decompress function, because the other GiST inet<br/></li>
<li></span><span class="Comment"> * support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> work with the <a href="#L79" title="utils/adt/network_gist.c:79">GistInetKey</a> representation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The GiST fetch function<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Reconstruct the original inet datum from a <a href="#L79" title="utils/adt/network_gist.c:79">GistInetKey</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L590">&#x200c;</a><span class="linkable">inet_gist_fetch</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *entry = (GISTENTRY *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L79" title="utils/adt/network_gist.c:79">GistInetKey</a> *key = <a href="#L88" title="utils/adt/network_gist.c:88">DatumGetInetKeyP</a>(entry-&gt;key);<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *retval;<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *dst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dst = (inet *) <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(inet));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ip_family(dst) = <a href="#L96" title="utils/adt/network_gist.c:96">gk_ip_family</a>(key);<br/></li>
<li>&nbsp; &nbsp; ip_bits(dst) = <a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(key);<br/></li>
<li>&nbsp; &nbsp; memcpy(ip_addr(dst), <a href="#L99" title="utils/adt/network_gist.c:99">gk_ip_addr</a>(key), ip_addrsize(dst));<br/></li>
<li>&nbsp; &nbsp; SET_INET_VARSIZE(dst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; retval = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTENTRY));<br/></li>
<li>&nbsp; &nbsp; gistentryinit(*retval, InetPGetDatum(dst), entry-&gt;rel, entry-&gt;page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;offset, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(retval);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The GiST page split penalty function<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Charge a large penalty if address family doesn't match, or a somewhat<br/></li>
<li></span><span class="Comment"> * smaller one if the new value would degrade the union's minbits<br/></li>
<li></span><span class="Comment"> * (minimum netmask width).&nbsp; Otherwise, penalty is inverse of the<br/></li>
<li></span><span class="Comment"> * new number of common address bits.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L620">&#x200c;</a><span class="linkable">inet_gist_penalty</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *origent = (GISTENTRY *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *newent = (GISTENTRY *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">float</span>&nbsp; &nbsp; &nbsp;&nbsp; *penalty = (<span class="Type">float</span> *) PG_GETARG_POINTER(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L79" title="utils/adt/network_gist.c:79">GistInetKey</a> *orig = <a href="#L88" title="utils/adt/network_gist.c:88">DatumGetInetKeyP</a>(origent-&gt;key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *new = <a href="#L88" title="utils/adt/network_gist.c:88">DatumGetInetKeyP</a>(newent-&gt;key);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commonbits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L96" title="utils/adt/network_gist.c:96">gk_ip_family</a>(orig) == <a href="#L96" title="utils/adt/network_gist.c:96">gk_ip_family</a>(new))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(orig) &lt;= <a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(new))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commonbits = <a href="network.c.html#L1603" title="utils/adt/network.c:1603">bitncommon</a>(<a href="#L99" title="utils/adt/network_gist.c:99">gk_ip_addr</a>(orig), <a href="#L99" title="utils/adt/network_gist.c:99">gk_ip_addr</a>(new),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(<a href="#L98" title="utils/adt/network_gist.c:98">gk_ip_commonbits</a>(orig),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L98" title="utils/adt/network_gist.c:98">gk_ip_commonbits</a>(new)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (commonbits &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *penalty = <span class="Constant">1.0f</span> / commonbits;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *penalty = <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *penalty = <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *penalty = <span class="Constant">4</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(penalty);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The GiST PickSplit method<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There are two ways to split. First one is to split by address families,<br/></li>
<li></span><span class="Comment"> * if there are multiple families appearing in the input.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The second and more common way is to split by addresses. To achieve this,<br/></li>
<li></span><span class="Comment"> * determine the number of leading bits shared by all the keys, then split on<br/></li>
<li></span><span class="Comment"> * the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>.&nbsp; (We don't currently consider the netmask widths while doing<br/></li>
<li></span><span class="Comment"> * this; should we?)&nbsp; If we fail to get a nontrivial split that way, split<br/></li>
<li></span><span class="Comment"> * 50-50.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L663">&#x200c;</a><span class="linkable">inet_gist_picksplit</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; GIST_SPLITVEC *splitvec = (GIST_SPLITVEC *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *ent = entryvec-&gt;vector;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minbits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commonbits;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *addr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L79" title="utils/adt/network_gist.c:79">GistInetKey</a> *tmp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *left_union,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *right_union;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *left,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *right;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxoff = entryvec-&gt;n - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; nbytes = (maxoff + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; left = (OffsetNumber *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nbytes);<br/></li>
<li>&nbsp; &nbsp; right = (OffsetNumber *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nbytes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; splitvec-&gt;spl_left = left;<br/></li>
<li>&nbsp; &nbsp; splitvec-&gt;spl_right = right;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; splitvec-&gt;spl_nleft = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; splitvec-&gt;spl_nright = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine parameters of the union of all the inputs. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L345" title="utils/adt/network_gist.c:345">calc_inet_union_params</a>(ent, FirstOffsetNumber, maxoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;minfamily, &amp;maxfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;minbits, &amp;commonbits);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (minfamily != maxfamily)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Multiple families, so split by family. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there's more than 2 families, all but maxfamily go into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * left union.&nbsp; This could only happen if the inputs include some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * IPv4, some IPv6, and some already-multiple-family unions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = <a href="#L88" title="utils/adt/network_gist.c:88">DatumGetInetKeyP</a>(ent[i].key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L96" title="utils/adt/network_gist.c:96">gk_ip_family</a>(tmp) != maxfamily)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left[splitvec-&gt;spl_nleft++] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right[splitvec-&gt;spl_nright++] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Split on the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> after the common bits.&nbsp; If that yields a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * trivial split, try the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> position to the right.&nbsp; Repeat till<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * success; or if we run out of bits, do an arbitrary 50-50 split.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxbits = <a href="#L100" title="utils/adt/network_gist.c:100">ip_family_maxbits</a>(minfamily);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (commonbits &lt; maxbits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Split using the commonbits'th <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> position. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitbyte = commonbits / <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask = <span class="Constant">0x80</span> &gt;&gt; (commonbits % <span class="Constant">8</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splitvec-&gt;spl_nleft = splitvec-&gt;spl_nright = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = <a href="#L88" title="utils/adt/network_gist.c:88">DatumGetInetKeyP</a>(ent[i].key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr = <a href="#L99" title="utils/adt/network_gist.c:99">gk_ip_addr</a>(tmp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((addr[bitbyte] &amp; bitmask) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left[splitvec-&gt;spl_nleft++] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right[splitvec-&gt;spl_nright++] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (splitvec-&gt;spl_nleft &gt; <span class="Constant">0</span> &amp;&amp; splitvec-&gt;spl_nright &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* success */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commonbits++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (commonbits &gt;= maxbits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Failed ... do a 50-50 split. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splitvec-&gt;spl_nleft = splitvec-&gt;spl_nright = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= maxoff / <span class="Constant">2</span>; i = OffsetNumberNext(i))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left[splitvec-&gt;spl_nleft++] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; i &lt;= maxoff; i = OffsetNumberNext(i))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right[splitvec-&gt;spl_nright++] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute the union value for each side from scratch.&nbsp; In most cases we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could approximate the union <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> with what we already know, but this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensures that each side has minbits and commonbits set as high as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L407" title="utils/adt/network_gist.c:407">calc_inet_union_params_indexed</a>(ent, left, splitvec-&gt;spl_nleft,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;minfamily, &amp;maxfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;minbits, &amp;commonbits);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (minfamily != maxfamily)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; minfamily = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; tmp = <a href="#L88" title="utils/adt/network_gist.c:88">DatumGetInetKeyP</a>(ent[left[<span class="Constant">0</span>]].key);<br/></li>
<li>&nbsp; &nbsp; addr = <a href="#L99" title="utils/adt/network_gist.c:99">gk_ip_addr</a>(tmp);<br/></li>
<li>&nbsp; &nbsp; left_union = <a href="#L472" title="utils/adt/network_gist.c:472">build_inet_union_key</a>(minfamily, minbits, commonbits, addr);<br/></li>
<li>&nbsp; &nbsp; splitvec-&gt;spl_ldatum = PointerGetDatum(left_union);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L407" title="utils/adt/network_gist.c:407">calc_inet_union_params_indexed</a>(ent, right, splitvec-&gt;spl_nright,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;minfamily, &amp;maxfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;minbits, &amp;commonbits);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (minfamily != maxfamily)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; minfamily = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; tmp = <a href="#L88" title="utils/adt/network_gist.c:88">DatumGetInetKeyP</a>(ent[right[<span class="Constant">0</span>]].key);<br/></li>
<li>&nbsp; &nbsp; addr = <a href="#L99" title="utils/adt/network_gist.c:99">gk_ip_addr</a>(tmp);<br/></li>
<li>&nbsp; &nbsp; right_union = <a href="#L472" title="utils/adt/network_gist.c:472">build_inet_union_key</a>(minfamily, minbits, commonbits, addr);<br/></li>
<li>&nbsp; &nbsp; splitvec-&gt;spl_rdatum = PointerGetDatum(right_union);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(splitvec);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The GiST equality function<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L797">&#x200c;</a><span class="linkable">inet_gist_same</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L79" title="utils/adt/network_gist.c:79">GistInetKey</a> *left = <a href="#L88" title="utils/adt/network_gist.c:88">DatumGetInetKeyP</a>(PG_GETARG_DATUM(<span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; <a href="#L79" title="utils/adt/network_gist.c:79">GistInetKey</a> *right = <a href="#L88" title="utils/adt/network_gist.c:88">DatumGetInetKeyP</a>(PG_GETARG_DATUM(<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *result = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) PG_GETARG_POINTER(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *result = (<a href="#L96" title="utils/adt/network_gist.c:96">gk_ip_family</a>(left) == <a href="#L96" title="utils/adt/network_gist.c:96">gk_ip_family</a>(right) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(left) == <a href="#L97" title="utils/adt/network_gist.c:97">gk_ip_minbits</a>(right) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L98" title="utils/adt/network_gist.c:98">gk_ip_commonbits</a>(left) == <a href="#L98" title="utils/adt/network_gist.c:98">gk_ip_commonbits</a>(right) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; memcmp(<a href="#L99" title="utils/adt/network_gist.c:99">gk_ip_addr</a>(left), <a href="#L99" title="utils/adt/network_gist.c:99">gk_ip_addr</a>(right),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L103" title="utils/adt/network_gist.c:103">gk_ip_addrsize</a>(left)) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(result);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
