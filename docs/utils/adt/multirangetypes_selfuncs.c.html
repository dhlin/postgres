<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/multirangetypes_selfuncs.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/multirangetypes_selfuncs.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L456">calc_hist_selectivity</a></li>
<li><a href="#L1131">calc_hist_selectivity_contained</a></li>
<li><a href="#L1252">calc_hist_selectivity_contains</a></li>
<li><a href="#L707">calc_hist_selectivity_scalar</a></li>
<li><a href="#L966">calc_length_hist_frac</a></li>
<li><a href="#L291">calc_multirangesel</a></li>
<li><a href="#L78">default_multirange_selectivity</a></li>
<li><a href="#L918">get_distance</a></li>
<li><a href="#L873">get_len_position</a></li>
<li><a href="#L794">get_position</a></li>
<li><a href="#L768">length_hist_bsearch</a></li>
<li><a href="#L137">multirangesel</a></li>
<li><a href="#L739">rbound_bsearch</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * multirangetypes_selfuncs.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Functions for selectivity estimation of multirange operators<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Estimates are based on histograms of <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> and <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bounds, and the<br/></li>
<li></span><span class="Comment"> * fraction of empty multiranges.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/multirangetypes_selfuncs.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_operator.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_statistic.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/float.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/multirangetypes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rangetypes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/selfuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/typcache.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L291" title="utils/adt/multirangetypes_selfuncs.c:291">calc_multirangesel</a>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VariableStatData *vardata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> MultirangeType *constval, Oid operator);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L78" title="utils/adt/multirangetypes_selfuncs.c:78">default_multirange_selectivity</a>(Oid operator);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="rangetypes_selfuncs.c.html#L373" title="utils/adt/rangetypes_selfuncs.c:373">calc_hist_selectivity</a>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VariableStatData *vardata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> MultirangeType *constval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid operator);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="rangetypes_selfuncs.c.html#L596" title="utils/adt/rangetypes_selfuncs.c:596">calc_hist_selectivity_scalar</a>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeBound *constbound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeBound *hist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> hist_nvalues, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="rangetypes_selfuncs.c.html#L628" title="utils/adt/rangetypes_selfuncs.c:628">rbound_bsearch</a>(TypeCacheEntry *typcache, <span class="Type">const</span> RangeBound *value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeBound *hist, <span class="Type">int</span> hist_length, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>);<br/></li>
<li><span class="Type">static</span> float8 <a href="rangetypes_selfuncs.c.html#L683" title="utils/adt/rangetypes_selfuncs.c:683">get_position</a>(TypeCacheEntry *typcache, <span class="Type">const</span> RangeBound *value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeBound *hist1, <span class="Type">const</span> RangeBound *hist2);<br/></li>
<li><span class="Type">static</span> float8 <a href="rangetypes_selfuncs.c.html#L762" title="utils/adt/rangetypes_selfuncs.c:762">get_len_position</a>(<span class="Type">double</span> value, <span class="Type">double</span> hist1, <span class="Type">double</span> hist2);<br/></li>
<li><span class="Type">static</span> float8 <a href="rangetypes_selfuncs.c.html#L807" title="utils/adt/rangetypes_selfuncs.c:807">get_distance</a>(TypeCacheEntry *typcache, <span class="Type">const</span> RangeBound *bound1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeBound *bound2);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="rangetypes_selfuncs.c.html#L657" title="utils/adt/rangetypes_selfuncs.c:657">length_hist_bsearch</a>(Datum *length_hist_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> length_hist_nvalues, <span class="Type">double</span> value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="rangetypes_selfuncs.c.html#L855" title="utils/adt/rangetypes_selfuncs.c:855">calc_length_hist_frac</a>(Datum *length_hist_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> length_hist_nvalues, <span class="Type">double</span> length1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> length2, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="rangetypes_selfuncs.c.html#L1018" title="utils/adt/rangetypes_selfuncs.c:1018">calc_hist_selectivity_contained</a>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> RangeBound *<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeBound *<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> RangeBound *hist_lower,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> hist_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *length_hist_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> length_hist_nvalues);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="rangetypes_selfuncs.c.html#L1139" title="utils/adt/rangetypes_selfuncs.c:1139">calc_hist_selectivity_contains</a>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeBound *<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeBound *<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeBound *hist_lower,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> hist_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *length_hist_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> length_hist_nvalues);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns a default selectivity estimate for given operator, when we don't<br/></li>
<li></span><span class="Comment"> * have statistics or cannot use them for some reason.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L78">&#x200c;</a></span><span class="linkable">default_multirange_selectivity</span>(Oid operator)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (operator)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_OVERLAPS_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_OVERLAPS_RANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_RANGE_OVERLAPS_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.01</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_RANGE_CONTAINS_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_RANGE_MULTIRANGE_CONTAINED_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_CONTAINS_RANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_CONTAINS_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_RANGE_CONTAINED_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_MULTIRANGE_CONTAINED_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.005</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_CONTAINS_ELEM_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_ELEM_CONTAINED_OP:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;multirange @&gt; elem&quot; is more or less identical to a scalar<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inequality &quot;A &gt;= b AND A &lt;= c&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DEFAULT_MULTIRANGE_INEQ_SEL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_LESS_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_LESS_EQUAL_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_GREATER_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_GREATER_EQUAL_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_LEFT_RANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_LEFT_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_RANGE_LEFT_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_RIGHT_RANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_RIGHT_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_RANGE_RIGHT_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_OVERLAPS_LEFT_RANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_RANGE_OVERLAPS_LEFT_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_OVERLAPS_LEFT_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_OVERLAPS_RIGHT_RANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_RANGE_OVERLAPS_RIGHT_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_OVERLAPS_RIGHT_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* these are similar to regular scalar inequalities */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DEFAULT_INEQ_SEL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all multirange operators should be handled above, but just in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.01</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L137" title="utils/adt/multirangetypes_selfuncs.c:137">multirangesel</a> -- restriction selectivity for multirange operators<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L137">&#x200c;</a><span class="linkable">multirangesel</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operator = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *args = (List *) PG_GETARG_POINTER(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varRelid = PG_GETARG_INT32(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; VariableStatData vardata;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *other;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; varonleft;<br/></li>
<li>&nbsp; &nbsp; Selectivity selec;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typcache = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; MultirangeType *constmultirange = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; RangeType&nbsp; *constrange = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If expression is not (variable op something) or (something op<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * variable), then punt and return a default estimate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="selfuncs.c.html#L4883" title="utils/adt/selfuncs.c:4883">get_restriction_variable</a>(root, args, varRelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;vardata, &amp;other, &amp;varonleft))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L78" title="utils/adt/multirangetypes_selfuncs.c:78">default_multirange_selectivity</a>(operator));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Can't do anything useful if the something is not a constant, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsA(other, Const))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L78" title="utils/adt/multirangetypes_selfuncs.c:78">default_multirange_selectivity</a>(operator));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All the multirange operators are strict, so we can cope with a NULL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constant right away.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (((Const *) other)-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(<span class="Constant">0.0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If var is on the right, commute the operator, so that we can assume the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * var is on the left in what follows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!varonleft)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we have other Op var, commute to make var Op other */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; operator = <a href="../cache/lsyscache.c.html#L1509" title="utils/cache/lsyscache.c:1509">get_commutator</a>(operator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!operator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use default selectivity (should we raise an error instead?) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="#L78" title="utils/adt/multirangetypes_selfuncs.c:78">default_multirange_selectivity</a>(operator));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK, there's a Var and a Const we're dealing with here.&nbsp; We need the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Const to be of same multirange type as the column, else we can't do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anything useful. (Such cases will likely fail at runtime, but here we'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rather just return a default estimate.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the operator is &quot;multirange @&gt; <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>&quot;, the constant should be of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type of the multirange column. Convert it to a multirange<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that includes only that single point, so that we don't need special<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handling for that in what follows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (operator == OID_MULTIRANGE_CONTAINS_ELEM_OP)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typcache = <a href="multirangetypes.c.html#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, vardata.vartype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((Const *) other)-&gt;consttype == typcache-&gt;rngtype-&gt;rngelemtype-&gt;type_id)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeBound&nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.inclusive = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.val = ((Const *) other)-&gt;constvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.infinite = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.inclusive = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.val = ((Const *) other)-&gt;constvalue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.infinite = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>.<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constrange = <a href="rangetypes.c.html#L1727" title="utils/adt/rangetypes.c:1727">range_serialize</a>(typcache-&gt;rngtype, &amp;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constmultirange = <a href="multirangetypes.c.html#L646" title="utils/adt/multirangetypes.c:646">make_multirange</a>(typcache-&gt;type_id, typcache-&gt;rngtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span>, &amp;constrange);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (operator == OID_RANGE_MULTIRANGE_CONTAINED_OP ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operator == OID_MULTIRANGE_CONTAINS_RANGE_OP ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operator == OID_MULTIRANGE_OVERLAPS_RANGE_OP ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operator == OID_MULTIRANGE_OVERLAPS_LEFT_RANGE_OP ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operator == OID_MULTIRANGE_OVERLAPS_RIGHT_RANGE_OP ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operator == OID_MULTIRANGE_LEFT_RANGE_OP ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operator == OID_MULTIRANGE_RIGHT_RANGE_OP)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Promote a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> in &quot;multirange OP <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot; just like we do an <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in &quot;multirange OP <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typcache = <a href="multirangetypes.c.html#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, vardata.vartype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((Const *) other)-&gt;consttype == typcache-&gt;rngtype-&gt;type_id)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constrange = DatumGetRangeTypeP(((Const *) other)-&gt;constvalue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constmultirange = <a href="multirangetypes.c.html#L646" title="utils/adt/multirangetypes.c:646">make_multirange</a>(typcache-&gt;type_id, typcache-&gt;rngtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span>, &amp;constrange);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (operator == OID_RANGE_OVERLAPS_MULTIRANGE_OP ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operator == OID_RANGE_OVERLAPS_LEFT_MULTIRANGE_OP ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operator == OID_RANGE_OVERLAPS_RIGHT_MULTIRANGE_OP ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operator == OID_RANGE_LEFT_MULTIRANGE_OP ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operator == OID_RANGE_RIGHT_MULTIRANGE_OP ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operator == OID_RANGE_CONTAINS_MULTIRANGE_OP ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operator == OID_MULTIRANGE_ELEM_CONTAINED_OP ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operator == OID_MULTIRANGE_RANGE_CONTAINED_OP)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Here, the Var is the elem/<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, not the multirange.&nbsp; For <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just punt and return the default estimate.&nbsp; In future we could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * disassemble the multirange constant to do something more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * intelligent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (((Const *) other)-&gt;consttype == vardata.vartype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Both sides are the same multirange type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typcache = <a href="multirangetypes.c.html#L548" title="utils/adt/multirangetypes.c:548">multirange_get_typcache</a>(fcinfo, vardata.vartype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constmultirange = DatumGetMultirangeTypeP(((Const *) other)-&gt;constvalue);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we got a valid constant on one side of the operator, proceed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimate using statistics. Otherwise punt and return a default constant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimate.&nbsp; Note that <a href="#L291" title="utils/adt/multirangetypes_selfuncs.c:291">calc_multirangesel</a> need not handle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OID_MULTIRANGE_*_CONTAINED_OP.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (constmultirange)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selec = <a href="#L291" title="utils/adt/multirangetypes_selfuncs.c:291">calc_multirangesel</a>(typcache, &amp;vardata, constmultirange, operator);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; selec = <a href="#L78" title="utils/adt/multirangetypes_selfuncs.c:78">default_multirange_selectivity</a>(operator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseVariableStats(vardata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CLAMP_PROBABILITY(selec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8((float8) selec);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L291">&#x200c;</a></span><span class="linkable">calc_multirangesel</span>(TypeCacheEntry *typcache, VariableStatData *vardata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> MultirangeType *constval, Oid operator)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; hist_selec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; selec;<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; empty_frac,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; null_frac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First look up the fraction of NULLs and empty multiranges from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_statistic.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(vardata-&gt;statsTuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_statistic stats;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttStatsSlot sslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats = (Form_pg_statistic) GETSTRUCT(vardata-&gt;statsTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; null_frac = stats-&gt;stanullfrac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to get fraction of empty multiranges */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;sslot, vardata-&gt;statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATISTIC_KIND_RANGE_LENGTH_HISTOGRAM,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTSTATSSLOT_NUMBERS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sslot.nnumbers != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid empty fraction statistic&quot;</span>);&nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; empty_frac = sslot.numbers[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;sslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No empty fraction statistic. Assume no empty ranges. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; empty_frac = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No stats are available. Follow through the calculations below<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyway, assuming no NULLs and no empty multiranges. This still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allows us to give a better-than-nothing estimate based on whether<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the constant is an empty multirange or not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; null_frac = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; empty_frac = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultirangeIsEmpty(constval))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * An empty multirange matches all multiranges, all empty multiranges,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or nothing, depending on the operator<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (operator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* these return false if either argument is empty */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_OVERLAPS_RANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_OVERLAPS_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_OVERLAPS_LEFT_RANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_OVERLAPS_LEFT_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_OVERLAPS_RIGHT_RANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_OVERLAPS_RIGHT_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_LEFT_RANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_LEFT_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_RIGHT_RANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_RIGHT_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing is less than an empty multirange */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_LESS_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only empty multiranges can be contained by an empty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multirange<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_RANGE_MULTIRANGE_CONTAINED_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_MULTIRANGE_CONTAINED_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* only empty ranges are &lt;= an empty multirange */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_LESS_EQUAL_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = empty_frac;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* everything contains an empty multirange */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_CONTAINS_RANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_CONTAINS_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* everything is &gt;= an empty multirange */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_GREATER_EQUAL_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* all non-empty multiranges are &gt; an empty multirange */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_GREATER_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">1.0</span> - empty_frac;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* an <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> cannot be empty */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_CONTAINS_ELEM_OP:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* filtered out by <a href="#L137" title="utils/adt/multirangetypes_selfuncs.c:137">multirangesel</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_RANGE_OVERLAPS_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_RANGE_OVERLAPS_LEFT_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_RANGE_OVERLAPS_RIGHT_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_RANGE_LEFT_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_RANGE_RIGHT_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_RANGE_CONTAINS_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_ELEM_CONTAINED_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_RANGE_CONTAINED_OP:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected operator </span><span class="Special">%u</span><span class="Constant">&quot;</span>, operator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = <span class="Constant">0.0</span>;&nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Calculate selectivity using bound histograms. If that fails for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * some reason, e.g no histogram in pg_statistic, use the default<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constant estimate for the fraction of non-empty <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still somewhat better than just returning the default estimate,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because this still takes into account the fraction of empty and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NULL tuples, if we had statistics for them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hist_selec = <a href="rangetypes_selfuncs.c.html#L373" title="utils/adt/rangetypes_selfuncs.c:373">calc_hist_selectivity</a>(typcache, vardata, constval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hist_selec &lt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec = <a href="#L78" title="utils/adt/multirangetypes_selfuncs.c:78">default_multirange_selectivity</a>(operator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> the results for the empty multiranges and histogram<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * calculations, realizing that the histogram covers only the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-null, non-empty <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (operator == OID_RANGE_MULTIRANGE_CONTAINED_OP ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operator == OID_MULTIRANGE_MULTIRANGE_CONTAINED_OP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* empty is contained by anything non-empty */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = (<span class="Constant">1.0</span> - empty_frac) * hist_selec + empty_frac;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* with <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other operator, empty Op non-empty matches nothing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selec = (<span class="Constant">1.0</span> - empty_frac) * hist_selec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* all multirange operators are strict */<br/></li>
<li></span>&nbsp; &nbsp; selec *= (<span class="Constant">1.0</span> - null_frac);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* result should be in <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, but make sure... */<br/></li>
<li></span>&nbsp; &nbsp; CLAMP_PROBABILITY(selec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> selec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Calculate multirange operator selectivity using histograms of multirange bounds.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This estimate is for the portion of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that are not empty and not<br/></li>
<li></span><span class="Comment"> * NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L456">&#x200c;</a></span><span class="linkable">calc_hist_selectivity</span>(TypeCacheEntry *typcache, VariableStatData *vardata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> MultirangeType *constval, Oid operator)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *rng_typcache = typcache-&gt;rngtype;<br/></li>
<li>&nbsp; &nbsp; AttStatsSlot hslot;<br/></li>
<li>&nbsp; &nbsp; AttStatsSlot lslot;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nhist;<br/></li>
<li>&nbsp; &nbsp; RangeBound *hist_lower;<br/></li>
<li>&nbsp; &nbsp; RangeBound *hist_upper;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; const_lower;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; const_upper;<br/></li>
<li>&nbsp; &nbsp; RangeBound&nbsp; &nbsp; tmp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; hist_selec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't use the histogram with insecure multirange support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="selfuncs.c.html#L5735" title="utils/adt/selfuncs.c:5735">statistic_proc_security_check</a>(vardata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rng_typcache-&gt;rng_cmp_proc_finfo.fn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(rng_typcache-&gt;rng_subdiff_finfo.fn_oid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="selfuncs.c.html#L5735" title="utils/adt/selfuncs.c:5735">statistic_proc_security_check</a>(vardata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rng_typcache-&gt;rng_subdiff_finfo.fn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to get histogram of ranges */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(HeapTupleIsValid(vardata-&gt;statsTuple) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;hslot, vardata-&gt;statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATISTIC_KIND_BOUNDS_HISTOGRAM, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTSTATSSLOT_VALUES)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check that it's a histogram, not just a dummy entry */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (hslot.nvalues &lt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;hslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Convert histogram of ranges into histograms of its <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> and <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bounds.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nhist = hslot.nvalues;<br/></li>
<li>&nbsp; &nbsp; hist_lower = (RangeBound *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RangeBound) * nhist);<br/></li>
<li>&nbsp; &nbsp; hist_upper = (RangeBound *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RangeBound) * nhist);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nhist; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; empty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="rangetypes.c.html#L1856" title="utils/adt/rangetypes.c:1856">range_deserialize</a>(rng_typcache, DatumGetRangeTypeP(hslot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;hist_lower[i], &amp;hist_upper[i], &amp;empty);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The histogram should not contain <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> empty ranges */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (empty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;bounds histogram contains an empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* @&gt; and @&lt; also need a histogram of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> lengths */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (operator == OID_MULTIRANGE_CONTAINS_RANGE_OP ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; operator == OID_MULTIRANGE_CONTAINS_MULTIRANGE_OP ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; operator == OID_MULTIRANGE_RANGE_CONTAINED_OP ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; operator == OID_MULTIRANGE_MULTIRANGE_CONTAINED_OP)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(HeapTupleIsValid(vardata-&gt;statsTuple) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3234" title="utils/cache/lsyscache.c:3234">get_attstatsslot</a>(&amp;lslot, vardata-&gt;statsTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; STATISTIC_KIND_RANGE_LENGTH_HISTOGRAM,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ATTSTATSSLOT_VALUES)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;hslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check that it's a histogram, not just a dummy entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lslot.nvalues &lt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;lslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;hslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;lslot, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(lslot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract the bounds of the constant value. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(constval-&gt;rangeCount &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="multirangetypes.c.html#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(rng_typcache, constval, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;const_lower, &amp;tmp);<br/></li>
<li>&nbsp; &nbsp; <a href="multirangetypes.c.html#L744" title="utils/adt/multirangetypes.c:744">multirange_get_bounds</a>(rng_typcache, constval, constval-&gt;rangeCount - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;tmp, &amp;const_upper);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate selectivity comparing the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> or <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constant with the histogram of <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> or <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bounds.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (operator)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_LESS_OP:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The regular b-tree comparison operators (&lt;, &lt;=, &gt;, &gt;=) <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bounds first, and the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bounds for <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bounds. Estimate that by comparing the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bounds<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only. This gives a fairly accurate estimate assuming there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aren't many rows with a <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the constant's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rangetypes_selfuncs.c.html#L596" title="utils/adt/rangetypes_selfuncs.c:596">calc_hist_selectivity_scalar</a>(rng_typcache, &amp;const_lower,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hist_lower, nhist, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_LESS_EQUAL_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rangetypes_selfuncs.c.html#L596" title="utils/adt/rangetypes_selfuncs.c:596">calc_hist_selectivity_scalar</a>(rng_typcache, &amp;const_lower,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hist_lower, nhist, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_GREATER_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span> - <a href="rangetypes_selfuncs.c.html#L596" title="utils/adt/rangetypes_selfuncs.c:596">calc_hist_selectivity_scalar</a>(rng_typcache, &amp;const_lower,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hist_lower, nhist, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_GREATER_EQUAL_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span> - <a href="rangetypes_selfuncs.c.html#L596" title="utils/adt/rangetypes_selfuncs.c:596">calc_hist_selectivity_scalar</a>(rng_typcache, &amp;const_lower,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hist_lower, nhist, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_LEFT_RANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_LEFT_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* var &lt;&lt; const when <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>(var) &lt; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>(const) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rangetypes_selfuncs.c.html#L596" title="utils/adt/rangetypes_selfuncs.c:596">calc_hist_selectivity_scalar</a>(rng_typcache, &amp;const_lower,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hist_upper, nhist, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_RIGHT_RANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_RIGHT_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* var &gt;&gt; const when <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>(var) &gt; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>(const) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span> - <a href="rangetypes_selfuncs.c.html#L596" title="utils/adt/rangetypes_selfuncs.c:596">calc_hist_selectivity_scalar</a>(rng_typcache, &amp;const_upper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hist_lower, nhist, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_OVERLAPS_RIGHT_RANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_OVERLAPS_RIGHT_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bounds */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span> - <a href="rangetypes_selfuncs.c.html#L596" title="utils/adt/rangetypes_selfuncs.c:596">calc_hist_selectivity_scalar</a>(rng_typcache, &amp;const_lower,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hist_lower, nhist, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_OVERLAPS_LEFT_RANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_OVERLAPS_LEFT_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bounds */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rangetypes_selfuncs.c.html#L596" title="utils/adt/rangetypes_selfuncs.c:596">calc_hist_selectivity_scalar</a>(rng_typcache, &amp;const_upper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hist_upper, nhist, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_OVERLAPS_RANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_OVERLAPS_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_CONTAINS_ELEM_OP:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A &amp;&amp; B &lt;=&gt; NOT (A &lt;&lt; B OR A &gt;&gt; B).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since A &lt;&lt; B and A &gt;&gt; B are mutually exclusive events we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sum their probabilities to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> probability of (A &lt;&lt; B OR A &gt;&gt;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * B).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;multirange @&gt; elem&quot; is equivalent to &quot;multirange &amp;&amp;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * {[elem,elem]}&quot;. The caller already constructed the singular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> from the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> constant, so just treat it the same as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &amp;&amp;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rangetypes_selfuncs.c.html#L596" title="utils/adt/rangetypes_selfuncs.c:596">calc_hist_selectivity_scalar</a>(rng_typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;const_lower, hist_upper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nhist, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec +=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Constant">1.0</span> - <a href="rangetypes_selfuncs.c.html#L596" title="utils/adt/rangetypes_selfuncs.c:596">calc_hist_selectivity_scalar</a>(rng_typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;const_upper, hist_lower,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nhist, <span class="Constant">true</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec = <span class="Constant">1.0</span> - hist_selec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_CONTAINS_RANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_CONTAINS_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rangetypes_selfuncs.c.html#L1139" title="utils/adt/rangetypes_selfuncs.c:1139">calc_hist_selectivity_contains</a>(rng_typcache, &amp;const_lower,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;const_upper, hist_lower, nhist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lslot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, lslot.nvalues);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_MULTIRANGE_CONTAINED_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_RANGE_MULTIRANGE_CONTAINED_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (const_lower.infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Lower bound no longer matters. Just estimate the fraction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with an <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound &lt;= const <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rangetypes_selfuncs.c.html#L596" title="utils/adt/rangetypes_selfuncs.c:596">calc_hist_selectivity_scalar</a>(rng_typcache, &amp;const_upper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hist_upper, nhist, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (const_upper.infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1.0</span> - <a href="rangetypes_selfuncs.c.html#L596" title="utils/adt/rangetypes_selfuncs.c:596">calc_hist_selectivity_scalar</a>(rng_typcache, &amp;const_lower,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hist_lower, nhist, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rangetypes_selfuncs.c.html#L1018" title="utils/adt/rangetypes_selfuncs.c:1018">calc_hist_selectivity_contained</a>(rng_typcache, &amp;const_lower,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;const_upper, hist_lower, nhist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lslot.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, lslot.nvalues);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* filtered out by <a href="#L137" title="utils/adt/multirangetypes_selfuncs.c:137">multirangesel</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_RANGE_OVERLAPS_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_RANGE_OVERLAPS_LEFT_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_RANGE_OVERLAPS_RIGHT_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_RANGE_LEFT_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_RANGE_RIGHT_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_RANGE_CONTAINS_MULTIRANGE_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_ELEM_CONTAINED_OP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> OID_MULTIRANGE_RANGE_CONTAINED_OP:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unknown multirange operator </span><span class="Special">%u</span><span class="Constant">&quot;</span>, operator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist_selec = -<span class="Constant">1.0</span>;&nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;lslot);<br/></li>
<li>&nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L3344" title="utils/cache/lsyscache.c:3344">free_attstatsslot</a>(&amp;hslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> hist_selec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Look up the fraction of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> less than (or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, if '<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>' argument<br/></li>
<li></span><span class="Comment"> * is true) a given const in a histogram of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> bounds.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L707">&#x200c;</a></span><span class="linkable">calc_hist_selectivity_scalar</span>(TypeCacheEntry *typcache, <span class="Type">const</span> RangeBound *constbound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeBound *hist, <span class="Type">int</span> hist_nvalues, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Selectivity selec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find the histogram bin the given constant falls into. Estimate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * selectivity as the number of preceding whole bins.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; index = <a href="rangetypes_selfuncs.c.html#L628" title="utils/adt/rangetypes_selfuncs.c:628">rbound_bsearch</a>(typcache, constbound, hist, hist_nvalues, <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>);<br/></li>
<li>&nbsp; &nbsp; selec = (Selectivity) (Max(index, <span class="Constant">0</span>)) / (Selectivity) (hist_nvalues - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Adjust using linear interpolation within the bin */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (index &gt;= <span class="Constant">0</span> &amp;&amp; index &lt; hist_nvalues - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selec += <a href="rangetypes_selfuncs.c.html#L683" title="utils/adt/rangetypes_selfuncs.c:683">get_position</a>(typcache, constbound, &amp;hist[index],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;hist[index + <span class="Constant">1</span>]) / (Selectivity) (hist_nvalues - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> selec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Binary search on an array of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> bounds. Returns greatest index of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment"> * bound in array which is less(less or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>) than given <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> bound. If all<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> bounds in array are greater or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(greater) than given <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> bound,<br/></li>
<li></span><span class="Comment"> * return -1. When &quot;<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>&quot; flag is set conditions in brackets are used.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is used in scalar operator selectivity estimation. Another<br/></li>
<li></span><span class="Comment"> * goal of this function is to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a histogram bin where to stop<br/></li>
<li></span><span class="Comment"> * interpolation of portion of bounds which are less than or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to given bound.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L739">&#x200c;</a></span><span class="linkable">rbound_bsearch</span>(TypeCacheEntry *typcache, <span class="Type">const</span> RangeBound *value, <span class="Type">const</span> RangeBound *hist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> hist_length, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = hist_length - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; middle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> &lt; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; middle = (<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> + <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> + <span class="Constant">1</span>) / <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;hist[middle], value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &lt; <span class="Constant">0</span> || (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> &amp;&amp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> == <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = middle;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = middle - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Binary search on length histogram. Returns greatest index of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> length in<br/></li>
<li></span><span class="Comment"> * histogram which is less than (less than or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>) the given length value. If<br/></li>
<li></span><span class="Comment"> * all lengths in the histogram are greater than (greater than or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>) the<br/></li>
<li></span><span class="Comment"> * given length, returns -1.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L768">&#x200c;</a></span><span class="linkable">length_hist_bsearch</span>(Datum *length_hist_values, <span class="Type">int</span> length_hist_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> value, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = length_hist_nvalues - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; middle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> &lt; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; middleval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; middle = (<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> + <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> + <span class="Constant">1</span>) / <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; middleval = DatumGetFloat8(length_hist_values[middle]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (middleval &lt; value || (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> &amp;&amp; middleval &lt;= value))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = middle;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = middle - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get relative position of value in histogram bin in [0,1] <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> float8<br/></li>
<li><a id="L794">&#x200c;</a><span class="linkable">get_position</span>(TypeCacheEntry *typcache, <span class="Type">const</span> RangeBound *value, <span class="Type">const</span> RangeBound *hist1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeBound *hist2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_subdiff = OidIsValid(typcache-&gt;rng_subdiff_finfo.fn_oid);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; position;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!hist1-&gt;infinite &amp;&amp; !hist2-&gt;infinite)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; bin_width;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Both bounds are finite. Assuming the subtype's comparison function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * works sanely, the value must be finite, too, because it lies<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * somewhere between the bounds.&nbsp; If it doesn't, arbitrarily return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 0.5.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (value-&gt;infinite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.5</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can't interpolate without subdiff function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!has_subdiff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.5</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Calculate relative position using subdiff function. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; bin_width = DatumGetFloat8(<a href="../fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;typcache-&gt;rng_subdiff_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typcache-&gt;rng_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hist2-&gt;val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hist1-&gt;val));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnan(bin_width) || bin_width &lt;= <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.5</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* punt for NaN or zero-width bin */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; position = DatumGetFloat8(<a href="../fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;typcache-&gt;rng_subdiff_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typcache-&gt;rng_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value-&gt;val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hist1-&gt;val))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; / bin_width;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnan(position))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.5</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* punt for NaN from subdiff, Inf/Inf, etc */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Relative position must be in [0,1] <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; position = Max(position, <span class="Constant">0.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; position = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(position, <span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> position;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (hist1-&gt;infinite &amp;&amp; !hist2-&gt;infinite)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Lower bin boundary is -infinite, <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> is finite. If the value is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * -infinite, return 0.0 to indicate it's <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise return 1.0 to indicate it's infinitely far from the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bound.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ((value-&gt;infinite &amp;&amp; value-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>) ? <span class="Constant">0.0</span> : <span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!hist1-&gt;infinite &amp;&amp; hist2-&gt;infinite)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* same as above, but in reverse */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ((value-&gt;infinite &amp;&amp; !value-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>) ? <span class="Constant">1.0</span> : <span class="Constant">0.0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If both bin boundaries are infinite, they should be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other, and the value should also be infinite and <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to both<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bounds. (But don't Assert that, to avoid crashing if a user creates<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a datatype with a broken comparison function).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Assume the value to lie in the middle of the infinite bounds.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.5</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get relative position of value in a length histogram bin in [0,1] <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L873">&#x200c;</a></span><span class="linkable">get_len_position</span>(<span class="Type">double</span> value, <span class="Type">double</span> hist1, <span class="Type">double</span> hist2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!isinf(hist1) &amp;&amp; !isinf(hist2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Both bounds are finite. The value should be finite too, because it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lies somewhere between the bounds. If it doesn't, just return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * something.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isinf(value))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.5</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1.0</span> - (hist2 - value) / (hist2 - hist1);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (isinf(hist1) &amp;&amp; !isinf(hist2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Lower bin boundary is -infinite, <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> is finite. Return 1.0 to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indicate the value is infinitely far from the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (isinf(hist1) &amp;&amp; isinf(hist2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* same as above, but in reverse */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If both bin boundaries are infinite, they should be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other, and the value should also be infinite and <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to both<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bounds. (But don't Assert that, to avoid crashing unnecessarily if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the caller messes up)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Assume the value to lie in the middle of the infinite bounds.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.5</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Measure distance between two <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> bounds.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> float8<br/></li>
<li><a id="L918">&#x200c;</a><span class="linkable">get_distance</span>(TypeCacheEntry *typcache, <span class="Type">const</span> RangeBound *bound1, <span class="Type">const</span> RangeBound *bound2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_subdiff = OidIsValid(typcache-&gt;rng_subdiff_finfo.fn_oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!bound1-&gt;infinite &amp;&amp; !bound2-&gt;infinite)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Neither bound is infinite, use subdiff function or return default<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * value of 1.0 if no subdiff is available.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (has_subdiff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = DatumGetFloat8(<a href="../fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;typcache-&gt;rng_subdiff_finfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typcache-&gt;rng_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bound2-&gt;val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bound1-&gt;val));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reject possible NaN result, also negative result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnan(res) || res &lt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (bound1-&gt;infinite &amp;&amp; bound2-&gt;infinite)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Both bounds are infinite */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bound1-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> == bound2-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> get_float8_infinity();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* One bound is infinite, the other is not */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> get_float8_infinity();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Calculate the average of function P(x), in the interval [length1, length2],<br/></li>
<li></span><span class="Comment"> * where P(x) is the fraction of tuples with length &lt; x (or length &lt;= x if<br/></li>
<li></span><span class="Comment"> * '<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>' is true).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L966">&#x200c;</a></span><span class="linkable">calc_length_hist_frac</span>(Datum *length_hist_values, <span class="Type">int</span> length_hist_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> length1, <span class="Type">double</span> length2, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; frac;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; A,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; B,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PA,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PB;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; pos;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; area;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(length2 &gt;= length1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (length2 &lt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen, but doesn't hurt to check */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* All lengths in the table are &lt;= infinite. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isinf(length2) &amp;&amp; <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The average of a function between A and B can be calculated by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * formula:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; B<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; 1&nbsp; &nbsp; &nbsp; &nbsp; /<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * -------&nbsp; &nbsp; | P(x)dx<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; B - A&nbsp; &nbsp; /<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The geometrical interpretation of the integral is the area under the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * graph of P(x). P(x) is defined by the length histogram. We calculate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the area in a piecewise fashion, iterating through the length histogram<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bins. Each bin is a trapezoid:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; P(x2)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /|<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; / |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * P(x1)/&nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp;&nbsp; |&nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp;&nbsp; |&nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; ---+---+--<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp;&nbsp; x1&nbsp; x2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where x1 and x2 are the boundaries of the current histogram, and P(x1)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and P(x1) are the cumulative fraction of tuples at the boundaries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The area of each trapezoid is 1/2 * (P(x2) + P(x1)) * (x2 - x1)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The first bin contains the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound passed by the caller, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use linear interpolation between the previous and <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> histogram bin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * boundary to calculate P(x1). Likewise for the last bin: we use linear<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interpolation to calculate P(x2). For the bins in between, x1 and x2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lie on histogram bin boundaries, so P(x1) and P(x2) are simply:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * P(x1) =&nbsp; &nbsp; &nbsp; (bin index) / (number of bins)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * P(x2) = (bin index + 1 / (number of bins)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First bin, the one that contains <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound */<br/></li>
<li></span>&nbsp; &nbsp; i = <a href="rangetypes_selfuncs.c.html#L657" title="utils/adt/rangetypes_selfuncs.c:657">length_hist_bsearch</a>(length_hist_values, length_hist_nvalues, length1, <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= length_hist_nvalues - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (i &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pos = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* interpolate length1's position in the bin */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pos = <a href="rangetypes_selfuncs.c.html#L762" title="utils/adt/rangetypes_selfuncs.c:762">get_len_position</a>(length1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DatumGetFloat8(length_hist_values[i]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DatumGetFloat8(length_hist_values[i + <span class="Constant">1</span>]));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PB = (((<span class="Type">double</span>) i) + pos) / (<span class="Type">double</span>) (length_hist_nvalues - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; B = length1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In the degenerate case that length1 == length2, simply return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * P(length1). This is not merely an optimization: if length1 == length2,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we'd divide by zero later on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (length2 == length1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PB;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop through all the bins, until we hit the last bin, the one that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contains the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound. (if <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> and <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bounds are in the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bin, this falls out immediately)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; area = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (; i &lt; length_hist_nvalues - <span class="Constant">1</span>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; bin_upper = DatumGetFloat8(length_hist_values[i + <span class="Constant">1</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check if we've reached the last bin */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(bin_upper &lt; length2 || (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> &amp;&amp; bin_upper &lt;= length2)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of previous bin is the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of this bin */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; A = B;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PA = PB;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; B = bin_upper;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PB = (<span class="Type">double</span>) i / (<span class="Type">double</span>) (length_hist_nvalues - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add the area of this trapezoid to the total. The point of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if-check is to avoid NaN, in the corner case that PA == PB == 0,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and B - A == Inf. The area of a zero-height trapezoid (PA == PB ==<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 0) is zero, regardless of the width (B - A).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PA &gt; <span class="Constant">0</span> || PB &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; area += <span class="Constant">0.5</span> * (PB + PA) * (B - A);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Last bin */<br/></li>
<li></span>&nbsp; &nbsp; A = B;<br/></li>
<li>&nbsp; &nbsp; PA = PB;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; B = length2;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* last bin ends at the query <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= length_hist_nvalues - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pos = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetFloat8(length_hist_values[i]) == DatumGetFloat8(length_hist_values[i + <span class="Constant">1</span>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos = <a href="rangetypes_selfuncs.c.html#L762" title="utils/adt/rangetypes_selfuncs.c:762">get_len_position</a>(length2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DatumGetFloat8(length_hist_values[i]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DatumGetFloat8(length_hist_values[i + <span class="Constant">1</span>]));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PB = (((<span class="Type">double</span>) i) + pos) / (<span class="Type">double</span>) (length_hist_nvalues - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PA &gt; <span class="Constant">0</span> || PB &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; area += <span class="Constant">0.5</span> * (PB + PA) * (B - A);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ok, we have calculated the area, ie. the integral. Divide by width to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get the requested average.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Avoid NaN arising from infinite / infinite. This happens at least if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * length2 is infinite. It's not clear what the correct value would be in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that case, so 0.5 seems as good as <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isinf(area) &amp;&amp; isinf(length2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; frac = <span class="Constant">0.5</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; frac = area / (length2 - length1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> frac;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Calculate selectivity of &quot;var &lt;@ const&quot; operator, ie. estimate the fraction<br/></li>
<li></span><span class="Comment"> * of multiranges that fall within the constant <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> and <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bounds. This uses<br/></li>
<li></span><span class="Comment"> * the histograms of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bounds and <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> lengths, on the assumption<br/></li>
<li></span><span class="Comment"> * that the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> lengths are independent of the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bounds.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller has already checked that constant <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> and <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bounds are<br/></li>
<li></span><span class="Comment"> * finite.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L1131">&#x200c;</a></span><span class="linkable">calc_hist_selectivity_contained</span>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> RangeBound *<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, RangeBound *<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> RangeBound *hist_lower, <span class="Type">int</span> hist_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *length_hist_values, <span class="Type">int</span> length_hist_nvalues)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper_index;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; prev_dist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; bin_width;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; upper_bin_width;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; sum_frac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Begin by finding the bin containing the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound, in the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * histogram. Any <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> with a <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound &gt; constant <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * match, ie. there are no matches in bins greater than upper_index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;inclusive = !<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;inclusive;<br/></li>
<li>&nbsp; &nbsp; <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-&gt;<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; upper_index = <a href="rangetypes_selfuncs.c.html#L628" title="utils/adt/rangetypes_selfuncs.c:628">rbound_bsearch</a>(typcache, <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, hist_lower, hist_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound value is below the histogram's <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> limit, there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are no matches.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (upper_index &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound value is at or beyond the histogram's <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> limit,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * start our loop at the last actual bin, as though the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * within that bin; <a href="rangetypes_selfuncs.c.html#L683" title="utils/adt/rangetypes_selfuncs.c:683">get_position</a> will clamp its result to 1.0 anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (This corresponds to assuming that the data population above the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * histogram's <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> limit is empty, exactly like what we just assumed for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> limit.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; upper_index = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(upper_index, hist_nvalues - <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate upper_bin_width, ie. the fraction of the (upper_index,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * upper_index + 1) bin which is greater than <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of query <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using linear interpolation of subdiff function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; upper_bin_width = <a href="rangetypes_selfuncs.c.html#L683" title="utils/adt/rangetypes_selfuncs.c:683">get_position</a>(typcache, <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;hist_lower[upper_index],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;hist_lower[upper_index + <span class="Constant">1</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In the loop, dist and prev_dist are the distance of the &quot;current&quot; bin's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> and <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bounds from the constant <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bin_width represents the width of the current bin. Normally it is 1.0,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * meaning a full width bin, but can be less in the corner cases: start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and end of the loop. We start with bin_width = upper_bin_width, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we begin at the bin containing the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; prev_dist = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; bin_width = upper_bin_width;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sum_frac = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = upper_index; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; dist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; length_hist_frac;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; final_bin = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dist -- distance from <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of query <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> to <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the current bin in the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound histogram. Or to the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the constant <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, if this is the final bin, containing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constant <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="rangetypes.c.html#L2016" title="utils/adt/rangetypes.c:2016">range_cmp_bounds</a>(typcache, &amp;hist_lower[i], <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dist = <a href="rangetypes_selfuncs.c.html#L807" title="utils/adt/rangetypes_selfuncs.c:807">get_distance</a>(typcache, <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Subtract from bin_width the portion of this bin that we want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ignore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bin_width -= <a href="rangetypes_selfuncs.c.html#L683" title="utils/adt/rangetypes_selfuncs.c:683">get_position</a>(typcache, <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;hist_lower[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;hist_lower[i + <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bin_width &lt; <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bin_width = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final_bin = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dist = <a href="rangetypes_selfuncs.c.html#L807" title="utils/adt/rangetypes_selfuncs.c:807">get_distance</a>(typcache, &amp;hist_lower[i], <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Estimate the fraction of tuples in this bin that are narrow enough<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to not exceed the distance to the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of the query <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; length_hist_frac = <a href="rangetypes_selfuncs.c.html#L855" title="utils/adt/rangetypes_selfuncs.c:855">calc_length_hist_frac</a>(length_hist_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; length_hist_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prev_dist, dist, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add the fraction of tuples in this bin, with a suitable length, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the total.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sum_frac += length_hist_frac * bin_width / (<span class="Type">double</span>) (hist_nvalues - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (final_bin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bin_width = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prev_dist = dist;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> sum_frac;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Calculate selectivity of &quot;var @&gt; const&quot; operator, ie. estimate the fraction<br/></li>
<li></span><span class="Comment"> * of multiranges that contain the constant <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> and <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bounds. This uses<br/></li>
<li></span><span class="Comment"> * the histograms of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bounds and <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> lengths, on the assumption<br/></li>
<li></span><span class="Comment"> * that the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> lengths are independent of the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bounds.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L1252">&#x200c;</a></span><span class="linkable">calc_hist_selectivity_contains</span>(TypeCacheEntry *typcache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeBound *<a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, <span class="Type">const</span> RangeBound *<a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> RangeBound *hist_lower, <span class="Type">int</span> hist_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *length_hist_values, <span class="Type">int</span> length_hist_nvalues)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower_index;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; bin_width,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower_bin_width;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; sum_frac;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; prev_dist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the bin containing the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of query <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>. */<br/></li>
<li></span>&nbsp; &nbsp; lower_index = <a href="rangetypes_selfuncs.c.html#L628" title="utils/adt/rangetypes_selfuncs.c:628">rbound_bsearch</a>(typcache, <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, hist_lower, hist_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound value is below the histogram's <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> limit, there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are no matches.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lower_index &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound value is at or beyond the histogram's <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> limit,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * start our loop at the last actual bin, as though the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * within that bin; <a href="rangetypes_selfuncs.c.html#L683" title="utils/adt/rangetypes_selfuncs.c:683">get_position</a> will clamp its result to 1.0 anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (This corresponds to assuming that the data population above the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * histogram's <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> limit is empty, exactly like what we just assumed for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> limit.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lower_index = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(lower_index, hist_nvalues - <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate lower_bin_width, ie. the fraction of the of (lower_index,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lower_index + 1) bin which is greater than <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of query <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using linear interpolation of subdiff function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lower_bin_width = <a href="rangetypes_selfuncs.c.html#L683" title="utils/adt/rangetypes_selfuncs.c:683">get_position</a>(typcache, <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, &amp;hist_lower[lower_index],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;hist_lower[lower_index + <span class="Constant">1</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop through all the <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound bins, smaller than the query <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bound. In the loop, dist and prev_dist are the distance of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;current&quot; bin's <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> and <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bounds from the constant <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We begin from query <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound, and walk backwards, so the first bin's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound is the query <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound, and its distance to the query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound is the length of the query <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bin_width represents the width of the current bin. Normally it is 1.0,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * meaning a full width bin, except for the first bin, which is only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * counted up to the constant <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; prev_dist = <a href="rangetypes_selfuncs.c.html#L807" title="utils/adt/rangetypes_selfuncs.c:807">get_distance</a>(typcache, <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>);<br/></li>
<li>&nbsp; &nbsp; sum_frac = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; bin_width = lower_bin_width;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = lower_index; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; dist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; length_hist_frac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dist -- distance from <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of query <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> to current value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound histogram or <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of query <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> (if we've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reach it).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dist = <a href="rangetypes_selfuncs.c.html#L807" title="utils/adt/rangetypes_selfuncs.c:807">get_distance</a>(typcache, &amp;hist_lower[i], <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get average fraction of length histogram which covers intervals<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * longer than (or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to) distance to <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of query <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; length_hist_frac =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1.0</span> - <a href="rangetypes_selfuncs.c.html#L855" title="utils/adt/rangetypes_selfuncs.c:855">calc_length_hist_frac</a>(length_hist_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; length_hist_nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev_dist, dist, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sum_frac += length_hist_frac * bin_width / (<span class="Type">double</span>) (hist_nvalues - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bin_width = <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prev_dist = dist;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> sum_frac;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
